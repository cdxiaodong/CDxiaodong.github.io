<!DOCTYPE html><html lang="en" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="CDxiaodong"><meta name="keywords" content=""><meta name="description" content="[TOC] 已有1234压缩区段加密区段清除数据目录表修复重定位    目标1231.能够突破看雪的虚拟化检测dbg插件2.FUD “FUD”代表恶意软件完全不可被检测到的意思3.从攻击者角度来研究病毒查杀技术  注意事项12345678910111.   最核心的就是伪装，完全模拟正常PE程序。2.   壳代码没有异常行为，不触发杀软的检测规则。3.   傀儡文件的OEP代码尽量避免影响被加壳程"><meta property="og:type" content="article"><meta property="og:title" content="写个壳"><meta property="og:url" content="http://example.com/%E5%86%99%E4%B8%AA%E5%A3%B3.html"><meta property="og:site_name" content="CD_blog"><meta property="og:description" content="[TOC] 已有1234压缩区段加密区段清除数据目录表修复重定位    目标1231.能够突破看雪的虚拟化检测dbg插件2.FUD “FUD”代表恶意软件完全不可被检测到的意思3.从攻击者角度来研究病毒查杀技术  注意事项12345678910111.   最核心的就是伪装，完全模拟正常PE程序。2.   壳代码没有异常行为，不触发杀软的检测规则。3.   傀儡文件的OEP代码尽量避免影响被加壳程"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202210302007687.png"><meta property="og:image" content="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202211051701031.jpeg"><meta property="og:image" content="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202211051713878.jpeg"><meta property="og:image" content="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202211051728203.jpeg"><meta property="og:image" content="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202210291240377.png"><meta property="og:image" content="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202211231951871.png"><meta property="og:image" content="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202211232045931.png"><meta property="og:image" content="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202211241315060.png"><meta property="article:published_time" content="2022-12-05T16:00:00.000Z"><meta property="article:modified_time" content="2023-02-20T10:35:14.000Z"><meta property="article:author" content="CDxiaodong"><meta property="article:tag" content="学习笔记"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202210302007687.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>写个壳 - CD_blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/mac.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"example.com",root:"/",version:"1.9.4",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"eJkDJodFGiDL0TVTWRwDW40Z-gzGzoHsz",app_key:"xhVxcHFbhAlnmT8nFUbU2ps7",server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>CD&#39;s one more night</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>Home</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>Archives</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>Categories</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>Tags</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>About</span></a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> <span>Links</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="写个壳"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-12-06 00:00" pubdate>December 6, 2022 am</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 31k words </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 263 mins </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> views</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">写个壳</h1><div class="markdown-body"><p>[TOC]</p><h2 id="已有"><a href="#已有" class="headerlink" title="已有"></a>已有</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">压缩区段<br>加密区段<br>清除数据目录表<br>修复重定位<br></code></pre></td></tr></table></figure><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">1</span>.能够突破看雪的虚拟化检测<span class="hljs-keyword">dbg</span>插件<br><span class="hljs-number">2</span>.FUD “FUD”代表恶意软件完全不可被检测到的意思<br><span class="hljs-number">3</span>.从攻击者角度来研究病毒查杀技术<br></code></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span>   最核心的就是伪装，完全模拟正常PE程序。<br><br><span class="hljs-bullet">2.</span>   壳代码没有异常行为，不触发杀软的检测规则。<br><br><span class="hljs-bullet">3.</span>   傀儡文件的OEP代码尽量避免影响被加壳程序的正常执行<br><br><span class="hljs-bullet">4.</span>   核心功能为减少暴露面，提高做免杀的速度<br><br><span class="hljs-bullet">5.</span>   通过混淆引擎混淆壳代码，达到混淆后无特征代码。<br><br><span class="hljs-bullet">6.</span>   支持壳上壳，通过加其他VM壳处理内存特征码、反分析。<br></code></pre></td></tr></table></figure><p>不能使用多线程来进行解压缩 因为在shell代码中线程化是一个非常糟糕的想法！</p><h2 id="基础和高级"><a href="#基础和高级" class="headerlink" title="基础和高级"></a>基础和高级</h2><h3 id="一般的加壳都是下面这些步骤"><a href="#一般的加壳都是下面这些步骤" class="headerlink" title="一般的加壳都是下面这些步骤"></a>一般的加壳都是下面这些步骤</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span>使用加壳器给被加壳程序添加新区段。<br><span class="hljs-number">2.</span>加密/压缩被加壳程序。<br><span class="hljs-number">3.</span>将stub的代码段移植到新区段。 stub.dll<br><span class="hljs-number">4.</span>将被加壳程序的OEP记录到<span class="hljs-keyword">share</span>.h中。<br><span class="hljs-number">5.</span>将被加壳程序的EP设置到新区段。<br><span class="hljs-number">6.</span>保存为新文件。<br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gcode">在PE文件中开辟空间用于存储补丁代码<br>复制扩展PE头中的数据目录表<span class="hljs-comment">(DataDirectory)</span>的内容到存储补丁的空间中，复制完后清空原本的数据目录表<br>修正复制过去的数据目录表的内容<br>对修正完的数据目录表之后的数据<span class="hljs-comment">(不包括补丁部分)</span>进行加密<br>修改PE文件的程序入口为补丁代码<br>补丁代码还原前面被清空的数据目录表<br>补丁代码解密先前加密的数据<br>补丁代码加载导入表中需要导入的DLL<br>补丁代码修正IAT<br>补丁代码执行完后返回原本的程序入口<br></code></pre></td></tr></table></figure><ul><li>加壳的<strong>难点</strong>在于将数据目录项<strong>复制</strong>到补丁代码部分，并<strong>修正</strong>复制后的数据目录项</li><li>加壳中加密的核心是<strong>加密算法</strong></li></ul><h3 id="一般壳都是带压缩的壳"><a href="#一般壳都是带压缩的壳" class="headerlink" title="一般壳都是带压缩的壳"></a>一般壳都是带压缩的壳</h3><p>压缩是一个比较复杂的过程，对于一个主要功能的加密的壳来说，压缩也有一定的加密效果，如果使用了一些加密库加密，即使你压缩了，会发现加壳后的文件比没加壳之前还要大！</p><p>vmp用不好，就变成了第三类壳：增积壳<br>作用：虽然没有虚拟化保护软件关键函数，但是可以增加软件体积，吓唬破解者，顺便增加检测虚拟机或是调试器附加的功能</p><p>很多常见的壳都用汇编写的，确实，汇编确实可以写出很多短小精悍、骚操作的代码，这是C++所没有的，但是C++支持内联汇编，在一定程度上弥补了它的不足。</p><h3 id="加密节-除了tls和rsrc"><a href="#加密节-除了tls和rsrc" class="headerlink" title="加密节(除了tls和rsrc)"></a>加密节(除了tls和rsrc)</h3><p>比如加密压缩的过程中每次可以随机使用不同的加密压缩算法，比如调用rar，zip，upx的压缩算法，比如使用DES、3DES、AES 、 RSA、DSA 、SHA-1、MD5等加密算法……或者这些都随机调用，每次生成算法都不同</p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>哈夫曼树 upx</p><p>到现在我比较想写的是unishox2压缩算法<a target="_blank" rel="noopener" href="https://github.com/siara-cc/Unishox2">siara-cc&#x2F;Unishox2: Compression for Unicode short strings (github.com)</a>和base-N压缩算法<a target="_blank" rel="noopener" href="https://modexp.wordpress.com/">莫迪克|关于计算机安全的随机帖子 (wordpress.com)</a></p><h3 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h3><p>参考VMP</p><p>学保护模式 ——》 为了突破UAC (也能学到反调试)</p><p>反调试 –》为了学加壳等</p><p>学tenprotect的保护机制 –》反向学习反调试(因为会学到<strong>Windbg双机调试的保护、ValidAccessMask清零的保护和DebugPort清零</strong>的保护)</p><p>对于PE结构的表的获取结构体 还有一种是利用特征码的获取结构体(只能获取某个内核api) 显然就没那么高操作 pe表获取结构体也会引用其中内容。所以pe结构是一个值得反复学习的东西</p><p>常规的反调试都是getparentpresent和beginndebuged来获取是否被调试。</p><p>2019年有一个文章用的是NtqueryInformationProcess(这个函数可以同时在0环和3环运行)的第二个参数传入ProcessDeubgpory并获取传出的nDebugPort来判断是否被调试</p><p>写出了好的反调试方法，可以放在壳代码的各个角落，检测到调试就马上退出程序，多放置几个阴人位置，这样就能增加破解的难度了！</p><p>在32位程序中，有人把钩子挂到64位的”ntdll.dll”上，然后来反反调试，可以用crc校验或者检测关键字节来反反反调试</p><p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1277269-1-1.html">https://www.52pojie.cn/thread-1277269-1-1.html</a></p><p>一般虚拟机沙箱的网卡还有文件默认设置 进程少等特点 可以用来检测一下</p><p>30个反调试方法(2016年)</p><p><a target="_blank" rel="noopener" href="https://github.com/wanttobeno/AntiDebuggers/blob/master/Tencent2016D.cpp">https://github.com/wanttobeno/AntiDebuggers/blob/master/Tencent2016D.cpp</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://github.com/strivexjun/XAntiDebug/blob/master/XAntiDebug/XAntiDebug.cpp">https://github.com/strivexjun/XAntiDebug/blob/master/XAntiDebug/XAntiDebug.cpp</a></p><p>anti-debug-popf</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>anti-debug-int2d</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>当然直接ollvm可以直接反调试</p><h3 id="加密iat"><a href="#加密iat" class="headerlink" title="加密iat"></a>加密iat</h3><p>IAT(导入地址表 import address table)每个元素的地址就是内存窗口的地址</p><p>这时候我们就需要去加密这些地址来干扰调试器对winapi的获取</p><p>加密原理</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">遍历导入表获取每个函数的IAT地址（对应上图内存栏中地址的值）<br>取出IAT地址的内容，就是函数的地址（上图内存栏中数值的值），把该函数地址进行加密后得到一个数据<br>申请一段内存，其中存放解密上述的数据得到真地址，然后调用该地址的代码。<br>把申请的内存地址放入IAT地址对应的数值中。<br>完成以上步骤后IAT就被加密了，当然第3步当中可以进行适当的混淆和加花指令别人就更加看不出来了。<br><br></code></pre></td></tr></table></figure><p>hash单向散列(数值加密) 加密api函数的字符串 (因为一些有经验的逆向师会对字符串比较敏感)</p><p>众所周知1个字节是8位，这代表他表示2的8次方个数，也就是256种可能，如果我们把它的一个数据代表一个系统中的函数（API），相当于给函数一个序号，那么1个字节就能存储256个函数的信息，那2个字节就能存储2的16次方也就是65536个API函数，这真是大大的好消息， windows系统中的API函数也就几千个，2个字节存储其全部API函数信息真是绰绰有余。</p><p>而让这2个字节的数据代表一个函数，这个数据我们称它为Hash值，因此需要设计一个算法。我在这设计是方法是定义一个2字节类型（short）的数据，分别把nHash值先左移11位再右移5位后相加，再加上API函数中一个字符的Ascii码，以此循环遍历完整个API函数的所有字符，得到一个我们需要的Hash值。在之前写壳基础篇中提到过壳代码中的API是动态获取的，那么我们在动态获取的时候使用Hash值更能提高隐蔽性，使破解者不易发现我们所要使用的是哪个函数。<br>具体Hash加密代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pch.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>	&#123;<br>		<span class="hljs-comment">//用于保存Hash值</span><br>		<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> nHash = <span class="hljs-number">0</span>;<br>		<span class="hljs-type">char</span> arr[<span class="hljs-number">50</span>] = &#123;&#125;, *p;<br>		p = arr;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入API: &quot;</span>);<br>		scanf_s(<span class="hljs-string">&quot;%s&quot;</span>, arr, <span class="hljs-number">50</span>);<br>		<span class="hljs-keyword">while</span> (*p)<br>		&#123;<br>			<span class="hljs-comment">//先左移11位再右移5位相加后再加上该字符的Ascii</span><br>			nHash = ((nHash &lt;&lt; <span class="hljs-number">11</span>) | (nHash &gt;&gt; <span class="hljs-number">5</span>));<br>			nHash = nHash + *p;<br>			p++;<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hash值为：0x%X\n&quot;</span>, nHash);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用纯汇编来在壳代码中写入解密函数的好处</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-number">1.</span>代码少<br><span class="hljs-number">2.</span>更能锻炼基本功<br><span class="hljs-number">3.</span>可以用到一些骚操作<br><span class="hljs-number">4.</span>壳主要是指针的操作（加壳程序还得算上文件<span class="hljs-variable">IO</span>），汇编相对于<span class="hljs-built_in">C</span><span class="hljs-operator">/</span><span class="hljs-built_in">C</span><span class="hljs-operator">++</span>操纵指针起来更加得心应手。<br><span class="hljs-number">5.</span>尤其是汇编可以直接操纵堆栈，由此有了两大优势：一、方便数据寻址，二、方便堆栈平衡。<br><br></code></pre></td></tr></table></figure><p>hash加密(要有密钥的那种)</p><p>动态加密</p><p>加入动态解密的壳，这无疑是强度较高的壳了，它能够在目标程序运行起来之后，动态的对代码段进行解密。先运行一段代码解密后一部分的代码，然后再运行解密后的代码，可以往复循环，这样破解者只能看见运行着的代码的附近的代码，隔得远的代码处于加密状态，这样就需要花费大量的时间才能破解了，当然想要实现这种高强度，还是需要花费很多时间去设计的，而且要求我们对x86汇编语言有比较深刻理解，</p><p>解密代码才是动态解密中的核心点，重中之重。因为加密代码全部去加密就可。解密代码的话就将代码分段分时解密</p><p>这里要说一下GetPC技术，GetPC技术翻译为中文也就是获取指针计数器。在x86汇编中实际上就是获取当前代码EIP的技术。我这用的是call 指令，call xxx指令相当于 push 下一行代码的EIP + jmp xxx。 那么我们直接把XXX改为下一行指令的地址就能获取当前EIP</p><p>其他操作</p><p>在遍历还原导入表时，并没有直接将API的地址填入到IAT里，而是将节表5的地址，从起始位置开始，每隔16个字节，将地址填入到IAT里，然后在对应的节表5地址上填入push 真实函数地址 + retn的汇编指令。这样一来，原PE程序运行调用API时，就会跳到节表5里面，再从节表5里面跳到真实API地址，直接干掉了x64dbg的脱壳导入表自动修复功能。</p><h3 id="虚拟壳-技术要求过高-以后写-“如果虚拟壳写的好直接拿去卖也不用工作-年入50w-”"><a href="#虚拟壳-技术要求过高-以后写-“如果虚拟壳写的好直接拿去卖也不用工作-年入50w-”" class="headerlink" title="虚拟壳(技术要求过高 以后写 “如果虚拟壳写的好直接拿去卖也不用工作 年入50w+”)"></a>虚拟壳(技术要求过高 以后写 “如果虚拟壳写的好直接拿去卖也不用工作 年入50w+”)</h3><p>虚拟技术应用到壳的领域，设计了一套<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020">虚拟机</a>引擎，将原始的汇编代码转译成虚拟机指令，要理解原始的汇编代码，就必须对其虚拟机引擎进行研究，而这极大地增加了破解和逆向的难度及成本。</p><h3 id="随机花指令构造器"><a href="#随机花指令构造器" class="headerlink" title="随机花指令构造器"></a>随机花指令构造器</h3><p>构造花指令，可以使用无条件跳转，比如ret、call、jmp来跳转，也可以使用有条件跳转，跳转的越多，能给人造成的困扰越大。</p><h3 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202210302007687.png" srcset="/img/loading.gif" lazyload alt="image-20221030200744494"></p><p>xp-win11 x64 x32 都得兼容</p><h3 id="内核型加壳器-sys的"><a href="#内核型加壳器-sys的" class="headerlink" title="内核型加壳器 .sys的"></a>内核型加壳器 .sys的</h3><h3 id="伪装OEP"><a href="#伪装OEP" class="headerlink" title="伪装OEP"></a>伪装OEP</h3><h3 id="压缩资源"><a href="#压缩资源" class="headerlink" title="压缩资源"></a>压缩资源</h3><p>注意 是压缩资源 不是压缩区段</p><p>换句话说就是加壳压缩</p><p>用到的有:</p><p>哈夫曼编码(好像已启用) UPX源码 IEXPRESS UPX ASProtect WinRAR NSPack DarkCrypt</p><p>alib原理</p><p><strong>1：当压缩算法扫描到中间某段位置时，如何和前面的内容进行快速比较。</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">首先回答第一个问题，很简单，用哈希，笔者采用了FNV哈希算法，效果挺好的，用c++stl中的<span class="hljs-built_in">hash</span>不知道效果如何，不过其实后来发现，哈希冲突在这里并不严重，一个好的哈希只能带来速度和内存的提升了，没办法提升压缩率的。然后我们如何解决哈希冲突呢，<span class="hljs-built_in">hash</span>冲突这里其实是重点，所表达的就是可能出现了相同字节串。<br>我们先说这个算法如何工作，首先我们只对定长的几个字节算<span class="hljs-built_in">hash</span>值，例如我们只算<span class="hljs-number">5</span>个字节的<span class="hljs-built_in">hash</span>值，然后保存<span class="hljs-built_in">hash</span>，之后每扫描一个字节，取出当前位置往后<span class="hljs-number">5</span>个字节，算<span class="hljs-built_in">hash</span>，和前面的比较，如果<span class="hljs-built_in">hash</span>值相同，则在进一步比较每个字节内容，<span class="hljs-built_in">hash</span>可以很快的知道内容是不一样的，没有办法知道内容是一样的，所以我们还需要实际的去比较每个字节，这意味着，我们在保存<span class="hljs-built_in">hash</span>的时候，还需要保存算得这个<span class="hljs-built_in">hash</span>的字节在整个文件中的index，我们取出上一个相同<span class="hljs-built_in">hash</span>值的字节的起始index，和当前位置往后比，一直比到文件结束或着出现不同，这里是一个重点，如：abcdefgabcabcabcabc，想象一下，这里如何压缩呢，好的做法是：abcdefg3339,第一组<span class="hljs-number">33</span>代表offet是<span class="hljs-number">3</span>，长度是<span class="hljs-number">3</span>，第二个<span class="hljs-number">39</span>offet是<span class="hljs-number">3</span>（就是第一个<span class="hljs-number">03</span>），长度是<span class="hljs-number">9</span>，所以，相同字节串可以涵盖本身（<span class="hljs-number">39</span>包含了自己）。<br>回到前面，我们应该如何设计保存<span class="hljs-built_in">hash</span>的结构了，首先为了快速索引，应该用一个数组或者vector保存<span class="hljs-built_in">hash</span>，既<span class="hljs-built_in">hash</span>值作为下标，这样可以快速索引，如何解决<span class="hljs-built_in">hash</span>冲突呢，easy，不解决，只保存，如我们构造一个长度为<span class="hljs-number">1000</span>的数组，把数组分成<span class="hljs-number">100</span>块，每块有<span class="hljs-number">10</span>个元素，产生的<span class="hljs-built_in">hash</span>值在<span class="hljs-number">0</span><span class="hljs-number">-99</span>中间，现在算的<span class="hljs-built_in">hash</span>值为<span class="hljs-number">1</span>，那么在第一块的第一个位置填入此时的index,往后又算出<span class="hljs-built_in">hash</span>值<span class="hljs-number">1</span>时，则在第<span class="hljs-number">1</span>块的第二个位置填入，所以，这里的块数作为<span class="hljs-built_in">hash</span>索引， 一块里面有多少个则代表可填入相同<span class="hljs-built_in">hash</span>值的数量，所以如果数量很多，那么就覆盖前面的，这里可以用一个环形缓冲区实现。<br></code></pre></td></tr></table></figure><p><strong>2：如何区分当前是压缩的内容，还是未压缩的内容。</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">回答第二个问题，如何分别是原来未压缩的数据，还是保存的<span class="hljs-built_in">offset</span>和<span class="hljs-built_in">length</span>呢，用VLQ编码，此处请goolge vlq编码，此外在实际验证中发现，<span class="hljs-built_in">offset</span> 和<span class="hljs-built_in">length</span>采用vlq编码后，往往<span class="hljs-built_in">length</span>比较小，采用vlq至少需要一个字节，所以可以考虑将<span class="hljs-built_in">length</span>编入<span class="hljs-built_in">offset</span>中，既<span class="hljs-built_in">offset</span>低位保存<span class="hljs-built_in">length</span>，再节省空间。<br></code></pre></td></tr></table></figure><h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><p>左节点右节点相加提供给单链</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">首先需要给出文件压缩和下面将要提到的文件解压缩的公共头文件<br><span class="hljs-number">1</span>.根据值和频率统计结果<br><span class="hljs-number">2</span>.利用结果创建哈夫曼树,得到相应的每个字符的哈夫曼编码<br><span class="hljs-number">3</span>.将数据写入文件<br>	(<span class="hljs-number">1</span>)校验头filehead<br>	(<span class="hljs-number">2</span>)将字符值和频率写入文件中<br>解压缩时重新创建hafuman数来译码<br></code></pre></td></tr></table></figure><h4 id="lzma-lz系列"><a href="#lzma-lz系列" class="headerlink" title="lzma  (lz系列)"></a>lzma (lz系列)</h4><p>采用马尔科夫链主要利用马尔科夫随机过程来消除原始文件中的基于上下文的冗余（如英文中字母Q后面紧接的字母为U的概率远较其它字母大），而不仅仅是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%93%88%E5%A4%AB%E6%9B%BC&spm=1001.2101.3001.7020">哈夫曼</a>编码中单纯的基于字符出现的随机统计概率</p><p>就是abcdefgabc转换成abcdefg73</p><h4 id="quicklz-号称世界上最快的压缩算法"><a href="#quicklz-号称世界上最快的压缩算法" class="headerlink" title="quicklz  号称世界上最快的压缩算法"></a>quicklz 号称世界上最快的压缩算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::string <span class="hljs-title">quicklz_compress</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; src)</span></span><br><span class="hljs-function"></span>&#123;<br>    qlz_state_compress state;<br>    <span class="hljs-built_in">memset</span>(&amp;state, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(qlz_state_compress));<br>    std::string dst;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">4096</span> + <span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>;pos&lt;src.<span class="hljs-built_in">size</span>();pos+=<span class="hljs-number">4096</span>) &#123;<br>        <span class="hljs-type">size_t</span> len = src.<span class="hljs-built_in">size</span>() - pos;<br>        len  = len &gt; <span class="hljs-number">4096</span> ? <span class="hljs-number">4096</span> : len;<br>        len = <span class="hljs-built_in">qlz_compress</span>(src.<span class="hljs-built_in">data</span>() + pos, buffer, len, &amp;state);<br>        dst.<span class="hljs-built_in">append</span>(buffer,len);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dst;<br>&#125;<br></code></pre></td></tr></table></figure><p>在压缩的过程中不断地读入3个字节，然后根据这3个字节得到一个hash值，根据这个hash值就可以找到offset，这个offset就是上次这个hash值出现的位置，而通过cache可以判断出这次出现的和最近一次出现相同hash值的时候的3个字节是不是相同（可能hash相同而实际的值不同）。</p><p>level1 四个字节四个字节的hash对比 获取重复值</p><p>level2 对比4个offset的hash 选取其中最长的当模板</p><p>level3</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(matchlen == <span class="hljs-number">3</span> &amp;&amp; offset &lt;= <span class="hljs-number">63</span>)<br>&#123;<br>    *dst = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)(offset &lt;&lt; <span class="hljs-number">2</span>);<br>    dst++;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matchlen == <span class="hljs-number">3</span> &amp;&amp; offset &lt;= <span class="hljs-number">16383</span>)<br>&#123;<br>    ui32 f = (ui32)((offset &lt;&lt; <span class="hljs-number">2</span>) | <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">fast_write</span>(f, dst, <span class="hljs-number">2</span>);<br>    dst += <span class="hljs-number">2</span>;<br>&#125;        <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matchlen &lt;= <span class="hljs-number">18</span> &amp;&amp; offset &lt;= <span class="hljs-number">1023</span>)<br>&#123;<br>    ui32 f = ((matchlen - <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-number">2</span>) | ((ui32)offset &lt;&lt; <span class="hljs-number">6</span>) | <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">fast_write</span>(f, dst, <span class="hljs-number">2</span>);<br>    dst += <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matchlen &lt;= <span class="hljs-number">33</span>)<br>&#123;<br>    ui32 f = ((matchlen - <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">2</span>) | ((ui32)offset &lt;&lt; <span class="hljs-number">7</span>) | <span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">fast_write</span>(f, dst, <span class="hljs-number">3</span>);<br>    dst += <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    ui32 f = ((matchlen - <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-number">7</span>) | ((ui32)offset &lt;&lt; <span class="hljs-number">15</span>) | <span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">fast_write</span>(f, dst, <span class="hljs-number">4</span>);<br>    dst += <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在level&#x3D;3的时候与前两个的不同之处是最低的两位统一作为标志</p><p><a target="_blank" rel="noopener" href="http://www.wjhsh.net/xumaojun-p-8541618.html">http://www.wjhsh.net/xumaojun-p-8541618.html</a></p><h3 id="图形化"><a href="#图形化" class="headerlink" title="图形化"></a>图形化</h3><h3 id="壳代码纯shellcode开发"><a href="#壳代码纯shellcode开发" class="headerlink" title="壳代码纯shellcode开发"></a>壳代码纯shellcode开发</h3><p>将壳代码编译为Shellcode代码，方便移植、混淆、特征码定位。Shellcode开发方法论坛搜索即可，非常多的帖子。</p><h3 id="API字符串隐藏"><a href="#API字符串隐藏" class="headerlink" title="API字符串隐藏"></a>API字符串隐藏</h3><p>Shellcode编程的常规编写技巧，将API字符串转为HASH，壳代码通过HASH来获取API地址。此技术主要用于缩短Shellcode体积、干扰分析人员分析。</p><h3 id="Shellcode动态获取外部参数"><a href="#Shellcode动态获取外部参数" class="headerlink" title="Shellcode动态获取外部参数"></a>Shellcode动态获取外部参数</h3><p>参考”图-CodeLoader数据结构”可以发现壳代码CodeLoaderCode(EntryPoint函数生成在壳代码CodeLoaderCode的首部)是储存在PARAM_CODE_LOADER结构体的尾部。</p><p>因此只需要动态定位到&amp;EntryPoint函数的内存地址，然后减去sizeof(PARAM_CODE_LOADER)就可以获取到加壳器传递的参数数据了。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202211051701031.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p><h3 id="简单图片隐写技术-最大化的压缩体积"><a href="#简单图片隐写技术-最大化的压缩体积" class="headerlink" title="简单图片隐写技术(最大化的压缩体积)"></a>简单图片隐写技术(最大化的压缩体积)</h3><h3 id="入口点模糊技术"><a href="#入口点模糊技术" class="headerlink" title="入口点模糊技术"></a>入口点模糊技术</h3><p>QVM引擎已经对主流编译器编译的程序，从入口点&#x3D;&#x3D;（OEP）&#x3D;&#x3D;开始提取&#x3D;&#x3D;一段&#x3D;&#x3D;特征代码作为判断依据，因此只要修改入口点代码QVM引擎就会报“HEUR&#x2F;Malware.QVM20.Gen”。</p><p>杀软检测入口点代码的绕过方法：</p><p>1、 使用壳代码完全伪造主流编译器编译的程序的入口点特征</p><p>2、 不修改入口点开始处的代码，而是在QVM引擎提取的入口点特征代码的&#x3D;&#x3D;尾部劫持执行流&#x3D;&#x3D;(此壳就是使用的这个方法)<img src="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202211051713878.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p><h3 id="内存加载PE-amp-支持壳上壳"><a href="#内存加载PE-amp-支持壳上壳" class="headerlink" title="内存加载PE&amp;支持壳上壳"></a>内存加载PE&amp;支持壳上壳</h3><p>​	当前使用的内存中加载PE技术,是通过将”被加壳程序”内存展开后，覆盖到当前进程的ImageBase处，随后修复”被加壳程序”的IAT表，设置区段属性，最终调用”被加壳程序”的OEP将执行权限交给”被加壳程序”。这种写壳方式的天生就支持壳上壳功能。</p><p>​	壳上壳的功能主要是为了躲避内存查杀。可使用VMP、TMD、SE等虚拟化壳的代码虚拟化功能来模糊化被加壳程序的内存特征，当然使用自写的VM、混淆引擎更好，&#x3D;&#x3D;不过写一个稳定、兼容性好的VM、混淆引擎耗时太长。&#x3D;&#x3D;</p><p>加多重壳需要注意关闭内层壳的校验基址，如下图的VMP：<img src="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202211051728203.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p><h3 id="兼容性较好的修复IAT表方法"><a href="#兼容性较好的修复IAT表方法" class="headerlink" title="兼容性较好的修复IAT表方法"></a>兼容性较好的修复IAT表方法</h3><p>使用双向链表</p><p>​	兼容性较好的修复导入表(IAT)方法，优先使用INT表来获取API地址。解决有些编译器编译的程序导入表(IAT)不规范的问题（Delphi）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//获取导入表首地址</span><br>IMAGE_DOS_HEADER* pDosHdr = (IMAGE_DOS_HEADER*)pImageBaseAddr;<br>IMAGE_NT_HEADERS* pNtHdr = (IMAGE_NT_HEADERS*)(pDosHdr-&gt;e_lfanew + (DWORD)pImageBaseAddr);<br>IMAGE_DATA_DIRECTORY* pDataDirHdr = (IMAGE_DATA_DIRECTORY*)pNtHdr-&gt;OptionalHeader.DataDirectory;<br>IMAGE_IMPORT_DESCRIPTOR* pImport = (IMAGE_IMPORT_DESCRIPTOR*)(pDataDirHdr[<span class="hljs-number">1</span>].VirtualAddress + (DWORD)pImageBaseAddr);<br> <br><span class="hljs-keyword">while</span> (pImport-&gt;OriginalFirstThunk != <span class="hljs-number">0</span> || pImport-&gt;FirstThunk != <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-comment">//获得当前DLL名</span><br>    <span class="hljs-type">char</span>* chName = (<span class="hljs-type">char</span>*)(pImport-&gt;Name + (DWORD)pImageBaseAddr);<br> <br>    <span class="hljs-comment">//加载模块</span><br>    HMODULE hModule = <span class="hljs-built_in">p_LoadLibraryExA</span>(chName, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br> <br>    <span class="hljs-comment">//如果有INT表则通过INT表来修复IAT表</span><br>    DWORD* pReferenceTab = <span class="hljs-literal">nullptr</span>;<br>    (pImport-&gt;OriginalFirstThunk == <span class="hljs-number">0x0</span>) || (pImport-&gt;OriginalFirstThunk == <span class="hljs-number">0xFFFFFFFF</span>) ?<br>        pReferenceTab = (DWORD*)(pImport-&gt;FirstThunk + (DWORD)pImageBaseAddr) :<br>        pReferenceTab = (DWORD*)(pImport-&gt;OriginalFirstThunk + (DWORD)pImageBaseAddr);<br> <br>    <span class="hljs-comment">//被修复的IAT表</span><br>    DWORD* pIatTab = (DWORD*)(pImport-&gt;FirstThunk + (DWORD)pImageBaseAddr);<br> <br>    DWORD dwIatIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (pReferenceTab[dwIatIndex] != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">//判断是什么方式导入 &lt;序号&gt; &lt;名称&gt;</span><br>        <span class="hljs-keyword">if</span> ((pReferenceTab[dwIatIndex] &amp; <span class="hljs-number">0x80000000</span>) == <span class="hljs-number">0</span>) <span class="hljs-comment">//最高为1是序号导入</span><br>        &#123;<br>            IMAGE_IMPORT_BY_NAME* pByName = (IMAGE_IMPORT_BY_NAME*)<br>                (pReferenceTab[dwIatIndex] + (DWORD)pImageBaseAddr);<br> <br>            <span class="hljs-comment">//获取到的API地址</span><br>            pIatTab[dwIatIndex] = (DWORD)<span class="hljs-built_in">p_GetProcAddress</span>(hModule, pByName-&gt;Name);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            DWORD dwIndex = pReferenceTab[dwIatIndex] &amp; <span class="hljs-number">0x7FFFFFFF</span>;<br>            <span class="hljs-comment">//获取到的API地址</span><br>            DWORD dwApiAddr = (DWORD)<span class="hljs-built_in">p_GetProcAddress</span>(hModule, (<span class="hljs-type">char</span>*)dwIndex);<br>            pIatTab[dwIatIndex] = (DWORD)dwApiAddr;<br>        &#125;<br>        ++dwIatIndex;<br>    &#125;<br>    <span class="hljs-comment">//指向下一个结构体</span><br>    pImport += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="长时间执行垃圾指令进行沙箱逃逸"><a href="#长时间执行垃圾指令进行沙箱逃逸" class="headerlink" title="长时间执行垃圾指令进行沙箱逃逸"></a>长时间执行垃圾指令进行沙箱逃逸</h3><h3 id="反注射"><a href="#反注射" class="headerlink" title="反注射"></a>反注射</h3><ul><li>使用EnumProcessModulesEx (32位、64位和所有选项)枚举模块</li><li>使用工具帮助枚举模块32</li><li>使用LdrEnumerateLoadedModules枚举流程LDR结构</li><li>直接列举流程LDR结构</li><li>具有GetModuleInformation的行走记忆</li><li>隐藏模块的行走记忆</li></ul><h3 id="反dumping"><a href="#反dumping" class="headerlink" title="反dumping"></a>反dumping</h3><ul><li>从内存中擦除PE头</li><li>SizeOfImage</li></ul><h3 id="定时攻击-反沙盒"><a href="#定时攻击-反沙盒" class="headerlink" title="定时攻击[反沙盒]"></a>定时攻击[反沙盒]</h3><p><a target="_blank" rel="noopener" href="https://github.com/LordNoteworthy/al-khaser#antidebug">https://github.com/LordNoteworthy/al-khaser#antidebug</a></p><h3 id="人类互动-x2F-通用-反沙盒"><a href="#人类互动-x2F-通用-反沙盒" class="headerlink" title="人类互动&#x2F;通用[反沙盒]"></a>人类互动&#x2F;通用[反沙盒]</h3><h3 id="反虚拟化-x2F-全系统仿真"><a href="#反虚拟化-x2F-全系统仿真" class="headerlink" title="反虚拟化&#x2F;全系统仿真"></a>反虚拟化&#x2F;全系统仿真</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs clean">### 注册表项工件**<br><br>### **文件系统工件**<br><br>### **目录工件**<br><br>### **记忆假象**<br><br>### **mac地址**<br><br>### **虚拟设备**<br><br>### **硬件设备信息**<br><br>### **DLL导出和加载的DLL**<br><br>### **系统固件表**<br><br>### **WMI**<br><br>### **中央处理器<br></code></pre></td></tr></table></figure><h3 id="Anti-Disassembly"><a href="#Anti-Disassembly" class="headerlink" title="Anti-Disassembly"></a>Anti-Disassembly</h3><ul><li>以恒定条件跳跃</li><li>目标相同的跳转指令</li><li>不可能拆卸</li><li>函数指针</li><li>返回指针滥用</li></ul><h3 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h3><ol><li></li></ol><p>如果在外壳程序中，有复杂的操作，要用到容器，比如矢量、链表或者树，不能用Windows提供的标准模板库，因为这里面说不一定就会用到API,从而导致程序出错。<br>可以仿照标准模板库设计自己的库，比如设计一个vector容器</p><p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1277269-1-1.html">https://www.52pojie.cn/thread-1277269-1-1.html</a></p><ol start="2"><li></li></ol><p>在外壳里面怎么获取随机数的问题，可以直接逆向(直接改写源码)srand()和rand()两个函数，<br>以下的随机数函数就是照搬srand()和rand()</p><ol start="3"><li></li></ol><p>垃圾指令构造器的设计非常简单，难点在于垃圾指令的选择，有些指令是不能作为垃圾指令的，改变普通寄存器的指令不能用，比如AAA指令，会改变eax寄存器的值。具体参考Intel手册。</p><p>但是&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>其实也不是不能用，可以对上下文分析看哪些寄存器暂时未被使用，然后对其赋值。如果有 CALL&#x2F;JMP 可以暂时先跳过。</p><p>而且感觉插入 CALL&#x2F;JMP 后很容易破坏自动分析工具？可以在垃圾代码中插入一堆看上去有用实际上没用流程控制&#x2F;空函数调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">; 比如这里可以放入操作 eax/ecx 的指令，如 add eax, ebx; call dword[nop]<br>mov eax, <span class="hljs-number">1</span><br>; 比如这里可以放入操作 ecx 的指令，如 add ecx, eax<br>xor eax, ebx<br>; 这里 可以放入操作 ecx 的指令<br>mov ecx, <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>也可以插一段算法，比如趁着某个寄存器还未被使用的时候修改，然后用算法还原到之前的状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">mov eax, <span class="hljs-number">1</span><br>; 插入 add eax, <span class="hljs-number">3</span><br>mov ecx, <span class="hljs-number">1</span><br>; 插入 dec eax; sub eax, <span class="hljs-number">2</span><br>; 插入这两段后，eax 就变回原来的值了（我记得 VMP 也有类似的处理，不过更复杂？）<br>; 也可以利用此时 ecx 为 <span class="hljs-number">1</span>（常量赋值），把这一段改成 add eax, ecx; sub eax, <span class="hljs-number">4</span><br>xor eax, ebx<br></code></pre></td></tr></table></figure><h2 id="免杀方法"><a href="#免杀方法" class="headerlink" title="免杀方法"></a>免杀方法</h2><p>当前主流的技术,需要有源代码才能操作。通过修改病毒的特征字符串、动态API调用、修改编译环境、套程序外壳(MFC、SDK、QT)等</p><h3 id="输入表-IAT-免杀法"><a href="#输入表-IAT-免杀法" class="headerlink" title="输入表(IAT)免杀法"></a>输入表(IAT)免杀法</h3><p>发式引擎会扫描目标程序的输入表中是否包含指定的函数特征序列(函数调用特征码)。</p><p>解决方案：(本段摘自未知作者)</p><ul><li><p><input disabled type="checkbox"> 1、 输入表函数移位法：这是最早也是比较简单的输人表免杀方法了，虽然效果已经不像当年那么好了，但却是学习免杀过程必须要掌握的基础知识。我们使用C32打开一个EXE文件，找到输入表段，找到我们定位出的特征输入表，比如ShellExecuteA就是，我们将其使用OO填充，然后在附近找到一片空白区域，将刚才找到的代码再粘贴到空白区域中，并记下新函数的地址，ShellExecuteA字符串最前面的那个“S”的地址减2，即00078925，这样就实现了转移，但是要想让程序知道我们转移的函数，我们还得告诉输入表，刚才那个地址是文件偏移地址，但不是内存地址，我们需要利用OC计算出新的输入表函数ShellExecuteA的内存位置，并在LoadPE中修改才行。</p></li><li><p><input disabled type="checkbox"> 2、 输入表函数对调法：这个方法的原理就是将输入表函数名长度相同的函数在C32中进行对调，只有长度一样才不会出错，然后在LoadPE中做相应的修改即可。比如被查杀的函数是OpenFileA，存在于A.dll文件中，我们在b.dll中找到了一个GetATimeA函数，这两个函数名称长度一样，我们在C32中做了静态对换之后，还要将它们的RVA进行对换</p></li><li><p><input checked disabled type="checkbox"> 3、 手工重建输入表：关于输入表的重建，我想大家都非常熟悉了吧，这算是比较复杂的一种方法了，不过免杀效果非常好，这也是必须要掌握的方法哦！这个方法其实就是添加一个新区段，再把原来的输入表移到我们新建的区段上，重建主要是针对杀毒软件定位到大片输入表函数。</p></li><li><p><input disabled type="checkbox"> 4、 输入表隐藏法：将输入表加密隐藏，然后内存解密修复输入表。属于保护壳常用的技术。</p></li></ul><p>代码混淆、加花：通过对特征代码进行膨胀、乱序来干扰启发式引擎的分析，以及提升人工提取特征码的难度。</p><p>入口模糊技术</p><p>内存加载执行PE文件：壳的基本技术，论坛资料很多。</p><h3 id="机器学习引擎（以360QVM为例），绕过方式如下："><a href="#机器学习引擎（以360QVM为例），绕过方式如下：" class="headerlink" title="机器学习引擎（以360QVM为例），绕过方式如下："></a><strong>机器学习引擎（以360QVM为例），绕过方式如下：</strong></h3><p>模拟正常程序的PE结构（该免杀壳方案能有效针对该引擎，或许还能污染机器学习引擎的分析结果）</p><p><strong>常见QVM引擎报毒原因：</strong></p><p>HEUR&#x2F;Malware.QVM06.Gen 一般情况下加数字签名可过HEUR&#x2F;Malware.QVM07.Gen 一般情况下换资源HEUR&#x2F;Malware.QVM13.Gen 加壳了HEUR&#x2F;Malware.QVM19.Gen 杀壳HEUR&#x2F;Malware.QVM20.Gen 改变了入口点HEUR&#x2F;Malware.QVM27.Gen 输入表HEUR&#x2F;Malware.QVM18.Gen 加花HEUR&#x2F;Malware.QVM05.Gen 加资源，改入口点</p><h3 id="沙箱-虚拟机-行为分析引擎，绕过方式如下："><a href="#沙箱-虚拟机-行为分析引擎，绕过方式如下：" class="headerlink" title="沙箱(虚拟机)行为分析引擎，绕过方式如下："></a><strong>沙箱(虚拟机)行为分析引擎，绕过方式如下：</strong></h3><p>简介：所谓“沙箱”安全技术，是指以计算机系统为基础对恶意软件的行为与特征进行分析并最终检测出恶意代码的方案。</p><p>解决方案：</p><p>1、通过检测沙箱(虚拟机)与物理机的差异化(参考：<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-225735.htm)%EF%BC%8C%E6%A3%80%E6%B5%8B%E5%88%B0%E6%B2%99%E7%AE%B1(%E8%99%9A%E6%8B%9F%E6%9C%BA)%E5%88%99%E4%B8%8D%E6%89%A7%E8%A1%8C%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E3%80%82">https://bbs.pediy.com/thread-225735.htm)，检测到沙箱(虚拟机)则不执行恶意代码。</a></p><p>2、延时180+秒(效果比较好)加载恶意代码，沙箱(虚拟机)的检测结束后无法探测到恶意行为。笔者比较推崇此方法，因为此方法针对的是所有反病毒厂商的沙箱(虚拟机)检测。</p><p>3、挖掘开机启动程序的代码执行漏洞，配合白加黑技术来执行敏感行为。</p><h3 id="主动防御："><a href="#主动防御：" class="headerlink" title="主动防御："></a><strong>主动防御：</strong></h3><p>简介：主动防御是基于程序行为自主分析判断的实时防护技术，不以病毒的特征码作为判断病毒的依据，而是从最原始的病毒定义出发，直接将程序的行为作为判断病毒的依据。</p><p>360主动防御模块经过做黑灰兄弟们的不懈努力，已经非常完善了，绝大部分常规、非常规的行为绕过方式均已被拦截，并弹出一个默认阻止的小框框。</p><p>1、继续挖掘非常规方法绕过主防的拦截，主防未监控到的区域。</p><p>2、白程序(包含在杀软白名单库中的程序)加黑程序方式来执行高危行为，写启动项、键盘记录等。(不过要注意的是360白程序判定逻辑，灰程序加载的白程序 &#x3D; 灰程序，因此需要绕过主防的程序执行链监控)</p><h3 id="3-免杀壳开发-by-AYZRxx"><a href="#3-免杀壳开发-by-AYZRxx" class="headerlink" title="3  免杀壳开发(by: AYZRxx)"></a>3 免杀壳开发(by: AYZRxx)</h3><h4 id="3-1-免杀壳核心思想-伪装"><a href="#3-1-免杀壳核心思想-伪装" class="headerlink" title="3.1  免杀壳核心思想-伪装"></a>3.1 免杀壳核心思想-伪装</h4><p>经过10多年的发展，反病毒引擎已经在误报&amp;查毒粒度之间取了一个比较好的平衡，常规的免杀技术（特征码免杀、源码免杀）处理成本越来越高。不过反病毒引擎天然存在某些”缺陷”，例如正常软件会加商业保护壳，导致会受到商业壳的制约，无法将所有壳标记为病毒。</p><p>由于内存执行”被加壳程序”是壳的基础行为，&#x3D;&#x3D;而内存执行PE这个”壳的基础行为”可以很好的将”被加壳程序”的特征码隐藏起来。&#x3D;&#x3D;因此编写一款无特征码壳是一个非常好的反杀软查杀(特征码、启发式)的方案。</p><p>\1. &#x3D;&#x3D;模拟正常PE程序结构, 模拟正常PE程序结构, 模拟正常PE程序结构&#x3D;&#x3D;</p><p>\2. 特征代码最小化，并且&#x3D;&#x3D;被查杀后&#x3D;&#x3D;可通过&#x3D;&#x3D;混淆引擎&#x3D;&#x3D;来混淆壳代码，达到快速变种、快速免杀的效果。</p><p>\3. 笔者不建议进行任何可能提高程序熵值的操作，&#x3D;&#x3D;尽可能将壳程序的PE格式、数据结构、代码执行顺序与正常程序保持一致。&#x3D;&#x3D;</p><h4 id="3-2-免杀壳的编写框架说明"><a href="#3-2-免杀壳的编写框架说明" class="headerlink" title="3.2  免杀壳的编写框架说明"></a>3.2 免杀壳的编写框架说明</h4><p>这个免杀壳的代码主要分为三部分：</p><p>加壳器：这部分代码用来将被加壳程序、傀儡程序、壳代码拼装处理，组合生成一个免杀的PE文件。</p><p>CodeLoader（壳代码）：这部分代码用来反杀毒引擎、内存加载执行PeLoader，需要编译为Shellcode代码。</p><p>PeLoader（壳代码）：这部分代码用来内存执行Shelled（被加壳程序），需要编译为Shellcode代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">Ø  Shelled：被加壳程序<br><br>Ø  Pepput：傀儡程序，用来伪装成正常PE文件，植入壳代码的载体<br><br>Ø  CodeLoaderCode：壳代码<br><br>Ø  PeLoaderCode：壳代码<br><br>Ø  CodeLoader：作用是反调试、反沙箱(虚拟机)、加载执行PeLoader(只有这段代码暴露在杀毒引擎的检测范围之内，只需要对这段代码做混淆即可快速免杀)<br><br>Ø  PeLoader：作用是加载执行Shelled（被加壳程序）<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>、 加壳后只有CodeLoader代码暴露在杀毒引擎（静态）检测范围内，混淆前代码只有<span class="hljs-number">1</span>KB左右大小，由于可定位的特征代码少，特征码免杀较为简单。<br><br><span class="hljs-attribute">2</span>、 传统的Shellcode使用自解密的方式来模糊特征，需要代码段内存具有可写属性，该操作会导致启发式引擎报毒。CodeLoader代码则使用了代码混淆技术来达到免于杀毒引擎查杀的效果，代码段内存在PE结构种无需具有可写属性。<br><br><span class="hljs-attribute">3</span>、 并且只需要在CodeLoader代码加入检测沙箱、虚拟机的功能代码，绕过杀毒引擎的行为检测，就做到了基本的无特征码化、无行为化。<br><br><span class="hljs-attribute">4</span>、 无需创建傀儡进程，远程写内存这种高危行为杀毒软件是不允许的。<br><br><span class="hljs-attribute">5</span>、 内存加载PE文件就是老生常谈了，不再做过多的阐述，论坛里面有大量的优秀文章可供参考。<br></code></pre></td></tr></table></figure><h2 id="先看看别人的代码分析分析"><a href="#先看看别人的代码分析分析" class="headerlink" title="先看看别人的代码分析分析"></a>先看看别人的代码分析分析</h2><h3 id="Peprotect"><a href="#Peprotect" class="headerlink" title="Peprotect"></a>Peprotect</h3><h4 id="stub"><a href="#stub" class="headerlink" title="stub"></a>stub</h4><p>stub.cpp(植入的.cpp)</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-number">1</span>.汇编找到kernel<span class="hljs-selector-class">.dll</span><br><span class="hljs-number">2</span><span class="hljs-selector-class">.kernel</span><span class="hljs-selector-class">.dll</span>获取各类函数地址<br><span class="hljs-number">3</span>.填充iat<br><span class="hljs-number">4</span>.修复exe重定位<br><span class="hljs-number">5</span>.对加壳器(加密部分)的解密<br><span class="hljs-number">6</span>.执行TLS回调 <span class="hljs-comment">//当这个进程处于TIS保护状态时(默认处于)，需要重装TLS以进行修改</span><br><span class="hljs-number">7</span>.调用窗口函数验证密码(跟像是一种勒索软件)(看下有没有不需要窗口的但是能使用密码的)<br><span class="hljs-number">8</span>.解压<br><span class="hljs-number">9</span>.混淆函数(花指令)<br><span class="hljs-number">10</span>.壳程序<br></code></pre></td></tr></table></figure><p>dllmain.cpp</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">switch</span><br>	创建进程<br>	创建线程<br>	关闭线程<br>	关闭进程<br></code></pre></td></tr></table></figure><h4 id="peprotect"><a href="#peprotect" class="headerlink" title="peprotect"></a>peprotect</h4><p>peprotect.cpp</p><p>peprotectdl.cpp</p><p>用来设置对话框</p><h4 id="pack"><a href="#pack" class="headerlink" title="pack"></a>pack</h4><p>dllmain.cpp</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">switch</span><br>	创建进程<br>	创建线程<br>	关闭线程<br>	关闭进程<br></code></pre></td></tr></table></figure><p>PE.cpp</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">DWORD CPe::<span class="hljs-constructor">GetOepRva()</span> 获取目标程序的入口点Rva<br><span class="hljs-built_in">bool</span> CPe::ReadTargetFile 读取要加密文件到内存<br>DWORD CPe::<span class="hljs-constructor">RvaToOffset(DWORD Rva)</span>  用于将PE文件的rva转为文件偏移<br>DWORD CPe::AddSection 添加区段<br>DWORD CPe::<span class="hljs-constructor">GetFirstNewSectionRva()</span> 获取第一个新区段的rva<br>void CPe::<span class="hljs-constructor">SetNewOep(DWORD <span class="hljs-params">dwNewOep</span>)</span> 设置新的程序入口点<br>void CPe::<span class="hljs-constructor">SaveNewFile(<span class="hljs-params">char</span><span class="hljs-operator">*</span> <span class="hljs-params">pPath</span>)</span> 保存文件<br>DWORD  CPe::<span class="hljs-constructor">CalcAlignment(DWORD <span class="hljs-params">dwSize</span> , DWORD <span class="hljs-params">dwAlignment</span>)</span> 获取对齐后的大小<br>void CPe::<span class="hljs-constructor">FixDllRloc(PCHAR <span class="hljs-params">pStubBuf</span>, PCHAR <span class="hljs-params">pStub</span>)</span> 根据新区段的地址修复dll的重定位<span class="hljs-literal">[<span class="hljs-identifier">dll</span>是加载到内存的,这里根据默认加载基址,新添加的节区的<span class="hljs-identifier">rva</span>以及和原节区开始的差值来重新设置.<span class="hljs-identifier">text</span>的重定位]</span><br>void CPe::<span class="hljs-constructor">Encryption()</span> 对代码段进行加密<br>void CPe::<span class="hljs-constructor">CancleRandomBase()</span> 去除重定位<br>DWORD CPe::<span class="hljs-constructor">GetImportTableRva()</span> 获取导入表的rva<br>DWORD CPe::<span class="hljs-constructor">GetRelocRva()</span> 获取重定位表的rva<br>void CPe::<span class="hljs-constructor">ChangeImportTable()</span> 对导入表进行更改<br>DWORD CPe::<span class="hljs-constructor">GetImageBase()</span> 获取目标程序加载基址<br>void CPe::<span class="hljs-constructor">SetMemWritable()</span> 设置每个区段为可写状态<br>void CPe::<span class="hljs-constructor">ChangeReloc(PCHAR <span class="hljs-params">pBuf</span>)</span> 对于动态加载基址,需要将stub的重定位区段(.reloc)修改后保存,将PE重定位信息指针指向该地址（新区段）<br>DWORD CPe::<span class="hljs-constructor">GetNewSectionRva()</span> 如果要添加一个新区段,获得这个新区段的rva<br>DWORD CPe::<span class="hljs-constructor">GetLastSectionRva()</span> 获取最后一个段的rva<br>void CPe::<span class="hljs-constructor">EnCompression(PPACKINFO &amp; <span class="hljs-params">pPackInfo</span>)</span> 压缩区段 压缩在加密区段之后<br>PCHAR CPe::<span class="hljs-constructor">Compress(PVOID <span class="hljs-params">pSource</span>, IN <span class="hljs-params">long</span> InLength, OUT <span class="hljs-params">long</span> &amp; OutLength)</span> 调用压缩库<br>BOOL CPe::<span class="hljs-constructor">ModifyTlsTable(PPACKINFO &amp; <span class="hljs-params">pPackInfo</span>)</span> 修改Tls表<br>void CPe::<span class="hljs-constructor">SetTls(DWORD NewSectionRva, PCHAR <span class="hljs-params">pStubBuf</span>, PPACKINFO <span class="hljs-params">pPackInfo</span>)</span> 设置stub的tls表<br></code></pre></td></tr></table></figure><p>Pack.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">加壳<br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> _declspec(dllexport) c++调用c模块<br>	<span class="hljs-number">1.</span>调用LoadLibrary将stub.dll载入到内存<br>	<span class="hljs-number">2.</span>GetprocAddress在内存中找到和stub.dll通讯的 <span class="hljs-built_in">g_PackInfo</span>(stub.dll中设置了g_PackInfo的信息)<br>	<span class="hljs-number">3.</span>调用PE.cpp中的ReaTargetFile将pPath加密读取到内存<br>	<span class="hljs-number">4.b</span>TlsUseful = obj.<span class="hljs-built_in">ModifyTlsTable</span>(pPackInfo)获取TLS信息<br>	<span class="hljs-number">5.</span>obj.<span class="hljs-built_in">Encryption</span>();对代码段进行加密<br>	<span class="hljs-number">6.</span>obj.<span class="hljs-built_in">EnCompression</span>(pPackInfo);压缩区段<br>	<span class="hljs-number">7.</span>获取stub.dll的内存大小和节区头(也就是要拷贝的头部)<br>	<span class="hljs-number">8.</span>设置加壳信息<br>		pPackInfo-&gt;TargetOepRva = obj.<span class="hljs-built_in">GetOepRva</span>() 获取进程OEP<br>		ImageBase = obj.<span class="hljs-built_in">GetImageBase</span>(); 获取目标程序加载基址Iamgebase<br>		获取目标程序重定位表rva和导入表的rva ImportTableRva = obj.<span class="hljs-built_in">GetImportTableRva</span>() RelocRva = obj.<span class="hljs-built_in">GetRelocRva</span>()<br>	<span class="hljs-number">9.</span>获得Stub.dll模块中Start函数的相对虚拟地址：VA-Stub.dll基址<br>	<span class="hljs-number">10.</span>由于直接在本进程中修改会影响进程,所以将dll拷贝一份到pStubBuf   memcpy_s<br>	<span class="hljs-number">11.</span>obj.<span class="hljs-built_in">FixDllRloc</span>(pStubBuf, (PCHAR)hStub); 修复dll文件重定位,这里第二个参数应该传入Stub.dll模块基址hStub,因为这是dll加载时重定位的依据<br>	<span class="hljs-number">12.</span>把stub.dll的代码段.text添加为目标程序的新区段<br>	<span class="hljs-number">13.</span>SetTls<br>	<span class="hljs-number">14.</span><span class="hljs-comment">//obj.CancleRandomBase() 可以选择去掉重定位</span><br>	<span class="hljs-comment">// 或者将stub的重定位区段粘到最后面,将重定位项指向之,但是这之前也必须FixDllRloc,使其适应新的PE文件</span><br>	obj.<span class="hljs-built_in">ChangeReloc</span>(pStubBuf); <br>	<span class="hljs-number">15.</span>	把目标程序的OEP设置为stub中的start函数  obj.<span class="hljs-built_in">SetNewOep</span>(dwNewOep);<br>	<span class="hljs-number">16.</span> 设置每个区段可写 obj.<span class="hljs-built_in">SetMemWritable</span>();<br>	<span class="hljs-number">17.</span> 对IAT进行加密 obj.<span class="hljs-built_in">ChangeImportTable</span>();<br>	<span class="hljs-number">18.</span> 释放改<span class="hljs-function">dll <span class="hljs-title">FreeLibrary</span><span class="hljs-params">(hStub)</span></span>;<br>	<span class="hljs-number">19.</span>保存成文件		<br></code></pre></td></tr></table></figure><h3 id="Packer-master"><a href="#Packer-master" class="headerlink" title="Packer-master"></a>Packer-master</h3><h4 id="stub-dll"><a href="#stub-dll" class="headerlink" title="stub.dll"></a>stub.dll</h4><p>aplib.lib– 壳压缩引擎</p><p>info.h – c++文件系统 管理写读</p><p>dllmain.cpp (直接将创建线程和功能都写在里面了)(用到了内存管理)</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-number">1.</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SIZEOF_BASE_RELOCATION (sizeof(IMAGE_BASE_RELOCATION))  如果SDK不支持的话 这样定义基址重定位表  </span><br><span class="hljs-number">2.</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DLL_SAMPLE_API __declspec(dllexport) DLL导入类</span><br><span class="hljs-number">3.</span>打印日志位置，修改这个地方 LOG_PATH L<span class="hljs-string">&quot;D:/log.txt&quot;</span><br><span class="hljs-number">4.</span>生成自动删除文件名称<br><span class="hljs-number">5.</span>是否开始反调试代码 ANTI_REVERSE<br><span class="hljs-number">6.</span>默认打开日志  SUPPORT_LOG<br><span class="hljs-number">7.</span>自定义malloc模块   MemoryNode *node = (MemoryNode *)s_apier.VirtualAlloc(NULL, len + <span class="hljs-keyword">sizeof</span>(MemoryNode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);<span class="hljs-comment">//这个是内存管理 这个 (MemoryNode *)s_apier是类</span><br><span class="hljs-number">8.</span>自定义mfree模块 调用了virtualfree<br><span class="hljs-number">9.</span>自定义pmemcpy<br><span class="hljs-number">10.</span>自定义ccpy sstrlen  memsetZero<br><span class="hljs-number">11.</span>getNtHeader<br><span class="hljs-number">12.</span>getImageSectionHeader<br><span class="hljs-number">13.</span>自定义 *int_to_str mprintf<br><span class="hljs-number">14.b</span>eingdebugged反调试<br><span class="hljs-number">15.</span>定义pUnhandledExceptionFilter 异处理异常筛选器<br><span class="hljs-number">16.</span>利用SetUnhandledExceptionFilter和pUnhandledExceptionFilter自定义一个异常处理反调试器isDebug1<br><span class="hljs-number">17.</span>_declspec (thread) LPCTSTR g_strTLS = L<span class="hljs-string">&quot;Stub TLS DATA&quot;</span>声明一个线程本地变量<br><span class="hljs-number">18.</span>创建TLS段  自然还是用到了C语言<br><span class="hljs-number">19.</span>照旧汇编获取kernel32,不过好像更高级了一点<br><span class="hljs-number">20.</span>GetGPAFunAddr函数定义 里面获取DOS头、NT头  获取导出表项 获取导出表详细信息 处理以函数名查找函数地址的请求，循环获取ENT中的函数名，并与传入值对比对，如能匹配上则在EAT中以指定序号作为索引，并取出其地址值。<br><span class="hljs-number">21.</span>初始化必要的函数信息 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initFunction</span>()</span><br><span class="hljs-function">22.获取当前运行的进程地址 *<span class="hljs-title">getExePath</span>()</span><br><span class="hljs-function">23.生成临时bat文件字符串,使用mfree删除 *<span class="hljs-title">getTempDelBatFilePath</span>()</span><br><span class="hljs-function">24.自删除逻辑   <span class="hljs-title">deleteSelf</span>()</span><br><span class="hljs-function">25.自定义InitTLS表 (<span class="hljs-params">IMAGE_TLS_DIRECTORY中的地址就是虚拟地址直接用</span>)</span><br><span class="hljs-function">26.IAT重写 recoverIAT</span><br><span class="hljs-function">27.重定位OFFSET结构 typedef <span class="hljs-keyword">struct</span> _TYPEOFFSET</span><br><span class="hljs-function">28.修复原始重定位表 定位结构体(<span class="hljs-params">不一定需要</span>)  fixRelocation  还是调用了内存管理</span><br><span class="hljs-function">29.decompress 压缩  需要拷贝偏移</span><br><span class="hljs-function">30.isPasswordCorrect</span><br><span class="hljs-function">31.createWindowButton</span><br><span class="hljs-function">32.处理信息 WinProc</span><br><span class="hljs-function">33.checkPassword</span><br><span class="hljs-function">34.isTimeout</span><br><span class="hljs-function">35.主函数oid __<span class="hljs-title">declspec</span>(<span class="hljs-params">naked</span>)  <span class="hljs-title">pMain</span>()</span><br><span class="hljs-function">	解压数据<span class="hljs-title">decompress</span>()</span><br><span class="hljs-function">	修复重定向<span class="hljs-title">fixRelocation</span>()</span><br><span class="hljs-function">	检测密码</span><br><span class="hljs-function">	是否有限制时间</span><br><span class="hljs-function">	恢复IAT</span><br><span class="hljs-function">	看是否有TLS函数 如果有 则调用</span><br><span class="hljs-function">	转交控制权</span><br></code></pre></td></tr></table></figure><h4 id="packer-exe"><a href="#packer-exe" class="headerlink" title="packer.exe"></a>packer.exe</h4><p>InputInfo.cpp : 实现文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1.对话框<br>2.消息处理程序<br></code></pre></td></tr></table></figure><p>PackerDlg.cpp :对话框</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">用于应用程序“关于”菜单项的 <span class="hljs-built_in">CAboutDlg</span> 对话框<br>CPackerDlg 对话框<br>CPackerDlg 消息处理程序<br>当用户拖动最小化窗口时系统调用此函数取得光标<br></code></pre></td></tr></table></figure><p>pictureEx.cpp :界面装载图片</p><p>util.cpp</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">生成内存文件  不适用wi<span class="hljs-symbol">n32</span> CreateFileMapStruct<br>校验是否是<span class="hljs-number">32</span>位文件  isPEEXE<span class="hljs-number">32</span><br></code></pre></td></tr></table></figure><p>Task.cpp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>loading.cpp</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Task::<span class="hljs-constructor">SetPEStruct(<span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">fileBuf</span>, PEstruct &amp;<span class="hljs-params">peStruct</span>)</span> 设置PE结构<br>Task::<span class="hljs-constructor">RVA2FA(<span class="hljs-params">char</span><span class="hljs-operator">*</span> <span class="hljs-params">lpFileBuffer</span>, <span class="hljs-params">int</span> RVA)</span> ROA转FOA<br>Task::<span class="hljs-constructor">GetExpVarAddr(<span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span> <span class="hljs-params">strVarName</span>)</span> 获取扩展节地址？<br>Task::<span class="hljs-constructor">StoreSectionInfo(<span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">bufFile</span>, <span class="hljs-params">std</span>::<span class="hljs-params">vector</span>&lt;<span class="hljs-params">pSecInfo</span><span class="hljs-operator">*</span>&gt;&amp;<span class="hljs-params">vec</span>)</span> 储存节信息<br>Task::<span class="hljs-constructor">Align(DWORD <span class="hljs-params">dwAlign</span>, DWORD <span class="hljs-params">dwValue</span>)</span>  不知道干嘛的<br><span class="hljs-constructor">GetSecInfoByRVA(DWORD <span class="hljs-params">dwRVA</span>, DWORD <span class="hljs-params">dwAlign</span>, <span class="hljs-params">std</span>::<span class="hljs-params">vector</span>&lt;<span class="hljs-params">pSecInfo</span><span class="hljs-operator">*</span>&gt;&amp;<span class="hljs-params">vec</span>)</span> 获取SecInfo<br>Task::GetTargetImageSize 获取节大小<br>Task::GetPressSize 获取需要解压的大小<br>CopyPressData    赋值解压的数据<br>CompressData     压缩数据<br>Task::AddSec     用于AddTargetSection<br>Task::Start		 创建FILEmap结构  引用<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stub</span>.</span></span>dll 这只PE结构<br>Task::GetResRVA   用于修正资源表<br>Task::FixRsrc     修正资源表<br>GetSecInfoByName  通过名称获取节信息<br>SetPressDataDir   设置解压地址<br>ClearDataDir<br>fixStubRelocation 修复Stub重定位<br>Task::Pack    	  打包的主程序<br>SetDateAndPassword<br>SetGlobalVar<br>SaveFile<br>CopyToTargetFile<br>AddTargetSection<br>CopyToDestMemory   复制到目标内存<br></code></pre></td></tr></table></figure><p>内存管理是指软件运行时对计算机内存资源的分配和使用的技术。<em>其最主要的目的是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。</em></p><h3 id="GuiShou-Pack-master"><a href="#GuiShou-Pack-master" class="headerlink" title="GuiShou_Pack-master"></a>GuiShou_Pack-master</h3><p>这个是分阶段写的 可能有助于理解</p><h4 id="阶段1–基础功能实现"><a href="#阶段1–基础功能实现" class="headerlink" title="阶段1–基础功能实现"></a>阶段1–基础功能实现</h4><p>main.cpp —大部分函数调用的CPeFileoper.cpp</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">1.</span>CPeFileOper m_Pe 选择PE文件操作类对象<br><span class="hljs-number">2.</span><span class="hljs-built_in">char</span>* pTargetBuff = m_Pe.GetFileData 打开被加壳程序<br><span class="hljs-number">3.</span>m_Pe.<span class="hljs-constructor">LoadStub(&amp;<span class="hljs-params">stub</span>)</span>加载stub.dll<br><span class="hljs-number">4.</span>m_Pe.Encrypt加密被加壳程序的代码段<br><span class="hljs-number">5.</span>AddSection   GetSection  添加新区段<br><span class="hljs-number">6.</span>FixStubRelocation  GetSection  GetOptionHeader GetSection修复重定位<br><span class="hljs-number">7.</span><span class="hljs-constructor">GetOptionHeader(<span class="hljs-params">pTargetBuff</span>)</span>-&gt;AddressOfEntryPoint; 保存目标文件的OEP到stub的全局变量中<br><span class="hljs-number">8.</span>memcpy 将stub.dll的代码段复制到新加的GuiShou段中<br><span class="hljs-number">9.</span>修改OEP OEP=start(VA)-dll加载基址-段首RVA+新区段的段首RVA<br><span class="hljs-number">10.</span>去掉随机基址<br><span class="hljs-number">11.</span>SavePEFile保存被加壳的程序<br><br></code></pre></td></tr></table></figure><p>CPeFileoper.cpp</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pf">OpenPeFile 打开PE文件<br>GetFileData 获取文件内容和大小<br>GetD<span class="hljs-keyword">os</span>Header 获取D<span class="hljs-keyword">os</span>头<br>GetNtHeader 获取Nt头<br>GetFileHead 获取文件头<br>GetOptionHeader 获取可选头<br>GetLastSection 获取最后一个区段<br>AlignMent   计算对齐后的大小<br>GetSection  获取指定名字的区段头<br>AddSection  添加一个新的区段<br>SavePEFile  将文件保存到指定路径<br>LoadStub    加载stub.dll<br>Encrypt     加密目标程序的代码段<br>FixStubRelocation 修复stub.dll的重定位表<br></code></pre></td></tr></table></figure><p>stub.cpp</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Decrypt  解密代码段<br>GetApis  获取API函数地址 kernel获取LoadLibrary和VirtualProtect<br><span class="hljs-literal">Start</span>    dll的OEP获取函数API 解密代码段 跳转到原始的OEP<br></code></pre></td></tr></table></figure><h4 id="阶段2–增加弹框"><a href="#阶段2–增加弹框" class="headerlink" title="阶段2–增加弹框"></a>阶段2–增加弹框</h4><p>stub.cpp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">kernel32和user32获取各种相关api<br>pWcscmp 自己实现的一个字符串比较函数<br>AlertPasswordBox 密码弹框<br>WndPrco			窗口回调函数<br></code></pre></td></tr></table></figure><p>main.cpp 不需要改</p><p>CPeFileoper.cpp 不需要改</p><h4 id="3-0-增加反调试"><a href="#3-0-增加反调试" class="headerlink" title="3.0 增加反调试"></a>3.0 增加反调试</h4><p>stub.cpp</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">AntiDebug  反调试 调用pfnFindWindowW<br>MixFun     混淆函数  汇编<br><span class="hljs-built_in">Start</span>()函数里多了<span class="hljs-built_in">AntiDebug</span>()<br></code></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">没变<br></code></pre></td></tr></table></figure><h4 id="4-0-增加AES加密"><a href="#4-0-增加AES加密" class="headerlink" title="4.0 增加AES加密"></a>4.0 增加AES加密</h4><p>stub文件夹多了个AES.cpp</p><p>stub.cpp</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">在<span class="hljs-built_in">decrypt</span>函数里面添加了aes解密的方法 InvCipher<br></code></pre></td></tr></table></figure><p>stub.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> key[<span class="hljs-number">16</span>] = &#123;&#125;;<span class="hljs-comment">//解密密钥</span><br></code></pre></td></tr></table></figure><p>CPeFileOper.cpp</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">encrypt函数增加了aes加密<br>	AES aes(key);<br>	aes.<span class="hljs-constructor">Cipher(<span class="hljs-params">pTargetText</span>, <span class="hljs-params">dwTargetTextSize</span>)</span>;<br>CompressPE 压缩PE文件<br></code></pre></td></tr></table></figure><h4 id="5-0-增加Tls回调函数的调用"><a href="#5-0-增加Tls回调函数的调用" class="headerlink" title="5.0 增加Tls回调函数的调用"></a>5.0 增加Tls回调函数的调用</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">//用于获取非rsrc/tls段的总大小 没写 <span class="hljs-operator">=</span> <span class="hljs-operator">=</span> <br></code></pre></td></tr></table></figure><h4 id="6-0-增加花指令"><a href="#6-0-增加花指令" class="headerlink" title="6.0 增加花指令"></a>6.0 增加花指令</h4><p>stub.dll</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++">FusedFunc<br>_asm<br>	&#123;<br>		jmp label1<br>		label2 :<br>		_emit <span class="hljs-number">0xeb</span>; <span class="hljs-comment">//跳到下面的call</span><br>		_emit <span class="hljs-number">0x04</span>;<br>		CALL DWORD PTR DS : [EAX + EBX * <span class="hljs-number">2</span> + <span class="hljs-number">0x123402EB</span>]; <span class="hljs-comment">//执行EB 02  也就是跳到下一句</span><br><br>														  <span class="hljs-comment">//	call Init;// 获取一些基本函数的地址</span><br><br>														  <span class="hljs-comment">// call下一条,用于获得eip</span><br>		_emit <span class="hljs-number">0xE8</span>;<br>		_emit <span class="hljs-number">0x00</span>;<br>		_emit <span class="hljs-number">0x00</span>;<br>		_emit <span class="hljs-number">0x00</span>;<br>		_emit <span class="hljs-number">0x00</span>;<br>		<span class="hljs-comment">//-------跳到下面的call</span><br>		_emit <span class="hljs-number">0xEB</span>;<br>		_emit <span class="hljs-number">0x0E</span>;<br><br>		<span class="hljs-comment">//-------花</span><br>		PUSH <span class="hljs-number">0x0</span>;<br>		PUSH <span class="hljs-number">0x0</span>;<br>		MOV EAX, DWORD PTR FS : [<span class="hljs-number">0</span>];<br>		PUSH EAX;<br>		<span class="hljs-comment">//-------花</span><br><br><br>		<span class="hljs-comment">// fused:</span><br>		<span class="hljs-comment">//作用push下一条语句的地址</span><br>		<span class="hljs-comment">//pop eax;</span><br>		<span class="hljs-comment">//add eax, 0x1b;</span><br>		<span class="hljs-comment">/*push eax;*/</span><br>		CALL DWORD PTR DS : [EAX + EBX * <span class="hljs-number">2</span> + <span class="hljs-number">0x5019C083</span>];<br><br>		push funcAddress; <span class="hljs-comment">//这里如果是参数传入的需要注意上面的add eax,??的??</span><br>		retn;<br><br>		jmp label3<br><br>			<span class="hljs-comment">// 花</span><br>			_emit <span class="hljs-number">0xE8</span>;<br>		_emit <span class="hljs-number">0x00</span>;<br>		_emit <span class="hljs-number">0x00</span>;<br>		_emit <span class="hljs-number">0x00</span>;<br>		_emit <span class="hljs-number">0x00</span>;<br>		<span class="hljs-comment">// 花</span><br><br><br>	label1:<br>		jmp label2<br>			label3 :<br>	&#125;<br><br>callTls Tls回调函数<br>    pfnGetMoudleHandleA 获取当前程序的加载基址<br>    GetOptionHeader	获取Tls表<br>壳程序<br></code></pre></td></tr></table></figure><p>这段花指令和壳程序我在各大代码看了不下7遍:joy:</p><h4 id="7-0-增加全部区段加密"><a href="#7-0-增加全部区段加密" class="headerlink" title="7.0 增加全部区段加密"></a>7.0 增加全部区段加密</h4><p>stub.dll</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SetFileHeaderProtect</span>  设置属性可写<br>FixImportTable_Normal  修复IAT<br>RecoverDataDir        恢复数据目录表<br></code></pre></td></tr></table></figure><p>CPeFileOper.cpp</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">encrypt函数加密所有区段<br>			<span class="hljs-comment">//修改属性为可写</span><br>			DWORD dwOldAttr = <span class="hljs-number">0</span>;<br>			<span class="hljs-constructor">VirtualProtect(<span class="hljs-params">pTargetSection</span>, <span class="hljs-params">dwTargetSize</span>, PAGE_EXECUTE_READWRITE, &amp;<span class="hljs-params">dwOldAttr</span>)</span>;<br>			<span class="hljs-comment">//加密目标区段</span><br>			aes.<span class="hljs-constructor">Cipher(<span class="hljs-params">pTargetSection</span>, <span class="hljs-params">dwTargetSize</span>)</span>;<br>			<span class="hljs-comment">//修改回原来的属性</span><br>			<span class="hljs-constructor">VirtualProtect(<span class="hljs-params">pTargetSection</span>, <span class="hljs-params">dwTargetSize</span>, <span class="hljs-params">dwOldAttr</span>, &amp;<span class="hljs-params">dwOldAttr</span>)</span>;<br><br>ClearDataDir	清除数据目录表<br><br>删除了       CompressPE  压缩PE文件<br></code></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">m_Pe.<span class="hljs-constructor">ClearDataDir(<span class="hljs-params">pTargetBuff</span>, <span class="hljs-params">stub</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="8-0-增加IAT加密-加花"><a href="#8-0-增加IAT加密-加花" class="headerlink" title="8.0 增加IAT加密 加花"></a>8.0 增加IAT加密 加花</h4><p>stub.cpp</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">EncryptFun</span>     在里面再写一个加密函数  异或加密<br>EncodeIAT		加密IAT 调用EncryptFun加密impaddress<br></code></pre></td></tr></table></figure><p>CPeFileOper.cpp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">没变<br></code></pre></td></tr></table></figure><h4 id="8-0-增加IAT加密-未加花"><a href="#8-0-增加IAT加密-未加花" class="headerlink" title="8.0 增加IAT加密 未加花"></a>8.0 增加IAT加密 未加花</h4><p>对比加花 stub.cpp</p><table><thead><tr><th></th><th>加花</th><th>未加花</th></tr></thead><tbody><tr><td>在壳程序函数里</td><td>&#x2F;&#x2F;获取函数的API地址<br>FusedFunc((DWORD)GetApis);<br><br>&#x2F;&#x2F;解密代码段<br>FusedFunc((DWORD)Decrypt);<br><br>&#x2F;&#x2F;恢复数据目录表<br>FusedFunc((DWORD)RecoverDataDir);<br><br>&#x2F;&#x2F;修复IAT<br>FusedFunc((DWORD)FixImportTable_Normal);<br><br>&#x2F;&#x2F;反调试<br>FusedFunc((DWORD)AntiDebug);<br><br>&#x2F;&#x2F;密码弹框<br>FusedFunc((DWORD)AlertPasswordBox);<br><br>&#x2F;&#x2F;调用Tls回调函数<br>FusedFunc((DWORD)CallTls);<br><br>&#x2F;&#x2F;加密IAT<br>FusedFunc((DWORD)EncodeIAT);</td><td>不执行加壳函数</td></tr><tr><td></td><td></td><td></td></tr><tr><td>在start函数后</td><td>执行壳 FusedFunc((DWORD)AllFunc);</td><td></td></tr><tr><td></td><td></td><td>&#x2F;&#x2F;获取函数的API地址<br>GetApis();<br>&#x2F;&#x2F;解密代码段<br>Decrypt();<br>&#x2F;&#x2F;恢复数据目录表<br>RecoverDataDir();<br>&#x2F;&#x2F;修复IAT<br>FixImportTable_Normal();<br>&#x2F;&#x2F;反调试<br>AntiDebug();<br>&#x2F;&#x2F;密码弹框<br>AlertPasswordBox();<br>&#x2F;&#x2F;调用Tls回调函数<br>CallTls();<br>&#x2F;&#x2F;加密IAT<br>EncodeIAT();</td></tr><tr><td>总</td><td>所有函数都调用了FusedFunc函数</td><td></td></tr><tr><td>FusedFunc函数</td><td>加花函数 需要自己再改改</td><td></td></tr></tbody></table><h4 id="9-完整体"><a href="#9-完整体" class="headerlink" title="9.完整体"></a>9.完整体</h4><p>stub.dll</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">Decrypt  解密代码段<br>GetApis  获取API函数地址 kernel获取LoadLibrary和VirtualProtect<br>Start    dll的OEP获取函数API 解密代码段 跳转到原始的OEP<br>kernel32和user32获取各种相关api<br>pWcscmp 自己实现的一个字符串比较函数<br>AlertPasswordBox 密码弹框<br>WndPrco			窗口回调函数<br>AntiDebug  反调试 调用pfnFindWindowW<br>MixFun     混淆函数  汇编<br>Start<span class="hljs-params">()</span>函数里多了AntiDebug<span class="hljs-params">()</span><br>unsigned char key[16] = &#123;&#125;;<span class="hljs-string">//</span>解密密钥<br><span class="hljs-string">//</span>用于获取非rsrc/tls段的总大小 没写 = =<br>callT<span class="hljs-keyword">ls</span> T<span class="hljs-keyword">ls</span>回调函数<br>    pfnGetMoudleHandleA 获取当前程序的加载基址<br>    GetOptionHeader	获取T<span class="hljs-keyword">ls</span>表<br>增加花指令函数funcfund<br>SetFileHeaderProtect  设置属性可写<br>FixImportTable_Normal  修复IAT<br>RecoverDataDir        恢复数据目录表<br>EncryptFun     在里面再写一个加密函数  异或加密<br>EncodeIAT		加密IAT 调用EncryptFun加密impaddress<br></code></pre></td></tr></table></figure><h3 id="AtomPepacker"><a href="#AtomPepacker" class="headerlink" title="AtomPepacker"></a>AtomPepacker</h3><h4 id="ArgsTest"><a href="#ArgsTest" class="headerlink" title="ArgsTest"></a>ArgsTest</h4><p>判断args输入命令</p><h4 id="hasher"><a href="#hasher" class="headerlink" title="hasher"></a>hasher</h4><p>应该是使用hash加密(散列替换)api函数字符串</p><p><img src="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202210291240377.png" srcset="/img/loading.gif" lazyload alt="image-20221029124004927"></p><h4 id="DLLPP64Stub"><a href="#DLLPP64Stub" class="headerlink" title="DLLPP64Stub"></a>DLLPP64Stub</h4><h5 id="General-c"><a href="#General-c" class="headerlink" title="General.c"></a>General.c</h5><p>就是自定义一些字符转换</p><h5 id="Utils-c"><a href="#Utils-c" class="headerlink" title="Utils.c"></a>Utils.c</h5><p>InitializeDirectNtCalls 初始化调用nt结构</p><p>GetDllFromKnownDlls 调用kernel.dll获取各类dll</p><p>hSection &#x3D; NtOpenSection 获取NT节句柄</p><p>RefreshNtdll 需要时重新分配ntdll</p><p>GetModuleHandleH(自定义api哈希库) 从peb的ldr的pdte的InMemoryOrderModuleList.Flink 中枚举全部加载模块 然后获取模块句柄</p><p>LoadLibraryH(自定义api哈希库) 将指定的模块加载到调用进程的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4&spm=1001.2101.3001.7020">地址空间</a>中。指定的模块可能会导致其他模块被加载。对于其他加载选项</p><p>无CRT导入</p><p>RtlInitUnicodeString 初始化设备名称指针。</p><p><strong>IoDeleteSymbolicLink</strong> 例程从系统中删除符号链接</p><p>IoDeleteDevice 删除驱动</p><p><strong>Dbgprint</strong> extension 显示以前发送到<strong>dbgprint</strong>缓冲区的字符串。</p><h3 id="Shell-Protect-main-虚拟壳"><a href="#Shell-Protect-main-虚拟壳" class="headerlink" title="Shell_Protect-main(虚拟壳)"></a>Shell_Protect-main(虚拟壳)</h3><p>这个就有点难了 之后分析 别一口吃成胖子 先自己写个简单的加壳 然后改进 然后写这个虚拟化壳</p><p>就连压缩的代码都不一样 虚拟化实在太强了</p><p>compressiondata</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">在压缩之前要先进行Vmencode加密<br><span class="hljs-code">	自定义加密次数 </span><br><span class="hljs-code">	获取VM的其实地址</span><br><span class="hljs-code">	线性反汇编来求大小</span><br><span class="hljs-code">添加一个区段给压缩后的数据使用</span><br><span class="hljs-code">调用VMP</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><h4 id="反汇编引擎"><a href="#反汇编引擎" class="headerlink" title="反汇编引擎"></a>反汇编引擎</h4><p>用的是capstone</p><p>　 <a target="_blank" rel="noopener" href="https://github.com/aquynh/capstone">capstone</a> 可以说是所有反汇编引擎中集大成者，对于它我要多费点口水，因为我对他是又爱又恨。capstone是基于LLVM框架中的MC组件部分移植过来，所以LLVM支持的CPU构架，capstone也都支持。<br>　　它支持的CPU构架有:</p><blockquote><p>Arm, Arm64 (Armv8), M68K, Mips, PowerPC, Sparc, SystemZ, XCore &amp; X86 (include X86_64)</p></blockquote><p>而且Capstone对X86构架的指令集支持是最全的，这一点是其他引擎都比不上的，其支持的X86扩展指令集有：</p><blockquote><p>3dnow, 3dnowa, x86_64, adx, aes, atom, avx, avx2, avx512cd, avx512er, avx512f, avx512pf, bmi, bmi2, fma, fma4, fsgsbase, lzcnt, mmx, sha, slm, sse, sse2, sse3, sse4.1, sse4.2, sse4a, ssse3, tbm, xop.</p></blockquote><p>原来这东西是提供给虚拟机使用的</p><p>反汇编stub文件-&gt;每条汇编挂钩handler-&gt;当eip执行地址则进入虚拟机处理</p><p>然后compresstiondata会调用跟这个vm进行vmentry</p><p>这个就用来compressiondata前进行vm的解密</p><h3 id="之后我们分析这些源码有哪些是相通的函数-然后来看一下函数有没有细致差别"><a href="#之后我们分析这些源码有哪些是相通的函数-然后来看一下函数有没有细致差别" class="headerlink" title="之后我们分析这些源码有哪些是相通的函数 然后来看一下函数有没有细致差别"></a>之后我们分析这些源码有哪些是相通的函数 然后来看一下函数有没有细致差别</h3><p>Peprotect和guishou_pack-master的sutb.dll代码差不多</p><p>那我们进行pack-master和guishou_pack-master的stub.dll的相似函数的内容分析</p><table><thead><tr><th></th><th>pack-master</th><th>guishou_pack-master</th></tr></thead><tbody><tr><td>#头</td><td>#include “aplib.h”压缩引擎</td><td></td></tr><tr><td></td><td>info.h</td><td></td></tr><tr><td></td><td></td><td>AES.h</td></tr><tr><td></td><td>define IMAGE_SIZEOF_BASE_RELOCATION 定义基址重定位表</td><td></td></tr><tr><td></td><td>define LOG_PATH L”D:&#x2F;log.txt” 打印日志设置</td><td></td></tr><tr><td></td><td>define ANTI_REVERSE 反调试设置</td><td></td></tr><tr><td></td><td>define SUPPORT_LOG 打开默认日志</td><td></td></tr><tr><td>中</td><td>定义一堆内存数据流结构体和自定义的内容管理函数</td><td></td></tr><tr><td>开始</td><td>getNtHeader和getImageSectionHeader</td><td>获取各种头</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td>又写了两个内容管理函数</td><td></td></tr><tr><td></td><td>isdebug反调试</td><td></td></tr><tr><td></td><td>又定义一些七了八了的内容管理函数</td><td></td></tr><tr><td></td><td>根据pUnhandledExceptionFilter和pUnhandledExceptionFilter1使用汇编编写debug1</td><td></td></tr><tr><td></td><td>TlsCallBack</td><td></td></tr><tr><td>汇编获取kernel</td><td></td><td>better (kernel+GetGPAFunAddr)的汇编版hKernel32;</td></tr><tr><td>GetGPAFunAddr</td><td>DOS头\Nt头-&gt;导出表项-&gt;导出表详细信息-&gt;根据函数名查找详细地址值</td><td></td></tr><tr><td></td><td>利用GetGPAFunAddr获取API地址</td><td>利用hKernel32获取地址</td></tr><tr><td></td><td>编写getExePath获取进程地址</td><td></td></tr><tr><td></td><td>利用getExePath实现那些文件的自删除 不知道有个鬼用</td><td></td></tr><tr><td>总结</td><td>除了多了解压缩函数和内存管理啥也没有</td><td>使用汇编定位api使代码更好写<br>而且还做了加密 加壳 花指令等函数</td></tr></tbody></table><p>上面这个的话我感觉还是用汇编获取api更好用一点</p><p>stub.dll里面的函数InitTls和callTLS的区别</p><table><thead><tr><th></th><th>InitTls(pack-master)</th><th>callTLS(guishou_pack-master)</th></tr></thead><tbody><tr><td></td><td>获取pTlsCallBack和pStubCallBack的虚拟地址</td><td>(DWORD)pfnGetMoudleHandleA(NULL);获取程序的句柄加载基址</td></tr><tr><td></td><td>直接用虚拟地址获取TLScalbacke</td><td>GetOptionHeader((char*)dwBase)-&gt;DataDirectory[9].VirtualAddress;获取内存地址</td></tr><tr><td></td><td></td><td>pTlsTab &#x3D; (PIMAGE_TLS_DIRECTORY)(dwTlsRva + dwBase);TLs表的句柄加载基址和内存地址</td></tr><tr><td></td><td></td><td>nTlsCallBacks &#x3D; <em>(DWORD</em>)pTlsTab-&gt;AddressOfCallBacks;如果获取TLS表成功 引用AddressOfCallBacks;</td></tr><tr><td></td><td></td><td>使用汇编call nTlsCallBacks</td></tr></tbody></table><p>修复IAT(都是用的动态修复 因为计算机每次重启.系统dll映射到exe程序所在的地址都会变,IAT必须动态修复).修复IAT表需要用到”LoadLibraryA”和GetProcAddress两个函数，这两个函数存在于KERNEL32这个DLL中，可以通过FS寄存器找到进程环境块PEB，得到kernel32的地址，找到GetProcAddress函数所在地址，再通过GetProcAddress找到LoadLibraryA的地址。</p><table><thead><tr><th>recoverIAT</th><th>FixImportTable_Normal</th></tr></thead><tbody><tr><td>&#x2F;&#x2F;获取当前程序的加载基址&lt;br&#x2F;HMODULE hModule &#x3D; s_apier.GetModuleHandleW(NULL);<br>然后做出了判断是否获取成功</td><td>&#x2F;&#x2F;设置文件属性为可写<br>SetFileHeaderProtect(true);</td></tr><tr><td>获取NT头进而获取加载基址</td><td>&#x2F;&#x2F;获取当前程序的加载基址<br>DWORD ImageBase &#x3D; (DWORD)pfnGetMoudleHandleA(NULL);</td></tr><tr><td>&#x2F;&#x2F;导入表<br>lpImportTable &#x3D; (IMAGE_IMPORT_DESCRIPTOR*)((DWORD)lpImageBase + g_globalVar.dwIATVirtualAddress);<br>这里的dwIATVirtualAddress 是自己定义的结构体</td><td>&#x2F;&#x2F;导入表&#x3D;导入表偏移+加载基址<br>IMAGE_IMPORT_DESCRIPTOR* pImp &#x3D; (IMAGE_IMPORT_DESCRIPTOR*)(GetOptionHeader((char*)ImageBase)-&gt;DataDirectory[1].VirtualAddress + ImageBase);</td></tr><tr><td>获取IAT,这是需要将函数地址写入的地方,但是相比右边缺少了校验,默认为获取PINT</td><td>根据导入表获取Int 如果没有INT就获取IAT</td></tr><tr><td>后面跟右边差不多 我感觉右边的代码更好写且好用一点</td><td>&#x2F;&#x2F; 加载dll hImpModule &#x3D; (HMODULE)pLoadLibraryA((char*)(pImp-&gt;Name + ImageBase));</td></tr><tr><td></td><td>while导入函数地址u1.Function if (IMAGE_SNAP_BY_ORDINAL)判断导入的方式、序号还是名称IMAGE_SNAP_BY_ORDINAL(pInt-&gt;u1.Ordinal 来获取impaddress</td></tr><tr><td></td><td>pVirtualProtect保护piat的导入函数地址u1.Function</td></tr><tr><td></td><td>将刚才获取到的pint的impaddress赋值给pIat-&gt;u1.Function</td></tr><tr><td></td><td></td></tr></tbody></table><p>修复原始重定位表 (只有pepacker里面有)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fixRelocation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	DWORD dwImageBase;<br>	PIMAGE_BASE_RELOCATION	pReloc;<br><br>	<span class="hljs-keyword">if</span> (g_globalVar.dwRelocationRva == <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>	dwImageBase = (DWORD)s_apier.<span class="hljs-built_in">GetModuleHandleW</span>(<span class="hljs-literal">NULL</span>);<br>	<span class="hljs-keyword">if</span> (dwImageBase == <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-built_in">LOGGER_MESSAGE</span>(<span class="hljs-string">&quot;GetModuleHandleW failed&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	&#125;<br><br>	pReloc = (PIMAGE_BASE_RELOCATION)((DWORD)dwImageBase + g_globalVar.dwRelocationRva);<br>	<span class="hljs-keyword">while</span> (pReloc-&gt;VirtualAddress)<br>	&#123;<br>		PTYPEOFFSET pTypeOffset = (PTYPEOFFSET)(pReloc + <span class="hljs-number">1</span>);<br>		DWORD dwNumber = (pReloc-&gt;SizeOfBlock - IMAGE_SIZEOF_BASE_RELOCATION) / <span class="hljs-number">2</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; dwNumber; i++)<br>		&#123;<br>			<span class="hljs-keyword">if</span> (*(PWORD)(&amp;pTypeOffset[i]) == <span class="hljs-number">0</span>)<br>			&#123;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>			DWORD dwRVA = pTypeOffset[i].offset + pReloc-&gt;VirtualAddress;<br>			DWORD dwAddressOfReloc = *(PDWORD)(dwImageBase + dwRVA);<br><br>			<span class="hljs-comment">//设置修复后的重定向数据</span><br>			*(PDWORD)((DWORD)dwImageBase + dwRVA) = dwAddressOfReloc - g_globalVar.dwOrignalImageBase + dwImageBase;<br>		&#125;<br>		pReloc = (PIMAGE_BASE_RELOCATION)((DWORD)pReloc + pReloc-&gt;SizeOfBlock);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>pepacker也多了decompress解压缩函数</p><p>修复重定向估计也是为了配合解压使用的</p><p>那我们直接改guisuo_packer的代码 compress代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">压缩函数<br></code></pre></td></tr></table></figure><h2 id="开始写"><a href="#开始写" class="headerlink" title="开始写"></a>开始写</h2><h3 id="写个压缩区段-先分析一下流程"><a href="#写个压缩区段-先分析一下流程" class="headerlink" title="写个压缩区段 先分析一下流程"></a>写个压缩区段 先分析一下流程</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">压缩区段<br>1.获取文件头的大小，并获取除资源段<span class="hljs-string">.rsrc</span>和线程本地存储<span class="hljs-string">.tls</span>之外的区段的文件总大小<br>2.读取要压缩的段到内存<br>3.压缩 调用compress函数<br>	compress函数<br>		调用apsafe_pack压缩函数<br>4.保存<span class="hljs-string">.rsrc</span> <span class="hljs-string">.tls</span>段到内存空间<br>5.设置压缩信息到信息结构体<br>6. 申请新空间，使m_pNewBuf指向它，将m_pBuf文件头拷贝<br>7. 添加<span class="hljs-string">.compres</span>段<br><br></code></pre></td></tr></table></figure><p>再看一下encrypt加密区段函数</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">获取区段数量<br>获取第一个区段<br>pStub.pStubConf用于保存数据<br><span class="hljs-keyword">if</span>判断资源段和tls段不加密并跳过无效的区段<br>	<span class="hljs-keyword">else</span><br>		开始加密所有区段<br>			获取区段的首地址和大小<br>			修改属性为可写<br>			加密目标区段<br>			修改回原来的属性<br>			保存数据到共享信息结构体<br></code></pre></td></tr></table></figure><p>为了更好的编写和使用 得写一个函数用于获取rsrc和tls段的信息</p><p>好麻烦啊 直接在peprotect写加密吧</p><h3 id="stub-1"><a href="#stub-1" class="headerlink" title="stub"></a>stub</h3><ul><li><p><input checked disabled type="checkbox"> 解密代码段</p></li><li><p><input checked disabled type="checkbox"> 加密iat</p></li><li><p><input checked disabled type="checkbox"> 反调试 x3个 (后面可以嵌套ollvm)</p></li><li><p><input checked disabled type="checkbox"> 解压和压缩区段</p></li><li><p><input checked disabled type="checkbox"> 密码弹框</p></li><li><p><input checked disabled type="checkbox"> 调用Tls回调函数 (用于反调试)</p></li><li><p><input checked disabled type="checkbox"> 修复exe重定位</p></li><li><p><input checked disabled type="checkbox"> 恢复数据目录表</p></li><li><p><input checked disabled type="checkbox"> 混淆函数</p></li><li><p><input checked disabled type="checkbox"> 修复iat</p></li><li><p><input disabled type="checkbox"> 加花函数</p></li></ul><p>先看一下什么时候需要修复iat</p><p>修复iat 换句话来说就是修复导入表 importtable 但是都常见于脱壳</p><p>因为原来的程序在获取完IAT后就把字符删掉了，文件偏移里的字符串指针没有了，就没法自动获取地址了。所以必须脱壳之后必须把IAT修复好</p><p>那么解密代码段话就是类似一个脱壳的过程 可以会导致rva的偏移,这就需要我门修复iat去重新获取。</p><p>那么我们也要对应的去改一下pack.cpp</p><p>接下来看下要不要对那个虚拟壳进行改写学习</p><p><em>抹去PE指纹</em>(不过这类常规方法只能抹去内存中的pe头)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">clearpeheader</span><span class="hljs-params">()</span>&#123; <br>	hshellModule = GetModuleHandle(<span class="hljs-string">&quot;hshell.dll&quot;</span>);<br>	VirtualProtect((LPVOID)hshellModule, <span class="hljs-number">1024</span>, PAGE_READWRITE, &amp;dwOldProtect);<br>	<span class="hljs-comment">//抹去PE头</span><br>	<span class="hljs-type">PIMAGE_DOS_HEADER</span> <span class="hljs-variable">pDosHeader</span> <span class="hljs-operator">=</span> (PIMAGE_DOS_HEADER)hshellModule;<br>	pDosHeader-&gt;e_magic = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">PIMAGE_NT_HEADERS</span> <span class="hljs-variable">pNtheader</span> <span class="hljs-operator">=</span> (PIMAGE_NT_HEADERS)hshellModule;<br>	<span class="hljs-comment">//抹去MZ头</span><br>	pNtheader-&gt;Signature = <span class="hljs-number">0</span>;<br>	VirtualProtect((LPVOID)hshellModule,<span class="hljs-number">1024</span>,, &amp;dwOldProtect)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>有没有写入文件的方法</p><p>都不能运行:angry: 改addshelltool</p><h3 id="接下来改高级的"><a href="#接下来改高级的" class="headerlink" title="接下来改高级的"></a>接下来改高级的</h3><ol><li>兼容x64</li></ol><h4 id="error1"><a href="#error1" class="headerlink" title="error1"></a>error1</h4><p>__declspec(naked) naked 无法识别的扩展特性</p><p>__declspec(naked) 用来将汇编语言嵌入到c语言中,手工处理堆栈,即使是裸函数 我们也能运行<img src="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202211231951871.png" srcset="/img/loading.gif" lazyload alt="image-20221123195145733"></p><p>原来是这样</p><p>原因是x64不支持使用内联汇编代码</p><p>1.一个方法是直接把汇编代码转换成.asm文件然后再去引入</p><p>2.参考vmpshell的代码</p><p>做了判断函数</p><p>#ifdef _WIN64</p><p>直接 __stdcall之前的kernel 和分配好的函数</p><p>else &#x2F;&#x2F;win32</p><p>重新定义获取puGetModule和MyGetProcAddress函数</p><p>&#x2F;&#x2F;都是用来给下面sheller_code调用</p><p>我们就用第二套办法先试试</p><p>我们的目的都是为了获取windowsapi函数 但是在win64的话不需要先获取基址</p><p>而是可以直接 void _stdcall调用,所以我们只要知道我们需要哪些函数然后去定义就行<img src="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202211232045931.png" srcset="/img/loading.gif" lazyload alt="image-20221123204518797"></p><p>由于这个pGetProcAddress 我们自己定义的 x64下也没问题 所以我们直接用x64获取kernelbase就可</p><p>写到一半 发现好麻烦 除非之前已经定义过api了</p><p>我们用第一种方法</p><p>参考这个</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Giser_D/article/details/90670974">https://blog.csdn.net/Giser_D/article/details/90670974</a></p><p>在asm定义好了函数 所以在只要写好了头文件和cpp 就不再需要声明</p><p>怪不得 vmshell的x64代码频繁用到 __stdcall</p><p>都是从asm里面调用的(但是是在cpp里面调用)</p><p>所以根本就没有第二种方法</p><p>所以我们需要改的就需要这三个东西</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span><span class="hljs-selector-class">.asm</span><span class="hljs-selector-class">.h</span><br><span class="hljs-number">2</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.asm</span><br><span class="hljs-number">3</span>.cpp<br></code></pre></td></tr></table></figure><p>也就是说这个_stdcall写在cpp里面就可</p><p>只要stud.h引用了STUD_H 之后cpp调用stud.h就可<img src="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202211241315060.png" srcset="/img/loading.gif" lazyload alt="image-20221124131530810"></p><p>与kernelbase的也只有这一段 后面的都可以用pGetProcAddress和pLoadLibraryExA获取</p><p>这一段的是getkernelbase-&gt; pgetprocaddress -&gt; 获取各类函数</p><p>而这些函数我们都可以用汇编直接获取</p><ul><li><input disabled type="checkbox"> pLoadLibraryExA typedef定义 调用getprocaddress获取 汇编没有</li><li><input checked disabled type="checkbox"> pGetProcAddress 汇编有 但是我们代码也自己定义了</li><li><input disabled type="checkbox"> pExitProcess typedef定义 调用getprocaddress获取 汇编没有</li><li><input disabled type="checkbox"> pVirtualProtect typedef定义 调用getprocaddress获取 汇编没有</li><li><input disabled type="checkbox"> pGetLastError typedef定义 调用getprocaddress获取 汇编没有</li><li><input disabled type="checkbox"> pVirtualAlloc typedef定义 调用getprocaddress获取 汇编没有</li><li><input disabled type="checkbox"> pVirtualFree typedef定义 调用getprocaddress获取 汇编没有</li><li><input disabled type="checkbox"> pVirtualQuery typedef定义 调用getprocaddress获取 汇编没有</li></ul><p>汇编有的</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">puGetModule</span><br>MyGetProcAddress<br>CodeExecEntry<br>剩下的都是vm里的 没啥用<br><br></code></pre></td></tr></table></figure><p>只能直接获取LoadLibrary函数 看下怎么用的</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">pLoadLibraryExA</span> = (FnLoadLibraryExA)MyGetProcAddress(g_stud.s_Krenel32, <span class="hljs-number">0</span>xC0D83287)<span class="hljs-comment">;</span><br><span class="hljs-attr">pExitProcess</span> = (FnExitProcess)MyGetProcAddress(g_stud.s_Krenel32, <span class="hljs-number">0</span>x4FD18963)<span class="hljs-comment">;</span><br><span class="hljs-attr">pVirtualProtect</span> = (FnVirtualProtect)MyGetProcAddress(g_stud.s_Krenel32, <span class="hljs-number">0</span>xEF64A41E)<span class="hljs-comment">;</span><br><span class="hljs-attr">pGetLastError</span> = (FnGetLastError)MyGetProcAddress(g_stud.s_Krenel32, <span class="hljs-number">0</span>x12F461BB)<span class="hljs-comment">;</span><br><span class="hljs-attr">pVirtualAlloc</span> = (FnVirtualAlloc)MyGetProcAddress(g_stud.s_Krenel32, <span class="hljs-number">0</span>x1EDE5967)<span class="hljs-comment">;</span><br><span class="hljs-attr">pVirtualFree</span> = (FnVirtualFree)MyGetProcAddress(g_stud.s_Krenel32, <span class="hljs-number">0</span>x6144AA05)<span class="hljs-comment">;</span><br><br><br></code></pre></td></tr></table></figure><p>找了半天找不到直接asm获取kernelbase的办法 可能需要重构直接获取api了</p><p>判断PE 64 DLL NET</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> isPE  = in_pe_dos_header-&gt;e_magic == IMAGE_DOS_SIGNATURE;<br><span class="hljs-type">bool</span> is64  = in_pe_nt_header-&gt;FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64 &amp;&amp;<br>             in_pe_nt_header-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC;<br><span class="hljs-type">bool</span> isDLL = in_pe_nt_header-&gt;FileHeader.Characteristics &amp; IMAGE_FILE_DLL;<br><span class="hljs-type">bool</span> isNET = in_pe_nt_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size != <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/windows-c-x32-pe%E7%BB%93%E6%9E%84/" class="category-chain-item">windows c++ x32 pe结构</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">#学习笔记</a></div></div><div class="license-box my-3"><div class="license-title"><div>写个壳</div><div>http://example.com/写个壳.html</div></div><div class="license-meta"><div class="license-meta-item"><div>Author</div><div>CDxiaodong</div></div><div class="license-meta-item license-meta-date"><div>Posted on</div><div>December 6, 2022</div></div><div class="license-meta-item"><div>Licensed under</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - Attribution"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/shell%20%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91.html" title="shell 编程开发"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">shell 编程开发</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E5%BC%82%E5%B8%B8hook.html" title="内存访问异常hook"><span class="hidden-mobile">内存访问异常hook</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>Table of Contents</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">Keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://github.com/cdxiaodong" target="_blank" rel="nofollow noopener"><span>CD</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/cdxiaodong" target="_blank" rel="nofollow noopener"><span>XD</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">Views: <span id="busuanzi_value_site_pv"></span> </span><span id="busuanzi_container_site_uv" style="display:none">Visitors: <span id="busuanzi_value_site_uv"></span></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">Blog works best with JavaScript enabled</div></noscript></body></html>